{"version":3,"sources":["webpack:///firebase-firestore.js","webpack:///./firestore/index.js","webpack:///../firestore/dist/esm/src/util/log.js","webpack:///../firestore/dist/esm/src/util/assert.js","webpack:///../firestore/dist/esm/src/platform/platform.js","webpack:///../firestore/dist/esm/src/util/api.js","webpack:///../firestore/dist/esm/src/util/obj.js","webpack:///../firestore/dist/esm/src/util/input_validation.js","webpack:///../firestore/dist/esm/src/util/misc.js","webpack:///../firestore/dist/esm/src/api/blob.js","webpack:///../firestore/dist/esm/src/model/field_value.js","webpack:///../firestore/dist/esm/src/util/types.js","webpack:///../firestore/dist/esm/src/core/query.js","webpack:///../firestore/dist/esm/src/remote/rpc_error.js","webpack:///../firestore/dist/esm/src/model/collections.js","webpack:///../firestore/dist/esm/src/remote/watch_change.js","webpack:///../firestore/dist/esm/src/remote/serializer.js","webpack:///../firestore/dist/esm/src/api/field_path.js","webpack:///../firestore/dist/esm/src/core/view.js","webpack:///../firestore/dist/esm/src/local/encoded_resource_path.js","webpack:///../firestore/dist/esm/src/local/indexeddb_schema.js","webpack:///../firestore/dist/esm/src/local/simple_db.js","webpack:///../firestore/dist/esm/src/local/indexeddb_mutation_queue.js","webpack:///../firestore/dist/esm/src/local/indexeddb_query_cache.js","webpack:///../firestore/dist/esm/src/local/indexeddb_remote_document_cache.js","webpack:///../firestore/dist/esm/src/local/local_serializer.js","webpack:///../firestore/dist/esm/src/api/credentials.js","webpack:///../firestore/dist/esm/src/api/observer.js","webpack:///../firestore/dist/esm/src/api/user_data_converter.js","webpack:///../firestore/dist/esm/src/api/database.js","webpack:///../firestore/dist/esm/src/platform/config.js","webpack:///../firestore/dist/esm/index.js","webpack:///../firestore/dist/esm/src/core/version.js","webpack:///../firestore/dist/esm/src/util/error.js","webpack:///../firestore/dist/esm/src/api/geo_point.js","webpack:///../firestore/dist/esm/src/core/database_info.js","webpack:///../firestore/dist/esm/src/model/path.js","webpack:///../firestore/dist/esm/src/model/document_key.js","webpack:///../firestore/dist/esm/src/model/document.js","webpack:///../firestore/dist/esm/src/util/sorted_map.js","webpack:///../firestore/dist/esm/src/local/query_data.js","webpack:///../firestore/dist/esm/src/core/timestamp.js","webpack:///../firestore/dist/esm/src/core/snapshot_version.js","webpack:///../firestore/dist/esm/src/model/mutation.js","webpack:///../firestore/dist/esm/src/remote/existence_filter.js","webpack:///../firestore/dist/esm/src/util/sorted_set.js","webpack:///../firestore/dist/esm/src/remote/remote_event.js","webpack:///../firestore/dist/esm/src/remote/stream_bridge.js","webpack:///../firestore/dist/esm/src/platform_browser/webchannel_connection.js","webpack:///../firestore/dist/esm/src/platform_browser/browser_platform.js","webpack:///../firestore/dist/esm/src/platform_browser/browser_init.js","webpack:///../firestore/dist/esm/src/core/types.js","webpack:///../firestore/dist/esm/src/core/view_snapshot.js","webpack:///../firestore/dist/esm/src/core/target_id_generator.js","webpack:///../firestore/dist/esm/src/model/document_set.js","webpack:///../firestore/dist/esm/src/util/obj_map.js","webpack:///../firestore/dist/esm/src/core/event_manager.js","webpack:///../firestore/dist/esm/src/local/persistence_promise.js","webpack:///../firestore/dist/esm/src/local/eager_garbage_collector.js","webpack:///../firestore/dist/esm/src/local/local_view_changes.js","webpack:///../firestore/dist/esm/src/local/reference_set.js","webpack:///../firestore/dist/esm/src/util/async_queue.js","webpack:///../firestore/dist/esm/src/core/sync_engine.js","webpack:///../firestore/dist/esm/src/model/mutation_batch.js","webpack:///../firestore/dist/esm/src/local/indexeddb_persistence.js","webpack:///../firestore/dist/esm/src/local/local_documents_view.js","webpack:///../firestore/dist/esm/src/local/remote_document_change_buffer.js","webpack:///../firestore/dist/esm/src/local/local_store.js","webpack:///../firestore/dist/esm/src/local/memory_mutation_queue.js","webpack:///../firestore/dist/esm/src/local/memory_query_cache.js","webpack:///../firestore/dist/esm/src/local/memory_remote_document_cache.js","webpack:///../firestore/dist/esm/src/local/memory_persistence.js","webpack:///../firestore/dist/esm/src/local/no_op_garbage_collector.js","webpack:///../firestore/dist/esm/src/util/promise.js","webpack:///../firestore/dist/esm/src/remote/persistent_stream.js","webpack:///../firestore/dist/esm/src/remote/backoff.js","webpack:///../firestore/dist/esm/src/remote/datastore.js","webpack:///../firestore/dist/esm/src/core/transaction.js","webpack:///../firestore/dist/esm/src/remote/online_state_tracker.js","webpack:///../firestore/dist/esm/src/remote/remote_store.js","webpack:///../firestore/dist/esm/src/core/firestore_client.js","webpack:///../firestore/dist/esm/src/util/async_observer.js","webpack:///../firestore/dist/esm/src/auth/user.js","webpack:///../firestore/dist/esm/src/api/field_value.js","webpack:///../webchannel-wrapper/dist/index.js","webpack:///../logger/dist/esm/index.js","webpack:///../logger/dist/esm/src/logger.js"],"names":["webpackJsonpFirebase","115","module","exports","__webpack_require__","116","__webpack_exports__","getLogLevel","logClient","logLevel","dist_esm","DEBUG","LogLevel","SILENT","ERROR","setLogLevel","newLevel","error","SDK_VERSION","debug","tag","msg","obj","_i","arguments","length","args","map","argToString","apply","concat","log_error","platform","platform_PlatformSupport","getPlatform","formatJSON","e","fail","failure","message","Error","assert","assertion","emptyByteString","makeConstructorPrivate","cls","optionalMessage","PublicConstructor","error_FirestoreError","Code","INVALID_ARGUMENT","prototype","staticProperty","hasOwnProperty","contains","key","Object","call","defaulted","value","defaultValue","undefined","forEachNumber","fn","num","isNaN","forEach","isEmpty","shallowCopy","result","validateExactNumberOfArgs","functionName","numberOfArgs","formatPlural","validateAtLeastNumberOfArgs","minNumberOfArgs","validateBetweenNumberOfArgs","maxNumberOfArgs","validateNamedArrayAtLeastNumberOfElements","name","minNumberOfElements","Array","validateArgType","type","position","argument","validateType","ordinal","validateOptionalArgType","validateNamedType","optionName","validateNamedOptionalType","validateNamedPropertyEquals","inputName","input","expected","expectedDescription","expected_1","val","push","valueDescription","actualDescription","join","validateNamedOptionalPropertyEquals","isPlainObject","description","getPrototypeOf","substring","JSON","stringify","customObjectName","tryGetCustomObjectType","constructor","funcNameRegex","results","exec","validateDefined","validateOptionNames","options","optionNames","_","indexOf","invalidClassError","str","primitiveComparator","left","right","equals","isEqual","arrayEquals","i","immediatePredecessor","s","lastIndex","charAt","String","fromCharCode","charCodeAt","immediateSuccessor","assertUint8ArrayAvailable","Uint8Array","UNIMPLEMENTED","assertBase64Available","base64Available","numericComparator","numericEquals","isNullOrUndefined","isSafeInteger","isInteger","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","fieldFilter","field","op","field_value_NullValue","INSTANCE","query_RelationOp","EQUAL","NullFilter","field_value_DoubleValue","NAN","NanFilter","query_RelationFilter","isPermanentError","code","OK","CANCELLED","UNKNOWN","DEADLINE_EXCEEDED","RESOURCE_EXHAUSTED","INTERNAL","UNAVAILABLE","UNAUTHENTICATED","NOT_FOUND","ALREADY_EXISTS","PERMISSION_DENIED","FAILED_PRECONDITION","ABORTED","OUT_OF_RANGE","DATA_LOSS","mapCodeFromRpcStatus","status","RpcCode","mapCodeFromRpcCode","mapRpcCodeFromCode","mapCodeFromHttpStatus","maybeDocumentMap","EMPTY_MAYBE_DOCUMENT_MAP","documentMap","EMPTY_DOCUMENT_MAP","documentVersionMap","EMPTY_DOCUMENT_VERSION_MAP","documentKeySet","EMPTY_DOCUMENT_KEY_SET","applyResumeToken","change","resumeToken","assertPresent","parseInt64","hasTag","fromDotSeparatedString","path","search","RESERVED","field_path_FieldPath","bind","split","compareChangeType","c1","c2","order","ChangeType","Added","Modified","Metadata","Removed","encode","encodeSeparator","encodeSegment","get","segment","resultBuf","c","escapeChar","encodedNul","encodedEscape","encodedSeparatorChar","decode","path_ResourcePath","EMPTY_PATH","lastReasonableEscapeIndex","segments","segmentBuilder","start","end","currentPiece","createOrUpgradeDb","db","txn","fromVersion","toVersion","createOwnerStore","createMutationQueue","createQueryCache","createRemoteDocumentCache","p","persistence_promise_PersistencePromise","resolve","ensureTargetGlobalExists","next","targetGlobal","saveTargetCount","createObjectStore","DbOwner","store","DbMutationQueue","keyPath","DbMutationBatch","indexeddb_schema_DbDocumentMutation","DbRemoteDocument","DbTargetDocument","createIndex","documentTargetsIndex","documentTargetsKeyPath","unique","DbTarget","queryTargetsIndexName","queryTargetsKeyPath","DbTargetGlobal","metadata","globalStore","count","targetCount","put","snapshot_version_SnapshotVersion","MIN","toTimestamp","wrapRequest","request","reject","onsuccess","event","target","onerror","validateStreamToken","token","mutationsStore","getStore","documentMutationsStore","mutationQueuesStore","simple_db_SimpleDbTransaction","targetsStore","indexeddb_query_cache_getStore","globalTargetStore","documentTargetStore","remoteDocumentsStore","dbKey","docKey","toArray","isDocumentQuery","dbQuery","documents","makeCredentialsProvider","credentials","credentials_EmptyCredentialsProvider","credentials_FirstPartyCredentialsProvider","client","sessionIndex","isPartialObserver","implementsAnyMethods","methods","object","methods_1","method","isWrite","dataSource","UserDataSource","Set","MergeSet","Update","QueryValue","looksLikeJsonObject","Date","geo_point_GeoPoint","blob_Blob","DocumentKeyReference","FieldValueImpl","validatePlainObject","context","createError","fieldPathFromArgument","methodName","_internalPath","fieldPathFromDotSeparatedString","errorMessage","validateSetOptions","merge","validateSnapshotOptions","serverTimestamps","validateReference","documentRef","firestore","database_DocumentReference","changesFromSnapshot","snapshot","oldDocs","lastDoc_1","index_1","docChanges","doc","database_QueryDocumentSnapshot","fromCache","query","docComparator","oldIndex","newIndex","indexTracker_1","delete","add","resultChangeType","configureForFirebase","firebase","registerService","app","database_Firestore","firestoreNamespace","registerFirestore","instance","defineProperty","esm","PlatformSupport","setPlatform","tslib_es6","_super","FirestoreError","_this","this","toString","misc_AutoId","AutoId","newId","chars","autoId","Math","floor","random","Blob","binaryString","_binaryString","fromBase64String","base64","atob","fromUint8Array","array","char","toBase64","btoa","toUint8Array","buffer","other","_compareTo","PublicBlob","GeoPoint","latitude","longitude","isFinite","_lat","_long","enumerable","configurable","DatabaseInfo","databaseId","persistenceKey","host","ssl","DEFAULT_DATABASE_NAME","database_info_DatabaseId","DatabaseId","projectId","database","compareTo","path_Path","Path","offset","init","len","construct","create","comparator","child","nameOrPath","slice","limit","popFirst","size","popLast","firstSegment","lastSegment","index","isPrefixOf","p1","p2","min","ResourcePath","canonicalString","fromString","filter","identifierRegExp","path_FieldPath","FieldPath","isValidIdentifier","test","replace","isKeyField","keyField","fromServerFormat","current","addCurrentSegment","inBackticks","document_key_DocumentKey","DocumentKey","isDocumentKey","k1","k2","fromSegments","fromPathString","EMPTY","document_Document","Document","version","data","hasLocalMutations","fieldValue","compareByKey","d1","d2","compareByField","v1","v2","document_NoDocument","NoDocument","SortedMap","root","sorted_map_LLRBNode","insert","copy","BLACK","remove","node","cmp","prunedNodes","minKey","maxKey","inorderTraversal","action","k","v","reverseTraversal","getIterator","sorted_map_SortedMapIterator","getIteratorFrom","getReverseIterator","getReverseIteratorFrom","SortedMapIterator","startKey","isReverse","nodeStack","getNext","pop","hasNext","peek","LLRBNode","color","RED","n","fixUp","removeMin","isRed","moveRedLeft","smallest","rotateRight","moveRedRight","rotateLeft","colorFlip","nl","nr","checkMaxDepth","blackDepth","check","pow","LLRBEmptyNode","TypeOrder","ServerTimestampBehavior","QueryPurpose","field_value_FieldValueOptions","FieldValueOptions","serverTimestampBehavior","fromSnapshotOptions","Estimate","Previous","defaultOptions","Default","field_value_FieldValue","FieldValue","defaultCompareTo","typeOrder","NullValue","internalValue","field_value_BooleanValue","BooleanValue","of","TRUE","FALSE","field_value_NumberValue","NumberValue","field_value_IntegerValue","IntegerValue","DoubleValue","NaN","POSITIVE_INFINITY","Infinity","NEGATIVE_INFINITY","field_value_StringValue","StringValue","field_value_TimestampValue","TimestampValue","toDate","field_value_ServerTimestampValue","ServerTimestampValue","localWriteTime","previousValue","field_value_BlobValue","BlobValue","field_value_RefValue","RefValue","field_value_GeoPointValue","GeoPointValue","field_value_ObjectValue","ObjectValue","it1","it2","next1","next2","set","to","setChild","newChild","pathSegment","childName","field_value_ArrayValue","ArrayValue","minLength","NumberAsAny","Number","query_Query","Query","explicitOrderBy","filters","startAt","endAt","memoizedCanonicalId","memoizedOrderBy","assertValidBound","atPath","inequalityField","getInequalityFilterField","firstOrderByField","getFirstOrderByField","KEY_ORDERING_ASC","query_OrderBy","foundKeyOrdering","_a","orderBy","lastDirection","dir","Direction","ASCENDING","KEY_ORDERING_DESC","addFilter","isInequality","newFilters","addOrderBy","newOrderBy","withLimit","withStartAt","bound","withEndAt","canonicalId","_b","_c","comparedOnKeyField","comp","compare","matches","matchesAncestor","matchesOrderBy","matchesFilters","matchesBounds","hasLimit","docPath","sortsBeforeDocument","RelationOp","LESS_THAN","LESS_THAN_OR_EQUAL","GREATER_THAN_OR_EQUAL","GREATER_THAN","RelationFilter","refValue","comparison","matchesComparison","matchesValue","DESCENDING","query_Bound","Bound","before","component","orderByComponent","docValue","thisPosition","otherPosition","OrderBy","isKeyOrderBy","isoRegExp","RegExp","timestamp_Timestamp","Timestamp","seconds","nanos","now","fromEpochMilliseconds","fromDate","date","getTime","milliseconds","fromISOString","utc","fraction","nanoStr","substr","toEpochMilliseconds","SnapshotVersion","timestamp","fromMicroseconds","fromTimestamp","forDeletedDoc","toMicroseconds","MutationType","query_data_QueryData","QueryData","targetId","purpose","snapshotVersion","update","updated","mutation_FieldMask","FieldMask","fields","ServerTimestampTransform","FieldTransform","transform","MutationResult","transformResults","mutation_Precondition","Precondition","updateTime","exists","isValidFor","maybeDoc","isNone","NONE","mutation_Mutation","Mutation","verifyKeyMatches","getPostMutationVersion","mutation_SetMutation","SetMutation","precondition","applyToRemoteDocument","mutationResult","applyToLocalView","baseDoc","mutation_PatchMutation","PatchMutation","fieldMask","Patch","newData","patchDocument","patchObject","fieldPath","newValue","mutation_TransformMutation","TransformMutation","fieldTransforms","Transform","requireDocument","transformObject","localTransformResults","fieldTransform","mutation_DeleteMutation","DeleteMutation","Delete","ExistenceFilter","CurrentStatusUpdate","sorted_set_SortedSet","SortedSet","fromMapKeys","keys","has","elem","first","last","cb","forEachInRange","range","iter","forEachWhile","firstAfterOrEqual","unionWith","thisIt","otherIt","thisElem","otherElem","remote_event_RemoteEvent","RemoteEvent","targetChanges","documentUpdates","addDocumentUpdate","handleExistenceFilterMismatch","mapping","ResetMapping","currentStatusUpdate","MarkNotCurrent","WatchTargetChangeState","EMPTY_KEY_SET","docs","UpdateMapping","addedDocuments","removedDocuments","applyToKeySet","DocumentWatchChange","updatedTargetIds","removedTargetIds","newDoc","ExistenceFilterChange","existenceFilter","watch_change_WatchTargetChange","WatchTargetChange","state","targetIds","cause","watch_change_WatchChangeAggregator","WatchChangeAggregator","listenTargets","pendingTargetResponses","existenceFilters","frozen","watchChange","addDocumentChange","addTargetChange","addExistenceFilterChange","addChanges","watchChanges","createRemoteEvent","isActiveTarget","ensureTargetChange","None","docChange","relevant","targetChange","NoChange","recordTargetResponse","Current","MarkCurrent","Reset","newCount","DIRECTIONS","dirs","OPERATORS","ops","serializer_JsonProtoSerializer","JsonProtoSerializer","useProto3Json","unsafeCastProtoByteString","byteString","fromRpcStatus","toInt32Value","fromInt32Value","toBytes","bytes","fromBlob","blob","toResourceName","fullyQualifiedPrefixPath","fromResourceName","resource","isValidResourceName","toName","fromName","extractLocalPathFromResourceName","toQueryPath","encodedDatabaseId","fromQueryPath","resourceName","toValue","nullValue","booleanValue","integerValue","doubleValue","stringValue","mapValue","toMapValue","arrayValue","toArrayValue","timestampValue","geoPointValue","bytesValue","referenceValue","fromValue","fromFields","values","dbId","toMutationDocument","toFields","toDocument","document","fromDocument","fromFound","found","fromMissing","missing","readTime","fromMaybeDocument","toWatchTargetChangeState","toTestWatchChange","documentChange","documentDelete","documentRemove","targetChangeType","fromWatchChange","fromWatchTargetChangeState","causeProto","entityChange","docDelete","docRemove","versionFromListenResponse","toMutation","mutation","updateMask","toDocumentMask","toFieldTransform","currentDocument","toPrecondition","fromMutation","proto","fromPrecondition","fromDocumentMask","fromFieldTransform","fromWriteResult","fromWriteResults","protos","setToServerValue","toDocumentsTarget","fromDocumentsTarget","documentsTarget","toQueryTarget","structuredQuery","parent","from","collectionId","where","toFilter","toOrder","toCursor","fromQueryTarget","fromCount","filterBy","fromFilter","fromOrder","fromCursor","toListenRequestLabels","queryData","toLabel","goog-listen-tags","Listen","ExistenceFilterMismatch","LimboResolution","toTarget","toRelationFilter","toUnaryFilter","compositeFilter","unaryFilter","fromUnaryFilter","fromRelationFilter","f","reduce","accum","orderBys","toPropertyOrder","fromPropertyOrder","cursor","toDirection","fromDirection","toOperatorName","fromOperatorName","toFieldPathReference","fromFieldPathReference","fieldReference","direction","nanField","nullField","fieldPaths","paths","dist","stream_bridge_StreamBridge","StreamBridge","sendFn","closeFn","onOpen","callback","wrappedOnOpen","onClose","wrappedOnClose","onMessage","wrappedOnMessage","close","send","callOnOpen","callOnClose","err","callOnMessage","LOG_TAG","RPC_NAME_REST_MAPPING","BatchGetDocuments","Commit","X_GOOG_API_CLIENT_VALUE","webchannel_connection_WebChannelConnection","WebChannelConnection","info","pool","baseUrl","modifyHeadersForRequest","headers","header","authHeaders","invokeRPC","rpcName","url","makeUrl","Promise","getObject","xhr","listenOnce","COMPLETE","getLastErrorCode","NO_ERROR","json","getResponseJson","TIMEOUT","HTTP_ERROR","status_1","getStatus","getResponseText","getStatusText","getLastError","releaseObject","requestString","Content-Type","invokeStreamingRPC","openStream","urlParts","webchannelTransport","backgroundChannelTest","httpSessionIdParam","initMessageHeaders","httpHeadersOverwriteParam","messageUrlParams","sendRawJson","supportsCrossDomainXhr","channel","createWebChannel","opened","closed","streamBridge","open","unguardedEventListen","listen","param","setTimeout","EventType","OPEN","CLOSE","MESSAGE","msgData","status_2","urlRpcName","browser_platform_BrowserPlatform","BrowserPlatform","loadConnection","databaseInfo","newSerializer","encoded","raw","OnlineState","fieldNames","documentId","_DOCUMENT_ID","SyncState","GeneratorIds","view_snapshot_DocumentChangeSet","DocumentChangeSet","changeMap","track","oldChange","getChanges","changes","ViewSnapshot","hasPendingWrites","syncStateChanged","otherChanges","document_set_DocumentSet","DocumentSet","keyedMap","sortedSet","emptySet","oldSet","thisDoc","otherDoc","docStrings","newSet","obj_map_ObjectMap","ObjectMap","mapKeyFn","inner","id","matches_1","otherKey","splice","entries","entries_1","QueryListenersInfo","listeners","event_manager_EventManager","EventManager","syncEngine","queries","q","onlineState","Unknown","subscribe","onChange","onError","listener","firstListen","queryInfo","applyOnlineStateChange","viewSnap","onViewSnapshot","then","unlisten","lastListen","viewSnaps","viewSnaps_1","event_manager_QueryListener","QueryListener","queryObserver","raisedInitialEvent","snap","includeDocumentMetadataChanges","shouldRaiseEvent","shouldRaiseInitialEvent","raiseInitialEvent","maybeOnline","Offline","waitForSyncWhenOnline","hasPendingWritesChanged","includeQueryMetadataChanges","getInitialViewChanges","PersistencePromise","nextCallback","catchCallback","isDone","callbackAttached","catch","nextFn","catchFn","wrapFailure","wrapSuccess","toPromise","wrapUserFunction","waitFor","all","promise","nextPromise","idx","initial","eager_garbage_collector_EagerGarbageCollector","EagerGarbageCollector","isEager","sources","potentialGarbage","addGarbageSource","garbageSource","setGarbageCollector","removeGarbageSource","addPotentialGarbageKey","collectGarbage","promises","garbageKeys","hasRefsPromise","documentHasAnyReferences","hasRefs","source","containsKey","local_view_changes_LocalViewChanges","LocalViewChanges","addedKeys","removedKeys","fromSnapshot","viewSnapshot","reference_set_ReferenceSet","ReferenceSet","refsByKey","reference_set_DocReference","refsByTarget","compareByTargetId","garbageCollector","addReference","ref","addReferences","removeReference","removeRef","removeReferences","removeReferencesForId","emptyKey","startRef","endRef","removeAllReferences","referencesForId","firstRef","DocReference","targetOrBatchId","RESERVED_BITS","TimerId","TargetIdGenerator","generatorId","initAfter","afterWithoutGenerator","afterGenerator","previousId","forLocalStore","LocalStore","forSyncEngine","SyncEngine","AddedLimboDocument","RemovedLimboDocument","view_View","View","syncedDocuments","syncState","limboDocuments","mutatedKeys","documentSet","computeDocChanges","previousChanges","changeSet","oldDocumentSet","newMutatedKeys","newDocumentSet","needsRefill","lastDocInLimit","newMaybeDoc","oldDoc","docsEqual","applyChanges","sort","applyTargetChange","limboChanges","updateLimboDocuments","synced","newSyncState","Synced","Local","shouldBeInLimbo","targetMapping","oldLimboDocuments","QueryView","view","sync_engine_SyncEngine","localStore","remoteStore","currentUser","viewHandler","errorHandler","queryViewsByQuery","queryViewsByTarget","limboTargetsByKey","limboKeysByTarget","limboDocumentRefs","limboCollector","mutationUserCallbacks","targetIdGenerator","assertSubscribed","allocateQuery","executeQuery","remoteDocumentKeys","remoteKeys","viewDocChanges","viewChange","queryView","releaseQuery","removeAndCleanupQuery","write","batch","userCallback","localWrite","addMutationCallback","batchId","emitNewSnapsAndNotifyLocalStore","fillWritePipeline","wrapUpdateFunctionError","runTransaction","updateFunction","retries","transaction","createTransaction","userPromise","commit","applyRemoteEvent","remoteEvent","limboKey","newViewSnapshots","rejectListen","docMap","event_1","queryView_1","applySuccessfulWrite","mutationBatchResult","processUserCallback","acknowledgeBatch","rejectFailedWrite","rejectBatch","newCallbacks","toKey","gcLimboDocuments","updateTrackedLimbos","limboChanges_1","limboChange","trackLimboChange","limboTargetId","currentLimboDocs","newSnaps","docChangesInAllViews","queriesProcessed","notifyLocalViewChanges","fnName","handleUserChange","user","BATCHID_UNKNOWN","mutation_batch_MutationBatch","MutationBatch","mutations","batchResult","mutationResults","keySet","isTombstone","toTombstone","mutation_batch_MutationBatchResult","MutationBatchResult","commitVersion","streamToken","docVersions","versionMap","DbTimestamp","ownerId","leaseTimestampMs","userId","lastAcknowledgedBatchId","lastStreamToken","localWriteTimeMs","DbDocumentMutation","prefixForUser","prefixForPath","PLACEHOLDER","DbNoDocument","noDocument","lastListenSequenceNumber","highestTargetId","highestListenSequenceNumber","lastRemoteSnapshotVersion","ALL_STORES","simple_db_SimpleDb","SimpleDb","openOrCreate","runUpgrade","isAvailable","window","indexedDB","onupgradeneeded","oldVersion","deleteDatabase","ua","navigator","userAgent","mode","objectStores","transactionFn","transactionFnResult","abort","completionPromise","IterationController","dbCursor","shouldStop","nextKey","done","skip","SimpleDbTransaction","aborted","onabort","oncomplete","objectStoreNames","storeName","objectStore","simple_db_SimpleDbStore","SimpleDbStore","keyOrValue","loadAll","indexOrRange","iterateCursor","deleteAll","keysOnly","control","iterate","optionsOrCallback","cursorRequest","controller","userResult","primaryKey","skipToKey","continue","indexName","reverse","openKeyCursor","openCursor","indexeddb_mutation_queue_IndexedDbMutationQueue","IndexedDbMutationQueue","serializer","forUser","uid","isAuthenticated","loadNextBatchIdFromDb","nextBatchId","checkEmpty","empty","maxBatchId","nextUser","IDBKeyRange","keyForBatchId","getNextBatchId","getHighestAcknowledgedBatchId","getLastStreamToken","setLastStreamToken","addMutationBatch","dbBatch","toDbMutationBatch","mutations_1","indexKey","lookupMutationBatch","fromDbMutationBatch","getNextMutationBatchAfterBatchId","max","lowerBound","foundBatch","getAllMutationBatches","dbBatches","getAllMutationBatchesThroughBatchId","getAllMutationBatchesAffectingDocumentKey","documentKey","indexPrefix","indexStart","userID","encodedPath","batchID","mutationKey","getAllMutationBatchesAffectingQuery","queryPath","immediateChildrenLength","uniqueBatchIDs","removeMutationBatches","batches","indexTxn","this_1","batches_1","only","numDeleted","removePromise","performConsistencyCheck","startRange","danglingMutationReferences","gc","indexeddb_query_cache_IndexedDbQueryCache","IndexedDbQueryCache","lastSavedVersion","getHighestTargetId","getLastRemoteSnapshotVersion","setLastRemoteSnapshotVersion","addQueryData","saveQueryData","updateMetadataFromQueryData","saveMetadata","updateQueryData","removeQueryData","removeMatchingKeysForTargetId","toDbTarget","needsUpdate","getQueryData","fromDbTarget","addMatchingKeys","removeMatchingKeys","notifyGCForRemovedKeys","getMatchingKeysForTargetId","indexeddb_remote_document_cache_IndexedDbRemoteDocumentCache","IndexedDbRemoteDocumentCache","addEntry","maybeDocument","toDbRemoteDocument","removeEntry","getEntry","dbRemoteDoc","fromDbRemoteDocument","getDocumentsMatchingQuery","local_serializer_LocalSerializer","LocalSerializer","remoteSerializer","remoteDoc","serializedMutations","m","dbTarget","queryProto","dbTimestamp","EXISTING_OWNER_ERROR_MSG","indexeddb_persistence_IndexedDbPersistence","IndexedDbPersistence","prefix","generateOwnerId","dbName","MAIN_DATABASE","localStoragePrefix","started","simpleDb","tryAcquireOwnerLease","scheduleOwnerLeaseRefreshes","attachWindowUnloadHook","persistenceError","shutdown","detachWindowUnloadHook","stopOwnerLeaseRefreshes","releaseOwnerLease","getMutationQueue","getQueryCache","getRemoteDocumentCache","operation","ensureOwnerLease","buildStoragePrefix","isDefaultDatabase","dbOwner","validOwner","newDbOwner","minAcceptable","maxAcceptable","getZombiedOwnerId","ownerLeaseRefreshHandle","setInterval","reason","clearInterval","windowUnloadHandler","setZombiedOwnerId","addEventListener","removeEventListener","zombiedOwnerId","localStorage","getItem","zombiedOwnerLocalStorageKey","zombieOwnerId","removeItem","setItem","local_documents_view_LocalDocumentsView","LocalDocumentsView","remoteDocumentCache","mutationQueue","getDocument","computeLocalDocument","getDocuments","getDocumentsMatchingDocumentQuery","getDocumentsMatchingCollectionQuery","queryResults","computeLocalDocuments","promisedResults","matchingMutationBatches","matchingKeys","matchingMutationBatches_1","mutatedDoc","remote_document_change_buffer_RemoteDocumentChangeBuffer","RemoteDocumentChangeBuffer","assertChanges","bufferedEntry","local_store_LocalStore","persistence","initialUser","localViewReferences","heldBatchResults","remoteDocuments","queryCache","localDocuments","startMutationQueue","startQueryCache","oldBatches","promisedOldBatches","newBatches","changedKeys","_d","highestAck","ackedBatches","promisedBatch","changedDocuments","affected","shouldHoldBatchResult","documentBuffer_1","releaseBatchResults","promisedAffectedKeys","toReject","affectedKeys","promisedToReject","lastAcked","removeMutationBatch","documentBuffer","changedDocKeys","existingDoc","lastRemoteVersion","remoteVersion","releasedWriteKeys","releaseHeldBatchResults","promisedReleasedWriteKeys","viewChanges","viewChanges_1","nextMutationBatch","afterBatchId","readDocument","cached","documentBuffer_2","garbage","toRelease","isRemoteUpToVersion","batchResults","promiseChain","batchResults_1","applyWriteToRemoteDocuments","affectedDocs","batches_2","docKeys","ackVersion","memory_mutation_queue_MemoryMutationQueue","MemoryMutationQueue","highestAcknowledgedBatchId","batchesByDocumentKey","batchIndex","indexOfExistingBatchId","findMutationBatch","rawIndex","indexOfBatchId","getAllLiveMutationBatchesBeforeIndex","endIndex","immediateChildrenPathLength","startPath","rowKeyPath","batchCount","firstBatchId","queueCount","startIndex","queueIndex","length_1","references","memory_query_cache_MemoryQueryCache","MemoryQueryCache","memory_remote_document_cache_MemoryRemoteDocumentCache","MemoryRemoteDocumentCache","iterator","memory_persistence_MemoryPersistence","MemoryPersistence","mutationQueues","queue","MemoryPersistenceTransaction","no_op_garbage_collector_NoOpGarbageCollector","NoOpGarbageCollector","Deferred","PersistentStreamState","async_queue_DelayedOperation","DelayedOperation","asyncQueue","timerId","targetTimeMs","removalCallback","deferred","createAndSchedule","delayMs","targetTime","delayedOp","timerHandle","handleDelayElapsed","skipDelay","cancel","clearTimeout","enqueue","async_queue_AsyncQueue","AsyncQueue","tail","delayedOperations","operationInProgress","verifyNotFailed","newTail","stack","enqueueAfterDelay","containsDelayedOperation","removeDelayedOperation","verifyOperationInProgress","drain","findIndex","runDelayedOperationsEarly","lastTimerId","All","a","b","backoff_ExponentialBackoff","ExponentialBackoff","initialDelayMs","backoffFactor","maxDelayMs","timerPromise","reset","currentBaseMs","resetToMax","backoffAndRun","delayWithJitterMs","jitterDelayMs","BACKOFF_INITIAL_DELAY_MS","BACKOFF_MAX_DELAY_MS","BACKOFF_FACTOR","persistent_stream_PersistentStream","PersistentStream","connectionTimerId","idleTimerId","connection","credentialsProvider","inactivityTimerPromise","stream","backoff","Initial","isStarted","Backoff","Auth","Open","isOpen","performBackoff","auth","stop","Stopped","inhibitBackoff","markIdle","handleIdleCloseTimer","sendRequest","cancelIdleCheck","finalState","tearDown","getToken","startStream","rpcError","handleStreamClose","dispatchIfStillActive","currentStream_1","startRpc","persistent_stream_PersistentListenStream","PersistentListenStream","ListenStreamConnectionBackoff","ListenStreamIdle","watchChangeProto","onWatchChange","watch","addTarget","labels","unwatch","removeTarget","persistent_stream_PersistentWriteStream","PersistentWriteStream","WriteStreamConnectionBackoff","WriteStreamIdle","handshakeComplete_","writeMutations","responseProto","writeResults","commitTime","onMutationResult","onHandshakeComplete","writeHandshake","writes","datastore_Datastore","Datastore","newPersistentWriteStream","newPersistentWatchStream","params","response","lookup","transaction_Transaction","Transaction","datastore","readVersions","committed","recordVersion","docVersion","existingVersion","preconditionForUpdate","toMutations","unwritten","online_state_tracker_OnlineStateTracker","OnlineStateTracker","onlineStateHandler","watchStreamFailures","onlineStateTimer","shouldWarnClientIsOffline","handleWatchStreamStart","setAndBroadcast","OnlineStateTimeout","logClientOfflineWarningIfNecessary","handleWatchStreamFailure","Online","clearOnlineStateTimer","newState","remote_store_RemoteStore","RemoteStore","pendingWrites","lastBatchSeen","accumulatedWatchChanges","watchStream","writeStream","onlineStateTracker","enableNetwork","isNetworkEnabled","shouldStartWatchStream","startWatchStream","disableNetwork","disableNetworkInternal","cleanUpWatchStreamState","cleanUpWriteStreamState","sendWatchRequest","sendUnwatchRequest","recordPendingTargetRequest","onWatchStreamOpen","onWatchStreamClose","onWatchStreamChange","handleTargetError","handleWatchChangeBatch","aggregator","deletedDoc","trackedRemote","newQueryData","requestQueryData","canWriteMutations","outstandingWrites","shouldStartWriteStream","startWriteStream","handshakeComplete","onWriteStreamOpen","onWriteStreamClose","onWriteHandshakeComplete","shift","success","errorHandling","handleWriteError","handleHandshakeError","firestore_client_FirestoreClient","FirestoreClient","usePersistence","initializationDone","persistenceResult","initialized","setUserChangeListener","initializePersistence","initializeRest","startIndexedDbPersistence","canFallback","console","warn","startMemoryPersistence","storagePrefix","onlineStateChangedHandler","eventMgr","removeUserChangeListener","observer","AsyncObserver","muted","scheduleEvent","mute","eventHandler","User","otherUser","GOOGLE_CREDENTIALS","FIRST_PARTY","OAuthToken","Authorization","EmptyCredentialsProvider","userListener","forceRefresh","credentials_FirebaseCredentialsProvider","FirebaseCredentialsProvider","tokenListener","userCounter","newUser","getUser","addAuthTokenListener","initialUserCounter","tokenData","accessToken","removeAuthTokenListener","getUid","currentUid","credentials_FirstPartyToken","FirstPartyToken","gapi","X-Goog-AuthUser","FirstPartyCredentialsProvider","field_value_DeleteFieldValueImpl","serverTimestamp","field_value_ServerTimestampFieldValueImpl","DeleteFieldValueImpl","ServerTimestampFieldValueImpl","PublicFieldValue","RESERVED_FIELD_REGEX","user_data_converter_ParsedSetData","ParsedSetData","user_data_converter_ParsedUpdateData","ParsedUpdateData","user_data_converter_ParseContext","ParseContext","arrayElement","validatePath","childContextForField","childPath","validatePathSegment","childContextForFieldPath","childContextForArray","fieldDescription","user_data_converter_UserDataConverter","UserDataConverter","preConverter","parseSetData","updateData","parseData","parseMergeData","parseUpdateData","fieldMaskPaths","childContext","runPreConverter","parsedValue","mask","parseUpdateVarargs","moreFieldsAndValues","value_1","parseQueryValue","parsed","parseArray","parseObject","parseScalarValue","entryIndex","array_1","entry","parsedEntry","DEFAULT_HOST","DEFAULT_SSL","database_FirestoreSettings","FirestoreSettings","settings","FirestoreConfig","Firestore","databaseIdOrApp","_queue","_firestoreClient","config","firebaseApp","databaseIdFromApp","external_1","_config","_databaseId","settingsLiteral","newSettings","ensureClientConfigured","enablePersistence","configureClient","thisDb","otherDb","_key","_dataConverter","collection","pathString","database_CollectionReference","forPath","database_Transaction","database_WriteBatch","level","_firestore","_transaction","database_DocumentSnapshot","fieldOrUpdateData","WriteBatch","_mutations","_committed","verifyNotCommitted","DocumentReference","onSnapshot","includeMetadataChanges","currArg","internalOptions","complete","onSnapshotInternal","errHandler","asyncObserver","internalListener","SnapshotMetadata","DocumentSnapshot","_document","_fromCache","convertObject","convertValue","convertArray","QueryDocumentSnapshot","database_Query","_query","opStr","validateNewFilter","directionStr","validateNewOrderBy","docOrField","boundFromDocOrFields","startAfter","endBefore","boundFromDocument","allFields","boundFromFields","components","rawValue","wrapped","database_QuerySnapshot","firestoreClient","existingField","validateOrderByAndInequalityMatch","inequality","QuerySnapshot","_originalQuery","_snapshot","_cachedChanges","thisArg","convertToDocumentImpl","CollectionReference","parentPath","docRef","PublicFirestore","PublicTransaction","PublicWriteBatch","PublicDocumentReference","PublicDocumentSnapshot","PublicQueryDocumentSnapshot","PublicQuery","PublicQuerySnapshot","PublicCollectionReference","117","global","l","aa","ba","propertyIsEnumerable","ca","da","ea","ha","ia","d","unshift","Function","ja","t","H","Db","ka","captureStackTrace","la","ma","u","na","pa","fa","sa","ta","va","wa","xa","za","x","w","Ca","Da","Ea","Fa","Ha","Ga","Ia","Ja","Ka","Qa","documentMode","Va","ya","Ra","h","parseInt","z","bb","relatedTarget","button","screenY","screenX","clientY","clientX","metaKey","shiftKey","altKey","ctrlKey","pointerId","pointerType","changedTouches","srcElement","Oa","nodeName","fromElement","toElement","pageX","pageY","defaultPrevented","fb","proxy","src","capture","ga","eb","Z","gb","hb","jb","qa","ib","nb","once","ob","pb","qb","rb","kb","sb","ab","attachEvent","tb","addListener","removeListener","mb","ub","Za","vb","wb","detachEvent","lb","xb","yb","keyCode","returnValue","parentNode","zb","handleEvent","A","N","J","Ab","Bb","Cb","eval","Eb","Fb","Boolean","Gb","valueOf","Ib","Hb","Jb","Kb","Ob","Pb","Mb","Qb","Sb","MessageChannel","postMessage","createElement","style","display","documentElement","appendChild","contentWindow","location","protocol","origin","port1","onmessage","port2","onreadystatechange","removeChild","Ub","Tb","Vb","setImmediate","Window","Rb","Nb","Wb","Xb","g","r","Yb","O","Zb","$b","ac","Y","bc","dc","cc","ec","fc","hc","B","nc","qc","pc","oc","lc","lastIndexOf","C","log","jc","rc","kc","D","mc","sc","tc","E","I","W","Lb","uc","F","vc","wc","G","xc","ic","parse","yc","zc","dispatchEvent","Ac","K","Bc","Cc","Dc","Gc","Ic","Jc","Kc","Lc","Mc","Oc","Pc","ActiveXObject","XMLHttpRequest","L","T","R","Qc","Na","S","j","U","o","X","Rc","Uc","Vc","M","Wc","Xc","Yc","Zc","$c","V","ad","bd","cd","dd","ed","fd","gd","hd","Tc","Sc","jd","$","kd","ld","ra","nd","od","P","md","qd","decodeURIComponent","Q","rd","sd","td","ud","vd","match","pd","wd","xd","Dd","yd","Ed","Fd","abs","Gd","Hd","decodeURI","encodeURI","Id","Kd","Jd","Ld","toLowerCase","Md","Od","Nd","Pd","Qd","Rd","Sd","Td","Vd","Wd","Xd","Yd","Zd","$d","oa","La","ae","be","ce","de","ee","fe","ge","he","ie","je","encodeURIComponent","ke","Image","onload","le","ontimeout","me","re","y","timeout","pe","se","te","ue","goog","Ma","self","ne","qe","readyState","getResponseHeader","ve","we","xe","Ua","concurrentRequestLimit","fastHandshake","ye","ze","Ae","sendBeacon","Be","Ce","De","Ee","Pa","Fe","Ge","Ie","He","round","Wa","Je","Ke","Le","Ud","Aa","Me","hostname","port","Ne","Oe","Pe","testUrl","messageHeaders","clientProtocolHeaderRequired","X-Client-Protocol","messageContentType","X-WebChannel-Content-Type","X-WebChannel-Client-Profile","Qe","Re","__sm__","Se","Ue","Ve","We","Xe","Ye","$e","Ze","af","bf","cf","df","trim","Ba","Sa","Ta","parseFloat","Xa","compatMode","Ya","freeze","$a","2","3","4","preventDefault","\"","\\","/","\b","\f","\n","\r","\t","\u000b","Ec","Fc","Hc","Nc","zd","Ad","Bd","Cd","oe","toUpperCase","FormData","setRequestHeader","responseType","withCredentials","statusText","responseText","__data__","Te","createWebChannelTransport","ErrorCode","WebChannel","XhrIoPool","22","instances","inst","defaultLogLevel","INFO","defaultLogHandler","logType","toISOString","VERBOSE","WARN","Logger","_logLevel","_logHandler","TypeError"],"mappings":"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","file":"firebase-firestore.js","sourcesContent":["/*!\n * @license Firebase v4.12.0\n * Build: rev-ef14d4f\n * Terms: https://firebase.google.com/terms/\n */\ntry {\n        webpackJsonpFirebase([1],{\n\n/***/ 115:\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n__webpack_require__(116);\n\n\n/***/ }),\n\n/***/ 116:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// EXTERNAL MODULE: ../app/dist/esm/index.js + 1 modules\nvar esm = __webpack_require__(7);\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/core/version.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** The semver (www.semver.org) version of the SDK. */\nvar SDK_VERSION = esm[\"default\"].SDK_VERSION;\n\n//# sourceMappingURL=version.js.map\n\n// EXTERNAL MODULE: ../logger/dist/esm/index.js + 1 modules\nvar dist_esm = __webpack_require__(22);\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/log.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* tslint:disable:no-console */\n\n\n\nvar logClient = new dist_esm[\"Logger\"]('@firebase/firestore');\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogLevel[LogLevel[\"ERROR\"] = 1] = \"ERROR\";\n    LogLevel[LogLevel[\"SILENT\"] = 2] = \"SILENT\";\n})(LogLevel || (LogLevel = {}));\n// Helper methods are needed because variables can't be exported as read/write\nfunction getLogLevel() {\n    if (logClient.logLevel === dist_esm[\"LogLevel\"].DEBUG) {\n        return LogLevel.DEBUG;\n    }\n    else if (logClient.logLevel === dist_esm[\"LogLevel\"].SILENT) {\n        return LogLevel.SILENT;\n    }\n    else {\n        return LogLevel.ERROR;\n    }\n}\nfunction setLogLevel(newLevel) {\n    /**\n     * Map the new log level to the associated Firebase Log Level\n     */\n    switch (newLevel) {\n        case LogLevel.DEBUG:\n            logClient.logLevel = dist_esm[\"LogLevel\"].DEBUG;\n            break;\n        case LogLevel.ERROR:\n            logClient.logLevel = dist_esm[\"LogLevel\"].ERROR;\n            break;\n        case LogLevel.SILENT:\n            logClient.logLevel = dist_esm[\"LogLevel\"].SILENT;\n            break;\n        default:\n            logClient.error(\"Firestore (\" + SDK_VERSION + \"): Invalid value passed to `setLogLevel`\");\n    }\n}\nfunction debug(tag, msg) {\n    var obj = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        obj[_i - 2] = arguments[_i];\n    }\n    if (logClient.logLevel <= dist_esm[\"LogLevel\"].DEBUG) {\n        var args = obj.map(argToString);\n        logClient.debug.apply(logClient, [\"Firestore (\" + SDK_VERSION + \") [\" + tag + \"]: \" + msg].concat(args));\n    }\n}\nfunction log_error(msg) {\n    var obj = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        obj[_i - 1] = arguments[_i];\n    }\n    if (logClient.logLevel <= dist_esm[\"LogLevel\"].ERROR) {\n        var args = obj.map(argToString);\n        logClient.error.apply(logClient, [\"Firestore (\" + SDK_VERSION + \"): \" + msg].concat(args));\n    }\n}\n/**\n * Converts an additional log parameter to a string representation.\n */\nfunction argToString(obj) {\n    if (typeof obj === 'string') {\n        return obj;\n    }\n    else {\n        var platform = platform_PlatformSupport.getPlatform();\n        try {\n            return platform.formatJSON(obj);\n        }\n        catch (e) {\n            // Converting to JSON failed, just log the object directly\n            return obj;\n        }\n    }\n}\n\n//# sourceMappingURL=log.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/assert.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * Unconditionally fails, throwing an Error with the given message.\n *\n * Returns any so it can be used in expressions:\n * @example\n * let futureVar = fail('not implemented yet');\n */\nfunction fail(failure) {\n    // Log the failure in addition to throw an exception, just in case the\n    // exception is swallowed.\n    var message = \"FIRESTORE (\" + SDK_VERSION + \") INTERNAL ASSERTION FAILED: \" + failure;\n    log_error(message);\n    // NOTE: We don't use FirestoreError here because these are internal failures\n    // that cannot be handled by the user. (Also it would create a circular\n    // dependency between the error and assert modules which doesn't work.)\n    throw new Error(message);\n}\n/**\n * Fails if the given assertion condition is false, throwing an Error with the\n * given message if it did.\n */\nfunction assert(assertion, message) {\n    if (!assertion) {\n        fail(message);\n    }\n}\n\n//# sourceMappingURL=assert.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/platform/platform.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Provides singleton helpers where setup code can inject a platform at runtime.\n * setPlatform needs to be set before Firestore is used and must be set exactly\n * once.\n */\nvar platform_PlatformSupport = /** @class */ (function () {\n    function PlatformSupport() {\n    }\n    PlatformSupport.setPlatform = function (platform) {\n        if (PlatformSupport.platform) {\n            fail('Platform already defined');\n        }\n        PlatformSupport.platform = platform;\n    };\n    PlatformSupport.getPlatform = function () {\n        if (!PlatformSupport.platform) {\n            fail('Platform not set');\n        }\n        return PlatformSupport.platform;\n    };\n    return PlatformSupport;\n}());\n\n/**\n * Returns the representation of an empty \"proto\" byte string for the\n * platform.\n */\nfunction emptyByteString() {\n    return platform_PlatformSupport.getPlatform().emptyByteString;\n}\n\n//# sourceMappingURL=platform.js.map\n\n// EXTERNAL MODULE: /tmp/tmp-208812ou3wR5n5ZCvd/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(2);\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/error.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// TODO(mcg): Change to a string enum once we've upgraded to typescript 2.4.\n//  tslint:disable-next-line:variable-name Intended to look like a TS 2.4 enum\nvar Code = {\n    // Causes are copied from:\n    // https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\n    /** Not an error; returned on success. */\n    OK: 'ok',\n    /** The operation was cancelled (typically by the caller). */\n    CANCELLED: 'cancelled',\n    /** Unknown error or an error from a different error domain. */\n    UNKNOWN: 'unknown',\n    /**\n     * Client specified an invalid argument. Note that this differs from\n     * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are\n     * problematic regardless of the state of the system (e.g., a malformed file\n     * name).\n     */\n    INVALID_ARGUMENT: 'invalid-argument',\n    /**\n     * Deadline expired before operation could complete. For operations that\n     * change the state of the system, this error may be returned even if the\n     * operation has completed successfully. For example, a successful response\n     * from a server could have been delayed long enough for the deadline to\n     * expire.\n     */\n    DEADLINE_EXCEEDED: 'deadline-exceeded',\n    /** Some requested entity (e.g., file or directory) was not found. */\n    NOT_FOUND: 'not-found',\n    /**\n     * Some entity that we attempted to create (e.g., file or directory) already\n     * exists.\n     */\n    ALREADY_EXISTS: 'already-exists',\n    /**\n     * The caller does not have permission to execute the specified operation.\n     * PERMISSION_DENIED must not be used for rejections caused by exhausting\n     * some resource (use RESOURCE_EXHAUSTED instead for those errors).\n     * PERMISSION_DENIED must not be used if the caller can not be identified\n     * (use UNAUTHENTICATED instead for those errors).\n     */\n    PERMISSION_DENIED: 'permission-denied',\n    /**\n     * The request does not have valid authentication credentials for the\n     * operation.\n     */\n    UNAUTHENTICATED: 'unauthenticated',\n    /**\n     * Some resource has been exhausted, perhaps a per-user quota, or perhaps the\n     * entire file system is out of space.\n     */\n    RESOURCE_EXHAUSTED: 'resource-exhausted',\n    /**\n     * Operation was rejected because the system is not in a state required for\n     * the operation's execution. For example, directory to be deleted may be\n     * non-empty, an rmdir operation is applied to a non-directory, etc.\n     *\n     * A litmus test that may help a service implementor in deciding\n     * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:\n     *  (a) Use UNAVAILABLE if the client can retry just the failing call.\n     *  (b) Use ABORTED if the client should retry at a higher-level\n     *      (e.g., restarting a read-modify-write sequence).\n     *  (c) Use FAILED_PRECONDITION if the client should not retry until\n     *      the system state has been explicitly fixed. E.g., if an \"rmdir\"\n     *      fails because the directory is non-empty, FAILED_PRECONDITION\n     *      should be returned since the client should not retry unless\n     *      they have first fixed up the directory by deleting files from it.\n     *  (d) Use FAILED_PRECONDITION if the client performs conditional\n     *      REST Get/Update/Delete on a resource and the resource on the\n     *      server does not match the condition. E.g., conflicting\n     *      read-modify-write on the same resource.\n     */\n    FAILED_PRECONDITION: 'failed-precondition',\n    /**\n     * The operation was aborted, typically due to a concurrency issue like\n     * sequencer check failures, transaction aborts, etc.\n     *\n     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n     * and UNAVAILABLE.\n     */\n    ABORTED: 'aborted',\n    /**\n     * Operation was attempted past the valid range. E.g., seeking or reading\n     * past end of file.\n     *\n     * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed\n     * if the system state changes. For example, a 32-bit file system will\n     * generate INVALID_ARGUMENT if asked to read at an offset that is not in the\n     * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from\n     * an offset past the current file size.\n     *\n     * There is a fair bit of overlap between FAILED_PRECONDITION and\n     * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)\n     * when it applies so that callers who are iterating through a space can\n     * easily look for an OUT_OF_RANGE error to detect when they are done.\n     */\n    OUT_OF_RANGE: 'out-of-range',\n    /** Operation is not implemented or not supported/enabled in this service. */\n    UNIMPLEMENTED: 'unimplemented',\n    /**\n     * Internal errors. Means some invariants expected by underlying System has\n     * been broken. If you see one of these errors, Something is very broken.\n     */\n    INTERNAL: 'internal',\n    /**\n     * The service is currently unavailable. This is a most likely a transient\n     * condition and may be corrected by retrying with a backoff.\n     *\n     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n     * and UNAVAILABLE.\n     */\n    UNAVAILABLE: 'unavailable',\n    /** Unrecoverable data loss or corruption. */\n    DATA_LOSS: 'data-loss'\n};\n/**\n * An error class used for Firestore-generated errors. Ideally we should be\n * using FirebaseError, but integrating with it is overly arduous at the moment,\n * so we define our own compatible error class (with a `name` of 'FirebaseError'\n * and compatible `code` and `message` fields.)\n */\nvar error_FirestoreError = /** @class */ (function (_super) {\n    tslib_es6[\"__extends\"](FirestoreError, _super);\n    function FirestoreError(code, message) {\n        var _this = _super.call(this, message) || this;\n        _this.code = code;\n        _this.message = message;\n        _this.name = 'FirebaseError';\n        // HACK: We write a toString property directly because Error is not a real\n        // class and so inheritance does not work correctly. We could alternatively\n        // do the same \"back-door inheritance\" trick that FirebaseError does.\n        _this.toString = function () { return _this.name + \": [code=\" + _this.code + \"]: \" + _this.message; };\n        return _this;\n    }\n    return FirestoreError;\n}(Error));\n\n\n//# sourceMappingURL=error.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/api.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// We are doing some heavy reflective stuff, lots of any casting necessary\n/* tslint:disable:no-any */\n\n/**\n * Helper function to prevent instantiation through the constructor.\n *\n * This method creates a new constructor that throws when it's invoked.\n * The prototype of that constructor is then set to the prototype of the hidden\n * \"class\" to expose all the prototype methods and allow for instanceof\n * checks.\n *\n * To also make all the static methods available, all properties of the\n * original constructor are copied to the new constructor.\n */\nfunction makeConstructorPrivate(cls, optionalMessage) {\n    function PublicConstructor() {\n        var error = 'This constructor is private.';\n        if (optionalMessage) {\n            error += ' ';\n            error += optionalMessage;\n        }\n        throw new error_FirestoreError(Code.INVALID_ARGUMENT, error);\n    }\n    // Make sure instanceof checks work and all methods are exposed on the public\n    // constructor\n    PublicConstructor.prototype = cls.prototype;\n    // Copy any static methods/members\n    for (var staticProperty in cls) {\n        if (cls.hasOwnProperty(staticProperty)) {\n            PublicConstructor[staticProperty] = cls[staticProperty];\n        }\n    }\n    return PublicConstructor;\n}\n\n//# sourceMappingURL=api.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/obj.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction contains(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nfunction get(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key) ? obj[key] : null;\n}\nfunction obj_size(obj) {\n    var count = 0;\n    for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            count++;\n        }\n    }\n    return count;\n}\n/** Returns the given value if it's defined or the defaultValue otherwise. */\nfunction defaulted(value, defaultValue) {\n    return value !== undefined ? value : defaultValue;\n}\nfunction forEachNumber(obj, fn) {\n    for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            var num = Number(key);\n            if (!isNaN(num)) {\n                fn(num, obj[key]);\n            }\n        }\n    }\n}\nfunction forEach(obj, fn) {\n    for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            fn(key, obj[key]);\n        }\n    }\n}\nfunction lookupOrInsert(obj, key, valFn) {\n    if (!contains(obj, key)) {\n        obj[key] = valFn();\n    }\n    return obj[key];\n}\nfunction isEmpty(obj) {\n    assert(obj != null && typeof obj === 'object', 'isEmpty() expects object parameter.');\n    for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction shallowCopy(obj) {\n    assert(obj && typeof obj === 'object', 'shallowCopy() expects object parameter.');\n    var result = {};\n    for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            result[key] = obj[key];\n        }\n    }\n    return result;\n}\n\n//# sourceMappingURL=obj.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/input_validation.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n * Validates the invocation of functionName has the exact number of arguments.\n *\n * Forward the magic \"arguments\" variable as second parameter on which the\n * parameter validation is performed:\n * validateExactNumberOfArgs('myFunction', arguments, 2);\n */\nfunction validateExactNumberOfArgs(functionName, args, numberOfArgs) {\n    if (args.length !== numberOfArgs) {\n        throw new error_FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires \" +\n            formatPlural(numberOfArgs, 'argument') +\n            ', but was called with ' +\n            formatPlural(args.length, 'argument') +\n            '.');\n    }\n}\n/**\n * Validates the invocation of functionName has at least the provided number of\n * arguments (but can have many more).\n *\n * Forward the magic \"arguments\" variable as second parameter on which the\n * parameter validation is performed:\n * validateAtLeastNumberOfArgs('myFunction', arguments, 2);\n */\nfunction validateAtLeastNumberOfArgs(functionName, args, minNumberOfArgs) {\n    if (args.length < minNumberOfArgs) {\n        throw new error_FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires at least \" +\n            formatPlural(minNumberOfArgs, 'argument') +\n            ', but was called with ' +\n            formatPlural(args.length, 'argument') +\n            '.');\n    }\n}\n/**\n * Validates the invocation of functionName has number of arguments between\n * the values provided.\n *\n * Forward the magic \"arguments\" variable as second parameter on which the\n * parameter validation is performed:\n * validateBetweenNumberOfArgs('myFunction', arguments, 2, 3);\n */\nfunction validateBetweenNumberOfArgs(functionName, args, minNumberOfArgs, maxNumberOfArgs) {\n    if (args.length < minNumberOfArgs || args.length > maxNumberOfArgs) {\n        throw new error_FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires between \" + minNumberOfArgs + \" and \" +\n            (maxNumberOfArgs + \" arguments, but was called with \") +\n            formatPlural(args.length, 'argument') +\n            '.');\n    }\n}\n/**\n * Validates the provided argument is an array and has as least the expected\n * number of elements.\n */\nfunction validateNamedArrayAtLeastNumberOfElements(functionName, value, name, minNumberOfElements) {\n    if (!(value instanceof Array) || value.length < minNumberOfElements) {\n        throw new error_FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires its \" + name + \" argument to be an \" +\n            'array with at least ' +\n            (formatPlural(minNumberOfElements, 'element') + \".\"));\n    }\n}\n/**\n * Validates the provided positional argument has the native JavaScript type\n * using typeof checks.\n */\nfunction validateArgType(functionName, type, position, argument) {\n    validateType(functionName, type, ordinal(position) + \" argument\", argument);\n}\n/**\n * Validates the provided argument has the native JavaScript type using\n * typeof checks or is undefined.\n */\nfunction validateOptionalArgType(functionName, type, position, argument) {\n    if (argument !== undefined) {\n        validateArgType(functionName, type, position, argument);\n    }\n}\n/**\n * Validates the provided named option has the native JavaScript type using\n * typeof checks.\n */\nfunction validateNamedType(functionName, type, optionName, argument) {\n    validateType(functionName, type, optionName + \" option\", argument);\n}\n/**\n * Validates the provided named option has the native JavaScript type using\n * typeof checks or is undefined.\n */\nfunction validateNamedOptionalType(functionName, type, optionName, argument) {\n    if (argument !== undefined) {\n        validateNamedType(functionName, type, optionName, argument);\n    }\n}\n/**\n * Validates that the provided named option equals one of the expected values.\n */\nfunction validateNamedPropertyEquals(functionName, inputName, optionName, input, expected) {\n    var expectedDescription = [];\n    for (var _i = 0, expected_1 = expected; _i < expected_1.length; _i++) {\n        var val = expected_1[_i];\n        if (val === input) {\n            return;\n        }\n        expectedDescription.push(valueDescription(val));\n    }\n    var actualDescription = valueDescription(input);\n    throw new error_FirestoreError(Code.INVALID_ARGUMENT, \"Invalid value \" + actualDescription + \" provided to function \" + functionName + \"() for option \\\"\" + optionName + \"\\\". Acceptable values: \" + expectedDescription.join(', '));\n}\n/**\n * Validates that the provided named option equals one of the expected values or\n * is undefined.\n */\nfunction validateNamedOptionalPropertyEquals(functionName, inputName, optionName, input, expected) {\n    if (input !== undefined) {\n        validateNamedPropertyEquals(functionName, inputName, optionName, input, expected);\n    }\n}\n/** Helper to validate the type of a provided input. */\nfunction validateType(functionName, type, inputName, input) {\n    if (typeof input !== type || (type === 'object' && !isPlainObject(input))) {\n        var description = valueDescription(input);\n        throw new error_FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires its \" + inputName + \" \" +\n            (\"to be of type \" + type + \", but it was: \" + description));\n    }\n}\n/**\n * Returns true iff it's a non-null object without a custom prototype\n * (i.e. excludes Array, Date, etc.).\n */\nfunction isPlainObject(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        Object.getPrototypeOf(input) === Object.prototype);\n}\n/** Returns a string describing the type / value of the provided input. */\nfunction valueDescription(input) {\n    if (input === undefined) {\n        return 'undefined';\n    }\n    else if (input === null) {\n        return 'null';\n    }\n    else if (typeof input === 'string') {\n        if (input.length > 20) {\n            input = input.substring(0, 20) + \"...\";\n        }\n        return JSON.stringify(input);\n    }\n    else if (typeof input === 'number' || typeof input === 'boolean') {\n        return '' + input;\n    }\n    else if (typeof input === 'object') {\n        if (input instanceof Array) {\n            return 'an array';\n        }\n        else {\n            var customObjectName = tryGetCustomObjectType(input);\n            if (customObjectName) {\n                return \"a custom \" + customObjectName + \" object\";\n            }\n            else {\n                return 'an object';\n            }\n        }\n    }\n    else if (typeof input === 'function') {\n        return 'a function';\n    }\n    else {\n        return fail('Unknown wrong type: ' + typeof input);\n    }\n}\n/** Hacky method to try to get the constructor name for an object. */\nfunction tryGetCustomObjectType(input) {\n    if (input.constructor) {\n        var funcNameRegex = /function\\s+([^\\s(]+)\\s*\\(/;\n        var results = funcNameRegex.exec(input.constructor.toString());\n        if (results && results.length > 1) {\n            return results[1];\n        }\n    }\n    return null;\n}\n/** Validates the provided argument is defined. */\nfunction validateDefined(functionName, position, argument) {\n    if (argument === undefined) {\n        throw new error_FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires a valid \" + ordinal(position) + \" \" +\n            \"argument, but it was undefined.\");\n    }\n}\n/**\n * Validates the provided positional argument is an object, and its keys and\n * values match the expected keys and types provided in optionTypes.\n */\nfunction validateOptionNames(functionName, options, optionNames) {\n    forEach(options, function (key, _) {\n        if (optionNames.indexOf(key) < 0) {\n            throw new error_FirestoreError(Code.INVALID_ARGUMENT, \"Unknown option '\" + key + \"' passed to function \" + functionName + \"(). \" +\n                'Available options: ' +\n                optionNames.join(', '));\n        }\n    });\n}\n/**\n * Helper method to throw an error that the provided argument did not pass\n * an instanceof check.\n */\nfunction invalidClassError(functionName, type, position, argument) {\n    var description = valueDescription(argument);\n    return new error_FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires its \" + ordinal(position) + \" \" +\n        (\"argument to be a \" + type + \", but it was: \" + description));\n}\n/** Converts a number to its english word representation */\nfunction ordinal(num) {\n    switch (num) {\n        case 1:\n            return 'first';\n        case 2:\n            return 'second';\n        case 3:\n            return 'third';\n        default:\n            return num + 'th';\n    }\n}\n/**\n * Formats the given word as plural conditionally given the preceding number.\n */\nfunction formatPlural(num, str) {\n    return num + \" \" + str + (num === 1 ? '' : 's');\n}\n\n//# sourceMappingURL=input_validation.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/misc.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// tslint:disable-next-line:class-as-namespace\nvar misc_AutoId = /** @class */ (function () {\n    function AutoId() {\n    }\n    AutoId.newId = function () {\n        // Alphanumeric characters\n        var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n        var autoId = '';\n        for (var i = 0; i < 20; i++) {\n            autoId += chars.charAt(Math.floor(Math.random() * chars.length));\n        }\n        assert(autoId.length === 20, 'Invalid auto ID: ' + autoId);\n        return autoId;\n    };\n    return AutoId;\n}());\n\nfunction primitiveComparator(left, right) {\n    if (left < right)\n        return -1;\n    if (left > right)\n        return 1;\n    return 0;\n}\n/** Helper to compare nullable (or undefined-able) objects using isEqual(). */\nfunction equals(left, right) {\n    if (left !== null && left !== undefined) {\n        return !!(right && left.isEqual(right));\n    }\n    else {\n        // HACK: Explicitly cast since TypeScript's type narrowing apparently isn't\n        // smart enough.\n        return left === right;\n    }\n}\n/** Helper to compare arrays using isEqual(). */\nfunction arrayEquals(left, right) {\n    if (left.length !== right.length) {\n        return false;\n    }\n    for (var i = 0; i < left.length; i++) {\n        if (!left[i].isEqual(right[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Returns the largest lexicographically smaller string of equal or smaller\n * length. Returns an empty string if there is no such predecessor (if the input\n * is empty).\n *\n * Strings returned from this method can be invalid UTF-16 but this is sufficent\n * in use for indexeddb because that depends on lexicographical ordering but\n * shouldn't be used elsewhere.\n */\nfunction immediatePredecessor(s) {\n    // We can decrement the last character in the string and be done\n    // unless that character is 0 (0x0000), in which case we have to erase the\n    // last character.\n    var lastIndex = s.length - 1;\n    if (s.length === 0) {\n        // Special case the empty string.\n        return '';\n    }\n    else if (s.charAt(lastIndex) === '\\0') {\n        return s.substring(0, lastIndex);\n    }\n    else {\n        return (s.substring(0, lastIndex) +\n            String.fromCharCode(s.charCodeAt(lastIndex) - 1));\n    }\n}\n/**\n * Returns the immediate lexicographically-following string. This is useful to\n * construct an inclusive range for indexeddb iterators.\n */\nfunction immediateSuccessor(s) {\n    // Return the input string, with an additional NUL byte appended.\n    return s + '\\0';\n}\n\n//# sourceMappingURL=misc.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/api/blob.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n/** Helper function to assert Uint8Array is available at runtime. */\nfunction assertUint8ArrayAvailable() {\n    if (typeof Uint8Array === 'undefined') {\n        throw new error_FirestoreError(Code.UNIMPLEMENTED, 'Uint8Arrays are not available in this environment.');\n    }\n}\n/** Helper function to assert Base64 functions are available at runtime. */\nfunction assertBase64Available() {\n    if (!platform_PlatformSupport.getPlatform().base64Available) {\n        throw new error_FirestoreError(Code.UNIMPLEMENTED, 'Blobs are unavailable in Firestore in this environment.');\n    }\n}\n/**\n * Immutable class holding a blob (binary data).\n * This class is directly exposed in the public API.\n *\n * Note that while you can't hide the constructor in JavaScript code, we are\n * using the hack above to make sure no-one outside this module can call it.\n */\nvar blob_Blob = /** @class */ (function () {\n    function Blob(binaryString) {\n        assertBase64Available();\n        this._binaryString = binaryString;\n    }\n    Blob.fromBase64String = function (base64) {\n        validateExactNumberOfArgs('Blob.fromBase64String', arguments, 1);\n        validateArgType('Blob.fromBase64String', 'string', 1, base64);\n        assertBase64Available();\n        try {\n            var binaryString = platform_PlatformSupport.getPlatform().atob(base64);\n            return new Blob(binaryString);\n        }\n        catch (e) {\n            throw new error_FirestoreError(Code.INVALID_ARGUMENT, 'Failed to construct Blob from Base64 string: ' + e);\n        }\n    };\n    Blob.fromUint8Array = function (array) {\n        validateExactNumberOfArgs('Blob.fromUint8Array', arguments, 1);\n        assertUint8ArrayAvailable();\n        if (!(array instanceof Uint8Array)) {\n            throw invalidClassError('Blob.fromUint8Array', 'Uint8Array', 1, array);\n        }\n        // We can't call array.map directly because it expects the return type to\n        // be a Uint8Array, whereas we can convert it to a regular array by invoking\n        // map on the Array prototype.\n        var binaryString = Array.prototype.map\n            .call(array, function (char) {\n            return String.fromCharCode(char);\n        })\n            .join('');\n        return new Blob(binaryString);\n    };\n    Blob.prototype.toBase64 = function () {\n        validateExactNumberOfArgs('Blob.toBase64', arguments, 0);\n        assertBase64Available();\n        return platform_PlatformSupport.getPlatform().btoa(this._binaryString);\n    };\n    Blob.prototype.toUint8Array = function () {\n        validateExactNumberOfArgs('Blob.toUint8Array', arguments, 0);\n        assertUint8ArrayAvailable();\n        var buffer = new Uint8Array(this._binaryString.length);\n        for (var i = 0; i < this._binaryString.length; i++) {\n            buffer[i] = this._binaryString.charCodeAt(i);\n        }\n        return buffer;\n    };\n    Blob.prototype.toString = function () {\n        return 'Blob(base64: ' + this.toBase64() + ')';\n    };\n    Blob.prototype.isEqual = function (other) {\n        return this._binaryString === other._binaryString;\n    };\n    /**\n     * Actually private to JS consumers of our API, so this function is prefixed\n     * with an underscore.\n     */\n    Blob.prototype._compareTo = function (other) {\n        return primitiveComparator(this._binaryString, other._binaryString);\n    };\n    return Blob;\n}());\n\n// Public instance that disallows construction at runtime. This constructor is\n// used when exporting Blob on firebase.firestore.Blob and will be called Blob\n// publicly. Internally we still use Blob which has a type checked private\n// constructor. Note that Blob and PublicBlob can be used interchangeably in\n// instanceof checks.\n// For our internal TypeScript code PublicBlob doesn't exist as a type, and so\n// we need to use Blob as type and export it too.\n// tslint:disable-next-line:variable-name We're treating this as a class name.\nvar PublicBlob = makeConstructorPrivate(blob_Blob, 'Use Blob.fromUint8Array() or Blob.fromBase64String() instead.');\n\n//# sourceMappingURL=blob.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/api/geo_point.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n * Immutable class representing a geo point as latitude-longitude pair.\n * This class is directly exposed in the public API, including its constructor.\n */\nvar geo_point_GeoPoint = /** @class */ (function () {\n    function GeoPoint(latitude, longitude) {\n        validateExactNumberOfArgs('GeoPoint', arguments, 2);\n        validateArgType('GeoPoint', 'number', 1, latitude);\n        validateArgType('GeoPoint', 'number', 2, longitude);\n        if (!isFinite(latitude) || latitude < -90 || latitude > 90) {\n            throw new error_FirestoreError(Code.INVALID_ARGUMENT, 'Latitude must be a number between -90 and 90, but was: ' + latitude);\n        }\n        if (!isFinite(longitude) || longitude < -180 || longitude > 180) {\n            throw new error_FirestoreError(Code.INVALID_ARGUMENT, 'Longitude must be a number between -180 and 180, but was: ' + longitude);\n        }\n        this._lat = latitude;\n        this._long = longitude;\n    }\n    Object.defineProperty(GeoPoint.prototype, \"latitude\", {\n        /**\n         * Returns the latitude of this geo point, a number between -90 and 90.\n         */\n        get: function () {\n            return this._lat;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GeoPoint.prototype, \"longitude\", {\n        /**\n         * Returns the longitude of this geo point, a number between -180 and 180.\n         */\n        get: function () {\n            return this._long;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    GeoPoint.prototype.isEqual = function (other) {\n        return this._lat === other._lat && this._long === other._long;\n    };\n    /**\n     * Actually private to JS consumers of our API, so this function is prefixed\n     * with an underscore.\n     */\n    GeoPoint.prototype._compareTo = function (other) {\n        return (primitiveComparator(this._lat, other._lat) ||\n            primitiveComparator(this._long, other._long));\n    };\n    return GeoPoint;\n}());\n\n\n//# sourceMappingURL=geo_point.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/core/database_info.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar DatabaseInfo = /** @class */ (function () {\n    /**\n     * Constructs a DatabaseInfo using the provided host, databaseId and\n     * persistenceKey.\n     *\n     * @param databaseId The database to use.\n     * @param persistenceKey A unique identifier for this Firestore's local\n     * storage (used in conjunction with the databaseId).\n     * @param host The Firestore backend host to connect to.\n     * @param ssl Whether to use SSL when connecting.\n     */\n    function DatabaseInfo(databaseId, persistenceKey, host, ssl) {\n        this.databaseId = databaseId;\n        this.persistenceKey = persistenceKey;\n        this.host = host;\n        this.ssl = ssl;\n    }\n    return DatabaseInfo;\n}());\n\n/** The default database name for a project. */\nvar DEFAULT_DATABASE_NAME = '(default)';\n/** Represents the database ID a Firestore client is associated with. */\nvar database_info_DatabaseId = /** @class */ (function () {\n    function DatabaseId(projectId, database) {\n        this.projectId = projectId;\n        this.database = database ? database : DEFAULT_DATABASE_NAME;\n    }\n    Object.defineProperty(DatabaseId.prototype, \"isDefaultDatabase\", {\n        get: function () {\n            return this.database === DEFAULT_DATABASE_NAME;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DatabaseId.prototype.isEqual = function (other) {\n        return (other instanceof DatabaseId &&\n            other.projectId === this.projectId &&\n            other.database === this.database);\n    };\n    DatabaseId.prototype.compareTo = function (other) {\n        return (primitiveComparator(this.projectId, other.projectId) ||\n            primitiveComparator(this.database, other.database));\n    };\n    return DatabaseId;\n}());\n\n\n//# sourceMappingURL=database_info.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/model/path.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\nvar DOCUMENT_KEY_NAME = '__name__';\n/**\n * Path represents an ordered sequence of string segments.\n */\nvar path_Path = /** @class */ (function () {\n    function Path(segments, offset, length) {\n        this.init(segments, offset, length);\n    }\n    /**\n     * An initialization method that can be called from outside the constructor.\n     * We need this so that we can have a non-static construct method that returns\n     * the polymorphic `this` type.\n     */\n    Path.prototype.init = function (segments, offset, length) {\n        if (offset === undefined) {\n            offset = 0;\n        }\n        else if (offset > segments.length) {\n            fail('offset ' + offset + ' out of range ' + segments.length);\n        }\n        if (length === undefined) {\n            length = segments.length - offset;\n        }\n        else if (length > segments.length - offset) {\n            fail('length ' + length + ' out of range ' + (segments.length - offset));\n        }\n        this.segments = segments;\n        this.offset = offset;\n        this.len = length;\n    };\n    /**\n     * Constructs a new instance of Path using the same concrete type as `this`.\n     * We need this instead of using the normal constructor, because polymorphic\n     * `this` doesn't work on static methods.\n     */\n    Path.prototype.construct = function (segments, offset, length) {\n        var path = Object.create(Object.getPrototypeOf(this));\n        path.init(segments, offset, length);\n        return path;\n    };\n    Object.defineProperty(Path.prototype, \"length\", {\n        get: function () {\n            return this.len;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Path.prototype.isEqual = function (other) {\n        return Path.comparator(this, other) === 0;\n    };\n    Path.prototype.child = function (nameOrPath) {\n        var segments = this.segments.slice(this.offset, this.limit());\n        if (nameOrPath instanceof Path) {\n            nameOrPath.forEach(function (segment) {\n                segments.push(segment);\n            });\n        }\n        else if (typeof nameOrPath === 'string') {\n            segments.push(nameOrPath);\n        }\n        else {\n            fail('Unknown parameter type for Path.child(): ' + nameOrPath);\n        }\n        return this.construct(segments);\n    };\n    /** The index of one past the last segment of the path. */\n    Path.prototype.limit = function () {\n        return this.offset + this.length;\n    };\n    Path.prototype.popFirst = function (size) {\n        size = size === undefined ? 1 : size;\n        assert(this.length >= size, \"Can't call popFirst() with less segments\");\n        return this.construct(this.segments, this.offset + size, this.length - size);\n    };\n    Path.prototype.popLast = function () {\n        assert(!this.isEmpty(), \"Can't call popLast() on empty path\");\n        return this.construct(this.segments, this.offset, this.length - 1);\n    };\n    Path.prototype.firstSegment = function () {\n        assert(!this.isEmpty(), \"Can't call firstSegment() on empty path\");\n        return this.segments[this.offset];\n    };\n    Path.prototype.lastSegment = function () {\n        assert(!this.isEmpty(), \"Can't call lastSegment() on empty path\");\n        return this.segments[this.limit() - 1];\n    };\n    Path.prototype.get = function (index) {\n        assert(index < this.length, 'Index out of range');\n        return this.segments[this.offset + index];\n    };\n    Path.prototype.isEmpty = function () {\n        return this.length === 0;\n    };\n    Path.prototype.isPrefixOf = function (other) {\n        if (other.length < this.length) {\n            return false;\n        }\n        for (var i = 0; i < this.length; i++) {\n            if (this.get(i) !== other.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    Path.prototype.forEach = function (fn) {\n        for (var i = this.offset, end = this.limit(); i < end; i++) {\n            fn(this.segments[i]);\n        }\n    };\n    Path.prototype.toArray = function () {\n        return this.segments.slice(this.offset, this.limit());\n    };\n    Path.comparator = function (p1, p2) {\n        var len = Math.min(p1.length, p2.length);\n        for (var i = 0; i < len; i++) {\n            var left = p1.get(i);\n            var right = p2.get(i);\n            if (left < right)\n                return -1;\n            if (left > right)\n                return 1;\n        }\n        if (p1.length < p2.length)\n            return -1;\n        if (p1.length > p2.length)\n            return 1;\n        return 0;\n    };\n    return Path;\n}());\n\n/**\n * A slash-separated path for navigating resources (documents and collections)\n * within Firestore.\n */\nvar path_ResourcePath = /** @class */ (function (_super) {\n    tslib_es6[\"__extends\"](ResourcePath, _super);\n    function ResourcePath() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ResourcePath.prototype.canonicalString = function () {\n        // NOTE: The client is ignorant of any path segments containing escape\n        // sequences (e.g. __id123__) and just passes them through raw (they exist\n        // for legacy reasons and should not be used frequently).\n        return this.toArray().join('/');\n    };\n    ResourcePath.prototype.toString = function () {\n        return this.canonicalString();\n    };\n    /**\n     * Creates a resource path from the given slash-delimited string.\n     */\n    ResourcePath.fromString = function (path) {\n        // NOTE: The client is ignorant of any path segments containing escape\n        // sequences (e.g. __id123__) and just passes them through raw (they exist\n        // for legacy reasons and should not be used frequently).\n        if (path.indexOf('//') >= 0) {\n            throw new error_FirestoreError(Code.INVALID_ARGUMENT, \"Invalid path (\" + path + \"). Paths must not contain // in them.\");\n        }\n        // We may still have an empty segment at the beginning or end if they had a\n        // leading or trailing slash (which we allow).\n        var segments = path.split('/').filter(function (segment) { return segment.length > 0; });\n        return new ResourcePath(segments);\n    };\n    ResourcePath.EMPTY_PATH = new ResourcePath([]);\n    return ResourcePath;\n}(path_Path));\n\nvar identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\n/** A dot-separated path for navigating sub-objects within a document. */\nvar path_FieldPath = /** @class */ (function (_super) {\n    tslib_es6[\"__extends\"](FieldPath, _super);\n    function FieldPath() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Returns true if the string could be used as a segment in a field path\n     * without escaping.\n     */\n    FieldPath.isValidIdentifier = function (segment) {\n        return identifierRegExp.test(segment);\n    };\n    FieldPath.prototype.canonicalString = function () {\n        return this.toArray()\n            .map(function (str) {\n            str = str.replace('\\\\', '\\\\\\\\').replace('`', '\\\\`');\n            if (!FieldPath.isValidIdentifier(str)) {\n                str = '`' + str + '`';\n            }\n            return str;\n        })\n            .join('.');\n    };\n    FieldPath.prototype.toString = function () {\n        return this.canonicalString();\n    };\n    /**\n     * Returns true if this field references the key of a document.\n     */\n    FieldPath.prototype.isKeyField = function () {\n        return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;\n    };\n    /**\n     * The field designating the key of a document.\n     */\n    FieldPath.keyField = function () {\n        return new FieldPath([DOCUMENT_KEY_NAME]);\n    };\n    /**\n     * Parses a field string from the given server-formatted string.\n     *\n     * - Splitting the empty string is not allowed (for now at least).\n     * - Empty segments within the string (e.g. if there are two consecutive\n     *   separators) are not allowed.\n     *\n     * TODO(b/37244157): we should make this more strict. Right now, it allows\n     * non-identifier path components, even if they aren't escaped.\n     */\n    FieldPath.fromServerFormat = function (path) {\n        var segments = [];\n        var current = '';\n        var i = 0;\n        var addCurrentSegment = function () {\n            if (current.length === 0) {\n                throw new error_FirestoreError(Code.INVALID_ARGUMENT, \"Invalid field path (\" + path + \"). Paths must not be empty, begin \" +\n                    \"with '.', end with '.', or contain '..'\");\n            }\n            segments.push(current);\n            current = '';\n        };\n        var inBackticks = false;\n        while (i < path.length) {\n            var c = path[i];\n            if (c === '\\\\') {\n                if (i + 1 === path.length) {\n                    throw new error_FirestoreError(Code.INVALID_ARGUMENT, 'Path has trailing escape character: ' + path);\n                }\n                var next = path[i + 1];\n                if (!(next === '\\\\' || next === '.' || next === '`')) {\n                    throw new error_FirestoreError(Code.INVALID_ARGUMENT, 'Path has invalid escape sequence: ' + path);\n                }\n                current += next;\n                i += 2;\n            }\n            else if (c === '`') {\n                inBackticks = !inBackticks;\n                i++;\n            }\n            else if (c === '.' && !inBackticks) {\n                addCurrentSegment();\n                i++;\n            }\n            else {\n                current += c;\n                i++;\n            }\n        }\n        addCurrentSegment();\n        if (inBackticks) {\n            throw new error_FirestoreError(Code.INVALID_ARGUMENT, 'Unterminated ` in path: ' + path);\n        }\n        return new FieldPath(segments);\n    };\n    FieldPath.EMPTY_PATH = new FieldPath([]);\n    return FieldPath;\n}(path_Path));\n\n\n//# sourceMappingURL=path.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/model/document_key.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar document_key_DocumentKey = /** @class */ (function () {\n    function DocumentKey(path) {\n        this.path = path;\n        assert(DocumentKey.isDocumentKey(path), 'Invalid DocumentKey with an odd number of segments: ' +\n            path.toArray().join('/'));\n    }\n    DocumentKey.prototype.isEqual = function (other) {\n        return (other !== null && path_ResourcePath.comparator(this.path, other.path) === 0);\n    };\n    DocumentKey.prototype.toString = function () {\n        return this.path.toString();\n    };\n    DocumentKey.comparator = function (k1, k2) {\n        return path_ResourcePath.comparator(k1.path, k2.path);\n    };\n    DocumentKey.isDocumentKey = function (path) {\n        return path.length % 2 === 0;\n    };\n    /**\n     * Creates and returns a new document key with the given segments.\n     *\n     * @param path The segments of the path to the document\n     * @return A new instance of DocumentKey\n     */\n    DocumentKey.fromSegments = function (segments) {\n        return new DocumentKey(new path_ResourcePath(segments.slice()));\n    };\n    /**\n     * Creates and returns a new document key using '/' to split the string into\n     * segments.\n     *\n     * @param path The slash-separated path string to the document\n     * @return A new instance of DocumentKey\n     */\n    DocumentKey.fromPathString = function (path) {\n        return new DocumentKey(path_ResourcePath.fromString(path));\n    };\n    DocumentKey.EMPTY = new DocumentKey(new path_ResourcePath([]));\n    return DocumentKey;\n}());\n\n\n//# sourceMappingURL=document_key.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/model/document.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar document_Document = /** @class */ (function () {\n    function Document(key, version, data, options) {\n        this.key = key;\n        this.version = version;\n        this.data = data;\n        this.hasLocalMutations = options.hasLocalMutations;\n    }\n    Document.prototype.field = function (path) {\n        return this.data.field(path);\n    };\n    Document.prototype.fieldValue = function (path) {\n        var field = this.field(path);\n        return field ? field.value() : undefined;\n    };\n    Document.prototype.value = function () {\n        return this.data.value();\n    };\n    Document.prototype.isEqual = function (other) {\n        return (other instanceof Document &&\n            this.key.isEqual(other.key) &&\n            this.version.isEqual(other.version) &&\n            this.data.isEqual(other.data) &&\n            this.hasLocalMutations === other.hasLocalMutations);\n    };\n    Document.prototype.toString = function () {\n        return (\"Document(\" + this.key + \", \" + this.version + \", \" + this.data.toString() + \", \" +\n            (\"{hasLocalMutations: \" + this.hasLocalMutations + \"})\"));\n    };\n    Document.compareByKey = function (d1, d2) {\n        return document_key_DocumentKey.comparator(d1.key, d2.key);\n    };\n    Document.compareByField = function (field, d1, d2) {\n        var v1 = d1.field(field);\n        var v2 = d2.field(field);\n        if (v1 !== undefined && v2 !== undefined) {\n            return v1.compareTo(v2);\n        }\n        else {\n            return fail(\"Trying to compare documents on fields that don't exist\");\n        }\n    };\n    return Document;\n}());\n\n/**\n * A class representing a deleted document.\n * Version is set to 0 if we don't point to any specific time, otherwise it\n * denotes time we know it didn't exist at.\n */\nvar document_NoDocument = /** @class */ (function () {\n    function NoDocument(key, version) {\n        this.key = key;\n        this.version = version;\n    }\n    NoDocument.prototype.toString = function () {\n        return \"NoDocument(\" + this.key + \", \" + this.version + \")\";\n    };\n    NoDocument.prototype.isEqual = function (other) {\n        return (other &&\n            other.version.isEqual(this.version) &&\n            other.key.isEqual(this.key));\n    };\n    NoDocument.compareByKey = function (d1, d2) {\n        return document_key_DocumentKey.comparator(d1.key, d2.key);\n    };\n    return NoDocument;\n}());\n\n\n//# sourceMappingURL=document.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/sorted_map.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// An immutable sorted map implementation, based on a Left-leaning Red-Black\n// tree.\nvar SortedMap = /** @class */ (function () {\n    function SortedMap(comparator, root) {\n        this.comparator = comparator;\n        this.root = root ? root : sorted_map_LLRBNode.EMPTY;\n    }\n    // Returns a copy of the map, with the specified key/value added or replaced.\n    SortedMap.prototype.insert = function (key, value) {\n        return new SortedMap(this.comparator, this.root\n            .insert(key, value, this.comparator)\n            .copy(null, null, sorted_map_LLRBNode.BLACK, null, null));\n    };\n    // Returns a copy of the map, with the specified key removed.\n    SortedMap.prototype.remove = function (key) {\n        return new SortedMap(this.comparator, this.root\n            .remove(key, this.comparator)\n            .copy(null, null, sorted_map_LLRBNode.BLACK, null, null));\n    };\n    // Returns the value of the node with the given key, or null.\n    SortedMap.prototype.get = function (key) {\n        var node = this.root;\n        while (!node.isEmpty()) {\n            var cmp = this.comparator(key, node.key);\n            if (cmp === 0) {\n                return node.value;\n            }\n            else if (cmp < 0) {\n                node = node.left;\n            }\n            else if (cmp > 0) {\n                node = node.right;\n            }\n        }\n        return null;\n    };\n    // Returns the index of the element in this sorted map, or -1 if it doesn't\n    // exist.\n    SortedMap.prototype.indexOf = function (key) {\n        // Number of nodes that were pruned when descending right\n        var prunedNodes = 0;\n        var node = this.root;\n        while (!node.isEmpty()) {\n            var cmp = this.comparator(key, node.key);\n            if (cmp === 0) {\n                return prunedNodes + node.left.size;\n            }\n            else if (cmp < 0) {\n                node = node.left;\n            }\n            else {\n                // Count all nodes left of the node plus the node itself\n                prunedNodes += node.left.size + 1;\n                node = node.right;\n            }\n        }\n        // Node not found\n        return -1;\n    };\n    SortedMap.prototype.isEmpty = function () {\n        return this.root.isEmpty();\n    };\n    Object.defineProperty(SortedMap.prototype, \"size\", {\n        // Returns the total number of nodes in the map.\n        get: function () {\n            return this.root.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // Returns the minimum key in the map.\n    SortedMap.prototype.minKey = function () {\n        return this.root.minKey();\n    };\n    // Returns the maximum key in the map.\n    SortedMap.prototype.maxKey = function () {\n        return this.root.maxKey();\n    };\n    // Traverses the map in key order and calls the specified action function\n    // for each key/value pair. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    SortedMap.prototype.inorderTraversal = function (action) {\n        return this.root.inorderTraversal(action);\n    };\n    SortedMap.prototype.forEach = function (fn) {\n        this.inorderTraversal(function (k, v) {\n            fn(k, v);\n            return false;\n        });\n    };\n    // Traverses the map in reverse key order and calls the specified action\n    // function for each key/value pair. If action returns true, traversal is\n    // aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    SortedMap.prototype.reverseTraversal = function (action) {\n        return this.root.reverseTraversal(action);\n    };\n    // Returns an iterator over the SortedMap.\n    SortedMap.prototype.getIterator = function () {\n        return new sorted_map_SortedMapIterator(this.root, null, this.comparator, false);\n    };\n    SortedMap.prototype.getIteratorFrom = function (key) {\n        return new sorted_map_SortedMapIterator(this.root, key, this.comparator, false);\n    };\n    SortedMap.prototype.getReverseIterator = function () {\n        return new sorted_map_SortedMapIterator(this.root, null, this.comparator, true);\n    };\n    SortedMap.prototype.getReverseIteratorFrom = function (key) {\n        return new sorted_map_SortedMapIterator(this.root, key, this.comparator, true);\n    };\n    return SortedMap;\n}()); // end SortedMap\n\n// An iterator over an LLRBNode.\nvar sorted_map_SortedMapIterator = /** @class */ (function () {\n    function SortedMapIterator(node, startKey, comparator, isReverse) {\n        this.isReverse = isReverse;\n        this.nodeStack = [];\n        var cmp = 1;\n        while (!node.isEmpty()) {\n            cmp = startKey ? comparator(node.key, startKey) : 1;\n            // flip the comparison if we're going in reverse\n            if (isReverse)\n                cmp *= -1;\n            if (cmp < 0) {\n                // This node is less than our start key. ignore it\n                if (this.isReverse) {\n                    node = node.left;\n                }\n                else {\n                    node = node.right;\n                }\n            }\n            else if (cmp === 0) {\n                // This node is exactly equal to our start key. Push it on the stack,\n                // but stop iterating;\n                this.nodeStack.push(node);\n                break;\n            }\n            else {\n                // This node is greater than our start key, add it to the stack and move\n                // to the next one\n                this.nodeStack.push(node);\n                if (this.isReverse) {\n                    node = node.right;\n                }\n                else {\n                    node = node.left;\n                }\n            }\n        }\n    }\n    SortedMapIterator.prototype.getNext = function () {\n        assert(this.nodeStack.length > 0, 'getNext() called on iterator when hasNext() is false.');\n        var node = this.nodeStack.pop();\n        var result = { key: node.key, value: node.value };\n        if (this.isReverse) {\n            node = node.left;\n            while (!node.isEmpty()) {\n                this.nodeStack.push(node);\n                node = node.right;\n            }\n        }\n        else {\n            node = node.right;\n            while (!node.isEmpty()) {\n                this.nodeStack.push(node);\n                node = node.left;\n            }\n        }\n        return result;\n    };\n    SortedMapIterator.prototype.hasNext = function () {\n        return this.nodeStack.length > 0;\n    };\n    SortedMapIterator.prototype.peek = function () {\n        if (this.nodeStack.length === 0)\n            return null;\n        var node = this.nodeStack[this.nodeStack.length - 1];\n        return { key: node.key, value: node.value };\n    };\n    return SortedMapIterator;\n}()); // end SortedMapIterator\n\n// Represents a node in a Left-leaning Red-Black tree.\nvar sorted_map_LLRBNode = /** @class */ (function () {\n    function LLRBNode(key, value, color, left, right) {\n        this.key = key;\n        this.value = value;\n        this.color = color != null ? color : LLRBNode.RED;\n        this.left = left != null ? left : LLRBNode.EMPTY;\n        this.right = right != null ? right : LLRBNode.EMPTY;\n        this.size = this.left.size + 1 + this.right.size;\n    }\n    // Returns a copy of the current node, optionally replacing pieces of it.\n    LLRBNode.prototype.copy = function (key, value, color, left, right) {\n        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);\n    };\n    LLRBNode.prototype.isEmpty = function () {\n        return false;\n    };\n    // Traverses the tree in key order and calls the specified action function\n    // for each node. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    LLRBNode.prototype.inorderTraversal = function (action) {\n        return (this.left.inorderTraversal(action) ||\n            action(this.key, this.value) ||\n            this.right.inorderTraversal(action));\n    };\n    // Traverses the tree in reverse key order and calls the specified action\n    // function for each node. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    LLRBNode.prototype.reverseTraversal = function (action) {\n        return (this.right.reverseTraversal(action) ||\n            action(this.key, this.value) ||\n            this.left.reverseTraversal(action));\n    };\n    // Returns the minimum node in the tree.\n    LLRBNode.prototype.min = function () {\n        if (this.left.isEmpty()) {\n            return this;\n        }\n        else {\n            return this.left.min();\n        }\n    };\n    // Returns the maximum key in the tree.\n    LLRBNode.prototype.minKey = function () {\n        return this.min().key;\n    };\n    // Returns the maximum key in the tree.\n    LLRBNode.prototype.maxKey = function () {\n        if (this.right.isEmpty()) {\n            return this.key;\n        }\n        else {\n            return this.right.maxKey();\n        }\n    };\n    // Returns new tree, with the key/value added.\n    LLRBNode.prototype.insert = function (key, value, comparator) {\n        var n = this;\n        var cmp = comparator(key, n.key);\n        if (cmp < 0) {\n            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\n        }\n        else if (cmp === 0) {\n            n = n.copy(null, value, null, null, null);\n        }\n        else {\n            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));\n        }\n        return n.fixUp();\n    };\n    LLRBNode.prototype.removeMin = function () {\n        if (this.left.isEmpty()) {\n            return LLRBNode.EMPTY;\n        }\n        var n = this;\n        if (!n.left.isRed() && !n.left.left.isRed())\n            n = n.moveRedLeft();\n        n = n.copy(null, null, null, n.left.removeMin(), null);\n        return n.fixUp();\n    };\n    // Returns new tree, with the specified item removed.\n    LLRBNode.prototype.remove = function (key, comparator) {\n        var smallest;\n        var n = this;\n        if (comparator(key, n.key) < 0) {\n            if (!n.left.isEmpty() && !n.left.isRed() && !n.left.left.isRed()) {\n                n = n.moveRedLeft();\n            }\n            n = n.copy(null, null, null, n.left.remove(key, comparator), null);\n        }\n        else {\n            if (n.left.isRed())\n                n = n.rotateRight();\n            if (!n.right.isEmpty() && !n.right.isRed() && !n.right.left.isRed()) {\n                n = n.moveRedRight();\n            }\n            if (comparator(key, n.key) === 0) {\n                if (n.right.isEmpty()) {\n                    return LLRBNode.EMPTY;\n                }\n                else {\n                    smallest = n.right.min();\n                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin());\n                }\n            }\n            n = n.copy(null, null, null, null, n.right.remove(key, comparator));\n        }\n        return n.fixUp();\n    };\n    LLRBNode.prototype.isRed = function () {\n        return this.color;\n    };\n    // Returns new tree after performing any needed rotations.\n    LLRBNode.prototype.fixUp = function () {\n        var n = this;\n        if (n.right.isRed() && !n.left.isRed())\n            n = n.rotateLeft();\n        if (n.left.isRed() && n.left.left.isRed())\n            n = n.rotateRight();\n        if (n.left.isRed() && n.right.isRed())\n            n = n.colorFlip();\n        return n;\n    };\n    LLRBNode.prototype.moveRedLeft = function () {\n        var n = this.colorFlip();\n        if (n.right.left.isRed()) {\n            n = n.copy(null, null, null, null, n.right.rotateRight());\n            n = n.rotateLeft();\n            n = n.colorFlip();\n        }\n        return n;\n    };\n    LLRBNode.prototype.moveRedRight = function () {\n        var n = this.colorFlip();\n        if (n.left.left.isRed()) {\n            n = n.rotateRight();\n            n = n.colorFlip();\n        }\n        return n;\n    };\n    LLRBNode.prototype.rotateLeft = function () {\n        var nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\n        return this.right.copy(null, null, this.color, nl, null);\n    };\n    LLRBNode.prototype.rotateRight = function () {\n        var nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\n        return this.left.copy(null, null, this.color, null, nr);\n    };\n    LLRBNode.prototype.colorFlip = function () {\n        var left = this.left.copy(null, null, !this.left.color, null, null);\n        var right = this.right.copy(null, null, !this.right.color, null, null);\n        return this.copy(null, null, !this.color, left, right);\n    };\n    // For testing.\n    LLRBNode.prototype.checkMaxDepth = function () {\n        var blackDepth = this.check();\n        if (Math.pow(2.0, blackDepth) <= this.size + 1) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    // In a balanced RB tree, the black-depth (number of black nodes) from root to\n    // leaves is equal on both sides.  This function verifies that or asserts.\n    LLRBNode.prototype.check = function () {\n        if (this.isRed() && this.left.isRed()) {\n            throw fail('Red node has red child(' + this.key + ',' + this.value + ')');\n        }\n        if (this.right.isRed()) {\n            throw fail('Right child of (' + this.key + ',' + this.value + ') is red');\n        }\n        var blackDepth = this.left.check();\n        if (blackDepth !== this.right.check()) {\n            throw fail('Black depths differ');\n        }\n        else {\n            return blackDepth + (this.isRed() ? 0 : 1);\n        }\n    };\n    // tslint:disable-next-line:no-any Empty node is shared between all LLRB trees.\n    LLRBNode.EMPTY = null;\n    LLRBNode.RED = true;\n    LLRBNode.BLACK = false;\n    return LLRBNode;\n}()); // end LLRBNode\n\n// Represents an empty node (a leaf node in the Red-Black Tree).\nvar LLRBEmptyNode = /** @class */ (function () {\n    function LLRBEmptyNode() {\n        this.size = 0;\n    }\n    // Returns a copy of the current node.\n    LLRBEmptyNode.prototype.copy = function (key, value, color, left, right) {\n        return this;\n    };\n    // Returns a copy of the tree, with the specified key/value added.\n    LLRBEmptyNode.prototype.insert = function (key, value, comparator) {\n        return new sorted_map_LLRBNode(key, value);\n    };\n    // Returns a copy of the tree, with the specified key removed.\n    LLRBEmptyNode.prototype.remove = function (key, comparator) {\n        return this;\n    };\n    LLRBEmptyNode.prototype.isEmpty = function () {\n        return true;\n    };\n    LLRBEmptyNode.prototype.inorderTraversal = function (action) {\n        return false;\n    };\n    LLRBEmptyNode.prototype.reverseTraversal = function (action) {\n        return false;\n    };\n    LLRBEmptyNode.prototype.minKey = function () {\n        return null;\n    };\n    LLRBEmptyNode.prototype.maxKey = function () {\n        return null;\n    };\n    LLRBEmptyNode.prototype.isRed = function () {\n        return false;\n    };\n    // For testing.\n    LLRBEmptyNode.prototype.checkMaxDepth = function () {\n        return true;\n    };\n    LLRBEmptyNode.prototype.check = function () {\n        return 0;\n    };\n    return LLRBEmptyNode;\n}()); // end LLRBEmptyNode\n\nsorted_map_LLRBNode.EMPTY = new LLRBEmptyNode();\n\n//# sourceMappingURL=sorted_map.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/model/field_value.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\nvar TypeOrder;\n(function (TypeOrder) {\n    // This order is defined by the backend.\n    TypeOrder[TypeOrder[\"NullValue\"] = 0] = \"NullValue\";\n    TypeOrder[TypeOrder[\"BooleanValue\"] = 1] = \"BooleanValue\";\n    TypeOrder[TypeOrder[\"NumberValue\"] = 2] = \"NumberValue\";\n    TypeOrder[TypeOrder[\"TimestampValue\"] = 3] = \"TimestampValue\";\n    TypeOrder[TypeOrder[\"StringValue\"] = 4] = \"StringValue\";\n    TypeOrder[TypeOrder[\"BlobValue\"] = 5] = \"BlobValue\";\n    TypeOrder[TypeOrder[\"RefValue\"] = 6] = \"RefValue\";\n    TypeOrder[TypeOrder[\"GeoPointValue\"] = 7] = \"GeoPointValue\";\n    TypeOrder[TypeOrder[\"ArrayValue\"] = 8] = \"ArrayValue\";\n    TypeOrder[TypeOrder[\"ObjectValue\"] = 9] = \"ObjectValue\";\n})(TypeOrder || (TypeOrder = {}));\n/** Defines the return value for pending server timestamps. */\nvar ServerTimestampBehavior;\n(function (ServerTimestampBehavior) {\n    ServerTimestampBehavior[ServerTimestampBehavior[\"Default\"] = 0] = \"Default\";\n    ServerTimestampBehavior[ServerTimestampBehavior[\"Estimate\"] = 1] = \"Estimate\";\n    ServerTimestampBehavior[ServerTimestampBehavior[\"Previous\"] = 2] = \"Previous\";\n})(ServerTimestampBehavior || (ServerTimestampBehavior = {}));\n/** Holds properties that define field value deserialization options. */\nvar field_value_FieldValueOptions = /** @class */ (function () {\n    function FieldValueOptions(serverTimestampBehavior) {\n        this.serverTimestampBehavior = serverTimestampBehavior;\n    }\n    FieldValueOptions.fromSnapshotOptions = function (options) {\n        switch (options.serverTimestamps) {\n            case 'estimate':\n                return new FieldValueOptions(ServerTimestampBehavior.Estimate);\n            case 'previous':\n                return new FieldValueOptions(ServerTimestampBehavior.Previous);\n            case 'none': // Fall-through intended.\n            case undefined:\n                return FieldValueOptions.defaultOptions;\n            default:\n                return fail('fromSnapshotOptions() called with invalid options.');\n        }\n    };\n    FieldValueOptions.defaultOptions = new FieldValueOptions(ServerTimestampBehavior.Default);\n    return FieldValueOptions;\n}());\n\n/**\n * A field value represents a datatype as stored by Firestore.\n */\nvar field_value_FieldValue = /** @class */ (function () {\n    function FieldValue() {\n    }\n    FieldValue.prototype.toString = function () {\n        var val = this.value();\n        return val === null ? 'null' : val.toString();\n    };\n    FieldValue.prototype.defaultCompareTo = function (other) {\n        assert(this.typeOrder !== other.typeOrder, 'Default compareTo should not be used for values of same type.');\n        var cmp = primitiveComparator(this.typeOrder, other.typeOrder);\n        return cmp;\n    };\n    return FieldValue;\n}());\n\nvar field_value_NullValue = /** @class */ (function (_super) {\n    tslib_es6[\"__extends\"](NullValue, _super);\n    function NullValue() {\n        var _this = _super.call(this) || this;\n        _this.typeOrder = TypeOrder.NullValue;\n        // internalValue is unused but we add it to work around\n        // https://github.com/Microsoft/TypeScript/issues/15585\n        _this.internalValue = null;\n        return _this;\n    }\n    NullValue.prototype.value = function (options) {\n        return null;\n    };\n    NullValue.prototype.isEqual = function (other) {\n        return other instanceof NullValue;\n    };\n    NullValue.prototype.compareTo = function (other) {\n        if (other instanceof NullValue) {\n            return 0;\n        }\n        return this.defaultCompareTo(other);\n    };\n    NullValue.INSTANCE = new NullValue();\n    return NullValue;\n}(field_value_FieldValue));\n\nvar field_value_BooleanValue = /** @class */ (function (_super) {\n    tslib_es6[\"__extends\"](BooleanValue, _super);\n    function BooleanValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.BooleanValue;\n        return _this;\n    }\n    BooleanValue.prototype.value = function (options) {\n        return this.internalValue;\n    };\n    BooleanValue.prototype.isEqual = function (other) {\n        return (other instanceof BooleanValue &&\n            this.internalValue === other.internalValue);\n    };\n    BooleanValue.prototype.compareTo = function (other) {\n        if (other instanceof BooleanValue) {\n            return primitiveComparator(this, other);\n        }\n        return this.defaultCompareTo(other);\n    };\n    BooleanValue.of = function (value) {\n        return value ? BooleanValue.TRUE : BooleanValue.FALSE;\n    };\n    BooleanValue.TRUE = new BooleanValue(true);\n    BooleanValue.FALSE = new BooleanValue(false);\n    return BooleanValue;\n}(field_value_FieldValue));\n\n/** Base class for IntegerValue and DoubleValue. */\nvar field_value_NumberValue = /** @class */ (function (_super) {\n    tslib_es6[\"__extends\"](NumberValue, _super);\n    function NumberValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.NumberValue;\n        return _this;\n    }\n    NumberValue.prototype.value = function (options) {\n        return this.internalValue;\n    };\n    NumberValue.prototype.compareTo = function (other) {\n        if (other instanceof NumberValue) {\n            return numericComparator(this.internalValue, other.internalValue);\n        }\n        return this.defaultCompareTo(other);\n    };\n    return NumberValue;\n}(field_value_FieldValue));\n\n/** Utility function to compare doubles (using Firestore semantics for NaN). */\nfunction numericComparator(left, right) {\n    if (left < right) {\n        return -1;\n    }\n    else if (left > right) {\n        return 1;\n    }\n    else if (left === right) {\n        return 0;\n    }\n    else {\n        // one or both are NaN.\n        if (isNaN(left)) {\n            return isNaN(right) ? 0 : -1;\n        }\n        else {\n            return 1;\n        }\n    }\n}\n/**\n * Utility function to check numbers for equality using Firestore semantics\n * (NaN === NaN, -0.0 !== 0.0).\n */\nfunction numericEquals(left, right) {\n    // Implemented based on Object.is() polyfill from\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n    if (left === right) {\n        // +0 != -0\n        return left !== 0 || 1 / left === 1 / right;\n    }\n    else {\n        // NaN == NaN\n        return left !== left && right !== right;\n    }\n}\nvar field_value_IntegerValue = /** @class */ (function (_super) {\n    tslib_es6[\"__extends\"](IntegerValue, _super);\n    function IntegerValue(internalValue) {\n        return _super.call(this, internalValue) || this;\n    }\n    IntegerValue.prototype.isEqual = function (other) {\n        // NOTE: DoubleValue and IntegerValue instances may compareTo() the same,\n        // but that doesn't make them equal via isEqual().\n        if (other instanceof IntegerValue) {\n            return numericEquals(this.internalValue, other.internalValue);\n        }\n        else {\n            return false;\n        }\n    };\n    return IntegerValue;\n}(field_value_NumberValue));\n\nvar field_value_DoubleValue = /** @class */ (function (_super) {\n    tslib_es6[\"__extends\"](DoubleValue, _super);\n    function DoubleValue(internalValue) {\n        var _this = _super.call(this, internalValue) || this;\n        _this.internalValue = internalValue;\n        return _this;\n    }\n    DoubleValue.prototype.isEqual = function (other) {\n        // NOTE: DoubleValue and IntegerValue instances may compareTo() the same,\n        // but that doesn't make them equal via isEqual().\n        if (other instanceof DoubleValue) {\n            return numericEquals(this.internalValue, other.internalValue);\n        }\n        else {\n            return false;\n        }\n    };\n    DoubleValue.NAN = new DoubleValue(NaN);\n    DoubleValue.POSITIVE_INFINITY = new DoubleValue(Infinity);\n    DoubleValue.NEGATIVE_INFINITY = new DoubleValue(-Infinity);\n    return DoubleValue;\n}(field_value_NumberValue));\n\n// TODO(b/37267885): Add truncation support\nvar field_value_StringValue = /** @class */ (function (_super) {\n    tslib_es6[\"__extends\"](StringValue, _super);\n    function StringValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.StringValue;\n        return _this;\n    }\n    StringValue.prototype.value = function (options) {\n        return this.internalValue;\n    };\n    StringValue.prototype.isEqual = function (other) {\n        return (other instanceof StringValue && this.internalValue === other.internalValue);\n    };\n    StringValue.prototype.compareTo = function (other) {\n        if (other instanceof StringValue) {\n            return primitiveComparator(this.internalValue, other.internalValue);\n        }\n        return this.defaultCompareTo(other);\n    };\n    return StringValue;\n}(field_value_FieldValue));\n\nvar field_value_TimestampValue = /** @class */ (function (_super) {\n    tslib_es6[\"__extends\"](TimestampValue, _super);\n    function TimestampValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.TimestampValue;\n        return _this;\n    }\n    TimestampValue.prototype.value = function (options) {\n        return this.internalValue.toDate();\n    };\n    TimestampValue.prototype.isEqual = function (other) {\n        return (other instanceof TimestampValue &&\n            this.internalValue.isEqual(other.internalValue));\n    };\n    TimestampValue.prototype.compareTo = function (other) {\n        if (other instanceof TimestampValue) {\n            return this.internalValue.compareTo(other.internalValue);\n        }\n        else if (other instanceof field_value_ServerTimestampValue) {\n            // Concrete timestamps come before server timestamps.\n            return -1;\n        }\n        else {\n            return this.defaultCompareTo(other);\n        }\n    };\n    return TimestampValue;\n}(field_value_FieldValue));\n\n/**\n * Represents a locally-applied ServerTimestamp.\n *\n * Notes:\n * - ServerTimestampValue instances are created as the result of applying a\n *   TransformMutation (see TransformMutation.applyTo()). They can only exist in\n *   the local view of a document. Therefore they do not need to be parsed or\n *   serialized.\n * - When evaluated locally (e.g. for snapshot.data()), they by default\n *   evaluate to `null`. This behavior can be configured by passing custom\n *   FieldValueOptions to value().\n * - With respect to other ServerTimestampValues, they sort by their\n *   localWriteTime.\n */\nvar field_value_ServerTimestampValue = /** @class */ (function (_super) {\n    tslib_es6[\"__extends\"](ServerTimestampValue, _super);\n    function ServerTimestampValue(localWriteTime, previousValue) {\n        var _this = _super.call(this) || this;\n        _this.localWriteTime = localWriteTime;\n        _this.previousValue = previousValue;\n        _this.typeOrder = TypeOrder.TimestampValue;\n        return _this;\n    }\n    ServerTimestampValue.prototype.value = function (options) {\n        if (options &&\n            options.serverTimestampBehavior === ServerTimestampBehavior.Estimate) {\n            return this.localWriteTime.toDate();\n        }\n        else if (options &&\n            options.serverTimestampBehavior === ServerTimestampBehavior.Previous) {\n            return this.previousValue ? this.previousValue.value(options) : null;\n        }\n        else {\n            return null;\n        }\n    };\n    ServerTimestampValue.prototype.isEqual = function (other) {\n        return (other instanceof ServerTimestampValue &&\n            this.localWriteTime.isEqual(other.localWriteTime));\n    };\n    ServerTimestampValue.prototype.compareTo = function (other) {\n        if (other instanceof ServerTimestampValue) {\n            return this.localWriteTime.compareTo(other.localWriteTime);\n        }\n        else if (other instanceof field_value_TimestampValue) {\n            // Server timestamps come after all concrete timestamps.\n            return 1;\n        }\n        else {\n            return this.defaultCompareTo(other);\n        }\n    };\n    ServerTimestampValue.prototype.toString = function () {\n        return '<ServerTimestamp localTime=' + this.localWriteTime.toString() + '>';\n    };\n    return ServerTimestampValue;\n}(field_value_FieldValue));\n\nvar field_value_BlobValue = /** @class */ (function (_super) {\n    tslib_es6[\"__extends\"](BlobValue, _super);\n    function BlobValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.BlobValue;\n        return _this;\n    }\n    BlobValue.prototype.value = function (options) {\n        return this.internalValue;\n    };\n    BlobValue.prototype.isEqual = function (other) {\n        return (other instanceof BlobValue &&\n            this.internalValue.isEqual(other.internalValue));\n    };\n    BlobValue.prototype.compareTo = function (other) {\n        if (other instanceof BlobValue) {\n            return this.internalValue._compareTo(other.internalValue);\n        }\n        return this.defaultCompareTo(other);\n    };\n    return BlobValue;\n}(field_value_FieldValue));\n\nvar field_value_RefValue = /** @class */ (function (_super) {\n    tslib_es6[\"__extends\"](RefValue, _super);\n    function RefValue(databaseId, key) {\n        var _this = _super.call(this) || this;\n        _this.databaseId = databaseId;\n        _this.key = key;\n        _this.typeOrder = TypeOrder.RefValue;\n        return _this;\n    }\n    RefValue.prototype.value = function (options) {\n        return this.key;\n    };\n    RefValue.prototype.isEqual = function (other) {\n        if (other instanceof RefValue) {\n            return (this.key.isEqual(other.key) && this.databaseId.isEqual(other.databaseId));\n        }\n        else {\n            return false;\n        }\n    };\n    RefValue.prototype.compareTo = function (other) {\n        if (other instanceof RefValue) {\n            var cmp = this.databaseId.compareTo(other.databaseId);\n            return cmp !== 0 ? cmp : document_key_DocumentKey.comparator(this.key, other.key);\n        }\n        return this.defaultCompareTo(other);\n    };\n    return RefValue;\n}(field_value_FieldValue));\n\nvar field_value_GeoPointValue = /** @class */ (function (_super) {\n    tslib_es6[\"__extends\"](GeoPointValue, _super);\n    function GeoPointValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.GeoPointValue;\n        return _this;\n    }\n    GeoPointValue.prototype.value = function (options) {\n        return this.internalValue;\n    };\n    GeoPointValue.prototype.isEqual = function (other) {\n        return (other instanceof GeoPointValue &&\n            this.internalValue.isEqual(other.internalValue));\n    };\n    GeoPointValue.prototype.compareTo = function (other) {\n        if (other instanceof GeoPointValue) {\n            return this.internalValue._compareTo(other.internalValue);\n        }\n        return this.defaultCompareTo(other);\n    };\n    return GeoPointValue;\n}(field_value_FieldValue));\n\nvar field_value_ObjectValue = /** @class */ (function (_super) {\n    tslib_es6[\"__extends\"](ObjectValue, _super);\n    function ObjectValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.ObjectValue;\n        return _this;\n    }\n    ObjectValue.prototype.value = function (options) {\n        var result = {};\n        this.internalValue.inorderTraversal(function (key, val) {\n            result[key] = val.value(options);\n        });\n        return result;\n    };\n    ObjectValue.prototype.forEach = function (action) {\n        this.internalValue.inorderTraversal(action);\n    };\n    ObjectValue.prototype.isEqual = function (other) {\n        if (other instanceof ObjectValue) {\n            var it1 = this.internalValue.getIterator();\n            var it2 = other.internalValue.getIterator();\n            while (it1.hasNext() && it2.hasNext()) {\n                var next1 = it1.getNext();\n                var next2 = it2.getNext();\n                if (next1.key !== next2.key || !next1.value.isEqual(next2.value)) {\n                    return false;\n                }\n            }\n            return !it1.hasNext() && !it2.hasNext();\n        }\n        return false;\n    };\n    ObjectValue.prototype.compareTo = function (other) {\n        if (other instanceof ObjectValue) {\n            var it1 = this.internalValue.getIterator();\n            var it2 = other.internalValue.getIterator();\n            while (it1.hasNext() && it2.hasNext()) {\n                var next1 = it1.getNext();\n                var next2 = it2.getNext();\n                var cmp = primitiveComparator(next1.key, next2.key) ||\n                    next1.value.compareTo(next2.value);\n                if (cmp) {\n                    return cmp;\n                }\n            }\n            // Only equal if both iterators are exhausted\n            return primitiveComparator(it1.hasNext(), it2.hasNext());\n        }\n        else {\n            return this.defaultCompareTo(other);\n        }\n    };\n    ObjectValue.prototype.set = function (path, to) {\n        assert(!path.isEmpty(), 'Cannot set field for empty path on ObjectValue');\n        if (path.length === 1) {\n            return this.setChild(path.firstSegment(), to);\n        }\n        else {\n            var child = this.child(path.firstSegment());\n            if (!(child instanceof ObjectValue)) {\n                child = ObjectValue.EMPTY;\n            }\n            var newChild = child.set(path.popFirst(), to);\n            return this.setChild(path.firstSegment(), newChild);\n        }\n    };\n    ObjectValue.prototype.delete = function (path) {\n        assert(!path.isEmpty(), 'Cannot delete field for empty path on ObjectValue');\n        if (path.length === 1) {\n            return new ObjectValue(this.internalValue.remove(path.firstSegment()));\n        }\n        else {\n            // nested field\n            var child = this.child(path.firstSegment());\n            if (child instanceof ObjectValue) {\n                var newChild = child.delete(path.popFirst());\n                return new ObjectValue(this.internalValue.insert(path.firstSegment(), newChild));\n            }\n            else {\n                // Don't actually change a primitive value to an object for a delete\n                return this;\n            }\n        }\n    };\n    ObjectValue.prototype.contains = function (path) {\n        return this.field(path) !== undefined;\n    };\n    ObjectValue.prototype.field = function (path) {\n        assert(!path.isEmpty(), \"Can't get field of empty path\");\n        var field = this;\n        path.forEach(function (pathSegment) {\n            if (field instanceof ObjectValue) {\n                field = field.internalValue.get(pathSegment) || undefined;\n            }\n            else {\n                field = undefined;\n            }\n        });\n        return field;\n    };\n    ObjectValue.prototype.toString = function () {\n        return JSON.stringify(this.value());\n    };\n    ObjectValue.prototype.child = function (childName) {\n        return this.internalValue.get(childName) || undefined;\n    };\n    ObjectValue.prototype.setChild = function (childName, value) {\n        return new ObjectValue(this.internalValue.insert(childName, value));\n    };\n    ObjectValue.EMPTY = new ObjectValue(new SortedMap(primitiveComparator));\n    return ObjectValue;\n}(field_value_FieldValue));\n\nvar field_value_ArrayValue = /** @class */ (function (_super) {\n    tslib_es6[\"__extends\"](ArrayValue, _super);\n    function ArrayValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.ArrayValue;\n        return _this;\n    }\n    ArrayValue.prototype.value = function (options) {\n        return this.internalValue.map(function (v) { return v.value(options); });\n    };\n    ArrayValue.prototype.forEach = function (action) {\n        this.internalValue.forEach(action);\n    };\n    ArrayValue.prototype.isEqual = function (other) {\n        if (other instanceof ArrayValue) {\n            if (this.internalValue.length !== other.internalValue.length) {\n                return false;\n            }\n            for (var i = 0; i < this.internalValue.length; i++) {\n                if (!this.internalValue[i].isEqual(other.internalValue[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    };\n    ArrayValue.prototype.compareTo = function (other) {\n        if (other instanceof ArrayValue) {\n            var minLength = Math.min(this.internalValue.length, other.internalValue.length);\n            for (var i = 0; i < minLength; i++) {\n                var cmp = this.internalValue[i].compareTo(other.internalValue[i]);\n                if (cmp) {\n                    return cmp;\n                }\n            }\n            return primitiveComparator(this.internalValue.length, other.internalValue.length);\n        }\n        else {\n            return this.defaultCompareTo(other);\n        }\n    };\n    ArrayValue.prototype.toString = function () {\n        return JSON.stringify(this.value());\n    };\n    return ArrayValue;\n}(field_value_FieldValue));\n\n\n//# sourceMappingURL=field_value.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/types.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Untyped Number alias we can use to check for ES6 methods / properties.\n// tslint:disable-next-line:no-any variable-name\nvar NumberAsAny = Number;\n/**\n * Minimum safe integer in Javascript because of floating point precision.\n * Added to not rely on ES6 features.\n */\nvar MIN_SAFE_INTEGER = NumberAsAny.MIN_SAFE_INTEGER || -(Math.pow(2, 53) - 1);\n/**\n * Maximum safe integer in Javascript because of floating point precision.\n * Added to not rely on ES6 features.\n */\nvar MAX_SAFE_INTEGER = NumberAsAny.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;\n/**\n * Returns whether an number is an integer, uses native implementation if\n * available.\n * Added to not rely on ES6 features.\n * @param value The value to test for being an integer\n */\nvar isInteger = NumberAsAny.isInteger ||\n    (function (value) {\n        return typeof value === 'number' &&\n            isFinite(value) &&\n            Math.floor(value) === value;\n    });\n/**\n * Returns whether a variable is either undefined or null.\n */\nfunction isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\n/**\n * Returns whether a value is an integer and in the safe integer range\n * @param value The value to test for being an integer and in the safe range\n */\nfunction isSafeInteger(value) {\n    return (isInteger(value) &&\n        value <= MAX_SAFE_INTEGER &&\n        value >= MIN_SAFE_INTEGER);\n}\n/**\n * Safely checks if the number is NaN.\n */\nfunction safeIsNaN(value) {\n    if (NumberAsAny.IsNaN) {\n        return NumberAsAny.IsNaN(value);\n    }\n    else {\n        return typeof value === 'number' && isNaN(value);\n    }\n}\n\n//# sourceMappingURL=types.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/core/query.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\nvar query_Query = /** @class */ (function () {\n    function Query(path, explicitOrderBy, filters, limit, startAt, endAt) {\n        if (explicitOrderBy === void 0) { explicitOrderBy = []; }\n        if (filters === void 0) { filters = []; }\n        if (limit === void 0) { limit = null; }\n        if (startAt === void 0) { startAt = null; }\n        if (endAt === void 0) { endAt = null; }\n        this.path = path;\n        this.explicitOrderBy = explicitOrderBy;\n        this.filters = filters;\n        this.limit = limit;\n        this.startAt = startAt;\n        this.endAt = endAt;\n        this.memoizedCanonicalId = null;\n        this.memoizedOrderBy = null;\n        if (this.startAt) {\n            this.assertValidBound(this.startAt);\n        }\n        if (this.endAt) {\n            this.assertValidBound(this.endAt);\n        }\n    }\n    Query.atPath = function (path) {\n        return new Query(path);\n    };\n    Object.defineProperty(Query.prototype, \"orderBy\", {\n        get: function () {\n            if (this.memoizedOrderBy === null) {\n                var inequalityField = this.getInequalityFilterField();\n                var firstOrderByField = this.getFirstOrderByField();\n                if (inequalityField !== null && firstOrderByField === null) {\n                    // In order to implicitly add key ordering, we must also add the\n                    // inequality filter field for it to be a valid query.\n                    // Note that the default inequality field and key ordering is ascending.\n                    if (inequalityField.isKeyField()) {\n                        this.memoizedOrderBy = [KEY_ORDERING_ASC];\n                    }\n                    else {\n                        this.memoizedOrderBy = [\n                            new query_OrderBy(inequalityField),\n                            KEY_ORDERING_ASC\n                        ];\n                    }\n                }\n                else {\n                    assert(inequalityField === null ||\n                        (firstOrderByField !== null &&\n                            inequalityField.isEqual(firstOrderByField)), 'First orderBy should match inequality field.');\n                    this.memoizedOrderBy = [];\n                    var foundKeyOrdering = false;\n                    for (var _i = 0, _a = this.explicitOrderBy; _i < _a.length; _i++) {\n                        var orderBy = _a[_i];\n                        this.memoizedOrderBy.push(orderBy);\n                        if (orderBy.field.isKeyField()) {\n                            foundKeyOrdering = true;\n                        }\n                    }\n                    if (!foundKeyOrdering) {\n                        // The order of the implicit key ordering always matches the last\n                        // explicit order by\n                        var lastDirection = this.explicitOrderBy.length > 0\n                            ? this.explicitOrderBy[this.explicitOrderBy.length - 1].dir\n                            : Direction.ASCENDING;\n                        this.memoizedOrderBy.push(lastDirection === Direction.ASCENDING\n                            ? KEY_ORDERING_ASC\n                            : KEY_ORDERING_DESC);\n                    }\n                }\n            }\n            return this.memoizedOrderBy;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Query.prototype.addFilter = function (filter) {\n        assert(this.getInequalityFilterField() == null ||\n            !(filter instanceof query_RelationFilter) ||\n            !filter.isInequality() ||\n            filter.field.isEqual(this.getInequalityFilterField()), 'Query must only have one inequality field.');\n        assert(!document_key_DocumentKey.isDocumentKey(this.path), 'No filtering allowed for document query');\n        var newFilters = this.filters.concat([filter]);\n        return new Query(this.path, this.explicitOrderBy.slice(), newFilters, this.limit, this.startAt, this.endAt);\n    };\n    Query.prototype.addOrderBy = function (orderBy) {\n        assert(!document_key_DocumentKey.isDocumentKey(this.path), 'No ordering allowed for document query');\n        assert(!this.startAt && !this.endAt, 'Bounds must be set after orderBy');\n        // TODO(dimond): validate that orderBy does not list the same key twice.\n        var newOrderBy = this.explicitOrderBy.concat([orderBy]);\n        return new Query(this.path, newOrderBy, this.filters.slice(), this.limit, this.startAt, this.endAt);\n    };\n    Query.prototype.withLimit = function (limit) {\n        return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), limit, this.startAt, this.endAt);\n    };\n    Query.prototype.withStartAt = function (bound) {\n        return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, bound, this.endAt);\n    };\n    Query.prototype.withEndAt = function (bound) {\n        return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, this.startAt, bound);\n    };\n    // TODO(b/29183165): This is used to get a unique string from a query to, for\n    // example, use as a dictionary key, but the implementation is subject to\n    // collisions. Make it collision-free.\n    Query.prototype.canonicalId = function () {\n        if (this.memoizedCanonicalId === null) {\n            var canonicalId = this.path.canonicalString();\n            canonicalId += '|f:';\n            for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {\n                var filter = _a[_i];\n                canonicalId += filter.canonicalId();\n                canonicalId += ',';\n            }\n            canonicalId += '|ob:';\n            // TODO(dimond): make this collision resistant\n            for (var _b = 0, _c = this.orderBy; _b < _c.length; _b++) {\n                var orderBy = _c[_b];\n                canonicalId += orderBy.canonicalId();\n                canonicalId += ',';\n            }\n            if (!isNullOrUndefined(this.limit)) {\n                canonicalId += '|l:';\n                canonicalId += this.limit;\n            }\n            if (this.startAt) {\n                canonicalId += '|lb:';\n                canonicalId += this.startAt.canonicalId();\n            }\n            if (this.endAt) {\n                canonicalId += '|ub:';\n                canonicalId += this.endAt.canonicalId();\n            }\n            this.memoizedCanonicalId = canonicalId;\n        }\n        return this.memoizedCanonicalId;\n    };\n    Query.prototype.toString = function () {\n        var str = 'Query(' + this.path.canonicalString();\n        if (this.filters.length > 0) {\n            str += \", filters: [\" + this.filters.join(', ') + \"]\";\n        }\n        if (!isNullOrUndefined(this.limit)) {\n            str += ', limit: ' + this.limit;\n        }\n        if (this.explicitOrderBy.length > 0) {\n            str += \", orderBy: [\" + this.explicitOrderBy.join(', ') + \"]\";\n        }\n        if (this.startAt) {\n            str += ', startAt: ' + this.startAt.canonicalId();\n        }\n        if (this.endAt) {\n            str += ', endAt: ' + this.endAt.canonicalId();\n        }\n        return str + ')';\n    };\n    Query.prototype.isEqual = function (other) {\n        if (this.limit !== other.limit) {\n            return false;\n        }\n        if (this.orderBy.length !== other.orderBy.length) {\n            return false;\n        }\n        for (var i = 0; i < this.orderBy.length; i++) {\n            if (!this.orderBy[i].isEqual(other.orderBy[i])) {\n                return false;\n            }\n        }\n        if (this.filters.length !== other.filters.length) {\n            return false;\n        }\n        for (var i = 0; i < this.filters.length; i++) {\n            if (!this.filters[i].isEqual(other.filters[i])) {\n                return false;\n            }\n        }\n        if (!this.path.isEqual(other.path)) {\n            return false;\n        }\n        if (this.startAt !== null\n            ? !this.startAt.isEqual(other.startAt)\n            : other.startAt !== null) {\n            return false;\n        }\n        return this.endAt !== null\n            ? this.endAt.isEqual(other.endAt)\n            : other.endAt === null;\n    };\n    Query.prototype.docComparator = function (d1, d2) {\n        var comparedOnKeyField = false;\n        for (var _i = 0, _a = this.orderBy; _i < _a.length; _i++) {\n            var orderBy = _a[_i];\n            var comp = orderBy.compare(d1, d2);\n            if (comp !== 0)\n                return comp;\n            comparedOnKeyField = comparedOnKeyField || orderBy.field.isKeyField();\n        }\n        // Assert that we actually compared by key\n        assert(comparedOnKeyField, \"orderBy used that doesn't compare on key field\");\n        return 0;\n    };\n    Query.prototype.matches = function (doc) {\n        return (this.matchesAncestor(doc) &&\n            this.matchesOrderBy(doc) &&\n            this.matchesFilters(doc) &&\n            this.matchesBounds(doc));\n    };\n    Query.prototype.hasLimit = function () {\n        return !isNullOrUndefined(this.limit);\n    };\n    Query.prototype.getFirstOrderByField = function () {\n        return this.explicitOrderBy.length > 0\n            ? this.explicitOrderBy[0].field\n            : null;\n    };\n    Query.prototype.getInequalityFilterField = function () {\n        for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {\n            var filter = _a[_i];\n            if (filter instanceof query_RelationFilter && filter.isInequality()) {\n                return filter.field;\n            }\n        }\n        return null;\n    };\n    Query.prototype.isDocumentQuery = function () {\n        return document_key_DocumentKey.isDocumentKey(this.path) && this.filters.length === 0;\n    };\n    Query.prototype.matchesAncestor = function (doc) {\n        var docPath = doc.key.path;\n        if (document_key_DocumentKey.isDocumentKey(this.path)) {\n            // exact match for document queries\n            return this.path.isEqual(docPath);\n        }\n        else {\n            // shallow ancestor queries by default\n            return (this.path.isPrefixOf(docPath) && this.path.length === docPath.length - 1);\n        }\n    };\n    /**\n     * A document must have a value for every ordering clause in order to show up\n     * in the results.\n     */\n    Query.prototype.matchesOrderBy = function (doc) {\n        for (var _i = 0, _a = this.explicitOrderBy; _i < _a.length; _i++) {\n            var orderBy = _a[_i];\n            // order by key always matches\n            if (!orderBy.field.isKeyField() &&\n                doc.field(orderBy.field) === undefined) {\n                return false;\n            }\n        }\n        return true;\n    };\n    Query.prototype.matchesFilters = function (doc) {\n        for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {\n            var filter = _a[_i];\n            if (!filter.matches(doc)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * Makes sure a document is within the bounds, if provided.\n     */\n    Query.prototype.matchesBounds = function (doc) {\n        if (this.startAt && !this.startAt.sortsBeforeDocument(this.orderBy, doc)) {\n            return false;\n        }\n        if (this.endAt && this.endAt.sortsBeforeDocument(this.orderBy, doc)) {\n            return false;\n        }\n        return true;\n    };\n    Query.prototype.assertValidBound = function (bound) {\n        assert(bound.position.length <= this.orderBy.length, 'Bound is longer than orderBy');\n    };\n    return Query;\n}());\n\nvar query_RelationOp = /** @class */ (function () {\n    function RelationOp(name) {\n        this.name = name;\n    }\n    RelationOp.fromString = function (op) {\n        switch (op) {\n            case '<':\n                return RelationOp.LESS_THAN;\n            case '<=':\n                return RelationOp.LESS_THAN_OR_EQUAL;\n            case '==':\n                return RelationOp.EQUAL;\n            case '>=':\n                return RelationOp.GREATER_THAN_OR_EQUAL;\n            case '>':\n                return RelationOp.GREATER_THAN;\n            default:\n                return fail('Unknown relation: ' + op);\n        }\n    };\n    RelationOp.prototype.toString = function () {\n        return this.name;\n    };\n    RelationOp.prototype.isEqual = function (other) {\n        return this.name === other.name;\n    };\n    RelationOp.LESS_THAN = new RelationOp('<');\n    RelationOp.LESS_THAN_OR_EQUAL = new RelationOp('<=');\n    RelationOp.EQUAL = new RelationOp('==');\n    RelationOp.GREATER_THAN = new RelationOp('>');\n    RelationOp.GREATER_THAN_OR_EQUAL = new RelationOp('>=');\n    return RelationOp;\n}());\n\nvar query_RelationFilter = /** @class */ (function () {\n    function RelationFilter(field, op, value) {\n        this.field = field;\n        this.op = op;\n        this.value = value;\n    }\n    RelationFilter.prototype.matches = function (doc) {\n        if (this.field.isKeyField()) {\n            assert(this.value instanceof field_value_RefValue, 'Comparing on key, but filter value not a RefValue');\n            var refValue = this.value;\n            var comparison = document_key_DocumentKey.comparator(doc.key, refValue.key);\n            return this.matchesComparison(comparison);\n        }\n        else {\n            var val = doc.field(this.field);\n            return val !== undefined && this.matchesValue(val);\n        }\n    };\n    RelationFilter.prototype.matchesValue = function (value) {\n        // Only compare types with matching backend order (such as double and int).\n        if (this.value.typeOrder !== value.typeOrder) {\n            return false;\n        }\n        return this.matchesComparison(value.compareTo(this.value));\n    };\n    RelationFilter.prototype.matchesComparison = function (comparison) {\n        switch (this.op) {\n            case query_RelationOp.LESS_THAN:\n                return comparison < 0;\n            case query_RelationOp.LESS_THAN_OR_EQUAL:\n                return comparison <= 0;\n            case query_RelationOp.EQUAL:\n                return comparison === 0;\n            case query_RelationOp.GREATER_THAN:\n                return comparison > 0;\n            case query_RelationOp.GREATER_THAN_OR_EQUAL:\n                return comparison >= 0;\n            default:\n                return fail('Unknown relation op' + this.op);\n        }\n    };\n    RelationFilter.prototype.isInequality = function () {\n        return this.op !== query_RelationOp.EQUAL;\n    };\n    RelationFilter.prototype.canonicalId = function () {\n        // TODO(b/29183165): Technically, this won't be unique if two values have\n        // the same description, such as the int 3 and the string \"3\". So we should\n        // add the types in here somehow, too.\n        return (this.field.canonicalString() + this.op.toString() + this.value.toString());\n    };\n    RelationFilter.prototype.isEqual = function (other) {\n        if (other instanceof RelationFilter) {\n            return (this.op.isEqual(other.op) &&\n                this.field.isEqual(other.field) &&\n                this.value.isEqual(other.value));\n        }\n        else {\n            return false;\n        }\n    };\n    RelationFilter.prototype.toString = function () {\n        return this.field.canonicalString() + \" \" + this.op + \" \" + this.value.value();\n    };\n    return RelationFilter;\n}());\n\n/**\n * Filter that matches 'null' values.\n */\nvar NullFilter = /** @class */ (function () {\n    function NullFilter(field) {\n        this.field = field;\n    }\n    NullFilter.prototype.matches = function (doc) {\n        var val = doc.field(this.field);\n        return val !== undefined && val.value() === null;\n    };\n    NullFilter.prototype.canonicalId = function () {\n        return this.field.canonicalString() + ' IS null';\n    };\n    NullFilter.prototype.toString = function () {\n        return this.field.canonicalString() + \" IS null\";\n    };\n    NullFilter.prototype.isEqual = function (other) {\n        if (other instanceof NullFilter) {\n            return this.field.isEqual(other.field);\n        }\n        else {\n            return false;\n        }\n    };\n    return NullFilter;\n}());\n\n/**\n * Filter that matches 'NaN' values.\n */\nvar NanFilter = /** @class */ (function () {\n    function NanFilter(field) {\n        this.field = field;\n    }\n    NanFilter.prototype.matches = function (doc) {\n        var val = doc.field(this.field).value();\n        return typeof val === 'number' && isNaN(val);\n    };\n    NanFilter.prototype.canonicalId = function () {\n        return this.field.canonicalString() + ' IS NaN';\n    };\n    NanFilter.prototype.toString = function () {\n        return this.field.canonicalString() + \" IS NaN\";\n    };\n    NanFilter.prototype.isEqual = function (other) {\n        if (other instanceof NanFilter) {\n            return this.field.isEqual(other.field);\n        }\n        else {\n            return false;\n        }\n    };\n    return NanFilter;\n}());\n\n/**\n * Creates a filter based on the provided arguments.\n */\nfunction fieldFilter(field, op, value) {\n    if (value.isEqual(field_value_NullValue.INSTANCE)) {\n        if (op !== query_RelationOp.EQUAL) {\n            throw new error_FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You can only perform equals ' + 'comparisons on null.');\n        }\n        return new NullFilter(field);\n    }\n    else if (value.isEqual(field_value_DoubleValue.NAN)) {\n        if (op !== query_RelationOp.EQUAL) {\n            throw new error_FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You can only perform equals ' + 'comparisons on NaN.');\n        }\n        return new NanFilter(field);\n    }\n    else {\n        return new query_RelationFilter(field, op, value);\n    }\n}\n/**\n * The direction of sorting in an order by.\n */\nvar Direction = /** @class */ (function () {\n    function Direction(name) {\n        this.name = name;\n    }\n    Direction.prototype.toString = function () {\n        return this.name;\n    };\n    Direction.ASCENDING = new Direction('asc');\n    Direction.DESCENDING = new Direction('desc');\n    return Direction;\n}());\n\n/**\n * Represents a bound of a query.\n *\n * The bound is specified with the given components representing a position and\n * whether it's just before or just after the position (relative to whatever the\n * query order is).\n *\n * The position represents a logical index position for a query. It's a prefix\n * of values for the (potentially implicit) order by clauses of a query.\n *\n * Bound provides a function to determine whether a document comes before or\n * after a bound. This is influenced by whether the position is just before or\n * just after the provided values.\n */\nvar query_Bound = /** @class */ (function () {\n    function Bound(position, before) {\n        this.position = position;\n        this.before = before;\n    }\n    Bound.prototype.canonicalId = function () {\n        // TODO(b/29183165): Make this collision robust.\n        var canonicalId = this.before ? 'b:' : 'a:';\n        for (var _i = 0, _a = this.position; _i < _a.length; _i++) {\n            var component = _a[_i];\n            canonicalId += component.toString();\n        }\n        return canonicalId;\n    };\n    /**\n     * Returns true if a document sorts before a bound using the provided sort\n     * order.\n     */\n    Bound.prototype.sortsBeforeDocument = function (orderBy, doc) {\n        assert(this.position.length <= orderBy.length, \"Bound has more components than query's orderBy\");\n        var comparison = 0;\n        for (var i = 0; i < this.position.length; i++) {\n            var orderByComponent = orderBy[i];\n            var component = this.position[i];\n            if (orderByComponent.field.isKeyField()) {\n                assert(component instanceof field_value_RefValue, 'Bound has a non-key value where the key path is being used.');\n                comparison = document_key_DocumentKey.comparator(component.key, doc.key);\n            }\n            else {\n                var docValue = doc.field(orderByComponent.field);\n                assert(docValue !== undefined, 'Field should exist since document matched the orderBy already.');\n                comparison = component.compareTo(docValue);\n            }\n            if (orderByComponent.dir === Direction.DESCENDING) {\n                comparison = comparison * -1;\n            }\n            if (comparison !== 0) {\n                break;\n            }\n        }\n        return this.before ? comparison <= 0 : comparison < 0;\n    };\n    Bound.prototype.isEqual = function (other) {\n        if (other === null) {\n            return false;\n        }\n        if (this.before !== other.before ||\n            this.position.length !== other.position.length) {\n            return false;\n        }\n        for (var i = 0; i < this.position.length; i++) {\n            var thisPosition = this.position[i];\n            var otherPosition = other.position[i];\n            return thisPosition.isEqual(otherPosition);\n        }\n        return true;\n    };\n    return Bound;\n}());\n\n/**\n * An ordering on a field, in some Direction. Direction defaults to ASCENDING.\n */\nvar query_OrderBy = /** @class */ (function () {\n    function OrderBy(field, dir) {\n        this.field = field;\n        if (dir === undefined) {\n            dir = Direction.ASCENDING;\n        }\n        this.dir = dir;\n        this.isKeyOrderBy = field.isKeyField();\n    }\n    OrderBy.prototype.compare = function (d1, d2) {\n        var comparison = this.isKeyOrderBy\n            ? document_Document.compareByKey(d1, d2)\n            : document_Document.compareByField(this.field, d1, d2);\n        switch (this.dir) {\n            case Direction.ASCENDING:\n                return comparison;\n            case Direction.DESCENDING:\n                return -1 * comparison;\n            default:\n                return fail('Unknown direction: ' + this.dir);\n        }\n    };\n    OrderBy.prototype.canonicalId = function () {\n        // TODO(b/29183165): Make this collision robust.\n        return this.field.canonicalString() + this.dir.toString();\n    };\n    OrderBy.prototype.toString = function () {\n        return this.field.canonicalString() + \" (\" + this.dir + \")\";\n    };\n    OrderBy.prototype.isEqual = function (other) {\n        return this.dir === other.dir && this.field.isEqual(other.field);\n    };\n    return OrderBy;\n}());\n\nvar KEY_ORDERING_ASC = new query_OrderBy(path_FieldPath.keyField(), Direction.ASCENDING);\nvar KEY_ORDERING_DESC = new query_OrderBy(path_FieldPath.keyField(), Direction.DESCENDING);\n\n//# sourceMappingURL=query.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/core/timestamp.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n// A RegExp matching ISO 8601 UTC timestamps with optional fraction.\nvar isoRegExp = new RegExp(/^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.(\\d+))?Z$/);\nvar timestamp_Timestamp = /** @class */ (function () {\n    function Timestamp(seconds, nanos) {\n        this.seconds = seconds;\n        this.nanos = nanos;\n        assert(nanos >= 0, 'timestamp nanoseconds out of range: ' + nanos);\n        assert(nanos < 1e9, 'timestamp nanoseconds out of range' + nanos);\n        // Midnight at the beginning of 1/1/1 is the earliest Firestore supports.\n        assert(seconds >= -62135596800, 'timestamp seconds out of range: ' + seconds);\n        // This will break in the year 10,000.\n        assert(seconds < 253402300800, 'timestamp seconds out of range' + seconds);\n    }\n    Timestamp.now = function () {\n        return Timestamp.fromEpochMilliseconds(Date.now());\n    };\n    Timestamp.fromDate = function (date) {\n        return Timestamp.fromEpochMilliseconds(date.getTime());\n    };\n    Timestamp.fromEpochMilliseconds = function (milliseconds) {\n        var seconds = Math.floor(milliseconds / 1000);\n        var nanos = (milliseconds - seconds * 1000) * 1e6;\n        return new Timestamp(seconds, nanos);\n    };\n    Timestamp.fromISOString = function (utc) {\n        // The date string can have higher precision (nanos) than the Date class\n        // (millis), so we do some custom parsing here.\n        // Parse the nanos right out of the string.\n        var nanos = 0;\n        var fraction = isoRegExp.exec(utc);\n        assert(!!fraction, 'invalid timestamp: ' + utc);\n        if (fraction[1]) {\n            // Pad the fraction out to 9 digits (nanos).\n            var nanoStr = fraction[1];\n            nanoStr = (nanoStr + '000000000').substr(0, 9);\n            nanos = Number(nanoStr);\n        }\n        // Parse the date to get the seconds.\n        var date = new Date(utc);\n        var seconds = Math.floor(date.getTime() / 1000);\n        return new Timestamp(seconds, nanos);\n    };\n    Timestamp.prototype.toDate = function () {\n        return new Date(this.toEpochMilliseconds());\n    };\n    Timestamp.prototype.toEpochMilliseconds = function () {\n        return this.seconds * 1000 + this.nanos / 1e6;\n    };\n    Timestamp.prototype.compareTo = function (other) {\n        if (this.seconds === other.seconds) {\n            return primitiveComparator(this.nanos, other.nanos);\n        }\n        return primitiveComparator(this.seconds, other.seconds);\n    };\n    Timestamp.prototype.isEqual = function (other) {\n        return other.seconds === this.seconds && other.nanos === this.nanos;\n    };\n    Timestamp.prototype.toString = function () {\n        return 'Timestamp(seconds=' + this.seconds + ', nanos=' + this.nanos + ')';\n    };\n    return Timestamp;\n}());\n\n\n//# sourceMappingURL=timestamp.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/core/snapshot_version.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A version of a document in Firestore. This corresponds to the version\n * timestamp, such as update_time or read_time.\n */\nvar snapshot_version_SnapshotVersion = /** @class */ (function () {\n    function SnapshotVersion(timestamp) {\n        this.timestamp = timestamp;\n    }\n    // TODO(b/34176344): Once we no longer need to use the old alpha protos,\n    // delete this constructor and use a timestamp-backed version everywhere.\n    SnapshotVersion.fromMicroseconds = function (value) {\n        var seconds = Math.floor(value / 1e6);\n        var nanos = (value % 1e6) * 1e3;\n        return new SnapshotVersion(new timestamp_Timestamp(seconds, nanos));\n    };\n    SnapshotVersion.fromTimestamp = function (value) {\n        return new SnapshotVersion(value);\n    };\n    SnapshotVersion.forDeletedDoc = function () {\n        return SnapshotVersion.MIN;\n    };\n    SnapshotVersion.prototype.compareTo = function (other) {\n        return this.timestamp.compareTo(other.timestamp);\n    };\n    SnapshotVersion.prototype.isEqual = function (other) {\n        return this.timestamp.isEqual(other.timestamp);\n    };\n    /** Returns a number representation of the version for use in spec tests. */\n    SnapshotVersion.prototype.toMicroseconds = function () {\n        // Convert to microseconds.\n        return this.timestamp.seconds * 1e6 + this.timestamp.nanos / 1000;\n    };\n    SnapshotVersion.prototype.toString = function () {\n        return 'SnapshotVersion(' + this.timestamp.toString() + ')';\n    };\n    SnapshotVersion.prototype.toTimestamp = function () {\n        return this.timestamp;\n    };\n    SnapshotVersion.MIN = new SnapshotVersion(new timestamp_Timestamp(0, 0));\n    return SnapshotVersion;\n}());\n\n\n//# sourceMappingURL=snapshot_version.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/query_data.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/** An enumeration of the different purposes we have for queries. */\nvar QueryPurpose;\n(function (QueryPurpose) {\n    /** A regular, normal query. */\n    QueryPurpose[QueryPurpose[\"Listen\"] = 0] = \"Listen\";\n    /**\n     * The query was used to refill a query after an existence filter mismatch.\n     */\n    QueryPurpose[QueryPurpose[\"ExistenceFilterMismatch\"] = 1] = \"ExistenceFilterMismatch\";\n    /** The query was used to resolve a limbo document. */\n    QueryPurpose[QueryPurpose[\"LimboResolution\"] = 2] = \"LimboResolution\";\n})(QueryPurpose || (QueryPurpose = {}));\n/**\n * An immutable set of metadata that the local store tracks for each query.\n */\nvar query_data_QueryData = /** @class */ (function () {\n    function QueryData(\n    /** The query being listened to. */\n    query, \n    /**\n     * The target ID to which the query corresponds; Assigned by the\n     * LocalStore for user listens and by the SyncEngine for limbo watches.\n     */\n    targetId, \n    /** The purpose of the query. */\n    purpose, \n    /** The latest snapshot version seen for this target. */\n    snapshotVersion, \n    /**\n     * An opaque, server-assigned token that allows watching a query to be\n     * resumed after disconnecting without retransmitting all the data that\n     * matches the query. The resume token essentially identifies a point in\n     * time from which the server should resume sending results.\n     */\n    resumeToken) {\n        if (snapshotVersion === void 0) { snapshotVersion = snapshot_version_SnapshotVersion.MIN; }\n        if (resumeToken === void 0) { resumeToken = emptyByteString(); }\n        this.query = query;\n        this.targetId = targetId;\n        this.purpose = purpose;\n        this.snapshotVersion = snapshotVersion;\n        this.resumeToken = resumeToken;\n    }\n    /**\n     * Creates a new query data instance with an updated snapshot version and\n     * resume token.\n     */\n    QueryData.prototype.update = function (updated) {\n        return new QueryData(this.query, this.targetId, this.purpose, updated.snapshotVersion, updated.resumeToken);\n    };\n    QueryData.prototype.isEqual = function (other) {\n        return (this.targetId === other.targetId &&\n            this.purpose === other.purpose &&\n            this.snapshotVersion.isEqual(other.snapshotVersion) &&\n            this.resumeToken === other.resumeToken &&\n            this.query.isEqual(other.query));\n    };\n    return QueryData;\n}());\n\n\n//# sourceMappingURL=query_data.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/model/mutation.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n/**\n * Provides a set of fields that can be used to partially patch a document.\n * FieldMask is used in conjunction with ObjectValue.\n * Examples:\n *   foo - Overwrites foo entirely with the provided value. If foo is not\n *         present in the companion ObjectValue, the field is deleted.\n *   foo.bar - Overwrites only the field bar of the object foo.\n *             If foo is not an object, foo is replaced with an object\n *             containing foo\n */\nvar mutation_FieldMask = /** @class */ (function () {\n    function FieldMask(fields) {\n        this.fields = fields;\n        // TODO(dimond): validation of FieldMask\n    }\n    FieldMask.prototype.isEqual = function (other) {\n        return arrayEquals(this.fields, other.fields);\n    };\n    return FieldMask;\n}());\n\n/** Transforms a value into a server-generated timestamp. */\nvar ServerTimestampTransform = /** @class */ (function () {\n    function ServerTimestampTransform() {\n    }\n    ServerTimestampTransform.prototype.isEqual = function (other) {\n        return other instanceof ServerTimestampTransform;\n    };\n    ServerTimestampTransform.instance = new ServerTimestampTransform();\n    return ServerTimestampTransform;\n}());\n\n/** A field path and the TransformOperation to perform upon it. */\nvar FieldTransform = /** @class */ (function () {\n    function FieldTransform(field, transform) {\n        this.field = field;\n        this.transform = transform;\n    }\n    FieldTransform.prototype.isEqual = function (other) {\n        return (this.field.isEqual(other.field) && this.transform.isEqual(other.transform));\n    };\n    return FieldTransform;\n}());\n\n/** The result of successfully applying a mutation to the backend. */\nvar MutationResult = /** @class */ (function () {\n    function MutationResult(\n    /**\n     * The version at which the mutation was committed or null for a delete.\n     */\n    version, \n    /**\n     * The resulting fields returned from the backend after a\n     * TransformMutation has been committed. Contains one FieldValue for each\n     * FieldTransform that was in the mutation.\n     *\n     * Will be null if the mutation was not a TransformMutation.\n     */\n    transformResults) {\n        this.version = version;\n        this.transformResults = transformResults;\n    }\n    return MutationResult;\n}());\n\nvar MutationType;\n(function (MutationType) {\n    MutationType[MutationType[\"Set\"] = 0] = \"Set\";\n    MutationType[MutationType[\"Patch\"] = 1] = \"Patch\";\n    MutationType[MutationType[\"Transform\"] = 2] = \"Transform\";\n    MutationType[MutationType[\"Delete\"] = 3] = \"Delete\";\n})(MutationType || (MutationType = {}));\n/**\n * Encodes a precondition for a mutation. This follows the model that the\n * backend accepts with the special case of an explicit \"empty\" precondition\n * (meaning no precondition).\n */\nvar mutation_Precondition = /** @class */ (function () {\n    function Precondition(updateTime, exists) {\n        this.updateTime = updateTime;\n        this.exists = exists;\n        assert(updateTime === undefined || exists === undefined, 'Precondition can specify \"exists\" or \"updateTime\" but not both');\n    }\n    /** Creates a new Precondition with an exists flag. */\n    Precondition.exists = function (exists) {\n        return new Precondition(undefined, exists);\n    };\n    /** Creates a new Precondition based on a version a document exists at. */\n    Precondition.updateTime = function (version) {\n        return new Precondition(version);\n    };\n    Object.defineProperty(Precondition.prototype, \"isNone\", {\n        /** Returns whether this Precondition is empty. */\n        get: function () {\n            return this.updateTime === undefined && this.exists === undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Returns true if the preconditions is valid for the given document\n     * (or null if no document is available).\n     */\n    Precondition.prototype.isValidFor = function (maybeDoc) {\n        if (this.updateTime !== undefined) {\n            return (maybeDoc instanceof document_Document &&\n                maybeDoc.version.isEqual(this.updateTime));\n        }\n        else if (this.exists !== undefined) {\n            if (this.exists) {\n                return maybeDoc instanceof document_Document;\n            }\n            else {\n                return maybeDoc === null || maybeDoc instanceof document_NoDocument;\n            }\n        }\n        else {\n            assert(this.isNone, 'Precondition should be empty');\n            return true;\n        }\n    };\n    Precondition.prototype.isEqual = function (other) {\n        return (equals(this.updateTime, other.updateTime) &&\n            this.exists === other.exists);\n    };\n    Precondition.NONE = new Precondition();\n    return Precondition;\n}());\n\n/**\n * A mutation describes a self-contained change to a document. Mutations can\n * create, replace, delete, and update subsets of documents.\n *\n * Mutations not only act on the value of the document but also it version.\n * In the case of Set, Patch, and Transform mutations we preserve the existing\n * version. In the case of Delete mutations, we reset the version to 0.\n *\n * Here's the expected transition table.\n *\n * MUTATION           APPLIED TO            RESULTS IN\n *\n * SetMutation        Document(v3)          Document(v3)\n * SetMutation        NoDocument(v3)        Document(v0)\n * SetMutation        null                  Document(v0)\n * PatchMutation      Document(v3)          Document(v3)\n * PatchMutation      NoDocument(v3)        NoDocument(v3)\n * PatchMutation      null                  null\n * TransformMutation  Document(v3)          Document(v3)\n * TransformMutation  NoDocument(v3)        NoDocument(v3)\n * TransformMutation  null                  null\n * DeleteMutation     Document(v3)          NoDocument(v0)\n * DeleteMutation     NoDocument(v3)        NoDocument(v0)\n * DeleteMutation     null                  NoDocument(v0)\n *\n * Note that TransformMutations don't create Documents (in the case of being\n * applied to a NoDocument), even though they would on the backend. This is\n * because the client always combines the TransformMutation with a SetMutation\n * or PatchMutation and we only want to apply the transform if the prior\n * mutation resulted in a Document (always true for a SetMutation, but not\n * necessarily for a PatchMutation).\n *\n * ## Subclassing Notes\n *\n * Subclasses of Mutation need to implement applyToRemoteDocument() and\n * applyToLocalView() to implement the actual behavior of applying the mutation\n * to some source document.\n */\nvar mutation_Mutation = /** @class */ (function () {\n    function Mutation() {\n    }\n    Mutation.prototype.verifyKeyMatches = function (maybeDoc) {\n        if (maybeDoc != null) {\n            assert(maybeDoc.key.isEqual(this.key), 'Can only apply a mutation to a document with the same key');\n        }\n    };\n    /**\n     * Returns the version from the given document for use as the result of a\n     * mutation. Mutations are defined to return the version of the base document\n     * only if it is an existing document. Deleted and unknown documents have a\n     * post-mutation version of SnapshotVersion.MIN.\n     */\n    Mutation.getPostMutationVersion = function (maybeDoc) {\n        if (maybeDoc instanceof document_Document) {\n            return maybeDoc.version;\n        }\n        else {\n            return snapshot_version_SnapshotVersion.MIN;\n        }\n    };\n    return Mutation;\n}());\n\n/**\n * A mutation that creates or replaces the document at the given key with the\n * object value contents.\n */\nvar mutation_SetMutation = /** @class */ (function (_super) {\n    tslib_es6[\"__extends\"](SetMutation, _super);\n    function SetMutation(key, value, precondition) {\n        var _this = _super.call(this) || this;\n        _this.key = key;\n        _this.value = value;\n        _this.precondition = precondition;\n        _this.type = MutationType.Set;\n        return _this;\n    }\n    SetMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {\n        this.verifyKeyMatches(maybeDoc);\n        assert(mutationResult.transformResults == null, 'Transform results received by SetMutation.');\n        // Unlike applyToLocalView, if we're applying a mutation to a remote\n        // document the server has accepted the mutation so the precondition must\n        // have held.\n        var version = mutation_Mutation.getPostMutationVersion(maybeDoc);\n        return new document_Document(this.key, version, this.value, {\n            hasLocalMutations: false\n        });\n    };\n    SetMutation.prototype.applyToLocalView = function (maybeDoc, baseDoc, localWriteTime) {\n        this.verifyKeyMatches(maybeDoc);\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        var version = mutation_Mutation.getPostMutationVersion(maybeDoc);\n        return new document_Document(this.key, version, this.value, {\n            hasLocalMutations: true\n        });\n    };\n    SetMutation.prototype.isEqual = function (other) {\n        return (other instanceof SetMutation &&\n            this.key.isEqual(other.key) &&\n            this.value.isEqual(other.value) &&\n            this.precondition.isEqual(other.precondition));\n    };\n    return SetMutation;\n}(mutation_Mutation));\n\n/**\n * A mutation that modifies fields of the document at the given key with the\n * given values. The values are applied through a field mask:\n *\n *  * When a field is in both the mask and the values, the corresponding field\n *    is updated.\n *  * When a field is in neither the mask nor the values, the corresponding\n *    field is unmodified.\n *  * When a field is in the mask but not in the values, the corresponding field\n *    is deleted.\n *  * When a field is not in the mask but is in the values, the values map is\n *    ignored.\n */\nvar mutation_PatchMutation = /** @class */ (function (_super) {\n    tslib_es6[\"__extends\"](PatchMutation, _super);\n    function PatchMutation(key, data, fieldMask, precondition) {\n        var _this = _super.call(this) || this;\n        _this.key = key;\n        _this.data = data;\n        _this.fieldMask = fieldMask;\n        _this.precondition = precondition;\n        _this.type = MutationType.Patch;\n        return _this;\n    }\n    PatchMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {\n        this.verifyKeyMatches(maybeDoc);\n        assert(mutationResult.transformResults == null, 'Transform results received by PatchMutation.');\n        // TODO(mcg): Relax enforcement of this precondition\n        //\n        // We shouldn't actually enforce the precondition since it already passed on\n        // the backend, but we may not have a local version of the document to\n        // patch, so we use the precondition to prevent incorrectly putting a\n        // partial document into our cache.\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        var version = mutation_Mutation.getPostMutationVersion(maybeDoc);\n        var newData = this.patchDocument(maybeDoc);\n        return new document_Document(this.key, version, newData, {\n            hasLocalMutations: false\n        });\n    };\n    PatchMutation.prototype.applyToLocalView = function (maybeDoc, baseDoc, localWriteTime) {\n        this.verifyKeyMatches(maybeDoc);\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        var version = mutation_Mutation.getPostMutationVersion(maybeDoc);\n        var newData = this.patchDocument(maybeDoc);\n        return new document_Document(this.key, version, newData, {\n            hasLocalMutations: true\n        });\n    };\n    PatchMutation.prototype.isEqual = function (other) {\n        return (other instanceof PatchMutation &&\n            this.key.isEqual(other.key) &&\n            this.fieldMask.isEqual(other.fieldMask) &&\n            this.precondition.isEqual(other.precondition));\n    };\n    /**\n     * Patches the data of document if available or creates a new document. Note\n     * that this does not check whether or not the precondition of this patch\n     * holds.\n     */\n    PatchMutation.prototype.patchDocument = function (maybeDoc) {\n        var data;\n        if (maybeDoc instanceof document_Document) {\n            data = maybeDoc.data;\n        }\n        else {\n            data = field_value_ObjectValue.EMPTY;\n        }\n        return this.patchObject(data);\n    };\n    PatchMutation.prototype.patchObject = function (data) {\n        for (var _i = 0, _a = this.fieldMask.fields; _i < _a.length; _i++) {\n            var fieldPath = _a[_i];\n            var newValue = this.data.field(fieldPath);\n            if (newValue !== undefined) {\n                data = data.set(fieldPath, newValue);\n            }\n            else {\n                data = data.delete(fieldPath);\n            }\n        }\n        return data;\n    };\n    return PatchMutation;\n}(mutation_Mutation));\n\n/**\n * A mutation that modifies specific fields of the document with transform\n * operations. Currently the only supported transform is a server timestamp, but\n * IP Address, increment(n), etc. could be supported in the future.\n *\n * It is somewhat similar to a PatchMutation in that it patches specific fields\n * and has no effect when applied to a null or NoDocument (see comment on\n * Mutation for rationale).\n */\nvar mutation_TransformMutation = /** @class */ (function (_super) {\n    tslib_es6[\"__extends\"](TransformMutation, _super);\n    function TransformMutation(key, fieldTransforms) {\n        var _this = _super.call(this) || this;\n        _this.key = key;\n        _this.fieldTransforms = fieldTransforms;\n        _this.type = MutationType.Transform;\n        // NOTE: We set a precondition of exists: true as a safety-check, since we\n        // always combine TransformMutations with a SetMutation or PatchMutation which\n        // (if successful) should end up with an existing document.\n        _this.precondition = mutation_Precondition.exists(true);\n        return _this;\n    }\n    TransformMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {\n        this.verifyKeyMatches(maybeDoc);\n        assert(mutationResult.transformResults != null, 'Transform results missing for TransformMutation.');\n        var transformResults = mutationResult.transformResults;\n        // TODO(mcg): Relax enforcement of this precondition\n        //\n        // We shouldn't actually enforce the precondition since it already passed on\n        // the backend, but we may not have a local version of the document to\n        // patch, so we use the precondition to prevent incorrectly putting a\n        // partial document into our cache.\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        var doc = this.requireDocument(maybeDoc);\n        var newData = this.transformObject(doc.data, transformResults);\n        return new document_Document(this.key, doc.version, newData, {\n            hasLocalMutations: false\n        });\n    };\n    TransformMutation.prototype.applyToLocalView = function (maybeDoc, baseDoc, localWriteTime) {\n        this.verifyKeyMatches(maybeDoc);\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        var doc = this.requireDocument(maybeDoc);\n        var transformResults = this.localTransformResults(localWriteTime, baseDoc);\n        var newData = this.transformObject(doc.data, transformResults);\n        return new document_Document(this.key, doc.version, newData, {\n            hasLocalMutations: true\n        });\n    };\n    TransformMutation.prototype.isEqual = function (other) {\n        return (other instanceof TransformMutation &&\n            this.key.isEqual(other.key) &&\n            arrayEquals(this.fieldTransforms, other.fieldTransforms) &&\n            this.precondition.isEqual(other.precondition));\n    };\n    /**\n     * Asserts that the given MaybeDocument is actually a Document and verifies\n     * that it matches the key for this mutation. Since we only support\n     * transformations with precondition exists this method is guaranteed to be\n     * safe.\n     */\n    TransformMutation.prototype.requireDocument = function (maybeDoc) {\n        assert(maybeDoc instanceof document_Document, 'Unknown MaybeDocument type ' + maybeDoc);\n        var doc = maybeDoc;\n        assert(doc.key.isEqual(this.key), 'Can only transform a document with the same key');\n        return doc;\n    };\n    /**\n     * Creates a list of \"transform results\" (a transform result is a field value\n     * representing the result of applying a transform) for use when applying a\n     * TransformMutation locally.\n     *\n     * @param localWriteTime The local time of the transform mutation (used to\n     *     generate ServerTimestampValues).\n     * @param baseDoc The document prior to applying this mutation batch.\n     * @return The transform results list.\n     */\n    TransformMutation.prototype.localTransformResults = function (localWriteTime, baseDoc) {\n        var transformResults = [];\n        for (var _i = 0, _a = this.fieldTransforms; _i < _a.length; _i++) {\n            var fieldTransform = _a[_i];\n            var transform = fieldTransform.transform;\n            if (transform instanceof ServerTimestampTransform) {\n                var previousValue = null;\n                if (baseDoc instanceof document_Document) {\n                    previousValue = baseDoc.field(fieldTransform.field) || null;\n                }\n                transformResults.push(new field_value_ServerTimestampValue(localWriteTime, previousValue));\n            }\n            else {\n                return fail('Encountered unknown transform: ' + transform);\n            }\n        }\n        return transformResults;\n    };\n    TransformMutation.prototype.transformObject = function (data, transformResults) {\n        assert(transformResults.length === this.fieldTransforms.length, 'TransformResults length mismatch.');\n        for (var i = 0; i < this.fieldTransforms.length; i++) {\n            var fieldTransform = this.fieldTransforms[i];\n            var transform = fieldTransform.transform;\n            var fieldPath = fieldTransform.field;\n            if (transform instanceof ServerTimestampTransform) {\n                data = data.set(fieldPath, transformResults[i]);\n            }\n            else {\n                return fail('Encountered unknown transform: ' + transform);\n            }\n        }\n        return data;\n    };\n    return TransformMutation;\n}(mutation_Mutation));\n\n/** A mutation that deletes the document at the given key. */\nvar mutation_DeleteMutation = /** @class */ (function (_super) {\n    tslib_es6[\"__extends\"](DeleteMutation, _super);\n    function DeleteMutation(key, precondition) {\n        var _this = _super.call(this) || this;\n        _this.key = key;\n        _this.precondition = precondition;\n        _this.type = MutationType.Delete;\n        return _this;\n    }\n    DeleteMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {\n        this.verifyKeyMatches(maybeDoc);\n        assert(mutationResult.transformResults == null, 'Transform results received by DeleteMutation.');\n        // Unlike applyToLocalView, if we're applying a mutation to a remote\n        // document the server has accepted the mutation so the precondition must\n        // have held.\n        return new document_NoDocument(this.key, snapshot_version_SnapshotVersion.MIN);\n    };\n    DeleteMutation.prototype.applyToLocalView = function (maybeDoc, baseDoc, localWriteTime) {\n        this.verifyKeyMatches(maybeDoc);\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        if (maybeDoc) {\n            assert(maybeDoc.key.isEqual(this.key), 'Can only apply mutation to document with same key');\n        }\n        return new document_NoDocument(this.key, snapshot_version_SnapshotVersion.forDeletedDoc());\n    };\n    DeleteMutation.prototype.isEqual = function (other) {\n        return (other instanceof DeleteMutation &&\n            this.key.isEqual(other.key) &&\n            this.precondition.isEqual(other.precondition));\n    };\n    return DeleteMutation;\n}(mutation_Mutation));\n\n\n//# sourceMappingURL=mutation.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/remote/existence_filter.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar ExistenceFilter = /** @class */ (function () {\n    // TODO(b/33078163): just use simplest form of existence filter for now\n    function ExistenceFilter(count) {\n        this.count = count;\n    }\n    ExistenceFilter.prototype.isEqual = function (other) {\n        return other && other.count === this.count;\n    };\n    return ExistenceFilter;\n}());\n\n\n//# sourceMappingURL=existence_filter.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/remote/rpc_error.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n * Error Codes describing the different ways GRPC can fail. These are copied\n * directly from GRPC's sources here:\n *\n * https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\n *\n * Important! The names of these identifiers matter because the string forms\n * are used for reverse lookups from the webchannel stream. Do NOT change the\n * names of these identifiers.\n */\nvar RpcCode;\n(function (RpcCode) {\n    RpcCode[RpcCode[\"OK\"] = 0] = \"OK\";\n    RpcCode[RpcCode[\"CANCELLED\"] = 1] = \"CANCELLED\";\n    RpcCode[RpcCode[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n    RpcCode[RpcCode[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\n    RpcCode[RpcCode[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\n    RpcCode[RpcCode[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\n    RpcCode[RpcCode[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\n    RpcCode[RpcCode[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\n    RpcCode[RpcCode[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\n    RpcCode[RpcCode[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\n    RpcCode[RpcCode[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\n    RpcCode[RpcCode[\"ABORTED\"] = 10] = \"ABORTED\";\n    RpcCode[RpcCode[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\n    RpcCode[RpcCode[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\n    RpcCode[RpcCode[\"INTERNAL\"] = 13] = \"INTERNAL\";\n    RpcCode[RpcCode[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\n    RpcCode[RpcCode[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\n})(RpcCode || (RpcCode = {}));\nfunction isPermanentError(code) {\n    switch (code) {\n        case Code.OK:\n            return fail('Treated status OK as error');\n        case Code.CANCELLED:\n        case Code.UNKNOWN:\n        case Code.DEADLINE_EXCEEDED:\n        case Code.RESOURCE_EXHAUSTED:\n        case Code.INTERNAL:\n        case Code.UNAVAILABLE:\n        // Unauthenticated means something went wrong with our token and we need\n        // to retry with new credentials which will happen automatically.\n        // TODO(b/37325376): Give up after second unauthenticated error.\n        case Code.UNAUTHENTICATED:\n            return false;\n        case Code.INVALID_ARGUMENT:\n        case Code.NOT_FOUND:\n        case Code.ALREADY_EXISTS:\n        case Code.PERMISSION_DENIED:\n        case Code.FAILED_PRECONDITION:\n        // Aborted might be retried in some scenarios, but that is dependant on\n        // the context and should handled individually by the calling code.\n        // See https://cloud.google.com/apis/design/errors.\n        case Code.ABORTED:\n        case Code.OUT_OF_RANGE:\n        case Code.UNIMPLEMENTED:\n        case Code.DATA_LOSS:\n            return true;\n        default:\n            return fail('Unknown status code: ' + code);\n    }\n}\n/**\n * Maps an error Code from a GRPC status identifier like 'NOT_FOUND'.\n *\n * @returns The Code equivalent to the given status string or undefined if\n *     there is no match.\n */\nfunction mapCodeFromRpcStatus(status) {\n    // tslint:disable-next-line:no-any lookup by string\n    var code = RpcCode[status];\n    if (code === undefined) {\n        return undefined;\n    }\n    return mapCodeFromRpcCode(code);\n}\n/**\n * Maps an error Code from GRPC status code number, like 0, 1, or 14. These\n * are not the same as HTTP status codes.\n *\n * @returns The Code equivalent to the given GRPC status code. Fails if there\n *     is no match.\n */\nfunction mapCodeFromRpcCode(code) {\n    if (code === undefined) {\n        // This shouldn't normally happen, but in certain error cases (like trying\n        // to send invalid proto messages) we may get an error with no GRPC code.\n        log_error('GRPC error has no .code');\n        return Code.UNKNOWN;\n    }\n    switch (code) {\n        case RpcCode.OK:\n            return Code.OK;\n        case RpcCode.CANCELLED:\n            return Code.CANCELLED;\n        case RpcCode.UNKNOWN:\n            return Code.UNKNOWN;\n        case RpcCode.DEADLINE_EXCEEDED:\n            return Code.DEADLINE_EXCEEDED;\n        case RpcCode.RESOURCE_EXHAUSTED:\n            return Code.RESOURCE_EXHAUSTED;\n        case RpcCode.INTERNAL:\n            return Code.INTERNAL;\n        case RpcCode.UNAVAILABLE:\n            return Code.UNAVAILABLE;\n        case RpcCode.UNAUTHENTICATED:\n            return Code.UNAUTHENTICATED;\n        case RpcCode.INVALID_ARGUMENT:\n            return Code.INVALID_ARGUMENT;\n        case RpcCode.NOT_FOUND:\n            return Code.NOT_FOUND;\n        case RpcCode.ALREADY_EXISTS:\n            return Code.ALREADY_EXISTS;\n        case RpcCode.PERMISSION_DENIED:\n            return Code.PERMISSION_DENIED;\n        case RpcCode.FAILED_PRECONDITION:\n            return Code.FAILED_PRECONDITION;\n        case RpcCode.ABORTED:\n            return Code.ABORTED;\n        case RpcCode.OUT_OF_RANGE:\n            return Code.OUT_OF_RANGE;\n        case RpcCode.UNIMPLEMENTED:\n            return Code.UNIMPLEMENTED;\n        case RpcCode.DATA_LOSS:\n            return Code.DATA_LOSS;\n        default:\n            return fail('Unknown status code: ' + code);\n    }\n}\n/**\n * Maps an RPC code from a Code. This is the reverse operation from\n * mapCodeFromRpcCode and should really only be used in tests.\n */\nfunction mapRpcCodeFromCode(code) {\n    if (code === undefined) {\n        return RpcCode.OK;\n    }\n    switch (code) {\n        case Code.OK:\n            return RpcCode.OK;\n        case Code.CANCELLED:\n            return RpcCode.CANCELLED;\n        case Code.UNKNOWN:\n            return RpcCode.UNKNOWN;\n        case Code.DEADLINE_EXCEEDED:\n            return RpcCode.DEADLINE_EXCEEDED;\n        case Code.RESOURCE_EXHAUSTED:\n            return RpcCode.RESOURCE_EXHAUSTED;\n        case Code.INTERNAL:\n            return RpcCode.INTERNAL;\n        case Code.UNAVAILABLE:\n            return RpcCode.UNAVAILABLE;\n        case Code.UNAUTHENTICATED:\n            return RpcCode.UNAUTHENTICATED;\n        case Code.INVALID_ARGUMENT:\n            return RpcCode.INVALID_ARGUMENT;\n        case Code.NOT_FOUND:\n            return RpcCode.NOT_FOUND;\n        case Code.ALREADY_EXISTS:\n            return RpcCode.ALREADY_EXISTS;\n        case Code.PERMISSION_DENIED:\n            return RpcCode.PERMISSION_DENIED;\n        case Code.FAILED_PRECONDITION:\n            return RpcCode.FAILED_PRECONDITION;\n        case Code.ABORTED:\n            return RpcCode.ABORTED;\n        case Code.OUT_OF_RANGE:\n            return RpcCode.OUT_OF_RANGE;\n        case Code.UNIMPLEMENTED:\n            return RpcCode.UNIMPLEMENTED;\n        case Code.DATA_LOSS:\n            return RpcCode.DATA_LOSS;\n        default:\n            return fail('Unknown status code: ' + code);\n    }\n}\n/**\n * Converts an HTTP Status Code to the equivalent error code.\n *\n * @param status An HTTP Status Code, like 200, 404, 503, etc.\n * @returns The equivalent Code. Unknown status codes are mapped to\n *     Code.UNKNOWN.\n */\nfunction mapCodeFromHttpStatus(status) {\n    // The canonical error codes for Google APIs [1] specify mapping onto HTTP\n    // status codes but the mapping is not bijective. In each case of ambiguity\n    // this function chooses a primary error.\n    //\n    // [1]\n    // https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto\n    switch (status) {\n        case 200:// OK\n            return Code.OK;\n        case 400:// Bad Request\n            return Code.INVALID_ARGUMENT;\n        // Other possibilities based on the forward mapping\n        // return Code.FAILED_PRECONDITION;\n        // return Code.OUT_OF_RANGE;\n        case 401:// Unauthorized\n            return Code.UNAUTHENTICATED;\n        case 403:// Forbidden\n            return Code.PERMISSION_DENIED;\n        case 404:// Not Found\n            return Code.NOT_FOUND;\n        case 409:// Conflict\n            return Code.ABORTED;\n        // Other possibilities:\n        // return Code.ALREADY_EXISTS;\n        case 416:// Range Not Satisfiable\n            return Code.OUT_OF_RANGE;\n        case 429:// Too Many Requests\n            return Code.RESOURCE_EXHAUSTED;\n        case 499:// Client Closed Request\n            return Code.CANCELLED;\n        case 500:// Internal Server Error\n            return Code.UNKNOWN;\n        // Other possibilities:\n        // return Code.INTERNAL;\n        // return Code.DATA_LOSS;\n        case 501:// Unimplemented\n            return Code.UNIMPLEMENTED;\n        case 503:// Service Unavailable\n            return Code.UNAVAILABLE;\n        case 504:// Gateway Timeout\n            return Code.DEADLINE_EXCEEDED;\n        default:\n            if (status >= 200 && status < 300)\n                return Code.OK;\n            if (status >= 400 && status < 500)\n                return Code.FAILED_PRECONDITION;\n            if (status >= 500 && status < 600)\n                return Code.INTERNAL;\n            return Code.UNKNOWN;\n    }\n}\n\n//# sourceMappingURL=rpc_error.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/sorted_set.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * SortedSet is an immutable (copy-on-write) collection that holds elements\n * in order specified by the provided comparator.\n *\n * NOTE: if provided comparator returns 0 for two elements, we consider them to\n * be equal!\n */\nvar sorted_set_SortedSet = /** @class */ (function () {\n    function SortedSet(comparator) {\n        this.comparator = comparator;\n        this.data = new SortedMap(this.comparator);\n    }\n    /**\n     * Creates a SortedSet from the keys of the map.\n     * This is currently implemented as an O(n) copy.\n     */\n    SortedSet.fromMapKeys = function (map) {\n        var keys = new SortedSet(map.comparator);\n        map.forEach(function (key) {\n            keys = keys.add(key);\n        });\n        return keys;\n    };\n    SortedSet.prototype.has = function (elem) {\n        return this.data.get(elem) !== null;\n    };\n    SortedSet.prototype.first = function () {\n        return this.data.minKey();\n    };\n    SortedSet.prototype.last = function () {\n        return this.data.maxKey();\n    };\n    Object.defineProperty(SortedSet.prototype, \"size\", {\n        get: function () {\n            return this.data.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SortedSet.prototype.indexOf = function (elem) {\n        return this.data.indexOf(elem);\n    };\n    /** Iterates elements in order defined by \"comparator\" */\n    SortedSet.prototype.forEach = function (cb) {\n        this.data.inorderTraversal(function (k, v) {\n            cb(k);\n            return false;\n        });\n    };\n    /** Iterates over `elem`s such that: range[0] <= elem < range[1]. */\n    SortedSet.prototype.forEachInRange = function (range, cb) {\n        var iter = this.data.getIteratorFrom(range[0]);\n        while (iter.hasNext()) {\n            var elem = iter.getNext();\n            if (this.comparator(elem.key, range[1]) >= 0)\n                return;\n            cb(elem.key);\n        }\n    };\n    /**\n     * Iterates over `elem`s such that: start <= elem until false is returned.\n     */\n    SortedSet.prototype.forEachWhile = function (cb, start) {\n        var iter;\n        if (start !== undefined) {\n            iter = this.data.getIteratorFrom(start);\n        }\n        else {\n            iter = this.data.getIterator();\n        }\n        while (iter.hasNext()) {\n            var elem = iter.getNext();\n            var result = cb(elem.key);\n            if (!result)\n                return;\n        }\n    };\n    /** Finds the least element greater than or equal to `elem`. */\n    SortedSet.prototype.firstAfterOrEqual = function (elem) {\n        var iter = this.data.getIteratorFrom(elem);\n        return iter.hasNext() ? iter.getNext().key : null;\n    };\n    /** Inserts or updates an element */\n    SortedSet.prototype.add = function (elem) {\n        return this.copy(this.data.remove(elem).insert(elem, true));\n    };\n    /** Deletes an element */\n    SortedSet.prototype.delete = function (elem) {\n        if (!this.has(elem))\n            return this;\n        return this.copy(this.data.remove(elem));\n    };\n    SortedSet.prototype.isEmpty = function () {\n        return this.data.isEmpty();\n    };\n    SortedSet.prototype.unionWith = function (other) {\n        var result = this;\n        other.forEach(function (elem) {\n            result = result.add(elem);\n        });\n        return result;\n    };\n    SortedSet.prototype.isEqual = function (other) {\n        if (!(other instanceof SortedSet))\n            return false;\n        if (this.size !== other.size)\n            return false;\n        var thisIt = this.data.getIterator();\n        var otherIt = other.data.getIterator();\n        while (thisIt.hasNext()) {\n            var thisElem = thisIt.getNext().key;\n            var otherElem = otherIt.getNext().key;\n            if (this.comparator(thisElem, otherElem) !== 0)\n                return false;\n        }\n        return true;\n    };\n    SortedSet.prototype.toString = function () {\n        var result = [];\n        this.forEach(function (elem) { return result.push(elem); });\n        return 'SortedSet(' + result.toString() + ')';\n    };\n    SortedSet.prototype.copy = function (data) {\n        var result = new SortedSet(this.comparator);\n        result.data = data;\n        return result;\n    };\n    return SortedSet;\n}());\n\n\n//# sourceMappingURL=sorted_set.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/model/collections.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\nvar EMPTY_MAYBE_DOCUMENT_MAP = new SortedMap(document_key_DocumentKey.comparator);\nfunction maybeDocumentMap() {\n    return EMPTY_MAYBE_DOCUMENT_MAP;\n}\nvar EMPTY_DOCUMENT_MAP = new SortedMap(document_key_DocumentKey.comparator);\nfunction documentMap() {\n    return EMPTY_DOCUMENT_MAP;\n}\nvar EMPTY_DOCUMENT_VERSION_MAP = new SortedMap(document_key_DocumentKey.comparator);\nfunction documentVersionMap() {\n    return EMPTY_DOCUMENT_VERSION_MAP;\n}\nvar EMPTY_DOCUMENT_KEY_SET = new sorted_set_SortedSet(document_key_DocumentKey.comparator);\nfunction documentKeySet() {\n    return EMPTY_DOCUMENT_KEY_SET;\n}\n\n//# sourceMappingURL=collections.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/remote/remote_event.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n * An event from the RemoteStore. It is split into targetChanges (changes to the\n * state or the set of documents in our watched targets) and documentUpdates\n * (changes to the actual documents).\n */\nvar remote_event_RemoteEvent = /** @class */ (function () {\n    function RemoteEvent(\n    /**\n     * The snapshot version this event brings us up to, or MIN if not set.\n     */\n    snapshotVersion, \n    /**\n     * A map from target to changes to the target. See TargetChange.\n     */\n    targetChanges, \n    /**\n     * A set of which documents have changed or been deleted, along with the\n     * doc's new values (if not deleted).\n     */\n    documentUpdates) {\n        this.snapshotVersion = snapshotVersion;\n        this.targetChanges = targetChanges;\n        this.documentUpdates = documentUpdates;\n    }\n    RemoteEvent.prototype.addDocumentUpdate = function (doc) {\n        this.documentUpdates = this.documentUpdates.insert(doc.key, doc);\n    };\n    RemoteEvent.prototype.handleExistenceFilterMismatch = function (targetId) {\n        /*\n         * An existence filter mismatch will reset the query and we need to reset\n         * the mapping to contain no documents and an empty resume token.\n         *\n         * Note:\n         *   * The reset mapping is empty, specifically forcing the consumer of the\n         *     change to forget all keys for this targetID;\n         *   * The resume snapshot for this target must be reset\n         *   * The target must be unacked because unwatching and rewatching\n         *     introduces a race for changes.\n         */\n        this.targetChanges[targetId] = {\n            mapping: new ResetMapping(),\n            snapshotVersion: snapshot_version_SnapshotVersion.MIN,\n            currentStatusUpdate: CurrentStatusUpdate.MarkNotCurrent,\n            resumeToken: emptyByteString()\n        };\n    };\n    return RemoteEvent;\n}());\n\n/**\n * Represents an update to the current status of a target, either explicitly\n * having no new state, or the new value to set. Note \"current\" has special\n * meaning for in the RPC protocol that implies that a target is both up-to-date\n * and consistent with the rest of the watch stream.\n */\nvar CurrentStatusUpdate;\n(function (CurrentStatusUpdate) {\n    /** The current status is not affected and should not be modified. */\n    CurrentStatusUpdate[CurrentStatusUpdate[\"None\"] = 0] = \"None\";\n    /** The target must be marked as no longer \"current\". */\n    CurrentStatusUpdate[CurrentStatusUpdate[\"MarkNotCurrent\"] = 1] = \"MarkNotCurrent\";\n    /** The target must be marked as \"current\". */\n    CurrentStatusUpdate[CurrentStatusUpdate[\"MarkCurrent\"] = 2] = \"MarkCurrent\";\n})(CurrentStatusUpdate || (CurrentStatusUpdate = {}));\nvar EMPTY_KEY_SET = documentKeySet();\nvar ResetMapping = /** @class */ (function () {\n    function ResetMapping() {\n        this.docs = EMPTY_KEY_SET;\n    }\n    Object.defineProperty(ResetMapping.prototype, \"documents\", {\n        get: function () {\n            return this.docs;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ResetMapping.prototype.add = function (key) {\n        this.docs = this.docs.add(key);\n    };\n    ResetMapping.prototype.delete = function (key) {\n        this.docs = this.docs.delete(key);\n    };\n    ResetMapping.prototype.isEqual = function (other) {\n        return other !== null && this.docs.isEqual(other.docs);\n    };\n    return ResetMapping;\n}());\n\nvar UpdateMapping = /** @class */ (function () {\n    function UpdateMapping() {\n        this.addedDocuments = EMPTY_KEY_SET;\n        this.removedDocuments = EMPTY_KEY_SET;\n    }\n    UpdateMapping.prototype.applyToKeySet = function (keys) {\n        var result = keys;\n        this.addedDocuments.forEach(function (key) { return (result = result.add(key)); });\n        this.removedDocuments.forEach(function (key) { return (result = result.delete(key)); });\n        return result;\n    };\n    UpdateMapping.prototype.add = function (key) {\n        this.addedDocuments = this.addedDocuments.add(key);\n        this.removedDocuments = this.removedDocuments.delete(key);\n    };\n    UpdateMapping.prototype.delete = function (key) {\n        this.addedDocuments = this.addedDocuments.delete(key);\n        this.removedDocuments = this.removedDocuments.add(key);\n    };\n    UpdateMapping.prototype.isEqual = function (other) {\n        return (other !== null &&\n            this.addedDocuments.isEqual(other.addedDocuments) &&\n            this.removedDocuments.isEqual(other.removedDocuments));\n    };\n    return UpdateMapping;\n}());\n\n\n//# sourceMappingURL=remote_event.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/remote/watch_change.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n/**\n * Represents a changed document and a list of target ids to which this change\n * applies.\n *\n * If document has been deleted NoDocument will be provided.\n */\nvar DocumentWatchChange = /** @class */ (function () {\n    function DocumentWatchChange(\n    /** The new document applies to all of these targets. */\n    updatedTargetIds, \n    /** The new document is removed from all of these targets. */\n    removedTargetIds, \n    /** The key of the document for this change. */\n    key, \n    /**\n     * The new document or NoDocument if it was deleted. Is null if the\n     * document went out of view without the server sending a new document.\n     */\n    newDoc) {\n        this.updatedTargetIds = updatedTargetIds;\n        this.removedTargetIds = removedTargetIds;\n        this.key = key;\n        this.newDoc = newDoc;\n    }\n    return DocumentWatchChange;\n}());\n\nvar ExistenceFilterChange = /** @class */ (function () {\n    function ExistenceFilterChange(targetId, existenceFilter) {\n        this.targetId = targetId;\n        this.existenceFilter = existenceFilter;\n    }\n    return ExistenceFilterChange;\n}());\n\nvar WatchTargetChangeState;\n(function (WatchTargetChangeState) {\n    WatchTargetChangeState[WatchTargetChangeState[\"NoChange\"] = 0] = \"NoChange\";\n    WatchTargetChangeState[WatchTargetChangeState[\"Added\"] = 1] = \"Added\";\n    WatchTargetChangeState[WatchTargetChangeState[\"Removed\"] = 2] = \"Removed\";\n    WatchTargetChangeState[WatchTargetChangeState[\"Current\"] = 3] = \"Current\";\n    WatchTargetChangeState[WatchTargetChangeState[\"Reset\"] = 4] = \"Reset\";\n})(WatchTargetChangeState || (WatchTargetChangeState = {}));\nvar watch_change_WatchTargetChange = /** @class */ (function () {\n    function WatchTargetChange(\n    /** What kind of change occurred to the watch target. */\n    state, \n    /** The target IDs that were added/removed/set. */\n    targetIds, \n    /**\n     * An opaque, server-assigned token that allows watching a query to be\n     * resumed after disconnecting without retransmitting all the data that\n     * matches the query. The resume token essentially identifies a point in\n     * time from which the server should resume sending results.\n     */\n    resumeToken, \n    /** An RPC error indicating why the watch failed. */\n    cause) {\n        if (resumeToken === void 0) { resumeToken = emptyByteString(); }\n        if (cause === void 0) { cause = null; }\n        this.state = state;\n        this.targetIds = targetIds;\n        this.resumeToken = resumeToken;\n        this.cause = cause;\n    }\n    return WatchTargetChange;\n}());\n\n/**\n * A helper class to accumulate watch changes into a RemoteEvent and other\n * target information.\n */\nvar watch_change_WatchChangeAggregator = /** @class */ (function () {\n    function WatchChangeAggregator(snapshotVersion, listenTargets, pendingTargetResponses) {\n        this.snapshotVersion = snapshotVersion;\n        this.listenTargets = listenTargets;\n        /** The existence filter - if any - for the given target IDs. */\n        this.existenceFilters = {};\n        /** Keeps track of the current target mappings */\n        this.targetChanges = {};\n        /** Keeps track of document to update */\n        this.documentUpdates = maybeDocumentMap();\n        /** Whether this aggregator was frozen and can no longer be modified */\n        this.frozen = false;\n        this.pendingTargetResponses = shallowCopy(pendingTargetResponses);\n    }\n    /** Aggregates a watch change into the current state */\n    WatchChangeAggregator.prototype.add = function (watchChange) {\n        assert(!this.frozen, 'Trying to modify frozen WatchChangeAggregator.');\n        if (watchChange instanceof DocumentWatchChange) {\n            this.addDocumentChange(watchChange);\n        }\n        else if (watchChange instanceof watch_change_WatchTargetChange) {\n            this.addTargetChange(watchChange);\n        }\n        else if (watchChange instanceof ExistenceFilterChange) {\n            this.addExistenceFilterChange(watchChange);\n        }\n        else {\n            fail('Unknown watch change: ' + watchChange);\n        }\n    };\n    /** Aggregates all provided watch changes to the current state in order */\n    WatchChangeAggregator.prototype.addChanges = function (watchChanges) {\n        var _this = this;\n        assert(!this.frozen, 'Trying to modify frozen WatchChangeAggregator.');\n        watchChanges.forEach(function (change) { return _this.add(change); });\n    };\n    /**\n     * Converts the current state into a remote event with the snapshot version\n     * provided via the constructor.\n     */\n    WatchChangeAggregator.prototype.createRemoteEvent = function () {\n        var _this = this;\n        var targetChanges = this.targetChanges;\n        // Remove all the non-active targets from the remote event.\n        forEachNumber(this.targetChanges, function (targetId) {\n            if (!_this.isActiveTarget(targetId)) {\n                delete targetChanges[targetId];\n            }\n        });\n        // Mark this aggregator as frozen so no further modifications are made\n        this.frozen = true;\n        return new remote_event_RemoteEvent(this.snapshotVersion, targetChanges, this.documentUpdates);\n    };\n    WatchChangeAggregator.prototype.ensureTargetChange = function (targetId) {\n        var change = this.targetChanges[targetId];\n        if (!change) {\n            // Create an UpdateMapping by default, since resets are always explicit.\n            change = {\n                currentStatusUpdate: CurrentStatusUpdate.None,\n                snapshotVersion: this.snapshotVersion,\n                mapping: new UpdateMapping(),\n                resumeToken: emptyByteString()\n            };\n            this.targetChanges[targetId] = change;\n        }\n        return change;\n    };\n    /**\n     * We need to wait for watch to ack targets before we process those events,\n     * so to know if a target is active, there must be no pending acks we're\n     * waiting for and it must be in the current list of targets that the client\n     * cares about.\n     *\n     * This method is visible for testing.\n     */\n    WatchChangeAggregator.prototype.isActiveTarget = function (targetId) {\n        return (!contains(this.pendingTargetResponses, targetId) &&\n            contains(this.listenTargets, targetId));\n    };\n    WatchChangeAggregator.prototype.addDocumentChange = function (docChange) {\n        var relevant = false;\n        for (var _i = 0, _a = docChange.updatedTargetIds; _i < _a.length; _i++) {\n            var targetId = _a[_i];\n            if (this.isActiveTarget(targetId)) {\n                var change = this.ensureTargetChange(targetId);\n                change.mapping.add(docChange.key);\n                relevant = true;\n            }\n        }\n        for (var _b = 0, _c = docChange.removedTargetIds; _b < _c.length; _b++) {\n            var targetId = _c[_b];\n            if (this.isActiveTarget(targetId)) {\n                var change = this.ensureTargetChange(targetId);\n                change.mapping.delete(docChange.key);\n                relevant = true;\n            }\n        }\n        // Only update the document if there is a new document to replace to an\n        // active target that is being listened to, this might be just a target\n        // update instead.\n        if (docChange.newDoc && relevant) {\n            this.documentUpdates = this.documentUpdates.insert(docChange.key, docChange.newDoc);\n        }\n    };\n    WatchChangeAggregator.prototype.addTargetChange = function (targetChange) {\n        var _this = this;\n        targetChange.targetIds.forEach(function (targetId) {\n            var change = _this.ensureTargetChange(targetId);\n            switch (targetChange.state) {\n                case WatchTargetChangeState.NoChange:\n                    if (_this.isActiveTarget(targetId)) {\n                        // Creating the change above satisfies the semantics of no-change.\n                        applyResumeToken(change, targetChange.resumeToken);\n                    }\n                    break;\n                case WatchTargetChangeState.Added:\n                    // We need to decrement the number of pending acks needed from watch\n                    // for this targetId.\n                    _this.recordTargetResponse(targetId);\n                    if (!contains(_this.pendingTargetResponses, targetId)) {\n                        // We have a freshly added target, so we need to reset any state\n                        // that we had previously This can happen e.g. when remove and add\n                        // back a target for existence filter mismatches.\n                        change.mapping = new UpdateMapping();\n                        change.currentStatusUpdate = CurrentStatusUpdate.None;\n                        delete _this.existenceFilters[targetId];\n                    }\n                    applyResumeToken(change, targetChange.resumeToken);\n                    break;\n                case WatchTargetChangeState.Removed:\n                    // We need to keep track of removed targets to we can\n                    // post-filter and remove any target changes.\n                    // We need to decrement the number of pending acks needed from watch\n                    // for this targetId.\n                    _this.recordTargetResponse(targetId);\n                    assert(!targetChange.cause, 'WatchChangeAggregator does not handle errored targets');\n                    break;\n                case WatchTargetChangeState.Current:\n                    if (_this.isActiveTarget(targetId)) {\n                        change.currentStatusUpdate = CurrentStatusUpdate.MarkCurrent;\n                        applyResumeToken(change, targetChange.resumeToken);\n                    }\n                    break;\n                case WatchTargetChangeState.Reset:\n                    if (_this.isActiveTarget(targetId)) {\n                        // Overwrite any existing target mapping with a reset\n                        // mapping. Every subsequent update will modify the reset\n                        // mapping, not an update mapping.\n                        change.mapping = new ResetMapping();\n                        applyResumeToken(change, targetChange.resumeToken);\n                    }\n                    break;\n                default:\n                    fail('Unknown target watch change state: ' + targetChange.state);\n            }\n        });\n    };\n    /**\n     * Record that we get a watch target add/remove by decrementing the number of\n     * pending target responses that we have.\n     */\n    WatchChangeAggregator.prototype.recordTargetResponse = function (targetId) {\n        var newCount = (this.pendingTargetResponses[targetId] || 0) - 1;\n        if (newCount === 0) {\n            delete this.pendingTargetResponses[targetId];\n        }\n        else {\n            this.pendingTargetResponses[targetId] = newCount;\n        }\n    };\n    WatchChangeAggregator.prototype.addExistenceFilterChange = function (change) {\n        if (this.isActiveTarget(change.targetId)) {\n            this.existenceFilters[change.targetId] = change.existenceFilter;\n        }\n    };\n    return WatchChangeAggregator;\n}());\n\n/**\n * Applies the resume token to the TargetChange, but only when it has a new\n * value. null and empty resumeTokens are discarded.\n */\nfunction applyResumeToken(change, resumeToken) {\n    if (resumeToken.length > 0) {\n        change.resumeToken = resumeToken;\n    }\n}\n\n//# sourceMappingURL=watch_change.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/remote/serializer.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar DIRECTIONS = (function () {\n    var dirs = {};\n    dirs[Direction.ASCENDING.name] = 'ASCENDING';\n    dirs[Direction.DESCENDING.name] = 'DESCENDING';\n    return dirs;\n})();\nvar OPERATORS = (function () {\n    var ops = {};\n    ops[query_RelationOp.LESS_THAN.name] = 'LESS_THAN';\n    ops[query_RelationOp.LESS_THAN_OR_EQUAL.name] = 'LESS_THAN_OR_EQUAL';\n    ops[query_RelationOp.GREATER_THAN.name] = 'GREATER_THAN';\n    ops[query_RelationOp.GREATER_THAN_OR_EQUAL.name] = 'GREATER_THAN_OR_EQUAL';\n    ops[query_RelationOp.EQUAL.name] = 'EQUAL';\n    return ops;\n})();\nfunction assertPresent(value, description) {\n    assert(!isNullOrUndefined(value), description + ' is missing');\n}\nfunction parseInt64(value) {\n    // TODO(bjornick): Handle int64 greater than 53 bits.\n    if (typeof value === 'number') {\n        return value;\n    }\n    else if (typeof value === 'string') {\n        return Number(value);\n    }\n    else {\n        return fail(\"can't parse \" + value);\n    }\n}\n/**\n * Generates JsonObject values for the Datastore API suitable for sending to\n * either GRPC stub methods or via the JSON/HTTP REST API.\n * TODO(klimt): We can remove the databaseId argument if we keep the full\n * resource name in documents.\n */\nvar serializer_JsonProtoSerializer = /** @class */ (function () {\n    function JsonProtoSerializer(databaseId, options) {\n        this.databaseId = databaseId;\n        this.options = options;\n    }\n    JsonProtoSerializer.prototype.emptyByteString = function () {\n        if (this.options.useProto3Json) {\n            return '';\n        }\n        else {\n            return new Uint8Array(0);\n        }\n    };\n    JsonProtoSerializer.prototype.unsafeCastProtoByteString = function (byteString) {\n        // byteStrings can be either string or UInt8Array, but the typings say\n        // it's always a string. Cast as string to avoid type check failing\n        return byteString;\n    };\n    JsonProtoSerializer.prototype.fromRpcStatus = function (status) {\n        var code = status.code === undefined\n            ? Code.UNKNOWN\n            : mapCodeFromRpcCode(status.code);\n        return new error_FirestoreError(code, status.message || '');\n    };\n    /**\n     * Returns a value for a number (or undefined) that's appropriate to put into\n     * a google.protobuf.Int32Value proto.\n     * DO NOT USE THIS FOR ANYTHING ELSE.\n     * This method cheats. It's typed as returning \"number\" because that's what\n     * our generated proto interfaces say Int32Value must be. But GRPC actually\n     * expects a { value: <number> } struct.\n     */\n    JsonProtoSerializer.prototype.toInt32Value = function (val) {\n        if (!isNullOrUndefined(val)) {\n            // tslint:disable-next-line:no-any We need to match generated Proto types.\n            return { value: val };\n        }\n        else {\n            return undefined;\n        }\n    };\n    /**\n     * Returns a number (or null) from a google.protobuf.Int32Value proto.\n     * DO NOT USE THIS FOR ANYTHING ELSE.\n     * This method cheats. It's typed as accepting \"number\" because that's what\n     * our generated proto interfaces say Int32Value must be, but it actually\n     * accepts { value: number } to match our serialization in toInt32Value().\n     */\n    JsonProtoSerializer.prototype.fromInt32Value = function (val) {\n        var result;\n        if (typeof val === 'object') {\n            // tslint:disable-next-line:no-any We need to match generated Proto types.\n            result = val.value;\n        }\n        else {\n            // We accept raw numbers (without the {value: ... } wrapper) for\n            // compatibility with legacy persisted data.\n            result = val;\n        }\n        return isNullOrUndefined(result) ? null : result;\n    };\n    /**\n     * Returns a value for a Date that's appropriate to put into a proto.\n     * DO NOT USE THIS FOR ANYTHING ELSE.\n     * This method cheats. It's typed as returning \"string\" because that's what\n     * our generated proto interfaces say dates must be. But it's easier and safer\n     * to actually return a Timestamp proto.\n     */\n    JsonProtoSerializer.prototype.toTimestamp = function (timestamp) {\n        return {\n            seconds: timestamp.seconds,\n            nanos: timestamp.nanos\n            // tslint:disable-next-line:no-any\n        };\n    };\n    JsonProtoSerializer.prototype.fromTimestamp = function (date) {\n        // The json interface (for the browser) will return an iso timestamp string,\n        // while the proto js library (for node) will return a\n        // google.protobuf.Timestamp instance.\n        if (typeof date === 'string') {\n            // TODO(b/37282237): Use strings for Proto3 timestamps\n            // assert(this.options.useProto3Json,\n            //   'The timestamp string format requires Proto3.');\n            return timestamp_Timestamp.fromISOString(date);\n        }\n        else {\n            assert(!!date, 'Cannot deserialize null or undefined timestamp.');\n            // TODO(b/37282237): Use strings for Proto3 timestamps\n            // assert(!this.options.useProto3Json,\n            //   'The timestamp instance format requires Proto JS.');\n            var seconds = parseInt64(date.seconds || '0');\n            var nanos = date.nanos || 0;\n            return new timestamp_Timestamp(seconds, nanos);\n        }\n    };\n    /**\n     * Returns a value for bytes that's appropriate to put in a proto.\n     * DO NOT USE THIS FOR ANYTHING ELSE.\n     * This method cheats. It's typed as returning \"string\" because that's what\n     * our generated proto interfaces say bytes must be. But it should return\n     * an Uint8Array in Node.\n     */\n    JsonProtoSerializer.prototype.toBytes = function (bytes) {\n        if (this.options.useProto3Json) {\n            return bytes.toBase64();\n        }\n        else {\n            // The typings say it's a string, but it needs to be a Uint8Array in Node.\n            return this.unsafeCastProtoByteString(bytes.toUint8Array());\n        }\n    };\n    /**\n     * Parse the blob from the protos into the internal Blob class. Note that the\n     * typings assume all blobs are strings, but they are actually Uint8Arrays\n     * on Node.\n     */\n    JsonProtoSerializer.prototype.fromBlob = function (blob) {\n        if (typeof blob === 'string') {\n            assert(this.options.useProto3Json, 'Expected bytes to be passed in as Uint8Array, but got a string instead.');\n            return blob_Blob.fromBase64String(blob);\n        }\n        else {\n            assert(!this.options.useProto3Json, 'Expected bytes to be passed in as string, but got something else instead.');\n            return blob_Blob.fromUint8Array(blob);\n        }\n    };\n    JsonProtoSerializer.prototype.toVersion = function (version) {\n        return this.toTimestamp(version.toTimestamp());\n    };\n    JsonProtoSerializer.prototype.fromVersion = function (version) {\n        assert(!!version, \"Trying to deserialize version that isn't set\");\n        return snapshot_version_SnapshotVersion.fromTimestamp(this.fromTimestamp(version));\n    };\n    JsonProtoSerializer.prototype.toResourceName = function (databaseId, path) {\n        return this.fullyQualifiedPrefixPath(databaseId)\n            .child('documents')\n            .child(path)\n            .canonicalString();\n    };\n    JsonProtoSerializer.prototype.fromResourceName = function (name) {\n        var resource = path_ResourcePath.fromString(name);\n        assert(this.isValidResourceName(resource), 'Tried to deserialize invalid key ' + resource.toString());\n        return resource;\n    };\n    JsonProtoSerializer.prototype.toName = function (key) {\n        return this.toResourceName(this.databaseId, key.path);\n    };\n    JsonProtoSerializer.prototype.fromName = function (name) {\n        var resource = this.fromResourceName(name);\n        assert(resource.get(1) === this.databaseId.projectId, 'Tried to deserialize key from different project: ' +\n            resource.get(1) +\n            ' vs ' +\n            this.databaseId.projectId);\n        assert((!resource.get(3) && !this.databaseId.database) ||\n            resource.get(3) === this.databaseId.database, 'Tried to deserialize key from different database: ' +\n            resource.get(3) +\n            ' vs ' +\n            this.databaseId.database);\n        return new document_key_DocumentKey(this.extractLocalPathFromResourceName(resource));\n    };\n    JsonProtoSerializer.prototype.toQueryPath = function (path) {\n        if (path.length === 0) {\n            // If the path is empty, the backend requires we leave off the /documents\n            // at the end.\n            return this.encodedDatabaseId;\n        }\n        return this.toResourceName(this.databaseId, path);\n    };\n    JsonProtoSerializer.prototype.fromQueryPath = function (name) {\n        var resourceName = this.fromResourceName(name);\n        if (resourceName.length === 4) {\n            return path_ResourcePath.EMPTY_PATH;\n        }\n        return this.extractLocalPathFromResourceName(resourceName);\n    };\n    Object.defineProperty(JsonProtoSerializer.prototype, \"encodedDatabaseId\", {\n        get: function () {\n            var path = new path_ResourcePath([\n                'projects',\n                this.databaseId.projectId,\n                'databases',\n                this.databaseId.database\n            ]);\n            return path.canonicalString();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    JsonProtoSerializer.prototype.fullyQualifiedPrefixPath = function (databaseId) {\n        return new path_ResourcePath([\n            'projects',\n            databaseId.projectId,\n            'databases',\n            databaseId.database\n        ]);\n    };\n    JsonProtoSerializer.prototype.extractLocalPathFromResourceName = function (resourceName) {\n        assert(resourceName.length > 4 && resourceName.get(4) === 'documents', 'tried to deserialize invalid key ' + resourceName.toString());\n        return resourceName.popFirst(5);\n    };\n    JsonProtoSerializer.prototype.isValidResourceName = function (path) {\n        // Resource names have at least 4 components (project ID, database ID)\n        return (path.length >= 4 &&\n            path.get(0) === 'projects' &&\n            path.get(2) === 'databases');\n    };\n    JsonProtoSerializer.prototype.toValue = function (val) {\n        if (val instanceof field_value_NullValue) {\n            return { nullValue: 'NULL_VALUE' };\n        }\n        else if (val instanceof field_value_BooleanValue) {\n            return { booleanValue: val.value() };\n        }\n        else if (val instanceof field_value_IntegerValue) {\n            return { integerValue: '' + val.value() };\n        }\n        else if (val instanceof field_value_DoubleValue) {\n            var doubleValue = val.value();\n            if (this.options.useProto3Json) {\n                // Proto 3 let's us encode NaN and Infinity as string values as\n                // expected by the backend. This is currently not checked by our unit\n                // tests because they rely on protobuf.js.\n                if (isNaN(doubleValue)) {\n                    return { doubleValue: 'NaN' };\n                }\n                else if (doubleValue === Infinity) {\n                    return { doubleValue: 'Infinity' };\n                }\n                else if (doubleValue === -Infinity) {\n                    return { doubleValue: '-Infinity' };\n                }\n            }\n            return { doubleValue: val.value() };\n        }\n        else if (val instanceof field_value_StringValue) {\n            return { stringValue: val.value() };\n        }\n        else if (val instanceof field_value_ObjectValue) {\n            return { mapValue: this.toMapValue(val) };\n        }\n        else if (val instanceof field_value_ArrayValue) {\n            return { arrayValue: this.toArrayValue(val) };\n        }\n        else if (val instanceof field_value_TimestampValue) {\n            return {\n                timestampValue: this.toTimestamp(val.internalValue)\n            };\n        }\n        else if (val instanceof field_value_GeoPointValue) {\n            return {\n                geoPointValue: {\n                    latitude: val.value().latitude,\n                    longitude: val.value().longitude\n                }\n            };\n        }\n        else if (val instanceof field_value_BlobValue) {\n            return {\n                bytesValue: this.toBytes(val.value())\n            };\n        }\n        else if (val instanceof field_value_RefValue) {\n            return {\n                referenceValue: this.toResourceName(val.databaseId, val.key.path)\n            };\n        }\n        else {\n            return fail('Unknown FieldValue ' + JSON.stringify(val));\n        }\n    };\n    JsonProtoSerializer.prototype.fromValue = function (obj) {\n        var _this = this;\n        // tslint:disable-next-line:no-any\n        var type = obj['value_type'];\n        if (hasTag(obj, type, 'nullValue')) {\n            return field_value_NullValue.INSTANCE;\n        }\n        else if (hasTag(obj, type, 'booleanValue')) {\n            return field_value_BooleanValue.of(obj.booleanValue);\n        }\n        else if (hasTag(obj, type, 'integerValue')) {\n            return new field_value_IntegerValue(parseInt64(obj.integerValue));\n        }\n        else if (hasTag(obj, type, 'doubleValue')) {\n            if (this.options.useProto3Json) {\n                // Proto 3 uses the string values 'NaN' and 'Infinity'.\n                if (obj.doubleValue === 'NaN') {\n                    return field_value_DoubleValue.NAN;\n                }\n                else if (obj.doubleValue === 'Infinity') {\n                    return field_value_DoubleValue.POSITIVE_INFINITY;\n                }\n                else if (obj.doubleValue === '-Infinity') {\n                    return field_value_DoubleValue.NEGATIVE_INFINITY;\n                }\n            }\n            return new field_value_DoubleValue(obj.doubleValue);\n        }\n        else if (hasTag(obj, type, 'stringValue')) {\n            return new field_value_StringValue(obj.stringValue);\n        }\n        else if (hasTag(obj, type, 'mapValue')) {\n            return this.fromFields(obj.mapValue.fields || {});\n        }\n        else if (hasTag(obj, type, 'arrayValue')) {\n            // \"values\" is not present if the array is empty\n            assertPresent(obj.arrayValue, 'arrayValue');\n            var values = obj.arrayValue.values || [];\n            return new field_value_ArrayValue(values.map(function (v) { return _this.fromValue(v); }));\n        }\n        else if (hasTag(obj, type, 'timestampValue')) {\n            assertPresent(obj.timestampValue, 'timestampValue');\n            return new field_value_TimestampValue(this.fromTimestamp(obj.timestampValue));\n        }\n        else if (hasTag(obj, type, 'geoPointValue')) {\n            assertPresent(obj.geoPointValue, 'geoPointValue');\n            var latitude = obj.geoPointValue.latitude || 0;\n            var longitude = obj.geoPointValue.longitude || 0;\n            return new field_value_GeoPointValue(new geo_point_GeoPoint(latitude, longitude));\n        }\n        else if (hasTag(obj, type, 'bytesValue')) {\n            assertPresent(obj.bytesValue, 'bytesValue');\n            var blob = this.fromBlob(obj.bytesValue);\n            return new field_value_BlobValue(blob);\n        }\n        else if (hasTag(obj, type, 'referenceValue')) {\n            assertPresent(obj.referenceValue, 'referenceValue');\n            var resourceName = this.fromResourceName(obj.referenceValue);\n            var dbId = new database_info_DatabaseId(resourceName.get(1), resourceName.get(3));\n            var key = new document_key_DocumentKey(this.extractLocalPathFromResourceName(resourceName));\n            return new field_value_RefValue(dbId, key);\n        }\n        else {\n            return fail('Unknown Value proto ' + JSON.stringify(obj));\n        }\n    };\n    /** Creates an api.Document from key and fields (but no create/update time) */\n    JsonProtoSerializer.prototype.toMutationDocument = function (key, fields) {\n        return {\n            name: this.toName(key),\n            fields: this.toFields(fields)\n        };\n    };\n    JsonProtoSerializer.prototype.toDocument = function (document) {\n        assert(!document.hasLocalMutations, \"Can't serialize documents with mutations.\");\n        return {\n            name: this.toName(document.key),\n            fields: this.toFields(document.data),\n            updateTime: this.toTimestamp(document.version.toTimestamp())\n        };\n    };\n    JsonProtoSerializer.prototype.fromDocument = function (document) {\n        return new document_Document(this.fromName(document.name), this.fromVersion(document.updateTime), this.fromFields(document.fields || {}), { hasLocalMutations: false });\n    };\n    JsonProtoSerializer.prototype.toFields = function (fields) {\n        var _this = this;\n        var result = {};\n        fields.forEach(function (key, value) {\n            result[key] = _this.toValue(value);\n        });\n        return result;\n    };\n    JsonProtoSerializer.prototype.fromFields = function (object) {\n        var _this = this;\n        // Proto map<string, Value> gets mapped to Object, so cast it.\n        var map = object;\n        var result = field_value_ObjectValue.EMPTY;\n        forEach(map, function (key, value) {\n            result = result.set(new path_FieldPath([key]), _this.fromValue(value));\n        });\n        return result;\n    };\n    JsonProtoSerializer.prototype.toMapValue = function (map) {\n        return {\n            fields: this.toFields(map)\n        };\n    };\n    JsonProtoSerializer.prototype.toArrayValue = function (array) {\n        var _this = this;\n        var result = [];\n        array.forEach(function (value) {\n            result.push(_this.toValue(value));\n        });\n        return { values: result };\n    };\n    JsonProtoSerializer.prototype.fromFound = function (doc) {\n        assert(!!doc.found, 'Tried to deserialize a found document from a missing document.');\n        assertPresent(doc.found.name, 'doc.found.name');\n        assertPresent(doc.found.updateTime, 'doc.found.updateTime');\n        var key = this.fromName(doc.found.name);\n        var version = this.fromVersion(doc.found.updateTime);\n        var fields = this.fromFields(doc.found.fields || {});\n        return new document_Document(key, version, fields, { hasLocalMutations: false });\n    };\n    JsonProtoSerializer.prototype.fromMissing = function (result) {\n        assert(!!result.missing, 'Tried to deserialize a missing document from a found document.');\n        assert(!!result.readTime, 'Tried to deserialize a missing document without a read time.');\n        var key = this.fromName(result.missing);\n        var version = this.fromVersion(result.readTime);\n        return new document_NoDocument(key, version);\n    };\n    JsonProtoSerializer.prototype.fromMaybeDocument = function (result) {\n        // tslint:disable-next-line:no-any\n        var type = result['result'];\n        if (hasTag(result, type, 'found')) {\n            return this.fromFound(result);\n        }\n        else if (hasTag(result, type, 'missing')) {\n            return this.fromMissing(result);\n        }\n        return fail('invalid batch get response: ' + JSON.stringify(result));\n    };\n    JsonProtoSerializer.prototype.toWatchTargetChangeState = function (state) {\n        switch (state) {\n            case WatchTargetChangeState.Added:\n                return 'ADD';\n            case WatchTargetChangeState.Current:\n                return 'CURRENT';\n            case WatchTargetChangeState.NoChange:\n                return 'NO_CHANGE';\n            case WatchTargetChangeState.Removed:\n                return 'REMOVE';\n            case WatchTargetChangeState.Reset:\n                return 'RESET';\n            default:\n                return fail('Unknown WatchTargetChangeState: ' + state);\n        }\n    };\n    JsonProtoSerializer.prototype.toTestWatchChange = function (watchChange) {\n        if (watchChange instanceof ExistenceFilterChange) {\n            return {\n                filter: {\n                    count: watchChange.existenceFilter.count,\n                    targetId: watchChange.targetId\n                }\n            };\n        }\n        if (watchChange instanceof DocumentWatchChange) {\n            if (watchChange.newDoc instanceof document_Document) {\n                var doc = watchChange.newDoc;\n                return {\n                    documentChange: {\n                        document: {\n                            name: this.toName(doc.key),\n                            fields: this.toFields(doc.data),\n                            updateTime: this.toVersion(doc.version)\n                        },\n                        targetIds: watchChange.updatedTargetIds,\n                        removedTargetIds: watchChange.removedTargetIds\n                    }\n                };\n            }\n            else if (watchChange.newDoc instanceof document_NoDocument) {\n                var doc = watchChange.newDoc;\n                return {\n                    documentDelete: {\n                        document: this.toName(doc.key),\n                        readTime: this.toVersion(doc.version),\n                        removedTargetIds: watchChange.removedTargetIds\n                    }\n                };\n            }\n            else if (watchChange.newDoc === null) {\n                return {\n                    documentRemove: {\n                        document: this.toName(watchChange.key),\n                        removedTargetIds: watchChange.removedTargetIds\n                    }\n                };\n            }\n        }\n        if (watchChange instanceof watch_change_WatchTargetChange) {\n            var cause = undefined;\n            if (watchChange.cause) {\n                cause = {\n                    code: mapRpcCodeFromCode(watchChange.cause.code),\n                    message: watchChange.cause.message\n                };\n            }\n            return {\n                targetChange: {\n                    targetChangeType: this.toWatchTargetChangeState(watchChange.state),\n                    targetIds: watchChange.targetIds,\n                    resumeToken: this.unsafeCastProtoByteString(watchChange.resumeToken),\n                    cause: cause\n                }\n            };\n        }\n        return fail('Unrecognized watch change: ' + JSON.stringify(watchChange));\n    };\n    JsonProtoSerializer.prototype.fromWatchChange = function (change) {\n        // tslint:disable-next-line:no-any\n        var type = change['response_type'];\n        var watchChange;\n        if (hasTag(change, type, 'targetChange')) {\n            assertPresent(change.targetChange, 'targetChange');\n            // proto3 default value is unset in JSON (undefined), so use 'NO_CHANGE'\n            // if unset\n            var state = this.fromWatchTargetChangeState(change.targetChange.targetChangeType || 'NO_CHANGE');\n            var targetIds = change.targetChange.targetIds || [];\n            var resumeToken = change.targetChange.resumeToken || this.emptyByteString();\n            var causeProto = change.targetChange.cause;\n            var cause = causeProto && this.fromRpcStatus(causeProto);\n            watchChange = new watch_change_WatchTargetChange(state, targetIds, resumeToken, cause || null);\n        }\n        else if (hasTag(change, type, 'documentChange')) {\n            assertPresent(change.documentChange, 'documentChange');\n            assertPresent(change.documentChange.document, 'documentChange.name');\n            assertPresent(change.documentChange.document.name, 'documentChange.document.name');\n            assertPresent(change.documentChange.document.updateTime, 'documentChange.document.updateTime');\n            var entityChange = change.documentChange;\n            var key = this.fromName(entityChange.document.name);\n            var version = this.fromVersion(entityChange.document.updateTime);\n            var fields = this.fromFields(entityChange.document.fields || {});\n            var doc = new document_Document(key, version, fields, {\n                hasLocalMutations: false\n            });\n            var updatedTargetIds = entityChange.targetIds || [];\n            var removedTargetIds = entityChange.removedTargetIds || [];\n            watchChange = new DocumentWatchChange(updatedTargetIds, removedTargetIds, doc.key, doc);\n        }\n        else if (hasTag(change, type, 'documentDelete')) {\n            assertPresent(change.documentDelete, 'documentDelete');\n            assertPresent(change.documentDelete.document, 'documentDelete.document');\n            var docDelete = change.documentDelete;\n            var key = this.fromName(docDelete.document);\n            var version = docDelete.readTime\n                ? this.fromVersion(docDelete.readTime)\n                : snapshot_version_SnapshotVersion.forDeletedDoc();\n            var doc = new document_NoDocument(key, version);\n            var removedTargetIds = docDelete.removedTargetIds || [];\n            watchChange = new DocumentWatchChange([], removedTargetIds, doc.key, doc);\n        }\n        else if (hasTag(change, type, 'documentRemove')) {\n            assertPresent(change.documentRemove, 'documentRemove');\n            assertPresent(change.documentRemove.document, 'documentRemove');\n            var docRemove = change.documentRemove;\n            var key = this.fromName(docRemove.document);\n            var removedTargetIds = docRemove.removedTargetIds || [];\n            watchChange = new DocumentWatchChange([], removedTargetIds, key, null);\n        }\n        else if (hasTag(change, type, 'filter')) {\n            // TODO(dimond): implement existence filter parsing with strategy.\n            assertPresent(change.filter, 'filter');\n            assertPresent(change.filter.targetId, 'filter.targetId');\n            var filter = change.filter;\n            var count = filter.count || 0;\n            var existenceFilter = new ExistenceFilter(count);\n            var targetId = filter.targetId;\n            watchChange = new ExistenceFilterChange(targetId, existenceFilter);\n        }\n        else {\n            return fail('Unknown change type ' + JSON.stringify(change));\n        }\n        return watchChange;\n    };\n    JsonProtoSerializer.prototype.fromWatchTargetChangeState = function (state) {\n        if (state === 'NO_CHANGE') {\n            return WatchTargetChangeState.NoChange;\n        }\n        else if (state === 'ADD') {\n            return WatchTargetChangeState.Added;\n        }\n        else if (state === 'REMOVE') {\n            return WatchTargetChangeState.Removed;\n        }\n        else if (state === 'CURRENT') {\n            return WatchTargetChangeState.Current;\n        }\n        else if (state === 'RESET') {\n            return WatchTargetChangeState.Reset;\n        }\n        else {\n            return fail('Got unexpected TargetChange.state: ' + state);\n        }\n    };\n    JsonProtoSerializer.prototype.versionFromListenResponse = function (change) {\n        // We have only reached a consistent snapshot for the entire stream if there\n        // is a read_time set and it applies to all targets (i.e. the list of\n        // targets is empty). The backend is guaranteed to send such responses.\n        // tslint:disable-next-line:no-any\n        var type = change['response_type'];\n        if (!hasTag(change, type, 'targetChange')) {\n            return snapshot_version_SnapshotVersion.MIN;\n        }\n        var targetChange = change.targetChange;\n        if (targetChange.targetIds && targetChange.targetIds.length) {\n            return snapshot_version_SnapshotVersion.MIN;\n        }\n        if (!targetChange.readTime) {\n            return snapshot_version_SnapshotVersion.MIN;\n        }\n        return this.fromVersion(targetChange.readTime);\n    };\n    JsonProtoSerializer.prototype.toMutation = function (mutation) {\n        var _this = this;\n        var result;\n        if (mutation instanceof mutation_SetMutation) {\n            result = {\n                update: this.toMutationDocument(mutation.key, mutation.value)\n            };\n        }\n        else if (mutation instanceof mutation_DeleteMutation) {\n            result = { delete: this.toName(mutation.key) };\n        }\n        else if (mutation instanceof mutation_PatchMutation) {\n            result = {\n                update: this.toMutationDocument(mutation.key, mutation.data),\n                updateMask: this.toDocumentMask(mutation.fieldMask)\n            };\n        }\n        else if (mutation instanceof mutation_TransformMutation) {\n            result = {\n                transform: {\n                    document: this.toName(mutation.key),\n                    fieldTransforms: mutation.fieldTransforms.map(function (transform) {\n                        return _this.toFieldTransform(transform);\n                    })\n                }\n            };\n        }\n        else {\n            return fail('Unknown mutation type ' + mutation.type);\n        }\n        if (!mutation.precondition.isNone) {\n            result.currentDocument = this.toPrecondition(mutation.precondition);\n        }\n        return result;\n    };\n    JsonProtoSerializer.prototype.fromMutation = function (proto) {\n        var _this = this;\n        var precondition = proto.currentDocument\n            ? this.fromPrecondition(proto.currentDocument)\n            : mutation_Precondition.NONE;\n        if (proto.update) {\n            assertPresent(proto.update.name, 'name');\n            var key = this.fromName(proto.update.name);\n            var value = this.fromFields(proto.update.fields || {});\n            if (proto.updateMask) {\n                var fieldMask = this.fromDocumentMask(proto.updateMask);\n                return new mutation_PatchMutation(key, value, fieldMask, precondition);\n            }\n            else {\n                return new mutation_SetMutation(key, value, precondition);\n            }\n        }\n        else if (proto.delete) {\n            var key = this.fromName(proto.delete);\n            return new mutation_DeleteMutation(key, precondition);\n        }\n        else if (proto.transform) {\n            var key = this.fromName(proto.transform.document);\n            var fieldTransforms = proto.transform.fieldTransforms.map(function (transform) {\n                return _this.fromFieldTransform(transform);\n            });\n            assert(precondition.exists === true, 'Transforms only support precondition \"exists == true\"');\n            return new mutation_TransformMutation(key, fieldTransforms);\n        }\n        else {\n            return fail('unknown mutation proto: ' + JSON.stringify(proto));\n        }\n    };\n    JsonProtoSerializer.prototype.toPrecondition = function (precondition) {\n        assert(!precondition.isNone, \"Can't serialize an empty precondition\");\n        if (precondition.updateTime !== undefined) {\n            return {\n                updateTime: this.toVersion(precondition.updateTime)\n            };\n        }\n        else if (precondition.exists !== undefined) {\n            return { exists: precondition.exists };\n        }\n        else {\n            return fail('Unknown precondition');\n        }\n    };\n    JsonProtoSerializer.prototype.fromPrecondition = function (precondition) {\n        if (precondition.updateTime !== undefined) {\n            return mutation_Precondition.updateTime(this.fromVersion(precondition.updateTime));\n        }\n        else if (precondition.exists !== undefined) {\n            return mutation_Precondition.exists(precondition.exists);\n        }\n        else {\n            return mutation_Precondition.NONE;\n        }\n    };\n    JsonProtoSerializer.prototype.fromWriteResult = function (proto) {\n        var _this = this;\n        // NOTE: Deletes don't have an updateTime.\n        var version = proto.updateTime\n            ? this.fromVersion(proto.updateTime)\n            : null;\n        var transformResults = null;\n        if (proto.transformResults && proto.transformResults.length > 0) {\n            transformResults = proto.transformResults.map(function (result) {\n                return _this.fromValue(result);\n            });\n        }\n        return new MutationResult(version, transformResults);\n    };\n    JsonProtoSerializer.prototype.fromWriteResults = function (protos) {\n        var _this = this;\n        return (protos || []).map(function (proto) { return _this.fromWriteResult(proto); });\n    };\n    JsonProtoSerializer.prototype.toFieldTransform = function (fieldTransform) {\n        assert(fieldTransform.transform instanceof ServerTimestampTransform, 'Unknown transform: ' + fieldTransform.transform);\n        return {\n            fieldPath: fieldTransform.field.canonicalString(),\n            setToServerValue: 'REQUEST_TIME'\n        };\n    };\n    JsonProtoSerializer.prototype.fromFieldTransform = function (proto) {\n        assert(proto.setToServerValue === 'REQUEST_TIME', 'Unknown transform proto: ' + JSON.stringify(proto));\n        var fieldPath = path_FieldPath.fromServerFormat(proto.fieldPath);\n        return new FieldTransform(fieldPath, ServerTimestampTransform.instance);\n    };\n    JsonProtoSerializer.prototype.toDocumentsTarget = function (query) {\n        return { documents: [this.toQueryPath(query.path)] };\n    };\n    JsonProtoSerializer.prototype.fromDocumentsTarget = function (documentsTarget) {\n        var count = documentsTarget.documents.length;\n        assert(count === 1, 'DocumentsTarget contained other than 1 document: ' + count);\n        var name = documentsTarget.documents[0];\n        return query_Query.atPath(this.fromQueryPath(name));\n    };\n    JsonProtoSerializer.prototype.toQueryTarget = function (query) {\n        // Dissect the path into parent, collectionId, and optional key filter.\n        var result = { structuredQuery: {} };\n        if (query.path.isEmpty()) {\n            result.parent = this.toQueryPath(path_ResourcePath.EMPTY_PATH);\n        }\n        else {\n            var path = query.path;\n            assert(path.length % 2 !== 0, 'Document queries with filters are not supported.');\n            result.parent = this.toQueryPath(path.popLast());\n            result.structuredQuery.from = [{ collectionId: path.lastSegment() }];\n        }\n        var where = this.toFilter(query.filters);\n        if (where) {\n            result.structuredQuery.where = where;\n        }\n        var orderBy = this.toOrder(query.orderBy);\n        if (orderBy) {\n            result.structuredQuery.orderBy = orderBy;\n        }\n        var limit = this.toInt32Value(query.limit);\n        if (limit !== undefined) {\n            result.structuredQuery.limit = limit;\n        }\n        if (query.startAt) {\n            result.structuredQuery.startAt = this.toCursor(query.startAt);\n        }\n        if (query.endAt) {\n            result.structuredQuery.endAt = this.toCursor(query.endAt);\n        }\n        return result;\n    };\n    JsonProtoSerializer.prototype.fromQueryTarget = function (target) {\n        var path = this.fromQueryPath(target.parent);\n        var query = target.structuredQuery;\n        var fromCount = query.from ? query.from.length : 0;\n        if (fromCount > 0) {\n            assert(fromCount === 1, 'StructuredQuery.from with more than one collection is not supported.');\n            var from = query.from[0];\n            path = path.child(from.collectionId);\n        }\n        var filterBy = [];\n        if (query.where) {\n            filterBy = this.fromFilter(query.where);\n        }\n        var orderBy = [];\n        if (query.orderBy) {\n            orderBy = this.fromOrder(query.orderBy);\n        }\n        var limit = null;\n        if (query.limit) {\n            limit = this.fromInt32Value(query.limit);\n        }\n        var startAt = null;\n        if (query.startAt) {\n            startAt = this.fromCursor(query.startAt);\n        }\n        var endAt = null;\n        if (query.endAt) {\n            endAt = this.fromCursor(query.endAt);\n        }\n        return new query_Query(path, orderBy, filterBy, limit, startAt, endAt);\n    };\n    JsonProtoSerializer.prototype.toListenRequestLabels = function (queryData) {\n        var value = this.toLabel(queryData.purpose);\n        if (value == null) {\n            return null;\n        }\n        else {\n            return {\n                'goog-listen-tags': value\n            };\n        }\n    };\n    JsonProtoSerializer.prototype.toLabel = function (purpose) {\n        switch (purpose) {\n            case QueryPurpose.Listen:\n                return null;\n            case QueryPurpose.ExistenceFilterMismatch:\n                return 'existence-filter-mismatch';\n            case QueryPurpose.LimboResolution:\n                return 'limbo-document';\n            default:\n                return fail('Unrecognized query purpose: ' + purpose);\n        }\n    };\n    JsonProtoSerializer.prototype.toTarget = function (queryData) {\n        var result;\n        var query = queryData.query;\n        if (query.isDocumentQuery()) {\n            result = { documents: this.toDocumentsTarget(query) };\n        }\n        else {\n            result = { query: this.toQueryTarget(query) };\n        }\n        result.targetId = queryData.targetId;\n        if (queryData.resumeToken.length > 0) {\n            result.resumeToken = this.unsafeCastProtoByteString(queryData.resumeToken);\n        }\n        return result;\n    };\n    JsonProtoSerializer.prototype.toFilter = function (filters) {\n        var _this = this;\n        if (filters.length === 0)\n            return;\n        var protos = filters.map(function (filter) {\n            return filter instanceof query_RelationFilter\n                ? _this.toRelationFilter(filter)\n                : _this.toUnaryFilter(filter);\n        });\n        if (protos.length === 1) {\n            return protos[0];\n        }\n        return { compositeFilter: { op: 'AND', filters: protos } };\n    };\n    JsonProtoSerializer.prototype.fromFilter = function (filter) {\n        var _this = this;\n        if (!filter) {\n            return [];\n        }\n        else if (filter.unaryFilter !== undefined) {\n            return [this.fromUnaryFilter(filter)];\n        }\n        else if (filter.fieldFilter !== undefined) {\n            return [this.fromRelationFilter(filter)];\n        }\n        else if (filter.compositeFilter !== undefined) {\n            return filter.compositeFilter.filters\n                .map(function (f) { return _this.fromFilter(f); })\n                .reduce(function (accum, current) { return accum.concat(current); });\n        }\n        else {\n            return fail('Unknown filter: ' + JSON.stringify(filter));\n        }\n    };\n    JsonProtoSerializer.prototype.toOrder = function (orderBys) {\n        var _this = this;\n        if (orderBys.length === 0)\n            return;\n        return orderBys.map(function (order) { return _this.toPropertyOrder(order); });\n    };\n    JsonProtoSerializer.prototype.fromOrder = function (orderBys) {\n        var _this = this;\n        return orderBys.map(function (order) { return _this.fromPropertyOrder(order); });\n    };\n    JsonProtoSerializer.prototype.toCursor = function (cursor) {\n        var _this = this;\n        return {\n            before: cursor.before,\n            values: cursor.position.map(function (component) { return _this.toValue(component); })\n        };\n    };\n    JsonProtoSerializer.prototype.fromCursor = function (cursor) {\n        var _this = this;\n        var before = !!cursor.before;\n        var position = cursor.values.map(function (component) { return _this.fromValue(component); });\n        return new query_Bound(position, before);\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.toDirection = function (dir) {\n        return DIRECTIONS[dir.name];\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.fromDirection = function (dir) {\n        switch (dir) {\n            case 'ASCENDING':\n                return Direction.ASCENDING;\n            case 'DESCENDING':\n                return Direction.DESCENDING;\n            default:\n                return undefined;\n        }\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.toOperatorName = function (op) {\n        return OPERATORS[op.name];\n    };\n    JsonProtoSerializer.prototype.fromOperatorName = function (op) {\n        switch (op) {\n            case 'EQUAL':\n                return query_RelationOp.EQUAL;\n            case 'GREATER_THAN':\n                return query_RelationOp.GREATER_THAN;\n            case 'GREATER_THAN_OR_EQUAL':\n                return query_RelationOp.GREATER_THAN_OR_EQUAL;\n            case 'LESS_THAN':\n                return query_RelationOp.LESS_THAN;\n            case 'LESS_THAN_OR_EQUAL':\n                return query_RelationOp.LESS_THAN_OR_EQUAL;\n            case 'OPERATOR_UNSPECIFIED':\n                return fail('Unspecified relation');\n            default:\n                return fail('Unknown relation');\n        }\n    };\n    JsonProtoSerializer.prototype.toFieldPathReference = function (path) {\n        return { fieldPath: path.canonicalString() };\n    };\n    JsonProtoSerializer.prototype.fromFieldPathReference = function (fieldReference) {\n        return path_FieldPath.fromServerFormat(fieldReference.fieldPath);\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.toPropertyOrder = function (orderBy) {\n        return {\n            field: this.toFieldPathReference(orderBy.field),\n            direction: this.toDirection(orderBy.dir)\n        };\n    };\n    JsonProtoSerializer.prototype.fromPropertyOrder = function (orderBy) {\n        return new query_OrderBy(this.fromFieldPathReference(orderBy.field), this.fromDirection(orderBy.direction));\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.toRelationFilter = function (filter) {\n        if (filter instanceof query_RelationFilter) {\n            return {\n                fieldFilter: {\n                    field: this.toFieldPathReference(filter.field),\n                    op: this.toOperatorName(filter.op),\n                    value: this.toValue(filter.value)\n                }\n            };\n        }\n        else {\n            return fail('Unrecognized filter: ' + JSON.stringify(filter));\n        }\n    };\n    JsonProtoSerializer.prototype.fromRelationFilter = function (filter) {\n        return new query_RelationFilter(this.fromFieldPathReference(filter.fieldFilter.field), this.fromOperatorName(filter.fieldFilter.op), this.fromValue(filter.fieldFilter.value));\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.toUnaryFilter = function (filter) {\n        if (filter instanceof NanFilter) {\n            return {\n                unaryFilter: {\n                    field: this.toFieldPathReference(filter.field),\n                    op: 'IS_NAN'\n                }\n            };\n        }\n        else if (filter instanceof NullFilter) {\n            return {\n                unaryFilter: {\n                    field: this.toFieldPathReference(filter.field),\n                    op: 'IS_NULL'\n                }\n            };\n        }\n        else {\n            return fail('Unrecognized filter: ' + JSON.stringify(filter));\n        }\n    };\n    JsonProtoSerializer.prototype.fromUnaryFilter = function (filter) {\n        switch (filter.unaryFilter.op) {\n            case 'IS_NAN':\n                var nanField = this.fromFieldPathReference(filter.unaryFilter.field);\n                return new NanFilter(nanField);\n            case 'IS_NULL':\n                var nullField = this.fromFieldPathReference(filter.unaryFilter.field);\n                return new NullFilter(nullField);\n            case 'OPERATOR_UNSPECIFIED':\n                return fail('Unspecified filter');\n            default:\n                return fail('Unknown filter');\n        }\n    };\n    JsonProtoSerializer.prototype.toDocumentMask = function (fieldMask) {\n        return {\n            fieldPaths: fieldMask.fields.map(function (field) { return field.canonicalString(); })\n        };\n    };\n    JsonProtoSerializer.prototype.fromDocumentMask = function (proto) {\n        var paths = proto.fieldPaths || [];\n        var fields = paths.map(function (path) { return path_FieldPath.fromServerFormat(path); });\n        return new mutation_FieldMask(fields);\n    };\n    return JsonProtoSerializer;\n}());\n\n/**\n * Checks for a specific oneof tag in a protocol buffer message.\n *\n * This intentionally accommodates two distinct cases:\n *\n * 1) Messages containing a type tag: these are the format produced by GRPC in\n * return values. These may contain default-value mappings for all tags in the\n * oneof but the type tag specifies which one was actually set.\n *\n * 2) Messages that don't contain a type tag: these are the format required by\n * GRPC as inputs. If we emitted objects with type tags, ProtoBuf.js would\n * choke claiming that the tags aren't fields in the Message.\n *\n * Allowing both formats here makes the serializer able to consume the outputs\n * it produces: for all messages it supports, fromX(toX(value)) == value.\n *\n * Note that case 2 suffers from ambiguity: if multiple tags are present\n * without a type tag then the callers are structured in such a way that the\n * first invocation will win. Since we only parse in this mode when parsing\n * the output of a serialize method this works, but it's not a general\n * solution.\n *\n * Unfortunately there is no general solution here because proto3 makes it\n * impossible to distinguish unset from explicitly set fields: both have the\n * default value for the type. Without the type tag but multiple value tags\n * it's possible to have default values for each tag in the oneof and not be\n * able to know which was actually in effect.\n */\nfunction hasTag(obj, type, tag) {\n    return type === tag || (!type && tag in obj);\n}\n\n//# sourceMappingURL=serializer.js.map\n\n// EXTERNAL MODULE: ../webchannel-wrapper/dist/index.js\nvar dist = __webpack_require__(117);\nvar dist_default = /*#__PURE__*/__webpack_require__.n(dist);\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/remote/stream_bridge.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Provides a simple helper class that implements the Stream interface to\n * bridge to other implementations that are streams but do not implement the\n * interface. The stream callbacks are invoked with the callOn... methods.\n */\nvar stream_bridge_StreamBridge = /** @class */ (function () {\n    function StreamBridge(args) {\n        this.sendFn = args.sendFn;\n        this.closeFn = args.closeFn;\n    }\n    StreamBridge.prototype.onOpen = function (callback) {\n        assert(!this.wrappedOnOpen, 'Called onOpen on stream twice!');\n        this.wrappedOnOpen = callback;\n    };\n    StreamBridge.prototype.onClose = function (callback) {\n        assert(!this.wrappedOnClose, 'Called onClose on stream twice!');\n        this.wrappedOnClose = callback;\n    };\n    StreamBridge.prototype.onMessage = function (callback) {\n        assert(!this.wrappedOnMessage, 'Called onMessage on stream twice!');\n        this.wrappedOnMessage = callback;\n    };\n    StreamBridge.prototype.close = function () {\n        this.closeFn();\n    };\n    StreamBridge.prototype.send = function (msg) {\n        this.sendFn(msg);\n    };\n    StreamBridge.prototype.callOnOpen = function () {\n        assert(this.wrappedOnOpen !== undefined, 'Cannot call onOpen because no callback was set');\n        this.wrappedOnOpen();\n    };\n    StreamBridge.prototype.callOnClose = function (err) {\n        assert(this.wrappedOnClose !== undefined, 'Cannot call onClose because no callback was set');\n        this.wrappedOnClose(err);\n    };\n    StreamBridge.prototype.callOnMessage = function (msg) {\n        assert(this.wrappedOnMessage !== undefined, 'Cannot call onMessage because no callback was set');\n        this.wrappedOnMessage(msg);\n    };\n    return StreamBridge;\n}());\n\n\n//# sourceMappingURL=stream_bridge.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/platform_browser/webchannel_connection.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\nvar LOG_TAG = 'Connection';\nvar RPC_STREAM_SERVICE = 'google.firestore.v1beta1.Firestore';\nvar RPC_URL_VERSION = 'v1beta1';\n/** Maps RPC names to the corresponding REST endpoint name. */\nvar RPC_NAME_REST_MAPPING = {\n    BatchGetDocuments: 'batchGet',\n    Commit: 'commit'\n};\n// TODO(b/38203344): The SDK_VERSION is set independently from Firebase because\n// we are doing out-of-band releases. Once we release as part of Firebase, we\n// should use the Firebase version instead.\nvar X_GOOG_API_CLIENT_VALUE = 'gl-js/ fire/' + SDK_VERSION;\nvar XHR_TIMEOUT_SECS = 15;\nvar webchannel_connection_WebChannelConnection = /** @class */ (function () {\n    function WebChannelConnection(info) {\n        this.databaseId = info.databaseId;\n        this.pool = new dist[\"XhrIoPool\"]();\n        var proto = info.ssl ? 'https' : 'http';\n        this.baseUrl = proto + '://' + info.host;\n    }\n    /**\n     * Modifies the headers for a request, adding any authorization token if\n     * present and any additional headers for the request.\n     */\n    WebChannelConnection.prototype.modifyHeadersForRequest = function (headers, token) {\n        if (token) {\n            for (var header in token.authHeaders) {\n                if (token.authHeaders.hasOwnProperty(header)) {\n                    headers[header] = token.authHeaders[header];\n                }\n            }\n        }\n        headers['X-Goog-Api-Client'] = X_GOOG_API_CLIENT_VALUE;\n    };\n    WebChannelConnection.prototype.invokeRPC = function (rpcName, request, token) {\n        var _this = this;\n        var url = this.makeUrl(rpcName);\n        return new Promise(function (resolve, reject) {\n            // tslint:disable-next-line:no-any XhrIoPool doesn't have TS typings.\n            _this.pool.getObject(function (xhr) {\n                xhr.listenOnce(dist[\"EventType\"].COMPLETE, function () {\n                    try {\n                        switch (xhr.getLastErrorCode()) {\n                            case dist[\"ErrorCode\"].NO_ERROR:\n                                var json = xhr.getResponseJson();\n                                debug(LOG_TAG, 'XHR received:', JSON.stringify(json));\n                                resolve(json);\n                                break;\n                            case dist[\"ErrorCode\"].TIMEOUT:\n                                debug(LOG_TAG, 'RPC \"' + rpcName + '\" timed out');\n                                reject(new error_FirestoreError(Code.DEADLINE_EXCEEDED, 'Request time out'));\n                                break;\n                            case dist[\"ErrorCode\"].HTTP_ERROR:\n                                var status_1 = xhr.getStatus();\n                                debug(LOG_TAG, 'RPC \"' + rpcName + '\" failed with status:', status_1, 'response text:', xhr.getResponseText());\n                                if (status_1 > 0) {\n                                    reject(new error_FirestoreError(mapCodeFromHttpStatus(status_1), 'Server responded with status ' + xhr.getStatusText()));\n                                }\n                                else {\n                                    // If we received an HTTP_ERROR but there's no status code,\n                                    // it's most probably a connection issue\n                                    debug(LOG_TAG, 'RPC \"' + rpcName + '\" failed');\n                                    reject(new error_FirestoreError(Code.UNAVAILABLE, 'Connection failed.'));\n                                }\n                                break;\n                            default:\n                                fail('RPC \"' +\n                                    rpcName +\n                                    '\" failed with unanticipated ' +\n                                    'webchannel error ' +\n                                    xhr.getLastErrorCode() +\n                                    ': ' +\n                                    xhr.getLastError() +\n                                    ', giving up.');\n                        }\n                    }\n                    finally {\n                        debug(LOG_TAG, 'RPC \"' + rpcName + '\" completed.');\n                        _this.pool.releaseObject(xhr);\n                    }\n                });\n                var requestString = JSON.stringify(request);\n                debug(LOG_TAG, 'XHR sending: ', url + ' ' + requestString);\n                // Content-Type: text/plain will avoid preflight requests which might\n                // mess with CORS and redirects by proxies. If we add custom headers\n                // we will need to change this code to potentially use the\n                // $httpOverwrite parameter supported by ESF to avoid\n                // triggering preflight requests.\n                var headers = { 'Content-Type': 'text/plain' };\n                _this.modifyHeadersForRequest(headers, token);\n                xhr.send(url, 'POST', requestString, headers, XHR_TIMEOUT_SECS);\n            });\n        });\n    };\n    WebChannelConnection.prototype.invokeStreamingRPC = function (rpcName, request, token) {\n        // The REST API automatically aggregates all of the streamed results, so we\n        // can just use the normal invoke() method.\n        return this.invokeRPC(rpcName, request, token);\n    };\n    WebChannelConnection.prototype.openStream = function (rpcName, token) {\n        var urlParts = [\n            this.baseUrl,\n            '/',\n            RPC_STREAM_SERVICE,\n            '/',\n            rpcName,\n            '/channel'\n        ];\n        var webchannelTransport = Object(dist[\"createWebChannelTransport\"])();\n        var request = {\n            // Background channel test avoids the initial two test calls and decreases\n            // initial cold start time.\n            // TODO(dimond): wenboz@ mentioned this might affect use with proxies and\n            // we should monitor closely for any reports.\n            backgroundChannelTest: true,\n            // Required for backend stickiness, routing behavior is based on this\n            // parameter.\n            httpSessionIdParam: 'gsessionid',\n            initMessageHeaders: {},\n            // Send our custom headers as a '$httpHeaders=' url param to avoid CORS\n            // preflight round-trip. This is formally defined here:\n            // https://github.com/google/closure-library/blob/b0e1815b13fb92a46d7c9b3c30de5d6a396a3245/closure/goog/net/rpc/httpcors.js#L40\n            httpHeadersOverwriteParam: '$httpHeaders',\n            messageUrlParams: {\n                // This param is used to improve routing and project isolation by the\n                // backend and must be included in every request.\n                database: \"projects/\" + this.databaseId.projectId + \"/databases/\" + this.databaseId.database\n            },\n            sendRawJson: true,\n            supportsCrossDomainXhr: true\n        };\n        this.modifyHeadersForRequest(request.initMessageHeaders, token);\n        var url = urlParts.join('');\n        debug(LOG_TAG, 'Creating WebChannel: ' + url + ' ' + request);\n        // tslint:disable-next-line:no-any Because listen isn't defined on it.\n        var channel = webchannelTransport.createWebChannel(url, request);\n        // WebChannel supports sending the first message with the handshake - saving\n        // a network round trip. However, it will have to call send in the same\n        // JS event loop as open. In order to enforce this, we delay actually\n        // opening the WebChannel until send is called. Whether we have called\n        // open is tracked with this variable.\n        var opened = false;\n        // A flag to determine whether the stream was closed (by us or through an\n        // error/close event) to avoid delivering multiple close events or sending\n        // on a closed stream\n        var closed = false;\n        var streamBridge = new stream_bridge_StreamBridge({\n            sendFn: function (msg) {\n                if (!closed) {\n                    if (!opened) {\n                        debug(LOG_TAG, 'Opening WebChannel transport.');\n                        channel.open();\n                        opened = true;\n                    }\n                    debug(LOG_TAG, 'WebChannel sending:', msg);\n                    channel.send(msg);\n                }\n                else {\n                    debug(LOG_TAG, 'Not sending because WebChannel is closed:', msg);\n                }\n            },\n            closeFn: function () { return channel.close(); }\n        });\n        // Closure events are guarded and exceptions are swallowed, so catch any\n        // exception and rethrow using a setTimeout so they become visible again.\n        // Note that eventually this function could go away if we are confident\n        // enough the code is exception free.\n        var unguardedEventListen = function (type, fn) {\n            // TODO(dimond): closure typing seems broken because WebChannel does\n            // not implement goog.events.Listenable\n            channel.listen(type, function (param) {\n                try {\n                    fn(param);\n                }\n                catch (e) {\n                    setTimeout(function () {\n                        throw e;\n                    }, 0);\n                }\n            });\n        };\n        unguardedEventListen(dist[\"WebChannel\"].EventType.OPEN, function () {\n            if (!closed) {\n                debug(LOG_TAG, 'WebChannel transport opened.');\n            }\n        });\n        unguardedEventListen(dist[\"WebChannel\"].EventType.CLOSE, function () {\n            if (!closed) {\n                closed = true;\n                debug(LOG_TAG, 'WebChannel transport closed');\n                streamBridge.callOnClose();\n            }\n        });\n        unguardedEventListen(dist[\"WebChannel\"].EventType.ERROR, function (err) {\n            if (!closed) {\n                closed = true;\n                debug(LOG_TAG, 'WebChannel transport errored:', err);\n                streamBridge.callOnClose(new error_FirestoreError(Code.UNAVAILABLE, 'The operation could not be completed'));\n            }\n        });\n        unguardedEventListen(dist[\"WebChannel\"].EventType.MESSAGE, function (msg) {\n            if (!closed) {\n                var msgData = msg.data[0];\n                assert(!!msgData, 'Got a webchannel message without data.');\n                // TODO(b/35143891): There is a bug in One Platform that caused errors\n                // (and only errors) to be wrapped in an extra array. To be forward\n                // compatible with the bug we need to check either condition. The latter\n                // can be removed once the fix has been rolled out.\n                var error = \n                // tslint:disable-next-line:no-any msgData.error is not typed.\n                msgData.error || (msgData[0] && msgData[0].error);\n                if (error) {\n                    debug(LOG_TAG, 'WebChannel received error:', error);\n                    // error.status will be a string like 'OK' or 'NOT_FOUND'.\n                    var status_2 = error.status;\n                    var code = mapCodeFromRpcStatus(status_2);\n                    var message = error.message;\n                    if (code === undefined) {\n                        code = Code.INTERNAL;\n                        message =\n                            'Unknown error status: ' +\n                                status_2 +\n                                ' with message ' +\n                                error.message;\n                    }\n                    // Mark closed so no further events are propagated\n                    closed = true;\n                    streamBridge.callOnClose(new error_FirestoreError(code, message));\n                    channel.close();\n                }\n                else {\n                    debug(LOG_TAG, 'WebChannel received:', msgData);\n                    streamBridge.callOnMessage(msgData);\n                }\n            }\n        });\n        setTimeout(function () {\n            // Technically we could/should wait for the WebChannel opened event,\n            // but because we want to send the first message with the WebChannel\n            // handshake we pretend the channel opened here (asynchronously), and\n            // then delay the actual open until the first message is sent.\n            streamBridge.callOnOpen();\n        }, 0);\n        return streamBridge;\n    };\n    // visible for testing\n    WebChannelConnection.prototype.makeUrl = function (rpcName) {\n        var urlRpcName = RPC_NAME_REST_MAPPING[rpcName];\n        assert(urlRpcName !== undefined, 'Unknown REST mapping for: ' + rpcName);\n        var url = [this.baseUrl, '/', RPC_URL_VERSION];\n        url.push('/projects/');\n        url.push(this.databaseId.projectId);\n        url.push('/databases/');\n        url.push(this.databaseId.database);\n        url.push('/documents');\n        url.push(':');\n        url.push(urlRpcName);\n        return url.join('');\n    };\n    return WebChannelConnection;\n}());\n\n\n//# sourceMappingURL=webchannel_connection.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/platform_browser/browser_platform.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar browser_platform_BrowserPlatform = /** @class */ (function () {\n    function BrowserPlatform() {\n        this.emptyByteString = '';\n        this.base64Available = typeof atob !== 'undefined';\n    }\n    BrowserPlatform.prototype.loadConnection = function (databaseInfo) {\n        return Promise.resolve(new webchannel_connection_WebChannelConnection(databaseInfo));\n    };\n    BrowserPlatform.prototype.newSerializer = function (databaseId) {\n        return new serializer_JsonProtoSerializer(databaseId, { useProto3Json: true });\n    };\n    BrowserPlatform.prototype.formatJSON = function (value) {\n        return JSON.stringify(value);\n    };\n    BrowserPlatform.prototype.atob = function (encoded) {\n        return atob(encoded);\n    };\n    BrowserPlatform.prototype.btoa = function (raw) {\n        return btoa(raw);\n    };\n    return BrowserPlatform;\n}());\n\n\n//# sourceMappingURL=browser_platform.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/platform_browser/browser_init.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * This code needs to run before Firestore is used. This can be achieved in\n * several ways:\n *   1) Through the JSCompiler compiling this code and then (automatically)\n *      executing it before exporting the Firestore symbols.\n *   2) Through importing this module first in a Firestore main module\n */\nplatform_PlatformSupport.setPlatform(new browser_platform_BrowserPlatform());\n\n//# sourceMappingURL=browser_init.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/api/field_path.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n// The objects that are a part of this API are exposed to third-parties as\n// compiled javascript so we want to flag our private members with a leading\n// underscore to discourage their use.\n// tslint:disable:strip-private-property-underscore\n/**\n * A FieldPath refers to a field in a document. The path may consist of a single\n * field name (referring to a top-level field in the document), or a list of\n * field names (referring to a nested field in the document).\n */\nvar field_path_FieldPath = /** @class */ (function () {\n    /**\n     * Creates a FieldPath from the provided field names. If more than one field\n     * name is provided, the path will point to a nested field in a document.\n     *\n     * @param fieldNames A list of field names.\n     */\n    function FieldPath() {\n        var fieldNames = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            fieldNames[_i] = arguments[_i];\n        }\n        validateNamedArrayAtLeastNumberOfElements('FieldPath', fieldNames, 'fieldNames', 1);\n        for (var i = 0; i < fieldNames.length; ++i) {\n            validateArgType('FieldPath', 'string', i, fieldNames[i]);\n            if (fieldNames[i].length === 0) {\n                throw new error_FirestoreError(Code.INVALID_ARGUMENT, \"Invalid field name at argument $(i + 1). \" +\n                    'Field names must not be empty.');\n            }\n        }\n        this._internalPath = new path_FieldPath(fieldNames);\n    }\n    FieldPath.documentId = function () {\n        return FieldPath._DOCUMENT_ID;\n    };\n    FieldPath.prototype.isEqual = function (other) {\n        if (!(other instanceof FieldPath)) {\n            throw invalidClassError('isEqual', 'FieldPath', 1, other);\n        }\n        return this._internalPath.isEqual(other._internalPath);\n    };\n    /**\n     * Internal Note: The backend doesn't technically support querying by\n     * document ID. Instead it queries by the entire document name (full path\n     * included), but in the cases we currently support documentId(), the net\n     * effect is the same.\n     */\n    FieldPath._DOCUMENT_ID = new FieldPath(path_FieldPath.keyField().canonicalString());\n    return FieldPath;\n}());\n\n/**\n * Matches any characters in a field path string that are reserved.\n */\nvar RESERVED = new RegExp('[~\\\\*/\\\\[\\\\]]');\n/**\n * Parses a field path string into a FieldPath, treating dots as separators.\n */\nfunction fromDotSeparatedString(path) {\n    var found = path.search(RESERVED);\n    if (found >= 0) {\n        throw new error_FirestoreError(Code.INVALID_ARGUMENT, \"Invalid field path (\" + path + \"). Paths must not contain \" +\n            \"'~', '*', '/', '[', or ']'\");\n    }\n    try {\n        return new (field_path_FieldPath.bind.apply(field_path_FieldPath, [void 0].concat(path.split('.'))))();\n    }\n    catch (e) {\n        throw new error_FirestoreError(Code.INVALID_ARGUMENT, \"Invalid field path (\" + path + \"). Paths must not be empty, \" +\n            \"begin with '.', end with '.', or contain '..'\");\n    }\n}\n\n//# sourceMappingURL=field_path.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/core/types.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Describes the online state of the Firestore client. Note that this does not\n * indicate whether or not the remote store is trying to connect or not. This is\n * primarily used by the View / EventManager code to change their behavior while\n * offline (e.g. get() calls shouldn't wait for data from the server and\n * snapshot events should set metadata.isFromCache=true).\n */\nvar OnlineState;\n(function (OnlineState) {\n    /**\n     * The Firestore client is in an unknown online state. This means the client\n     * is either not actively trying to establish a connection or it is currently\n     * trying to establish a connection, but it has not succeeded or failed yet.\n     * Higher-level components should not operate in offline mode.\n     */\n    OnlineState[OnlineState[\"Unknown\"] = 0] = \"Unknown\";\n    /**\n     * The client is connected and the connections are healthy. This state is\n     * reached after a successful connection and there has been at least one\n     * successful message received from the backends.\n     */\n    OnlineState[OnlineState[\"Online\"] = 1] = \"Online\";\n    /**\n     * The client is either trying to establish a connection but failing, or it\n     * has been explicitly marked offline via a call to disableNetwork().\n     * Higher-level components should operate in offline mode.\n     */\n    OnlineState[OnlineState[\"Offline\"] = 2] = \"Offline\";\n})(OnlineState || (OnlineState = {}));\n\n//# sourceMappingURL=types.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/core/view_snapshot.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\nvar ChangeType;\n(function (ChangeType) {\n    ChangeType[ChangeType[\"Added\"] = 0] = \"Added\";\n    ChangeType[ChangeType[\"Removed\"] = 1] = \"Removed\";\n    ChangeType[ChangeType[\"Modified\"] = 2] = \"Modified\";\n    ChangeType[ChangeType[\"Metadata\"] = 3] = \"Metadata\";\n})(ChangeType || (ChangeType = {}));\nvar SyncState;\n(function (SyncState) {\n    SyncState[SyncState[\"Local\"] = 0] = \"Local\";\n    SyncState[SyncState[\"Synced\"] = 1] = \"Synced\";\n})(SyncState || (SyncState = {}));\n/**\n * DocumentChangeSet keeps track of a set of changes to docs in a query, merging\n * duplicate events for the same doc.\n */\nvar view_snapshot_DocumentChangeSet = /** @class */ (function () {\n    function DocumentChangeSet() {\n        this.changeMap = new SortedMap(document_key_DocumentKey.comparator);\n    }\n    DocumentChangeSet.prototype.track = function (change) {\n        var key = change.doc.key;\n        var oldChange = this.changeMap.get(key);\n        if (!oldChange) {\n            this.changeMap = this.changeMap.insert(key, change);\n            return;\n        }\n        // Merge the new change with the existing change.\n        if (change.type !== ChangeType.Added &&\n            oldChange.type === ChangeType.Metadata) {\n            this.changeMap = this.changeMap.insert(key, change);\n        }\n        else if (change.type === ChangeType.Metadata &&\n            oldChange.type !== ChangeType.Removed) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: oldChange.type,\n                doc: change.doc\n            });\n        }\n        else if (change.type === ChangeType.Modified &&\n            oldChange.type === ChangeType.Modified) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: ChangeType.Modified,\n                doc: change.doc\n            });\n        }\n        else if (change.type === ChangeType.Modified &&\n            oldChange.type === ChangeType.Added) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: ChangeType.Added,\n                doc: change.doc\n            });\n        }\n        else if (change.type === ChangeType.Removed &&\n            oldChange.type === ChangeType.Added) {\n            this.changeMap = this.changeMap.remove(key);\n        }\n        else if (change.type === ChangeType.Removed &&\n            oldChange.type === ChangeType.Modified) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: ChangeType.Removed,\n                doc: oldChange.doc\n            });\n        }\n        else if (change.type === ChangeType.Added &&\n            oldChange.type === ChangeType.Removed) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: ChangeType.Modified,\n                doc: change.doc\n            });\n        }\n        else {\n            // This includes these cases, which don't make sense:\n            // Added->Added\n            // Removed->Removed\n            // Modified->Added\n            // Removed->Modified\n            // Metadata->Added\n            // Removed->Metadata\n            fail('unsupported combination of changes: ' +\n                JSON.stringify(change) +\n                ' after ' +\n                JSON.stringify(oldChange));\n        }\n    };\n    DocumentChangeSet.prototype.getChanges = function () {\n        var changes = [];\n        this.changeMap.inorderTraversal(function (key, change) {\n            changes.push(change);\n        });\n        return changes;\n    };\n    return DocumentChangeSet;\n}());\n\nvar ViewSnapshot = /** @class */ (function () {\n    function ViewSnapshot(query, docs, oldDocs, docChanges, fromCache, hasPendingWrites, syncStateChanged) {\n        this.query = query;\n        this.docs = docs;\n        this.oldDocs = oldDocs;\n        this.docChanges = docChanges;\n        this.fromCache = fromCache;\n        this.hasPendingWrites = hasPendingWrites;\n        this.syncStateChanged = syncStateChanged;\n    }\n    ViewSnapshot.prototype.isEqual = function (other) {\n        if (this.fromCache !== other.fromCache ||\n            this.hasPendingWrites !== other.hasPendingWrites ||\n            this.syncStateChanged !== other.syncStateChanged ||\n            !this.query.isEqual(other.query) ||\n            !this.docs.isEqual(other.docs) ||\n            !this.oldDocs.isEqual(other.oldDocs)) {\n            return false;\n        }\n        var changes = this.docChanges;\n        var otherChanges = other.docChanges;\n        if (changes.length !== otherChanges.length) {\n            return false;\n        }\n        for (var i = 0; i < changes.length; i++) {\n            if (changes[i].type !== otherChanges[i].type ||\n                !changes[i].doc.isEqual(otherChanges[i].doc)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    return ViewSnapshot;\n}());\n\n\n//# sourceMappingURL=view_snapshot.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/model/document_set.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n * DocumentSet is an immutable (copy-on-write) collection that holds documents\n * in order specified by the provided comparator. We always add a document key\n * comparator on top of what is provided to guarantee document equality based on\n * the key.\n */\nvar document_set_DocumentSet = /** @class */ (function () {\n    /** The default ordering is by key if the comparator is omitted */\n    function DocumentSet(comp) {\n        // We are adding document key comparator to the end as it's the only\n        // guaranteed unique property of a document.\n        if (comp) {\n            this.comparator = function (d1, d2) {\n                return comp(d1, d2) || document_key_DocumentKey.comparator(d1.key, d2.key);\n            };\n        }\n        else {\n            this.comparator = function (d1, d2) {\n                return document_key_DocumentKey.comparator(d1.key, d2.key);\n            };\n        }\n        this.keyedMap = documentMap();\n        this.sortedSet = new SortedMap(this.comparator);\n    }\n    /**\n     * Returns an empty copy of the existing DocumentSet, using the same\n     * comparator.\n     */\n    DocumentSet.emptySet = function (oldSet) {\n        return new DocumentSet(oldSet.comparator);\n    };\n    DocumentSet.prototype.has = function (key) {\n        return this.keyedMap.get(key) != null;\n    };\n    DocumentSet.prototype.get = function (key) {\n        return this.keyedMap.get(key);\n    };\n    DocumentSet.prototype.first = function () {\n        return this.sortedSet.minKey();\n    };\n    DocumentSet.prototype.last = function () {\n        return this.sortedSet.maxKey();\n    };\n    DocumentSet.prototype.isEmpty = function () {\n        return this.sortedSet.isEmpty();\n    };\n    /**\n     * Returns the index of the provided key in the document set, or -1 if the\n     * document key is not present in the set;\n     */\n    DocumentSet.prototype.indexOf = function (key) {\n        var doc = this.keyedMap.get(key);\n        return doc ? this.sortedSet.indexOf(doc) : -1;\n    };\n    Object.defineProperty(DocumentSet.prototype, \"size\", {\n        get: function () {\n            return this.sortedSet.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Iterates documents in order defined by \"comparator\" */\n    DocumentSet.prototype.forEach = function (cb) {\n        this.sortedSet.inorderTraversal(function (k, v) {\n            cb(k);\n            return false;\n        });\n    };\n    /** Inserts or updates a document with the same key */\n    DocumentSet.prototype.add = function (doc) {\n        // First remove the element if we have it.\n        var set = this.delete(doc.key);\n        return set.copy(set.keyedMap.insert(doc.key, doc), set.sortedSet.insert(doc, null));\n    };\n    /** Deletes a document with a given key */\n    DocumentSet.prototype.delete = function (key) {\n        var doc = this.get(key);\n        if (!doc) {\n            return this;\n        }\n        return this.copy(this.keyedMap.remove(key), this.sortedSet.remove(doc));\n    };\n    DocumentSet.prototype.isEqual = function (other) {\n        if (!(other instanceof DocumentSet))\n            return false;\n        if (this.size !== other.size)\n            return false;\n        var thisIt = this.sortedSet.getIterator();\n        var otherIt = other.sortedSet.getIterator();\n        while (thisIt.hasNext()) {\n            var thisDoc = thisIt.getNext().key;\n            var otherDoc = otherIt.getNext().key;\n            if (!thisDoc.isEqual(otherDoc))\n                return false;\n        }\n        return true;\n    };\n    DocumentSet.prototype.toString = function () {\n        var docStrings = [];\n        this.forEach(function (doc) {\n            docStrings.push(doc.toString());\n        });\n        if (docStrings.length === 0) {\n            return 'DocumentSet ()';\n        }\n        else {\n            return 'DocumentSet (\\n  ' + docStrings.join('  \\n') + '\\n)';\n        }\n    };\n    DocumentSet.prototype.copy = function (keyedMap, sortedSet) {\n        var newSet = new DocumentSet();\n        newSet.comparator = this.comparator;\n        newSet.keyedMap = keyedMap;\n        newSet.sortedSet = sortedSet;\n        return newSet;\n    };\n    return DocumentSet;\n}());\n\n\n//# sourceMappingURL=document_set.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/obj_map.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A map implementation that uses objects as keys. Objects must implement the\n * Equatable interface and must be immutable. Entries in the map are stored\n * together with the key being produced from the mapKeyFn. This map\n * automatically handles collisions of keys.\n */\nvar obj_map_ObjectMap = /** @class */ (function () {\n    function ObjectMap(mapKeyFn) {\n        this.mapKeyFn = mapKeyFn;\n        /**\n         * The inner map for a key -> value pair. Due to the possibility of\n         * collisions we keep a list of entries that we do a linear search through\n         * to find an actual match. Note that collisions should be rare, so we still\n         * expect near constant time lookups in practice.\n         */\n        this.inner = {};\n    }\n    /** Get a value for this key, or undefined if it does not exist. */\n    ObjectMap.prototype.get = function (key) {\n        var id = this.mapKeyFn(key);\n        var matches = this.inner[id];\n        if (matches === undefined) {\n            return undefined;\n        }\n        for (var _i = 0, matches_1 = matches; _i < matches_1.length; _i++) {\n            var _a = matches_1[_i], otherKey = _a[0], value = _a[1];\n            if (otherKey.isEqual(key)) {\n                return value;\n            }\n        }\n        return undefined;\n    };\n    ObjectMap.prototype.has = function (key) {\n        return this.get(key) !== undefined;\n    };\n    /** Put this key and value in the map. */\n    ObjectMap.prototype.set = function (key, value) {\n        var id = this.mapKeyFn(key);\n        var matches = this.inner[id];\n        if (matches === undefined) {\n            this.inner[id] = [[key, value]];\n            return;\n        }\n        for (var i = 0; i < matches.length; i++) {\n            if (matches[i][0].isEqual(key)) {\n                matches[i] = [key, value];\n                return;\n            }\n        }\n        matches.push([key, value]);\n    };\n    /**\n     * Remove this key from the map. Returns a boolean if anything was deleted.\n     */\n    ObjectMap.prototype.delete = function (key) {\n        var id = this.mapKeyFn(key);\n        var matches = this.inner[id];\n        if (matches === undefined) {\n            return false;\n        }\n        for (var i = 0; i < matches.length; i++) {\n            if (matches[i][0].isEqual(key)) {\n                if (matches.length === 1) {\n                    delete this.inner[id];\n                }\n                else {\n                    matches.splice(i, 1);\n                }\n                return true;\n            }\n        }\n        return false;\n    };\n    ObjectMap.prototype.forEach = function (fn) {\n        forEach(this.inner, function (_, entries) {\n            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n                var _a = entries_1[_i], k = _a[0], v = _a[1];\n                fn(k, v);\n            }\n        });\n    };\n    ObjectMap.prototype.isEmpty = function () {\n        return isEmpty(this.inner);\n    };\n    return ObjectMap;\n}());\n\n\n//# sourceMappingURL=obj_map.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/core/event_manager.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n/**\n * Holds the listeners and the last received ViewSnapshot for a query being\n * tracked by EventManager.\n */\nvar QueryListenersInfo = /** @class */ (function () {\n    function QueryListenersInfo() {\n        this.listeners = [];\n    }\n    return QueryListenersInfo;\n}());\n/**\n * EventManager is responsible for mapping queries to query event emitters.\n * It handles \"fan-out\". -- Identical queries will re-use the same watch on the\n * backend.\n */\nvar event_manager_EventManager = /** @class */ (function () {\n    function EventManager(syncEngine) {\n        this.syncEngine = syncEngine;\n        this.queries = new obj_map_ObjectMap(function (q) {\n            return q.canonicalId();\n        });\n        this.onlineState = OnlineState.Unknown;\n        this.syncEngine.subscribe(this.onChange.bind(this), this.onError.bind(this));\n    }\n    EventManager.prototype.listen = function (listener) {\n        var query = listener.query;\n        var firstListen = false;\n        var queryInfo = this.queries.get(query);\n        if (!queryInfo) {\n            firstListen = true;\n            queryInfo = new QueryListenersInfo();\n            this.queries.set(query, queryInfo);\n        }\n        queryInfo.listeners.push(listener);\n        listener.applyOnlineStateChange(this.onlineState);\n        if (queryInfo.viewSnap)\n            listener.onViewSnapshot(queryInfo.viewSnap);\n        if (firstListen) {\n            return this.syncEngine.listen(query).then(function (targetId) {\n                queryInfo.targetId = targetId;\n                return targetId;\n            });\n        }\n        else {\n            return Promise.resolve(queryInfo.targetId);\n        }\n    };\n    EventManager.prototype.unlisten = function (listener) {\n        return tslib_es6[\"__awaiter\"](this, void 0, void 0, function () {\n            var query, lastListen, queryInfo, i;\n            return tslib_es6[\"__generator\"](this, function (_a) {\n                query = listener.query;\n                lastListen = false;\n                queryInfo = this.queries.get(query);\n                if (queryInfo) {\n                    i = queryInfo.listeners.indexOf(listener);\n                    if (i >= 0) {\n                        queryInfo.listeners.splice(i, 1);\n                        lastListen = queryInfo.listeners.length === 0;\n                    }\n                }\n                if (lastListen) {\n                    this.queries.delete(query);\n                    return [2 /*return*/, this.syncEngine.unlisten(query)];\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    EventManager.prototype.onChange = function (viewSnaps) {\n        for (var _i = 0, viewSnaps_1 = viewSnaps; _i < viewSnaps_1.length; _i++) {\n            var viewSnap = viewSnaps_1[_i];\n            var query = viewSnap.query;\n            var queryInfo = this.queries.get(query);\n            if (queryInfo) {\n                for (var _a = 0, _b = queryInfo.listeners; _a < _b.length; _a++) {\n                    var listener = _b[_a];\n                    listener.onViewSnapshot(viewSnap);\n                }\n                queryInfo.viewSnap = viewSnap;\n            }\n        }\n    };\n    EventManager.prototype.onError = function (query, error) {\n        var queryInfo = this.queries.get(query);\n        if (queryInfo) {\n            for (var _i = 0, _a = queryInfo.listeners; _i < _a.length; _i++) {\n                var listener = _a[_i];\n                listener.onError(error);\n            }\n        }\n        // Remove all listeners. NOTE: We don't need to call syncEngine.unlisten()\n        // after an error.\n        this.queries.delete(query);\n    };\n    EventManager.prototype.applyOnlineStateChange = function (onlineState) {\n        this.onlineState = onlineState;\n        this.queries.forEach(function (_, queryInfo) {\n            for (var _i = 0, _a = queryInfo.listeners; _i < _a.length; _i++) {\n                var listener = _a[_i];\n                listener.applyOnlineStateChange(onlineState);\n            }\n        });\n    };\n    return EventManager;\n}());\n\n/**\n * QueryListener takes a series of internal view snapshots and determines\n * when to raise the event.\n *\n * It uses an Observer to dispatch events.\n */\nvar event_manager_QueryListener = /** @class */ (function () {\n    function QueryListener(query, queryObserver, options) {\n        this.query = query;\n        this.queryObserver = queryObserver;\n        /**\n         * Initial snapshots (e.g. from cache) may not be propagated to the wrapped\n         * observer. This flag is set to true once we've actually raised an event.\n         */\n        this.raisedInitialEvent = false;\n        this.onlineState = OnlineState.Unknown;\n        this.options = options || {};\n    }\n    QueryListener.prototype.onViewSnapshot = function (snap) {\n        assert(snap.docChanges.length > 0 || snap.syncStateChanged, 'We got a new snapshot with no changes?');\n        if (!this.options.includeDocumentMetadataChanges) {\n            // Remove the metadata only changes.\n            var docChanges = [];\n            for (var _i = 0, _a = snap.docChanges; _i < _a.length; _i++) {\n                var docChange = _a[_i];\n                if (docChange.type !== ChangeType.Metadata) {\n                    docChanges.push(docChange);\n                }\n            }\n            snap = new ViewSnapshot(snap.query, snap.docs, snap.oldDocs, docChanges, snap.fromCache, snap.hasPendingWrites, snap.syncStateChanged);\n        }\n        if (!this.raisedInitialEvent) {\n            if (this.shouldRaiseInitialEvent(snap, this.onlineState)) {\n                this.raiseInitialEvent(snap);\n            }\n        }\n        else if (this.shouldRaiseEvent(snap)) {\n            this.queryObserver.next(snap);\n        }\n        this.snap = snap;\n    };\n    QueryListener.prototype.onError = function (error) {\n        this.queryObserver.error(error);\n    };\n    QueryListener.prototype.applyOnlineStateChange = function (onlineState) {\n        this.onlineState = onlineState;\n        if (this.snap &&\n            !this.raisedInitialEvent &&\n            this.shouldRaiseInitialEvent(this.snap, onlineState)) {\n            this.raiseInitialEvent(this.snap);\n        }\n    };\n    QueryListener.prototype.shouldRaiseInitialEvent = function (snap, onlineState) {\n        assert(!this.raisedInitialEvent, 'Determining whether to raise first event but already had first event');\n        // Always raise the first event when we're synced\n        if (!snap.fromCache) {\n            return true;\n        }\n        // NOTE: We consider OnlineState.Unknown as online (it should become Offline\n        // or Online if we wait long enough).\n        var maybeOnline = onlineState !== OnlineState.Offline;\n        // Don't raise the event if we're online, aren't synced yet (checked\n        // above) and are waiting for a sync.\n        if (this.options.waitForSyncWhenOnline && maybeOnline) {\n            assert(snap.fromCache, 'Waiting for sync, but snapshot is not from cache');\n            return false;\n        }\n        // Raise data from cache if we have any documents or we are offline\n        return !snap.docs.isEmpty() || onlineState === OnlineState.Offline;\n    };\n    QueryListener.prototype.shouldRaiseEvent = function (snap) {\n        // We don't need to handle includeDocumentMetadataChanges here because\n        // the Metadata only changes have already been stripped out if needed.\n        // At this point the only changes we will see are the ones we should\n        // propagate.\n        if (snap.docChanges.length > 0) {\n            return true;\n        }\n        var hasPendingWritesChanged = this.snap && this.snap.hasPendingWrites !== snap.hasPendingWrites;\n        if (snap.syncStateChanged || hasPendingWritesChanged) {\n            return this.options.includeQueryMetadataChanges === true;\n        }\n        // Generally we should have hit one of the cases above, but it's possible\n        // to get here if there were only metadata docChanges and they got\n        // stripped out.\n        return false;\n    };\n    QueryListener.prototype.raiseInitialEvent = function (snap) {\n        assert(!this.raisedInitialEvent, 'Trying to raise initial events for second time');\n        snap = new ViewSnapshot(snap.query, snap.docs, document_set_DocumentSet.emptySet(snap.docs), QueryListener.getInitialViewChanges(snap), snap.fromCache, snap.hasPendingWrites, true);\n        this.raisedInitialEvent = true;\n        this.queryObserver.next(snap);\n    };\n    /** Returns changes as if all documents in the snap were added. */\n    QueryListener.getInitialViewChanges = function (snap) {\n        var result = [];\n        snap.docs.forEach(function (doc) {\n            result.push({ type: ChangeType.Added, doc: doc });\n        });\n        return result;\n    };\n    return QueryListener;\n}());\n\n\n//# sourceMappingURL=event_manager.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/persistence_promise.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * PersistencePromise<> is essentially a re-implementation of Promise<> except\n * it has a .next() method instead of .then() and .next() and .catch() callbacks\n * are executed synchronously when a PersistencePromise resolves rather than\n * asynchronously (Promise<> implementations use setImmediate() or similar).\n *\n * This is necessary to interoperate with IndexedDB which will automatically\n * commit transactions if control is returned to the event loop without\n * synchronously initiating another operation on the transaction.\n *\n * NOTE: .then() and .catch() only allow a single consumer, unlike normal\n * Promises.\n */\nvar persistence_promise_PersistencePromise = /** @class */ (function () {\n    function PersistencePromise(callback) {\n        var _this = this;\n        // NOTE: next/catchCallback will always point to our own wrapper functions,\n        // not the user's raw next() or catch() callbacks.\n        // tslint:disable-next-line:no-any Accept any result type for the next call in the Promise chain.\n        this.nextCallback = null;\n        // tslint:disable-next-line:no-any Accept any result type for the error handler.\n        this.catchCallback = null;\n        // When the operation resolves, we'll set result or error and mark isDone.\n        this.result = undefined;\n        this.error = undefined;\n        this.isDone = false;\n        // Set to true when .then() or .catch() are called and prevents additional\n        // chaining.\n        this.callbackAttached = false;\n        callback(function (value) {\n            _this.isDone = true;\n            _this.result = value;\n            if (_this.nextCallback) {\n                // value should be defined unless T is Void, but we can't express\n                // that in the type system.\n                _this.nextCallback(value);\n            }\n        }, function (error) {\n            _this.isDone = true;\n            _this.error = error;\n            if (_this.catchCallback) {\n                _this.catchCallback(error);\n            }\n        });\n    }\n    PersistencePromise.prototype.catch = function (fn) {\n        return this.next(undefined, fn);\n    };\n    PersistencePromise.prototype.next = function (nextFn, catchFn) {\n        var _this = this;\n        if (this.callbackAttached) {\n            fail('Called next() or catch() twice for PersistencePromise');\n        }\n        this.callbackAttached = true;\n        if (this.isDone) {\n            if (!this.error) {\n                return this.wrapSuccess(nextFn, this.result);\n            }\n            else {\n                return this.wrapFailure(catchFn, this.error);\n            }\n        }\n        else {\n            return new PersistencePromise(function (resolve, reject) {\n                _this.nextCallback = function (value) {\n                    _this.wrapSuccess(nextFn, value).next(resolve, reject);\n                };\n                _this.catchCallback = function (error) {\n                    _this.wrapFailure(catchFn, error).next(resolve, reject);\n                };\n            });\n        }\n    };\n    PersistencePromise.prototype.toPromise = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            _this.next(resolve, reject);\n        });\n    };\n    PersistencePromise.prototype.wrapUserFunction = function (fn) {\n        try {\n            var result = fn();\n            if (result instanceof PersistencePromise) {\n                return result;\n            }\n            else {\n                return PersistencePromise.resolve(result);\n            }\n        }\n        catch (e) {\n            return PersistencePromise.reject(e);\n        }\n    };\n    PersistencePromise.prototype.wrapSuccess = function (nextFn, value) {\n        if (nextFn) {\n            return this.wrapUserFunction(function () { return nextFn(value); });\n        }\n        else {\n            // If there's no nextFn, then R must be the same as T but we\n            // can't express that in the type system.\n            // tslint:disable-next-line:no-any\n            return PersistencePromise.resolve(value);\n        }\n    };\n    PersistencePromise.prototype.wrapFailure = function (catchFn, error) {\n        if (catchFn) {\n            return this.wrapUserFunction(function () { return catchFn(error); });\n        }\n        else {\n            return PersistencePromise.reject(error);\n        }\n    };\n    PersistencePromise.resolve = function (result) {\n        return new PersistencePromise(function (resolve, reject) {\n            resolve(result);\n        });\n    };\n    PersistencePromise.reject = function (error) {\n        return new PersistencePromise(function (resolve, reject) {\n            reject(error);\n        });\n    };\n    PersistencePromise.waitFor = function (\n    // tslint:disable-next-line:no-any Accept all Promise types in waitFor().\n    all) {\n        return all.reduce(function (promise, nextPromise, idx) {\n            return promise.next(function () {\n                return nextPromise;\n            });\n        }, PersistencePromise.resolve());\n    };\n    PersistencePromise.map = function (all) {\n        var results = [];\n        var first = true;\n        // initial is ignored, so we can cheat on the type.\n        // tslint:disable-next-line:no-any\n        var initial = PersistencePromise.resolve(null);\n        return all\n            .reduce(function (promise, nextPromise) {\n            return promise.next(function (result) {\n                if (!first) {\n                    results.push(result);\n                }\n                first = false;\n                return nextPromise;\n            });\n        }, initial)\n            .next(function (result) {\n            results.push(result);\n            return results;\n        });\n    };\n    return PersistencePromise;\n}());\n\n\n//# sourceMappingURL=persistence_promise.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/eager_garbage_collector.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A garbage collector implementation that eagerly collects documents as soon as\n * they're no longer referenced in any of its registered GarbageSources.\n *\n * This implementation keeps track of a set of keys that are potentially garbage\n * without keeping an exact reference count. During collectGarbage, the\n * collector verifies that all potential garbage keys actually have no\n * references by consulting its list of garbage sources.\n */\nvar eager_garbage_collector_EagerGarbageCollector = /** @class */ (function () {\n    function EagerGarbageCollector() {\n        this.isEager = true;\n        /**\n         * The garbage collectible sources to double-check during garbage collection.\n         */\n        this.sources = [];\n        /**\n         * A set of potentially garbage keys.\n         * PORTING NOTE: This would be a mutable set if Javascript had one.\n         */\n        this.potentialGarbage = documentKeySet();\n    }\n    EagerGarbageCollector.prototype.addGarbageSource = function (garbageSource) {\n        this.sources.push(garbageSource);\n        garbageSource.setGarbageCollector(this);\n    };\n    EagerGarbageCollector.prototype.removeGarbageSource = function (garbageSource) {\n        this.sources.splice(this.sources.indexOf(garbageSource), 1);\n        garbageSource.setGarbageCollector(null);\n    };\n    EagerGarbageCollector.prototype.addPotentialGarbageKey = function (key) {\n        this.potentialGarbage = this.potentialGarbage.add(key);\n    };\n    EagerGarbageCollector.prototype.collectGarbage = function (txn) {\n        var _this = this;\n        var promises = [];\n        var garbageKeys = documentKeySet();\n        this.potentialGarbage.forEach(function (key) {\n            var hasRefsPromise = _this.documentHasAnyReferences(txn, key);\n            promises.push(hasRefsPromise.next(function (hasRefs) {\n                // If there are no references, get the key.\n                if (!hasRefs) {\n                    garbageKeys = garbageKeys.add(key);\n                }\n                return persistence_promise_PersistencePromise.resolve();\n            }));\n        });\n        // Clear locally retained potential keys and returned confirmed garbage.\n        this.potentialGarbage = documentKeySet();\n        return persistence_promise_PersistencePromise.waitFor(promises).next(function () { return garbageKeys; });\n    };\n    EagerGarbageCollector.prototype.documentHasAnyReferences = function (txn, key) {\n        var initial = persistence_promise_PersistencePromise.resolve(false);\n        return this.sources\n            .map(function (source) { return function () { return source.containsKey(txn, key); }; })\n            .reduce(function (promise, nextPromise) {\n            return promise.next(function (result) {\n                if (result) {\n                    return persistence_promise_PersistencePromise.resolve(true);\n                }\n                else {\n                    return nextPromise();\n                }\n            });\n        }, initial);\n    };\n    return EagerGarbageCollector;\n}());\n\n\n//# sourceMappingURL=eager_garbage_collector.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/local_view_changes.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A set of changes to what documents are currently in view and out of view for\n * a given query. These changes are sent to the LocalStore by the View (via\n * the SyncEngine) and are used to pin / unpin documents as appropriate.\n */\nvar local_view_changes_LocalViewChanges = /** @class */ (function () {\n    function LocalViewChanges(query, addedKeys, removedKeys) {\n        this.query = query;\n        this.addedKeys = addedKeys;\n        this.removedKeys = removedKeys;\n    }\n    LocalViewChanges.fromSnapshot = function (viewSnapshot) {\n        var addedKeys = documentKeySet();\n        var removedKeys = documentKeySet();\n        for (var _i = 0, _a = viewSnapshot.docChanges; _i < _a.length; _i++) {\n            var docChange = _a[_i];\n            switch (docChange.type) {\n                case ChangeType.Added:\n                    addedKeys = addedKeys.add(docChange.doc.key);\n                    break;\n                case ChangeType.Removed:\n                    removedKeys = removedKeys.add(docChange.doc.key);\n                    break;\n                default:\n            }\n        }\n        return new LocalViewChanges(viewSnapshot.query, addedKeys, removedKeys);\n    };\n    return LocalViewChanges;\n}());\n\n\n//# sourceMappingURL=local_view_changes.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/reference_set.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n/**\n * A collection of references to a document from some kind of numbered entity\n * (either a target ID or batch ID). As references are added to or removed from\n * the set corresponding events are emitted to a registered garbage collector.\n *\n * Each reference is represented by a DocumentReference object. Each of them\n * contains enough information to uniquely identify the reference. They are all\n * stored primarily in a set sorted by key. A document is considered garbage if\n * there's no references in that set (this can be efficiently checked thanks to\n * sorting by key).\n *\n * ReferenceSet also keeps a secondary set that contains references sorted by\n * IDs. This one is used to efficiently implement removal of all references by\n * some target ID.\n */\nvar reference_set_ReferenceSet = /** @class */ (function () {\n    function ReferenceSet() {\n        // A set of outstanding references to a document sorted by key.\n        this.refsByKey = new sorted_set_SortedSet(reference_set_DocReference.compareByKey);\n        // A set of outstanding references to a document sorted by target id.\n        this.refsByTarget = new sorted_set_SortedSet(reference_set_DocReference.compareByTargetId);\n        /** Keeps track of keys that have references */\n        this.garbageCollector = null;\n    }\n    /** Returns true if the reference set contains no references. */\n    ReferenceSet.prototype.isEmpty = function () {\n        return this.refsByKey.isEmpty();\n    };\n    /** Adds a reference to the given document key for the given ID. */\n    ReferenceSet.prototype.addReference = function (key, id) {\n        var ref = new reference_set_DocReference(key, id);\n        this.refsByKey = this.refsByKey.add(ref);\n        this.refsByTarget = this.refsByTarget.add(ref);\n    };\n    /** Add references to the given document keys for the given ID. */\n    ReferenceSet.prototype.addReferences = function (keys, id) {\n        var _this = this;\n        keys.forEach(function (key) { return _this.addReference(key, id); });\n    };\n    /**\n     * Removes a reference to the given document key for the given\n     * ID.\n     */\n    ReferenceSet.prototype.removeReference = function (key, id) {\n        this.removeRef(new reference_set_DocReference(key, id));\n    };\n    ReferenceSet.prototype.removeReferences = function (keys, id) {\n        var _this = this;\n        keys.forEach(function (key) { return _this.removeReference(key, id); });\n    };\n    /**\n     * Clears all references with a given ID. Calls removeRef() for each key\n     * removed.\n     */\n    ReferenceSet.prototype.removeReferencesForId = function (id) {\n        var _this = this;\n        var emptyKey = document_key_DocumentKey.EMPTY;\n        var startRef = new reference_set_DocReference(emptyKey, id);\n        var endRef = new reference_set_DocReference(emptyKey, id + 1);\n        this.refsByTarget.forEachInRange([startRef, endRef], function (ref) {\n            _this.removeRef(ref);\n        });\n    };\n    ReferenceSet.prototype.removeAllReferences = function () {\n        var _this = this;\n        this.refsByKey.forEach(function (ref) { return _this.removeRef(ref); });\n    };\n    ReferenceSet.prototype.removeRef = function (ref) {\n        this.refsByKey = this.refsByKey.delete(ref);\n        this.refsByTarget = this.refsByTarget.delete(ref);\n        if (this.garbageCollector !== null) {\n            this.garbageCollector.addPotentialGarbageKey(ref.key);\n        }\n    };\n    ReferenceSet.prototype.referencesForId = function (id) {\n        var emptyKey = document_key_DocumentKey.EMPTY;\n        var startRef = new reference_set_DocReference(emptyKey, id);\n        var endRef = new reference_set_DocReference(emptyKey, id + 1);\n        var keys = documentKeySet();\n        this.refsByTarget.forEachInRange([startRef, endRef], function (ref) {\n            keys = keys.add(ref.key);\n        });\n        return keys;\n    };\n    ReferenceSet.prototype.setGarbageCollector = function (garbageCollector) {\n        this.garbageCollector = garbageCollector;\n    };\n    ReferenceSet.prototype.containsKey = function (txn, key) {\n        var ref = new reference_set_DocReference(key, 0);\n        var firstRef = this.refsByKey.firstAfterOrEqual(ref);\n        return persistence_promise_PersistencePromise.resolve(firstRef !== null && key.isEqual(firstRef.key));\n    };\n    return ReferenceSet;\n}());\n\nvar reference_set_DocReference = /** @class */ (function () {\n    function DocReference(key, targetOrBatchId) {\n        this.key = key;\n        this.targetOrBatchId = targetOrBatchId;\n    }\n    /** Compare by key then by ID */\n    DocReference.compareByKey = function (left, right) {\n        return (document_key_DocumentKey.comparator(left.key, right.key) ||\n            primitiveComparator(left.targetOrBatchId, right.targetOrBatchId));\n    };\n    /** Compare by ID then by key */\n    DocReference.compareByTargetId = function (left, right) {\n        return (primitiveComparator(left.targetOrBatchId, right.targetOrBatchId) ||\n            document_key_DocumentKey.comparator(left.key, right.key));\n    };\n    return DocReference;\n}());\n\n\n//# sourceMappingURL=reference_set.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/core/target_id_generator.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar RESERVED_BITS = 1;\nvar GeneratorIds;\n(function (GeneratorIds) {\n    GeneratorIds[GeneratorIds[\"LocalStore\"] = 0] = \"LocalStore\";\n    GeneratorIds[GeneratorIds[\"SyncEngine\"] = 1] = \"SyncEngine\";\n})(GeneratorIds || (GeneratorIds = {}));\n/**\n * TargetIdGenerator generates monotonically increasing integer IDs. There are\n * separate generators for different scopes. While these generators will operate\n * independently of each other, they are scoped, such that no two generators\n * will ever produce the same ID. This is useful, because sometimes the backend\n * may group IDs from separate parts of the client into the same ID space.\n */\nvar TargetIdGenerator = /** @class */ (function () {\n    function TargetIdGenerator(generatorId, initAfter) {\n        if (initAfter === void 0) { initAfter = 0; }\n        this.generatorId = generatorId;\n        // Replace the generator part of initAfter with this generator's ID.\n        var afterWithoutGenerator = (initAfter >> RESERVED_BITS) << RESERVED_BITS;\n        var afterGenerator = initAfter - afterWithoutGenerator;\n        if (afterGenerator >= generatorId) {\n            // For example, if:\n            //   this.generatorId = 0b0000\n            //   after = 0b1011\n            //   afterGenerator = 0b0001\n            // Then:\n            //   previous = 0b1010\n            //   next = 0b1100\n            this.previousId = afterWithoutGenerator | this.generatorId;\n        }\n        else {\n            // For example, if:\n            //   this.generatorId = 0b0001\n            //   after = 0b1010\n            //   afterGenerator = 0b0000\n            // Then:\n            //   previous = 0b1001\n            //   next = 0b1011\n            this.previousId =\n                (afterWithoutGenerator | this.generatorId) - (1 << RESERVED_BITS);\n        }\n    }\n    TargetIdGenerator.prototype.next = function () {\n        this.previousId += 1 << RESERVED_BITS;\n        return this.previousId;\n    };\n    TargetIdGenerator.forLocalStore = function (initAfter) {\n        if (initAfter === void 0) { initAfter = 0; }\n        return new TargetIdGenerator(GeneratorIds.LocalStore, initAfter);\n    };\n    TargetIdGenerator.forSyncEngine = function () {\n        return new TargetIdGenerator(GeneratorIds.SyncEngine);\n    };\n    return TargetIdGenerator;\n}());\n\n\n//# sourceMappingURL=target_id_generator.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/core/view.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\nvar AddedLimboDocument = /** @class */ (function () {\n    function AddedLimboDocument(key) {\n        this.key = key;\n    }\n    return AddedLimboDocument;\n}());\n\nvar RemovedLimboDocument = /** @class */ (function () {\n    function RemovedLimboDocument(key) {\n        this.key = key;\n    }\n    return RemovedLimboDocument;\n}());\n\n/**\n * View is responsible for computing the final merged truth of what docs are in\n * a query. It gets notified of local and remote changes to docs, and applies\n * the query filters and limits to determine the most correct possible results.\n */\nvar view_View = /** @class */ (function () {\n    function View(query, \n    /** Documents included in the remote target */\n    syncedDocuments) {\n        this.query = query;\n        this.syncedDocuments = syncedDocuments;\n        this.syncState = null;\n        /**\n         * A flag whether the view is current with the backend. A view is considered\n         * current after it has seen the current flag from the backend and did not\n         * lose consistency within the watch stream (e.g. because of an existence\n         * filter mismatch).\n         */\n        this.current = false;\n        /** Documents in the view but not in the remote target */\n        this.limboDocuments = documentKeySet();\n        /** Document Keys that have local changes */\n        this.mutatedKeys = documentKeySet();\n        this.documentSet = new document_set_DocumentSet(query.docComparator.bind(query));\n    }\n    /**\n     * Iterates over a set of doc changes, applies the query limit, and computes\n     * what the new results should be, what the changes were, and whether we may\n     * need to go back to the local cache for more results. Does not make any\n     * changes to the view.\n     * @param docChanges The doc changes to apply to this view.\n     * @param previousChanges If this is being called with a refill, then start\n     *        with this set of docs and changes instead of the current view.\n     * @return a new set of docs, changes, and refill flag.\n     */\n    View.prototype.computeDocChanges = function (docChanges, previousChanges) {\n        var _this = this;\n        var changeSet = previousChanges\n            ? previousChanges.changeSet\n            : new view_snapshot_DocumentChangeSet();\n        var oldDocumentSet = previousChanges\n            ? previousChanges.documentSet\n            : this.documentSet;\n        var newMutatedKeys = previousChanges\n            ? previousChanges.mutatedKeys\n            : this.mutatedKeys;\n        var newDocumentSet = oldDocumentSet;\n        var needsRefill = false;\n        // Track the last doc in a (full) limit. This is necessary, because some\n        // update (a delete, or an update moving a doc past the old limit) might\n        // mean there is some other document in the local cache that either should\n        // come (1) between the old last limit doc and the new last document, in the\n        // case of updates, or (2) after the new last document, in the case of\n        // deletes. So we keep this doc at the old limit to compare the updates to.\n        //\n        // Note that this should never get used in a refill (when previousChanges is\n        // set), because there will only be adds -- no deletes or updates.\n        var lastDocInLimit = this.query.hasLimit() && oldDocumentSet.size === this.query.limit\n            ? oldDocumentSet.last()\n            : null;\n        docChanges.inorderTraversal(function (key, newMaybeDoc) {\n            var oldDoc = oldDocumentSet.get(key);\n            var newDoc = newMaybeDoc instanceof document_Document ? newMaybeDoc : null;\n            if (newDoc) {\n                assert(key.isEqual(newDoc.key), 'Mismatching keys found in document changes: ' +\n                    key +\n                    ' != ' +\n                    newDoc.key);\n                newDoc = _this.query.matches(newDoc) ? newDoc : null;\n            }\n            if (newDoc) {\n                newDocumentSet = newDocumentSet.add(newDoc);\n                if (newDoc.hasLocalMutations) {\n                    newMutatedKeys = newMutatedKeys.add(key);\n                }\n                else {\n                    newMutatedKeys = newMutatedKeys.delete(key);\n                }\n            }\n            else {\n                newDocumentSet = newDocumentSet.delete(key);\n                newMutatedKeys = newMutatedKeys.delete(key);\n            }\n            // Calculate change\n            if (oldDoc && newDoc) {\n                var docsEqual = oldDoc.data.isEqual(newDoc.data);\n                if (!docsEqual ||\n                    oldDoc.hasLocalMutations !== newDoc.hasLocalMutations) {\n                    // only report a change if document actually changed\n                    if (docsEqual) {\n                        changeSet.track({ type: ChangeType.Metadata, doc: newDoc });\n                    }\n                    else {\n                        changeSet.track({ type: ChangeType.Modified, doc: newDoc });\n                    }\n                    if (lastDocInLimit &&\n                        _this.query.docComparator(newDoc, lastDocInLimit) > 0) {\n                        // This doc moved from inside the limit to after the limit.\n                        // That means there may be some doc in the local cache that's\n                        // actually less than this one.\n                        needsRefill = true;\n                    }\n                }\n            }\n            else if (!oldDoc && newDoc) {\n                changeSet.track({ type: ChangeType.Added, doc: newDoc });\n            }\n            else if (oldDoc && !newDoc) {\n                changeSet.track({ type: ChangeType.Removed, doc: oldDoc });\n                if (lastDocInLimit) {\n                    // A doc was removed from a full limit query. We'll need to\n                    // requery from the local cache to see if we know about some other\n                    // doc that should be in the results.\n                    needsRefill = true;\n                }\n            }\n        });\n        if (this.query.hasLimit()) {\n            // TODO(klimt): Make DocumentSet size be constant time.\n            while (newDocumentSet.size > this.query.limit) {\n                var oldDoc = newDocumentSet.last();\n                newDocumentSet = newDocumentSet.delete(oldDoc.key);\n                changeSet.track({ type: ChangeType.Removed, doc: oldDoc });\n            }\n        }\n        assert(!needsRefill || !previousChanges, 'View was refilled using docs that themselves needed refilling.');\n        return {\n            documentSet: newDocumentSet,\n            changeSet: changeSet,\n            needsRefill: needsRefill,\n            mutatedKeys: newMutatedKeys\n        };\n    };\n    /**\n     * Updates the view with the given ViewDocumentChanges and updates limbo docs\n     * and sync state from the given (optional) target change.\n     * @param docChanges The set of changes to make to the view's docs.\n     * @param targetChange A target change to apply for computing limbo docs and\n     *        sync state.\n     * @return A new ViewChange with the given docs, changes, and sync state.\n     */\n    View.prototype.applyChanges = function (docChanges, targetChange) {\n        var _this = this;\n        assert(!docChanges.needsRefill, 'Cannot apply changes that need a refill');\n        var oldDocs = this.documentSet;\n        this.documentSet = docChanges.documentSet;\n        this.mutatedKeys = docChanges.mutatedKeys;\n        // Sort changes based on type and query comparator\n        var changes = docChanges.changeSet.getChanges();\n        changes.sort(function (c1, c2) {\n            return (compareChangeType(c1.type, c2.type) ||\n                _this.query.docComparator(c1.doc, c2.doc));\n        });\n        this.applyTargetChange(targetChange);\n        var limboChanges = this.updateLimboDocuments();\n        var synced = this.limboDocuments.size === 0 && this.current;\n        var newSyncState = synced ? SyncState.Synced : SyncState.Local;\n        var syncStateChanged = newSyncState !== this.syncState;\n        this.syncState = newSyncState;\n        if (changes.length === 0 && !syncStateChanged) {\n            // no changes\n            return { limboChanges: limboChanges };\n        }\n        else {\n            var snap = new ViewSnapshot(this.query, docChanges.documentSet, oldDocs, changes, newSyncState === SyncState.Local, !docChanges.mutatedKeys.isEmpty(), syncStateChanged);\n            return {\n                snapshot: snap,\n                limboChanges: limboChanges\n            };\n        }\n    };\n    /**\n     * Applies an OnlineState change to the view, potentially generating a\n     * ViewChange if the view's syncState changes as a result.\n     */\n    View.prototype.applyOnlineStateChange = function (onlineState) {\n        if (this.current && onlineState === OnlineState.Offline) {\n            // If we're offline, set `current` to false and then call applyChanges()\n            // to refresh our syncState and generate a ViewChange as appropriate. We\n            // are guaranteed to get a new TargetChange that sets `current` back to\n            // true once the client is back online.\n            this.current = false;\n            return this.applyChanges({\n                documentSet: this.documentSet,\n                changeSet: new view_snapshot_DocumentChangeSet(),\n                mutatedKeys: this.mutatedKeys,\n                needsRefill: false\n            });\n        }\n        else {\n            // No effect, just return a no-op ViewChange.\n            return { limboChanges: [] };\n        }\n    };\n    /**\n     * Returns whether the doc for the given key should be in limbo.\n     */\n    View.prototype.shouldBeInLimbo = function (key) {\n        // If the remote end says it's part of this query, it's not in limbo.\n        if (this.syncedDocuments.has(key)) {\n            return false;\n        }\n        // The local store doesn't think it's a result, so it shouldn't be in limbo.\n        if (!this.documentSet.has(key)) {\n            return false;\n        }\n        // If there are local changes to the doc, they might explain why the server\n        // doesn't know that it's part of the query. So don't put it in limbo.\n        // TODO(klimt): Ideally, we would only consider changes that might actually\n        // affect this specific query.\n        if (this.documentSet.get(key).hasLocalMutations) {\n            return false;\n        }\n        // Everything else is in limbo.\n        return true;\n    };\n    /**\n     * Updates syncedDocuments, current, and limbo docs based on the given change.\n     * Returns the list of changes to which docs are in limbo.\n     */\n    View.prototype.applyTargetChange = function (targetChange) {\n        if (targetChange) {\n            var targetMapping = targetChange.mapping;\n            if (targetMapping instanceof ResetMapping) {\n                this.syncedDocuments = targetMapping.documents;\n            }\n            else if (targetMapping instanceof UpdateMapping) {\n                this.syncedDocuments = targetMapping.applyToKeySet(this.syncedDocuments);\n            }\n            switch (targetChange.currentStatusUpdate) {\n                case CurrentStatusUpdate.MarkCurrent:\n                    this.current = true;\n                    break;\n                case CurrentStatusUpdate.MarkNotCurrent:\n                    this.current = false;\n                    break;\n                case CurrentStatusUpdate.None:\n                    break;\n                default:\n                    fail('Unknown current status update: ' + targetChange.currentStatusUpdate);\n            }\n        }\n    };\n    View.prototype.updateLimboDocuments = function () {\n        var _this = this;\n        // We can only determine limbo documents when we're in-sync with the server.\n        if (!this.current) {\n            return [];\n        }\n        // TODO(klimt): Do this incrementally so that it's not quadratic when\n        // updating many documents.\n        var oldLimboDocuments = this.limboDocuments;\n        this.limboDocuments = documentKeySet();\n        this.documentSet.forEach(function (doc) {\n            if (_this.shouldBeInLimbo(doc.key)) {\n                _this.limboDocuments = _this.limboDocuments.add(doc.key);\n            }\n        });\n        // Diff the new limbo docs with the old limbo docs.\n        var changes = [];\n        oldLimboDocuments.forEach(function (key) {\n            if (!_this.limboDocuments.has(key)) {\n                changes.push(new RemovedLimboDocument(key));\n            }\n        });\n        this.limboDocuments.forEach(function (key) {\n            if (!oldLimboDocuments.has(key)) {\n                changes.push(new AddedLimboDocument(key));\n            }\n        });\n        return changes;\n    };\n    return View;\n}());\n\nfunction compareChangeType(c1, c2) {\n    var order = function (change) {\n        switch (change) {\n            case ChangeType.Added:\n                return 1;\n            case ChangeType.Modified:\n                return 2;\n            case ChangeType.Metadata:\n                // A metadata change is converted to a modified change at the public\n                // api layer.  Since we sort by document key and then change type,\n                // metadata and modified changes must be sorted equivalently.\n                return 2;\n            case ChangeType.Removed:\n                return 0;\n            default:\n                return fail('Unknown ChangeType: ' + change);\n        }\n    };\n    return order(c1) - order(c2);\n}\n\n//# sourceMappingURL=view.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/core/sync_engine.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar sync_engine_LOG_TAG = 'SyncEngine';\n/**\n * QueryView contains all of the data that SyncEngine needs to keep track of for\n * a particular query.\n */\nvar QueryView = /** @class */ (function () {\n    function QueryView(\n    /**\n     * The query itself.\n     */\n    query, \n    /**\n     * The target number created by the client that is used in the watch\n     * stream to identify this query.\n     */\n    targetId, \n    /**\n     * An identifier from the datastore backend that indicates the last state\n     * of the results that was received. This can be used to indicate where\n     * to continue receiving new doc changes for the query.\n     */\n    resumeToken, \n    /**\n     * The view is responsible for computing the final merged truth of what\n     * docs are in the query. It gets notified of local and remote changes,\n     * and applies the query filters and limits to determine the most correct\n     * possible results.\n     */\n    view) {\n        this.query = query;\n        this.targetId = targetId;\n        this.resumeToken = resumeToken;\n        this.view = view;\n    }\n    return QueryView;\n}());\n/**\n * SyncEngine is the central controller in the client SDK architecture. It is\n * the glue code between the EventManager, LocalStore, and RemoteStore. Some of\n * SyncEngine's responsibilities include:\n * 1. Coordinating client requests and remote events between the EventManager\n *    and the local and remote data stores.\n * 2. Managing a View object for each query, providing the unified view between\n *    the local and remote data stores.\n * 3. Notifying the RemoteStore when the LocalStore has new mutations in its\n *    queue that need sending to the backend.\n *\n * The SyncEngines methods should only ever be called by methods running in the\n * global async queue.\n */\nvar sync_engine_SyncEngine = /** @class */ (function () {\n    function SyncEngine(localStore, remoteStore, currentUser) {\n        this.localStore = localStore;\n        this.remoteStore = remoteStore;\n        this.currentUser = currentUser;\n        this.viewHandler = null;\n        this.errorHandler = null;\n        this.queryViewsByQuery = new obj_map_ObjectMap(function (q) {\n            return q.canonicalId();\n        });\n        this.queryViewsByTarget = {};\n        this.limboTargetsByKey = new SortedMap(document_key_DocumentKey.comparator);\n        this.limboKeysByTarget = {};\n        this.limboDocumentRefs = new reference_set_ReferenceSet();\n        this.limboCollector = new eager_garbage_collector_EagerGarbageCollector();\n        /** Stores user completion handlers, indexed by User and BatchId. */\n        this.mutationUserCallbacks = {};\n        this.targetIdGenerator = TargetIdGenerator.forSyncEngine();\n    }\n    /** Subscribes view and error handler. Can be called only once. */\n    SyncEngine.prototype.subscribe = function (viewHandler, errorHandler) {\n        assert(viewHandler !== null && errorHandler !== null, 'View and error handlers cannot be null');\n        assert(this.viewHandler === null && this.errorHandler === null, 'SyncEngine already has a subscriber.');\n        this.viewHandler = viewHandler;\n        this.errorHandler = errorHandler;\n        this.limboCollector.addGarbageSource(this.limboDocumentRefs);\n    };\n    /**\n     * Initiates the new listen, resolves promise when listen enqueued to the\n     * server. All the subsequent view snapshots or errors are sent to the\n     * subscribed handlers. Returns the targetId of the query.\n     */\n    SyncEngine.prototype.listen = function (query) {\n        var _this = this;\n        this.assertSubscribed('listen()');\n        assert(!this.queryViewsByQuery.has(query), 'We already listen to the query: ' + query);\n        return this.localStore.allocateQuery(query).then(function (queryData) {\n            return _this.localStore\n                .executeQuery(query)\n                .then(function (docs) {\n                return _this.localStore\n                    .remoteDocumentKeys(queryData.targetId)\n                    .then(function (remoteKeys) {\n                    var view = new view_View(query, remoteKeys);\n                    var viewDocChanges = view.computeDocChanges(docs);\n                    var viewChange = view.applyChanges(viewDocChanges);\n                    assert(viewChange.limboChanges.length === 0, 'View returned limbo docs before target ack from the server.');\n                    assert(!!viewChange.snapshot, 'applyChanges for new view should always return a snapshot');\n                    var data = new QueryView(query, queryData.targetId, queryData.resumeToken, view);\n                    _this.queryViewsByQuery.set(query, data);\n                    _this.queryViewsByTarget[queryData.targetId] = data;\n                    _this.viewHandler([viewChange.snapshot]);\n                    _this.remoteStore.listen(queryData);\n                });\n            })\n                .then(function () {\n                return queryData.targetId;\n            });\n        });\n    };\n    /** Stops listening to the query. */\n    SyncEngine.prototype.unlisten = function (query) {\n        var _this = this;\n        this.assertSubscribed('unlisten()');\n        var queryView = this.queryViewsByQuery.get(query);\n        assert(!!queryView, 'Trying to unlisten on query not found:' + query);\n        return this.localStore.releaseQuery(query).then(function () {\n            _this.remoteStore.unlisten(queryView.targetId);\n            return _this.removeAndCleanupQuery(queryView).then(function () {\n                return _this.localStore.collectGarbage();\n            });\n        });\n    };\n    /**\n     * Initiates the write of local mutation batch which involves adding the\n     * writes to the mutation queue, notifying the remote store about new\n     * mutations and raising events for any changes this write caused.\n     *\n     * The promise returned by this call is resolved when the above steps\n     * have completed, *not* when the write was acked by the backend. The\n     * userCallback is resolved once the write was acked/rejected by the\n     * backend (or failed locally for any other reason).\n     */\n    SyncEngine.prototype.write = function (batch, userCallback) {\n        var _this = this;\n        this.assertSubscribed('write()');\n        return this.localStore\n            .localWrite(batch)\n            .then(function (result) {\n            _this.addMutationCallback(result.batchId, userCallback);\n            return _this.emitNewSnapsAndNotifyLocalStore(result.changes);\n        })\n            .then(function () {\n            return _this.remoteStore.fillWritePipeline();\n        });\n    };\n    // TODO(klimt): Wrap the given error in a standard Firestore error object.\n    SyncEngine.prototype.wrapUpdateFunctionError = function (error) {\n        return error;\n    };\n    /**\n     * Takes an updateFunction in which a set of reads and writes can be performed\n     * atomically. In the updateFunction, the client can read and write values\n     * using the supplied transaction object. After the updateFunction, all\n     * changes will be committed. If some other client has changed any of the data\n     * referenced, then the updateFunction will be called again. If the\n     * updateFunction still fails after the given number of retries, then the\n     * transaction will be rejection.\n     *\n     * The transaction object passed to the updateFunction contains methods for\n     * accessing documents and collections. Unlike other datastore access, data\n     * accessed with the transaction will not reflect local changes that have not\n     * been committed. For this reason, it is required that all reads are\n     * performed before any writes. Transactions must be performed while online.\n     *\n     * The promise returned is resolved when the transaction is fully committed.\n     */\n    SyncEngine.prototype.runTransaction = function (updateFunction, retries) {\n        var _this = this;\n        if (retries === void 0) { retries = 5; }\n        assert(retries >= 0, 'Got negative number of retries for transaction.');\n        var transaction = this.remoteStore.createTransaction();\n        var wrappedUpdateFunction = function () {\n            try {\n                var userPromise = updateFunction(transaction);\n                if (isNullOrUndefined(userPromise) ||\n                    !userPromise.catch ||\n                    !userPromise.then) {\n                    return Promise.reject(Error('Transaction callback must return a Promise'));\n                }\n                return userPromise.catch(function (e) {\n                    return Promise.reject(_this.wrapUpdateFunctionError(e));\n                });\n            }\n            catch (e) {\n                return Promise.reject(_this.wrapUpdateFunctionError(e));\n            }\n        };\n        return wrappedUpdateFunction().then(function (result) {\n            return transaction\n                .commit()\n                .then(function () {\n                return result;\n            })\n                .catch(function (error) {\n                if (retries === 0) {\n                    return Promise.reject(error);\n                }\n                // TODO(klimt): Put in a retry delay?\n                return _this.runTransaction(updateFunction, retries - 1);\n            });\n        });\n    };\n    SyncEngine.prototype.applyRemoteEvent = function (remoteEvent) {\n        var _this = this;\n        this.assertSubscribed('applyRemoteEvent()');\n        // Make sure limbo documents are deleted if there were no results\n        forEachNumber(remoteEvent.targetChanges, function (targetId, targetChange) {\n            var limboKey = _this.limboKeysByTarget[targetId];\n            if (limboKey &&\n                targetChange.currentStatusUpdate ===\n                    CurrentStatusUpdate.MarkCurrent &&\n                !remoteEvent.documentUpdates.get(limboKey)) {\n                // When listening to a query the server responds with a snapshot\n                // containing documents matching the query and a current marker\n                // telling us we're now in sync. It's possible for these to arrive\n                // as separate remote events or as a single remote event.\n                // For a document query, there will be no documents sent in the\n                // response if the document doesn't exist.\n                //\n                // If the snapshot arrives separately from the current marker,\n                // we handle it normally and updateTrackedLimbos will resolve the\n                // limbo status of the document, removing it from limboDocumentRefs.\n                // This works because clients only initiate limbo resolution when\n                // a target is current and because all current targets are\n                // always at a consistent snapshot.\n                //\n                // However, if the document doesn't exist and the current marker\n                // arrives, the document is not present in the snapshot and our\n                // normal view handling would consider the document to remain in\n                // limbo indefinitely because there are no updates to the document.\n                // To avoid this, we specially handle this just this case here:\n                // synthesizing a delete.\n                //\n                // TODO(dimond): Ideally we would have an explicit lookup query\n                // instead resulting in an explicit delete message and we could\n                // remove this special logic.\n                remoteEvent.addDocumentUpdate(new document_NoDocument(limboKey, remoteEvent.snapshotVersion));\n            }\n        });\n        return this.localStore.applyRemoteEvent(remoteEvent).then(function (changes) {\n            return _this.emitNewSnapsAndNotifyLocalStore(changes, remoteEvent);\n        });\n    };\n    /**\n     * Applies an OnlineState change to the sync engine and notifies any views of\n     * the change.\n     */\n    SyncEngine.prototype.applyOnlineStateChange = function (onlineState) {\n        var newViewSnapshots = [];\n        this.queryViewsByQuery.forEach(function (query, queryView) {\n            var viewChange = queryView.view.applyOnlineStateChange(onlineState);\n            assert(viewChange.limboChanges.length === 0, 'OnlineState should not affect limbo documents.');\n            if (viewChange.snapshot) {\n                newViewSnapshots.push(viewChange.snapshot);\n            }\n        });\n        this.viewHandler(newViewSnapshots);\n    };\n    SyncEngine.prototype.rejectListen = function (targetId, err) {\n        var _this = this;\n        this.assertSubscribed('rejectListens()');\n        var limboKey = this.limboKeysByTarget[targetId];\n        if (limboKey) {\n            // Since this query failed, we won't want to manually unlisten to it.\n            // So go ahead and remove it from bookkeeping.\n            this.limboTargetsByKey = this.limboTargetsByKey.remove(limboKey);\n            delete this.limboKeysByTarget[targetId];\n            // TODO(klimt): We really only should do the following on permission\n            // denied errors, but we don't have the cause code here.\n            // It's a limbo doc. Create a synthetic event saying it was deleted.\n            // This is kind of a hack. Ideally, we would have a method in the local\n            // store to purge a document. However, it would be tricky to keep all of\n            // the local store's invariants with another method.\n            var docMap = new SortedMap(document_key_DocumentKey.comparator);\n            docMap = docMap.insert(limboKey, new document_NoDocument(limboKey, snapshot_version_SnapshotVersion.forDeletedDoc()));\n            var event_1 = new remote_event_RemoteEvent(snapshot_version_SnapshotVersion.MIN, {}, docMap);\n            return this.applyRemoteEvent(event_1);\n        }\n        else {\n            var queryView_1 = this.queryViewsByTarget[targetId];\n            assert(!!queryView_1, 'Unknown targetId: ' + targetId);\n            return this.localStore.releaseQuery(queryView_1.query).then(function () {\n                return _this.removeAndCleanupQuery(queryView_1).then(function () {\n                    _this.errorHandler(queryView_1.query, err);\n                });\n            });\n        }\n    };\n    SyncEngine.prototype.applySuccessfulWrite = function (mutationBatchResult) {\n        var _this = this;\n        this.assertSubscribed('applySuccessfulWrite()');\n        // The local store may or may not be able to apply the write result and\n        // raise events immediately (depending on whether the watcher is caught\n        // up), so we raise user callbacks first so that they consistently happen\n        // before listen events.\n        this.processUserCallback(mutationBatchResult.batch.batchId, \n        /*error=*/ null);\n        return this.localStore\n            .acknowledgeBatch(mutationBatchResult)\n            .then(function (changes) {\n            return _this.emitNewSnapsAndNotifyLocalStore(changes);\n        });\n    };\n    SyncEngine.prototype.rejectFailedWrite = function (batchId, error) {\n        var _this = this;\n        this.assertSubscribed('rejectFailedWrite()');\n        // The local store may or may not be able to apply the write result and\n        // raise events immediately (depending on whether the watcher is caught up),\n        // so we raise user callbacks first so that they consistently happen before\n        // listen events.\n        this.processUserCallback(batchId, error);\n        return this.localStore.rejectBatch(batchId).then(function (changes) {\n            return _this.emitNewSnapsAndNotifyLocalStore(changes);\n        });\n    };\n    SyncEngine.prototype.addMutationCallback = function (batchId, callback) {\n        var newCallbacks = this.mutationUserCallbacks[this.currentUser.toKey()];\n        if (!newCallbacks) {\n            newCallbacks = new SortedMap(primitiveComparator);\n        }\n        newCallbacks = newCallbacks.insert(batchId, callback);\n        this.mutationUserCallbacks[this.currentUser.toKey()] = newCallbacks;\n    };\n    /**\n     * Resolves or rejects the user callback for the given batch and then discards\n     * it.\n     */\n    SyncEngine.prototype.processUserCallback = function (batchId, error) {\n        var newCallbacks = this.mutationUserCallbacks[this.currentUser.toKey()];\n        // NOTE: Mutations restored from persistence won't have callbacks, so it's\n        // okay for there to be no callback for this ID.\n        if (newCallbacks) {\n            var callback = newCallbacks.get(batchId);\n            if (callback) {\n                assert(batchId === newCallbacks.minKey(), 'Mutation callbacks processed out-of-order?');\n                if (error) {\n                    callback.reject(error);\n                }\n                else {\n                    callback.resolve();\n                }\n                newCallbacks = newCallbacks.remove(batchId);\n            }\n            this.mutationUserCallbacks[this.currentUser.toKey()] = newCallbacks;\n        }\n    };\n    SyncEngine.prototype.removeAndCleanupQuery = function (queryView) {\n        this.queryViewsByQuery.delete(queryView.query);\n        delete this.queryViewsByTarget[queryView.targetId];\n        this.limboDocumentRefs.removeReferencesForId(queryView.targetId);\n        return this.gcLimboDocuments();\n    };\n    SyncEngine.prototype.updateTrackedLimbos = function (targetId, limboChanges) {\n        for (var _i = 0, limboChanges_1 = limboChanges; _i < limboChanges_1.length; _i++) {\n            var limboChange = limboChanges_1[_i];\n            if (limboChange instanceof AddedLimboDocument) {\n                this.limboDocumentRefs.addReference(limboChange.key, targetId);\n                this.trackLimboChange(limboChange);\n            }\n            else if (limboChange instanceof RemovedLimboDocument) {\n                debug(sync_engine_LOG_TAG, 'Document no longer in limbo: ' + limboChange.key);\n                this.limboDocumentRefs.removeReference(limboChange.key, targetId);\n            }\n            else {\n                fail('Unknown limbo change: ' + JSON.stringify(limboChange));\n            }\n        }\n        return this.gcLimboDocuments();\n    };\n    SyncEngine.prototype.trackLimboChange = function (limboChange) {\n        var key = limboChange.key;\n        if (!this.limboTargetsByKey.get(key)) {\n            debug(sync_engine_LOG_TAG, 'New document in limbo: ' + key);\n            var limboTargetId = this.targetIdGenerator.next();\n            var query = query_Query.atPath(key.path);\n            this.limboKeysByTarget[limboTargetId] = key;\n            this.remoteStore.listen(new query_data_QueryData(query, limboTargetId, QueryPurpose.Listen));\n            this.limboTargetsByKey = this.limboTargetsByKey.insert(key, limboTargetId);\n        }\n    };\n    SyncEngine.prototype.gcLimboDocuments = function () {\n        var _this = this;\n        // HACK: We can use a null transaction here, because we know that the\n        // reference set is entirely within memory and doesn't need a store engine.\n        return this.limboCollector\n            .collectGarbage(null)\n            .next(function (keys) {\n            keys.forEach(function (key) {\n                var limboTargetId = _this.limboTargetsByKey.get(key);\n                if (limboTargetId === null) {\n                    // This target already got removed, because the query failed.\n                    return;\n                }\n                _this.remoteStore.unlisten(limboTargetId);\n                _this.limboTargetsByKey = _this.limboTargetsByKey.remove(key);\n                delete _this.limboKeysByTarget[limboTargetId];\n            });\n        })\n            .toPromise();\n    };\n    // Visible for testing\n    SyncEngine.prototype.currentLimboDocs = function () {\n        return this.limboTargetsByKey;\n    };\n    SyncEngine.prototype.emitNewSnapsAndNotifyLocalStore = function (changes, remoteEvent) {\n        var _this = this;\n        var newSnaps = [];\n        var docChangesInAllViews = [];\n        var queriesProcessed = [];\n        this.queryViewsByQuery.forEach(function (_, queryView) {\n            queriesProcessed.push(Promise.resolve()\n                .then(function () {\n                var viewDocChanges = queryView.view.computeDocChanges(changes);\n                if (!viewDocChanges.needsRefill) {\n                    return viewDocChanges;\n                }\n                // The query has a limit and some docs were removed, so we need\n                // to re-run the query against the local store to make sure we\n                // didn't lose any good docs that had been past the limit.\n                return _this.localStore.executeQuery(queryView.query).then(function (docs) {\n                    return queryView.view.computeDocChanges(docs, viewDocChanges);\n                });\n            })\n                .then(function (viewDocChanges) {\n                var targetChange = remoteEvent && remoteEvent.targetChanges[queryView.targetId];\n                var viewChange = queryView.view.applyChanges(viewDocChanges, targetChange);\n                return _this.updateTrackedLimbos(queryView.targetId, viewChange.limboChanges).then(function () {\n                    if (viewChange.snapshot) {\n                        newSnaps.push(viewChange.snapshot);\n                        var docChanges = local_view_changes_LocalViewChanges.fromSnapshot(viewChange.snapshot);\n                        docChangesInAllViews.push(docChanges);\n                    }\n                });\n            }));\n        });\n        return Promise.all(queriesProcessed)\n            .then(function () {\n            _this.viewHandler(newSnaps);\n            return _this.localStore.notifyLocalViewChanges(docChangesInAllViews);\n        })\n            .then(function () {\n            return _this.localStore.collectGarbage();\n        });\n    };\n    SyncEngine.prototype.assertSubscribed = function (fnName) {\n        assert(this.viewHandler !== null && this.errorHandler !== null, 'Trying to call ' + fnName + ' before calling subscribe().');\n    };\n    SyncEngine.prototype.handleUserChange = function (user) {\n        var _this = this;\n        this.currentUser = user;\n        return this.localStore\n            .handleUserChange(user)\n            .then(function (changes) {\n            return _this.emitNewSnapsAndNotifyLocalStore(changes);\n        })\n            .then(function () {\n            return _this.remoteStore.handleUserChange(user);\n        });\n    };\n    return SyncEngine;\n}());\n\n\n//# sourceMappingURL=sync_engine.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/model/mutation_batch.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\nvar BATCHID_UNKNOWN = -1;\n/**\n * A batch of mutations that will be sent as one unit to the backend.\n */\nvar mutation_batch_MutationBatch = /** @class */ (function () {\n    function MutationBatch(batchId, localWriteTime, mutations) {\n        this.batchId = batchId;\n        this.localWriteTime = localWriteTime;\n        this.mutations = mutations;\n    }\n    /**\n     * Applies all the mutations in this MutationBatch to the specified document\n     * to create a new remote document\n     *\n     * @param docKey The key of the document to apply mutations to.\n     * @param maybeDoc The document to apply mutations to.\n     * @param batchResult The result of applying the MutationBatch to the\n     * backend.\n     */\n    MutationBatch.prototype.applyToRemoteDocument = function (docKey, maybeDoc, batchResult) {\n        if (maybeDoc) {\n            assert(maybeDoc.key.isEqual(docKey), \"applyToRemoteDocument: key \" + docKey + \" should match maybeDoc key\\n        \" + maybeDoc.key);\n        }\n        var mutationResults = batchResult.mutationResults;\n        assert(mutationResults.length === this.mutations.length, \"Mismatch between mutations length\\n      (\" + this.mutations.length + \") and mutation results length\\n      (\" + mutationResults.length + \").\");\n        for (var i = 0; i < this.mutations.length; i++) {\n            var mutation = this.mutations[i];\n            if (mutation.key.isEqual(docKey)) {\n                var mutationResult = mutationResults[i];\n                maybeDoc = mutation.applyToRemoteDocument(maybeDoc, mutationResult);\n            }\n        }\n        return maybeDoc;\n    };\n    /**\n     * Computes the local view of a document given all the mutations in this\n     * batch.\n     *\n     * @param docKey The key of the document to apply mutations to.\n     * @param maybeDoc The document to apply mutations to.\n     */\n    MutationBatch.prototype.applyToLocalView = function (docKey, maybeDoc) {\n        if (maybeDoc) {\n            assert(maybeDoc.key.isEqual(docKey), \"applyToLocalDocument: key \" + docKey + \" should match maybeDoc key\\n        \" + maybeDoc.key);\n        }\n        var baseDoc = maybeDoc;\n        for (var i = 0; i < this.mutations.length; i++) {\n            var mutation = this.mutations[i];\n            if (mutation.key.isEqual(docKey)) {\n                maybeDoc = mutation.applyToLocalView(maybeDoc, baseDoc, this.localWriteTime);\n            }\n        }\n        return maybeDoc;\n    };\n    MutationBatch.prototype.keys = function () {\n        var keySet = documentKeySet();\n        for (var _i = 0, _a = this.mutations; _i < _a.length; _i++) {\n            var mutation = _a[_i];\n            keySet = keySet.add(mutation.key);\n        }\n        return keySet;\n    };\n    MutationBatch.prototype.isEqual = function (other) {\n        return (this.batchId === other.batchId &&\n            arrayEquals(this.mutations, other.mutations));\n    };\n    /**\n     * Returns true if this mutation batch has already been removed from the\n     * mutation queue.\n     *\n     * Note that not all implementations of the MutationQueue necessarily use\n     * tombstones as part of their implementation and generally speaking no code\n     * outside the mutation queues should really care about this.\n     */\n    MutationBatch.prototype.isTombstone = function () {\n        return this.mutations.length === 0;\n    };\n    /** Converts this batch into a tombstone */\n    MutationBatch.prototype.toTombstone = function () {\n        return new MutationBatch(this.batchId, this.localWriteTime, []);\n    };\n    return MutationBatch;\n}());\n\n/** The result of applying a mutation batch to the backend. */\nvar mutation_batch_MutationBatchResult = /** @class */ (function () {\n    function MutationBatchResult(batch, commitVersion, mutationResults, streamToken, \n    /**\n     * A pre-computed mapping from each mutated document to the resulting\n     * version.\n     */\n    docVersions) {\n        this.batch = batch;\n        this.commitVersion = commitVersion;\n        this.mutationResults = mutationResults;\n        this.streamToken = streamToken;\n        this.docVersions = docVersions;\n    }\n    /**\n     * Creates a new MutationBatchResult for the given batch and results. There\n     * must be one result for each mutation in the batch. This static factory\n     * caches a document=>version mapping (docVersions).\n     */\n    MutationBatchResult.from = function (batch, commitVersion, results, streamToken) {\n        assert(batch.mutations.length === results.length, 'Mutations sent ' +\n            batch.mutations.length +\n            ' must equal results received ' +\n            results.length);\n        var versionMap = documentVersionMap();\n        var mutations = batch.mutations;\n        for (var i = 0; i < mutations.length; i++) {\n            var version = results[i].version;\n            if (version === null) {\n                // deletes don't have a version, so we substitute the commitVersion\n                // of the entire batch.\n                version = commitVersion;\n            }\n            versionMap = versionMap.insert(mutations[i].key, version);\n        }\n        return new MutationBatchResult(batch, commitVersion, results, streamToken, versionMap);\n    };\n    return MutationBatchResult;\n}());\n\n\n//# sourceMappingURL=mutation_batch.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/encoded_resource_path.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nvar escapeChar = '\\u0001';\nvar encodedSeparatorChar = '\\u0001';\nvar encodedNul = '\\u0010';\nvar encodedEscape = '\\u0011';\n/**\n * Encodes a resource path into a IndexedDb-compatible string form.\n */\nfunction encode(path) {\n    var result = '';\n    for (var i = 0; i < path.length; i++) {\n        if (result.length > 0) {\n            result = encodeSeparator(result);\n        }\n        result = encodeSegment(path.get(i), result);\n    }\n    return encodeSeparator(result);\n}\n/** Encodes a single segment of a resource path into the given result */\nfunction encodeSegment(segment, resultBuf) {\n    var result = resultBuf;\n    var length = segment.length;\n    for (var i = 0; i < length; i++) {\n        var c = segment.charAt(i);\n        switch (c) {\n            case '\\0':\n                result += escapeChar + encodedNul;\n                break;\n            case escapeChar:\n                result += escapeChar + encodedEscape;\n                break;\n            default:\n                result += c;\n        }\n    }\n    return result;\n}\n/** Encodes a path separator into the given result */\nfunction encodeSeparator(result) {\n    return result + escapeChar + encodedSeparatorChar;\n}\n/**\n * Decodes the given IndexedDb-compatible string form of a resource path into\n * a ResourcePath instance. Note that this method is not suitable for use with\n * decoding resource names from the server; those are One Platform format\n * strings.\n */\nfunction decode(path) {\n    // Event the empty path must encode as a path of at least length 2. A path\n    // with exactly 2 must be the empty path.\n    var length = path.length;\n    assert(length >= 2, 'Invalid path ' + path);\n    if (length === 2) {\n        assert(path.charAt(0) === escapeChar && path.charAt(1) === encodedSeparatorChar, 'Non-empty path ' + path + ' had length 2');\n        return path_ResourcePath.EMPTY_PATH;\n    }\n    // Escape characters cannot exist past the second-to-last position in the\n    // source value.\n    var lastReasonableEscapeIndex = length - 2;\n    var segments = [];\n    var segmentBuilder = '';\n    for (var start = 0; start < length;) {\n        // The last two characters of a valid encoded path must be a separator, so\n        // there must be an end to this segment.\n        var end = path.indexOf(escapeChar, start);\n        if (end < 0 || end > lastReasonableEscapeIndex) {\n            fail('Invalid encoded resource path: \"' + path + '\"');\n        }\n        var next = path.charAt(end + 1);\n        switch (next) {\n            case encodedSeparatorChar:\n                var currentPiece = path.substring(start, end);\n                var segment = void 0;\n                if (segmentBuilder.length === 0) {\n                    // Avoid copying for the common case of a segment that excludes \\0\n                    // and \\001\n                    segment = currentPiece;\n                }\n                else {\n                    segmentBuilder += currentPiece;\n                    segment = segmentBuilder;\n                    segmentBuilder = '';\n                }\n                segments.push(segment);\n                break;\n            case encodedNul:\n                segmentBuilder += path.substring(start, end);\n                segmentBuilder += '\\0';\n                break;\n            case encodedEscape:\n                // The escape character can be used in the output to encode itself.\n                segmentBuilder += path.substring(start, end + 1);\n                break;\n            default:\n                fail('Invalid encoded resource path: \"' + path + '\"');\n        }\n        start = end + 2;\n    }\n    return new path_ResourcePath(segments);\n}\n/**\n * Computes the prefix successor of the given path, computed by encode above.\n * A prefix successor is the first key that cannot be prefixed by the given\n * path. It's useful for defining the end of a prefix scan such that all keys\n * in the scan have the same prefix.\n *\n * Note that this is not a general prefix successor implementation, which is\n * tricky to get right with Strings, given that they encode down to UTF-8.\n * Instead this relies on the fact that all paths encoded by this class are\n * always terminated with a separator, and so a successor can always be\n * cheaply computed by incrementing the last character of the path.\n */\nfunction prefixSuccessor(path) {\n    var c = path.charCodeAt(path.length - 1);\n    // TODO(mcg): this really should be a general thing, but not worth it right\n    // now\n    assert(c === 1, 'successor may only operate on paths generated by encode');\n    return path.substring(0, path.length - 1) + String.fromCharCode(c + 1);\n}\n\n//# sourceMappingURL=encoded_resource_path.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/indexeddb_schema.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n/**\n * Schema Version for the Web client:\n * 1. Initial version including Mutation Queue, Query Cache, and Remote Document\n *    Cache\n * 2. Added targetCount to targetGlobal row.\n */\nvar SCHEMA_VERSION = 2;\n/**\n * Performs database creation and schema upgrades.\n *\n * Note that in production, this method is only ever used to upgrade the schema\n * to SCHEMA_VERSION. Different values of toVersion are only used for testing\n * and local feature development.\n */\nfunction createOrUpgradeDb(db, txn, fromVersion, toVersion) {\n    // This function currently supports migrating to schema version 1 (Mutation\n    // Queue, Query and Remote Document Cache) and schema version 2 (Query\n    // counting).\n    assert(fromVersion < toVersion && fromVersion >= 0 && toVersion <= 2, 'Unexpected schema upgrade from v${fromVersion} to v{toVersion}.');\n    if (fromVersion < 1 && toVersion >= 1) {\n        createOwnerStore(db);\n        createMutationQueue(db);\n        createQueryCache(db);\n        createRemoteDocumentCache(db);\n    }\n    var p = persistence_promise_PersistencePromise.resolve();\n    if (fromVersion < 2 && toVersion >= 2) {\n        p = ensureTargetGlobalExists(txn).next(function (targetGlobal) {\n            return saveTargetCount(txn, targetGlobal);\n        });\n    }\n    return p;\n}\n/**\n * Wrapper class to store timestamps (seconds and nanos) in IndexedDb objects.\n */\nvar DbTimestamp = /** @class */ (function () {\n    function DbTimestamp(seconds, nanos) {\n        this.seconds = seconds;\n        this.nanos = nanos;\n    }\n    return DbTimestamp;\n}());\n\n/**\n * A singleton object to be stored in the 'owner' store in IndexedDb.\n *\n * A given database can be owned by a single tab at a given time. That tab\n * must validate that it is still the owner before every write operation and\n * should regularly write an updated timestamp to prevent other tabs from\n * \"stealing\" ownership of the db.\n */\nvar DbOwner = /** @class */ (function () {\n    function DbOwner(ownerId, leaseTimestampMs) {\n        this.ownerId = ownerId;\n        this.leaseTimestampMs = leaseTimestampMs;\n    }\n    /** Name of the IndexedDb object store. */\n    DbOwner.store = 'owner';\n    return DbOwner;\n}());\n\nfunction createOwnerStore(db) {\n    db.createObjectStore(DbOwner.store);\n}\n/**\n * An object to be stored in the 'mutationQueues' store in IndexedDb.\n *\n * Each user gets a single queue of MutationBatches to apply to the server.\n * DbMutationQueue tracks the metadata about the queue.\n */\nvar DbMutationQueue = /** @class */ (function () {\n    function DbMutationQueue(\n    /**\n     * The normalized user ID to which this queue belongs.\n     */\n    userId, \n    /**\n     * An identifier for the highest numbered batch that has been acknowledged\n     * by the server. All MutationBatches in this queue with batchIds less\n     * than or equal to this value are considered to have been acknowledged by\n     * the server.\n     */\n    lastAcknowledgedBatchId, \n    /**\n     * A stream token that was previously sent by the server.\n     *\n     * See StreamingWriteRequest in datastore.proto for more details about\n     * usage.\n     *\n     * After sending this token, earlier tokens may not be used anymore so\n     * only a single stream token is retained.\n     */\n    lastStreamToken) {\n        this.userId = userId;\n        this.lastAcknowledgedBatchId = lastAcknowledgedBatchId;\n        this.lastStreamToken = lastStreamToken;\n    }\n    /** Name of the IndexedDb object store.  */\n    DbMutationQueue.store = 'mutationQueues';\n    /** Keys are automatically assigned via the userId property. */\n    DbMutationQueue.keyPath = 'userId';\n    return DbMutationQueue;\n}());\n\n/**\n * An object to be stored in the 'mutations' store in IndexedDb.\n *\n * Represents a batch of user-level mutations intended to be sent to the server\n * in a single write. Each user-level batch gets a separate DbMutationBatch\n * with a new batchId.\n */\nvar DbMutationBatch = /** @class */ (function () {\n    function DbMutationBatch(\n    /**\n     * The normalized user ID to which this batch belongs.\n     */\n    userId, \n    /**\n     * An identifier for this batch, allocated by the mutation queue in a\n     * monotonically increasing manner.\n     */\n    batchId, \n    /**\n     * The local write time of the batch, stored as milliseconds since the\n     * epoch.\n     */\n    localWriteTimeMs, \n    /**\n     * A list of mutations to apply. All mutations will be applied atomically.\n     *\n     * Mutations are serialized via JsonProtoSerializer.toMutation().\n     */\n    mutations) {\n        this.userId = userId;\n        this.batchId = batchId;\n        this.localWriteTimeMs = localWriteTimeMs;\n        this.mutations = mutations;\n    }\n    /** Name of the IndexedDb object store.  */\n    DbMutationBatch.store = 'mutations';\n    /** Keys are automatically assigned via the userId, batchId properties. */\n    DbMutationBatch.keyPath = ['userId', 'batchId'];\n    return DbMutationBatch;\n}());\n\nfunction createMutationQueue(db) {\n    db.createObjectStore(DbMutationQueue.store, {\n        keyPath: DbMutationQueue.keyPath\n    });\n    db.createObjectStore(DbMutationBatch.store, {\n        keyPath: DbMutationBatch.keyPath\n    });\n    db.createObjectStore(indexeddb_schema_DbDocumentMutation.store);\n}\n/**\n * An object to be stored in the 'documentMutations' store in IndexedDb.\n *\n * A manually maintained index of all the mutation batches that affect a given\n * document key. The rows in this table are references based on the contents of\n * DbMutationBatch.mutations.\n */\nvar indexeddb_schema_DbDocumentMutation = /** @class */ (function () {\n    function DbDocumentMutation() {\n    }\n    /**\n     * Creates a [userId] key for use in the DbDocumentMutations index to iterate\n     * over all of a user's document mutations.\n     */\n    DbDocumentMutation.prefixForUser = function (userId) {\n        return [userId];\n    };\n    /**\n     * Creates a [userId, encodedPath] key for use in the DbDocumentMutations\n     * index to iterate over all at document mutations for a given path or lower.\n     */\n    DbDocumentMutation.prefixForPath = function (userId, path) {\n        return [userId, encode(path)];\n    };\n    /**\n     * Creates a full index key of [userId, encodedPath, batchId] for inserting\n     * and deleting into the DbDocumentMutations index.\n     */\n    DbDocumentMutation.key = function (userId, path, batchId) {\n        return [userId, encode(path), batchId];\n    };\n    DbDocumentMutation.store = 'documentMutations';\n    /**\n     * Because we store all the useful information for this store in the key,\n     * there is no useful information to store as the value. The raw (unencoded)\n     * path cannot be stored because IndexedDb doesn't store prototype\n     * information.\n     */\n    DbDocumentMutation.PLACEHOLDER = new DbDocumentMutation();\n    return DbDocumentMutation;\n}());\n\nfunction createRemoteDocumentCache(db) {\n    db.createObjectStore(DbRemoteDocument.store);\n}\n/**\n * Represents the known absence of a document at a particular version.\n * Stored in IndexedDb as part of a DbRemoteDocument object.\n */\nvar DbNoDocument = /** @class */ (function () {\n    function DbNoDocument(path, readTime) {\n        this.path = path;\n        this.readTime = readTime;\n    }\n    return DbNoDocument;\n}());\n\n/**\n * An object to be stored in the 'remoteDocuments' store in IndexedDb. It\n * represents either a cached document (if it exists) or a cached \"no-document\"\n * (if it is known to not exist).\n *\n * Note: This is the persisted equivalent of a MaybeDocument and could perhaps\n * be made more general if necessary.\n */\nvar DbRemoteDocument = /** @class */ (function () {\n    function DbRemoteDocument(\n    /**\n     * Set to an instance of a DbNoDocument if it is known that no document\n     * exists.\n     */\n    noDocument, \n    /**\n     * Set to an instance of a Document if there's a cached version of the\n     * document.\n     */\n    document) {\n        this.noDocument = noDocument;\n        this.document = document;\n    }\n    DbRemoteDocument.store = 'remoteDocuments';\n    return DbRemoteDocument;\n}());\n\n/**\n * An object to be stored in the 'targets' store in IndexedDb.\n *\n * This is based on and should be kept in sync with the proto used in the iOS\n * client.\n *\n * Each query the client listens to against the server is tracked on disk so\n * that the query can be efficiently resumed on restart.\n */\nvar DbTarget = /** @class */ (function () {\n    function DbTarget(\n    /**\n     * An auto-generated sequential numeric identifier for the query.\n     *\n     * Queries are stored using their canonicalId as the key, but these\n     * canonicalIds can be quite long so we additionally assign a unique\n     * queryId which can be used by referenced data structures (e.g.\n     * indexes) to minimize the on-disk cost.\n     */\n    targetId, \n    /**\n     * The canonical string representing this query. This is not unique.\n     */\n    canonicalId, \n    /**\n     * The last readTime received from the Watch Service for this query.\n     *\n     * This is the same value as TargetChange.read_time in the protos.\n     */\n    readTime, \n    /**\n     * An opaque, server-assigned token that allows watching a query to be\n     * resumed after disconnecting without retransmitting all the data\n     * that matches the query. The resume token essentially identifies a\n     * point in time from which the server should resume sending results.\n     *\n     * This is related to the snapshotVersion in that the resumeToken\n     * effectively also encodes that value, but the resumeToken is opaque\n     * and sometimes encodes additional information.\n     *\n     * A consequence of this is that the resumeToken should be used when\n     * asking the server to reason about where this client is in the watch\n     * stream, but the client should use the snapshotVersion for its own\n     * purposes.\n     *\n     * This is the same value as TargetChange.resume_token in the protos.\n     */\n    resumeToken, \n    /**\n     * A sequence number representing the last time this query was\n     * listened to, used for garbage collection purposes.\n     *\n     * Conventionally this would be a timestamp value, but device-local\n     * clocks are unreliable and they must be able to create new listens\n     * even while disconnected. Instead this should be a monotonically\n     * increasing number that's incremented on each listen call.\n     *\n     * This is different from the queryId since the queryId is an\n     * immutable identifier assigned to the Query on first use while\n     * lastListenSequenceNumber is updated every time the query is\n     * listened to.\n     */\n    lastListenSequenceNumber, \n    /**\n     * The query for this target.\n     *\n     * Because canonical ids are not unique we must store the actual query. We\n     * use the proto to have an object we can persist without having to\n     * duplicate translation logic to and from a `Query` object.\n     */\n    query) {\n        this.targetId = targetId;\n        this.canonicalId = canonicalId;\n        this.readTime = readTime;\n        this.resumeToken = resumeToken;\n        this.lastListenSequenceNumber = lastListenSequenceNumber;\n        this.query = query;\n    }\n    DbTarget.store = 'targets';\n    /** Keys are automatically assigned via the targetId property. */\n    DbTarget.keyPath = 'targetId';\n    /** The name of the queryTargets index. */\n    DbTarget.queryTargetsIndexName = 'queryTargetsIndex';\n    /**\n     * The index of all canonicalIds to the targets that they match. This is not\n     * a unique mapping because canonicalId does not promise a unique name for all\n     * possible queries, so we append the targetId to make the mapping unique.\n     */\n    DbTarget.queryTargetsKeyPath = ['canonicalId', 'targetId'];\n    return DbTarget;\n}());\n\n/**\n * An object representing an association between a target and a document.\n * Stored in the targetDocument object store to store the documents tracked by a\n * particular target.\n */\nvar DbTargetDocument = /** @class */ (function () {\n    function DbTargetDocument(\n    /**\n     * The targetId identifying a target.\n     */\n    targetId, \n    /**\n     * The path to the document, as encoded in the key.\n     */\n    path) {\n        this.targetId = targetId;\n        this.path = path;\n    }\n    /** Name of the IndexedDb object store.  */\n    DbTargetDocument.store = 'targetDocuments';\n    /** Keys are automatically assigned via the targetId, path properties. */\n    DbTargetDocument.keyPath = ['targetId', 'path'];\n    /** The index name for the reverse index. */\n    DbTargetDocument.documentTargetsIndex = 'documentTargetsIndex';\n    /** We also need to create the reverse index for these properties. */\n    DbTargetDocument.documentTargetsKeyPath = ['path', 'targetId'];\n    return DbTargetDocument;\n}());\n\n/**\n * A record of global state tracked across all Targets, tracked separately\n * to avoid the need for extra indexes.\n *\n * This should be kept in-sync with the proto used in the iOS client.\n */\nvar DbTargetGlobal = /** @class */ (function () {\n    function DbTargetGlobal(\n    /**\n     * The highest numbered target id across all targets.\n     *\n     * See DbTarget.targetId.\n     */\n    highestTargetId, \n    /**\n     * The highest numbered lastListenSequenceNumber across all targets.\n     *\n     * See DbTarget.lastListenSequenceNumber.\n     */\n    highestListenSequenceNumber, \n    /**\n     * A global snapshot version representing the last consistent snapshot we\n     * received from the backend. This is monotonically increasing and any\n     * snapshots received from the backend prior to this version (e.g. for\n     * targets resumed with a resumeToken) should be suppressed (buffered)\n     * until the backend has caught up to this snapshot version again. This\n     * prevents our cache from ever going backwards in time.\n     */\n    lastRemoteSnapshotVersion, \n    /**\n     * The number of targets persisted.\n     */\n    targetCount) {\n        this.highestTargetId = highestTargetId;\n        this.highestListenSequenceNumber = highestListenSequenceNumber;\n        this.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion;\n        this.targetCount = targetCount;\n    }\n    /**\n     * The key string used for the single object that exists in the\n     * DbTargetGlobal store.\n     */\n    DbTargetGlobal.key = 'targetGlobalKey';\n    DbTargetGlobal.store = 'targetGlobal';\n    return DbTargetGlobal;\n}());\n\nfunction createQueryCache(db) {\n    var targetDocumentsStore = db.createObjectStore(DbTargetDocument.store, {\n        keyPath: DbTargetDocument.keyPath\n    });\n    targetDocumentsStore.createIndex(DbTargetDocument.documentTargetsIndex, DbTargetDocument.documentTargetsKeyPath, { unique: true });\n    var targetStore = db.createObjectStore(DbTarget.store, {\n        keyPath: DbTarget.keyPath\n    });\n    // NOTE: This is unique only because the TargetId is the suffix.\n    targetStore.createIndex(DbTarget.queryTargetsIndexName, DbTarget.queryTargetsKeyPath, { unique: true });\n    db.createObjectStore(DbTargetGlobal.store);\n}\n/**\n * Counts the number of targets persisted and adds that value to the target\n * global singleton.\n */\nfunction saveTargetCount(txn, metadata) {\n    var globalStore = txn.store(DbTargetGlobal.store);\n    var targetStore = txn.store(DbTarget.store);\n    return targetStore.count().next(function (count) {\n        metadata.targetCount = count;\n        return globalStore.put(DbTargetGlobal.key, metadata);\n    });\n}\n/**\n * Ensures that the target global singleton row exists by adding it if it's\n * missing.\n *\n * @param {IDBTransaction} txn The version upgrade transaction for indexeddb\n */\nfunction ensureTargetGlobalExists(txn) {\n    var globalStore = txn.store(DbTargetGlobal.store);\n    return globalStore.get(DbTargetGlobal.key).next(function (metadata) {\n        if (metadata != null) {\n            return persistence_promise_PersistencePromise.resolve(metadata);\n        }\n        else {\n            metadata = new DbTargetGlobal(\n            /*highestTargetId=*/ 0, \n            /*lastListenSequenceNumber=*/ 0, snapshot_version_SnapshotVersion.MIN.toTimestamp(), \n            /*targetCount=*/ 0);\n            return globalStore.put(DbTargetGlobal.key, metadata).next(function () { return metadata; });\n        }\n    });\n}\n/**\n * The list of all default IndexedDB stores used throughout the SDK. This is\n * used when creating transactions so that access across all stores is done\n * atomically.\n */\nvar ALL_STORES = [\n    DbMutationQueue.store,\n    DbMutationBatch.store,\n    indexeddb_schema_DbDocumentMutation.store,\n    DbRemoteDocument.store,\n    DbTarget.store,\n    DbOwner.store,\n    DbTargetGlobal.store,\n    DbTargetDocument.store\n];\n\n//# sourceMappingURL=indexeddb_schema.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/simple_db.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\nvar simple_db_LOG_TAG = 'SimpleDb';\n/**\n * Provides a wrapper around IndexedDb with a simplified interface that uses\n * Promise-like return values to chain operations. Real promises cannot be used\n * since .then() continuations are executed asynchronously (e.g. via\n * .setImmediate), which would cause IndexedDB to end the transaction.\n * See PersistencePromise for more details.\n */\nvar simple_db_SimpleDb = /** @class */ (function () {\n    function SimpleDb(db) {\n        this.db = db;\n    }\n    /** Opens the specified database, creating or upgrading it if necessary. */\n    SimpleDb.openOrCreate = function (name, version, runUpgrade) {\n        assert(SimpleDb.isAvailable(), 'IndexedDB not supported in current environment.');\n        debug(simple_db_LOG_TAG, 'Opening database:', name);\n        return new persistence_promise_PersistencePromise(function (resolve, reject) {\n            // TODO(mikelehen): Investigate browser compatibility.\n            // https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB\n            // suggests IE9 and older WebKit browsers handle upgrade\n            // differently. They expect setVersion, as described here:\n            // https://developer.mozilla.org/en-US/docs/Web/API/IDBVersionChangeRequest/setVersion\n            var request = window.indexedDB.open(name, version);\n            request.onsuccess = function (event) {\n                var db = event.target.result;\n                resolve(new SimpleDb(db));\n            };\n            request.onerror = function (event) {\n                reject(event.target.error);\n            };\n            request.onupgradeneeded = function (event) {\n                debug(simple_db_LOG_TAG, 'Database \"' + name + '\" requires upgrade from version:', event.oldVersion);\n                var db = event.target.result;\n                // We are provided a version upgrade transaction from the request, so\n                // we wrap that in a SimpleDbTransaction to allow use of our friendlier\n                // API for schema migration operations.\n                var txn = new simple_db_SimpleDbTransaction(request.transaction);\n                runUpgrade(db, txn, event.oldVersion, SCHEMA_VERSION).next(function () {\n                    debug(simple_db_LOG_TAG, 'Database upgrade to version ' + SCHEMA_VERSION + ' complete');\n                });\n            };\n        }).toPromise();\n    };\n    /** Deletes the specified database. */\n    SimpleDb.delete = function (name) {\n        debug(simple_db_LOG_TAG, 'Removing database:', name);\n        return wrapRequest(window.indexedDB.deleteDatabase(name)).toPromise();\n    };\n    /** Returns true if IndexedDB is available in the current environment. */\n    SimpleDb.isAvailable = function () {\n        if (typeof window === 'undefined' || window.indexedDB == null) {\n            return false;\n        }\n        // We extensively use indexed array values and compound keys,\n        // which IE and Edge do not support. However, they still have indexedDB\n        // defined on the window, so we need to check for them here and make sure\n        // to return that persistence is not enabled for those browsers.\n        // For tracking support of this feature, see here:\n        // https://developer.microsoft.com/en-us/microsoft-edge/platform/status/indexeddbarraysandmultientrysupport/\n        // Check the UA string to find out the browser.\n        var ua = window.navigator.userAgent;\n        // IE 10\n        // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';\n        // IE 11\n        // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';\n        // Edge\n        // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML,\n        // like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';\n        if (ua.indexOf('MSIE ') > 0 ||\n            ua.indexOf('Trident/') > 0 ||\n            ua.indexOf('Edge/') > 0) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    };\n    SimpleDb.prototype.runTransaction = function (mode, objectStores, transactionFn) {\n        var transaction = simple_db_SimpleDbTransaction.open(this.db, mode, objectStores);\n        var transactionFnResult = transactionFn(transaction)\n            .catch(function (error) {\n            // Abort the transaction if there was an\n            // error.\n            transaction.abort();\n            return persistence_promise_PersistencePromise.reject(error);\n        })\n            .toPromise();\n        // Wait for the transaction to complete (i.e. IndexedDb's onsuccess event to\n        // fire), but still return the original transactionFnResult back to the\n        // caller.\n        return transaction.completionPromise.then(function () { return transactionFnResult; });\n    };\n    SimpleDb.prototype.close = function () {\n        this.db.close();\n    };\n    return SimpleDb;\n}());\n\n/**\n * A controller for iterating over a key range or index. It allows an iterate\n * callback to delete the currently-referenced object, or jump to a new key\n * within the key range or index.\n */\nvar IterationController = /** @class */ (function () {\n    function IterationController(dbCursor) {\n        this.dbCursor = dbCursor;\n        this.shouldStop = false;\n        this.nextKey = null;\n    }\n    Object.defineProperty(IterationController.prototype, \"isDone\", {\n        get: function () {\n            return this.shouldStop;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(IterationController.prototype, \"skipToKey\", {\n        get: function () {\n            return this.nextKey;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(IterationController.prototype, \"cursor\", {\n        set: function (value) {\n            this.dbCursor = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * This function can be called to stop iteration at any point.\n     */\n    IterationController.prototype.done = function () {\n        this.shouldStop = true;\n    };\n    /**\n     * This function can be called to skip to that next key, which could be\n     * an index or a primary key.\n     */\n    IterationController.prototype.skip = function (key) {\n        this.nextKey = key;\n    };\n    /**\n     * Delete the current cursor value from the object store.\n     *\n     * NOTE: You CANNOT do this with a keysOnly query.\n     */\n    IterationController.prototype.delete = function () {\n        return wrapRequest(this.dbCursor.delete());\n    };\n    return IterationController;\n}());\n\n/**\n * Wraps an IDBTransaction and exposes a store() method to get a handle to a\n * specific object store.\n */\nvar simple_db_SimpleDbTransaction = /** @class */ (function () {\n    function SimpleDbTransaction(transaction) {\n        var _this = this;\n        this.transaction = transaction;\n        this.aborted = false;\n        this.completionPromise = new Promise(function (resolve, reject) {\n            // We consider aborting to be \"normal\" and just resolve the promise.\n            // May need to revisit if/when we actually need to abort transactions.\n            _this.transaction.onabort = _this.transaction.oncomplete = function (event) {\n                resolve();\n            };\n            _this.transaction.onerror = function (event) {\n                reject(event.target.error);\n            };\n        });\n    }\n    SimpleDbTransaction.open = function (db, mode, objectStoreNames) {\n        return new SimpleDbTransaction(db.transaction(objectStoreNames, mode));\n    };\n    SimpleDbTransaction.prototype.abort = function () {\n        if (!this.aborted) {\n            debug(simple_db_LOG_TAG, 'Aborting transaction.');\n            this.aborted = true;\n            this.transaction.abort();\n        }\n    };\n    /**\n     * Returns a SimpleDbStore<KeyType, ValueType> for the specified store. All\n     * operations performed on the SimpleDbStore happen within the context of this\n     * transaction and it cannot be used anymore once the transaction is\n     * completed.\n     *\n     * Note that we can't actually enforce that the KeyType and ValueType are\n     * correct, but they allow type safety through the rest of the consuming code.\n     */\n    SimpleDbTransaction.prototype.store = function (storeName) {\n        var store = this.transaction.objectStore(storeName);\n        assert(!!store, 'Object store not part of transaction: ' + storeName);\n        return new simple_db_SimpleDbStore(store);\n    };\n    return SimpleDbTransaction;\n}());\n\n/**\n * A wrapper around an IDBObjectStore providing an API that:\n *\n * 1) Has generic KeyType / ValueType parameters to provide strongly-typed\n * methods for acting against the object store.\n * 2) Deals with IndexedDB's onsuccess / onerror event callbacks, making every\n * method return a PersistencePromise instead.\n * 3) Provides a higher-level API to avoid needing to do excessive wrapping of\n * intermediate IndexedDB types (IDBCursorWithValue, etc.)\n */\nvar simple_db_SimpleDbStore = /** @class */ (function () {\n    function SimpleDbStore(store) {\n        this.store = store;\n    }\n    SimpleDbStore.prototype.put = function (keyOrValue, value) {\n        var request;\n        if (value !== undefined) {\n            debug(simple_db_LOG_TAG, 'PUT', this.store.name, keyOrValue, value);\n            request = this.store.put(value, keyOrValue);\n        }\n        else {\n            debug(simple_db_LOG_TAG, 'PUT', this.store.name, '<auto-key>', keyOrValue);\n            request = this.store.put(keyOrValue);\n        }\n        return wrapRequest(request);\n    };\n    /**\n     * Gets the object with the specified key from the specified store, or null\n     * if no object exists with the specified key.\n     *\n     * @key The key of the object to get.\n     * @return The object with the specified key or null if no object exists.\n     */\n    SimpleDbStore.prototype.get = function (key) {\n        var _this = this;\n        var request = this.store.get(key);\n        // tslint:disable-next-line:no-any We're doing an unsafe cast to ValueType.\n        return wrapRequest(request).next(function (result) {\n            // Normalize nonexistence to null.\n            if (result === undefined) {\n                result = null;\n            }\n            debug(simple_db_LOG_TAG, 'GET', _this.store.name, key, result);\n            return result;\n        });\n    };\n    SimpleDbStore.prototype.delete = function (key) {\n        debug(simple_db_LOG_TAG, 'DELETE', this.store.name, key);\n        var request = this.store.delete(key);\n        return wrapRequest(request);\n    };\n    /**\n     * If we ever need more of the count variants, we can add overloads. For now,\n     * all we need is to count everything in a store.\n     *\n     * Returns the number of rows in the store.\n     */\n    SimpleDbStore.prototype.count = function () {\n        debug(simple_db_LOG_TAG, 'COUNT', this.store.name);\n        var request = this.store.count();\n        return wrapRequest(request);\n    };\n    SimpleDbStore.prototype.loadAll = function (indexOrRange, range) {\n        var cursor = this.cursor(this.options(indexOrRange, range));\n        var results = [];\n        return this.iterateCursor(cursor, function (key, value) {\n            results.push(value);\n        }).next(function () {\n            return results;\n        });\n    };\n    SimpleDbStore.prototype.deleteAll = function (indexOrRange, range) {\n        debug(simple_db_LOG_TAG, 'DELETE ALL', this.store.name);\n        var options = this.options(indexOrRange, range);\n        options.keysOnly = false;\n        var cursor = this.cursor(options);\n        return this.iterateCursor(cursor, function (key, value, control) {\n            // NOTE: Calling delete() on a cursor is documented as more efficient than\n            // calling delete() on an object store with a single key\n            // (https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/delete),\n            // however, this requires us *not* to use a keysOnly cursor\n            // (https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/delete). We\n            // may want to compare the performance of each method.\n            return control.delete();\n        });\n    };\n    SimpleDbStore.prototype.iterate = function (optionsOrCallback, callback) {\n        var options;\n        if (!callback) {\n            options = {};\n            callback = optionsOrCallback;\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        var cursor = this.cursor(options);\n        return this.iterateCursor(cursor, callback);\n    };\n    SimpleDbStore.prototype.iterateCursor = function (cursorRequest, fn) {\n        var results = [];\n        return new persistence_promise_PersistencePromise(function (resolve, reject) {\n            cursorRequest.onerror = function (event) {\n                reject(event.target.error);\n            };\n            cursorRequest.onsuccess = function (event) {\n                var cursor = event.target.result;\n                if (!cursor) {\n                    resolve();\n                    return;\n                }\n                var controller = new IterationController(cursor);\n                var userResult = fn(cursor.primaryKey, cursor.value, controller);\n                if (userResult instanceof persistence_promise_PersistencePromise) {\n                    results.push(userResult);\n                }\n                if (controller.isDone) {\n                    resolve();\n                }\n                else if (controller.skipToKey === null) {\n                    cursor.continue();\n                }\n                else {\n                    cursor.continue(controller.skipToKey);\n                }\n            };\n        }).next(function () {\n            return persistence_promise_PersistencePromise.waitFor(results);\n        });\n    };\n    SimpleDbStore.prototype.options = function (indexOrRange, range) {\n        var indexName = undefined;\n        if (indexOrRange !== undefined) {\n            if (typeof indexOrRange === 'string') {\n                indexName = indexOrRange;\n            }\n            else {\n                assert(range === undefined, '3rd argument must not be defined if 2nd is a range.');\n                range = indexOrRange;\n            }\n        }\n        return { index: indexName, range: range };\n    };\n    SimpleDbStore.prototype.cursor = function (options) {\n        var direction = 'next';\n        if (options.reverse) {\n            direction = 'prev';\n        }\n        if (options.index) {\n            var index = this.store.index(options.index);\n            if (options.keysOnly) {\n                return index.openKeyCursor(options.range, direction);\n            }\n            else {\n                return index.openCursor(options.range, direction);\n            }\n        }\n        else {\n            return this.store.openCursor(options.range, direction);\n        }\n    };\n    return SimpleDbStore;\n}());\n\n/**\n * Wraps an IDBRequest in a PersistencePromise, using the onsuccess / onerror\n * handlers to resolve / reject the PersistencePromise as appropriate.\n */\nfunction wrapRequest(request) {\n    return new persistence_promise_PersistencePromise(function (resolve, reject) {\n        request.onsuccess = function (event) {\n            var result = event.target.result;\n            resolve(result);\n        };\n        request.onerror = function (event) {\n            reject(event.target.error);\n        };\n    });\n}\n\n//# sourceMappingURL=simple_db.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/indexeddb_mutation_queue.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\n/** A mutation queue for a specific user, backed by IndexedDB. */\nvar indexeddb_mutation_queue_IndexedDbMutationQueue = /** @class */ (function () {\n    function IndexedDbMutationQueue(\n    /**\n     * The normalized userId (e.g. null UID => \"\" userId) used to store /\n     * retrieve mutations.\n     */\n    userId, serializer) {\n        this.userId = userId;\n        this.serializer = serializer;\n        this.garbageCollector = null;\n    }\n    /**\n     * Creates a new mutation queue for the given user.\n     * @param user The user for which to create a mutation queue.\n     * @param serializer The serializer to use when persisting to IndexedDb.\n     */\n    IndexedDbMutationQueue.forUser = function (user, serializer) {\n        // TODO(mcg): Figure out what constraints there are on userIDs\n        // In particular, are there any reserved characters? are empty ids allowed?\n        // For the moment store these together in the same mutations table assuming\n        // that empty userIDs aren't allowed.\n        assert(user.uid !== '', 'UserID must not be an empty string.');\n        var userId = user.isAuthenticated() ? user.uid : '';\n        return new IndexedDbMutationQueue(userId, serializer);\n    };\n    IndexedDbMutationQueue.prototype.start = function (transaction) {\n        var _this = this;\n        return IndexedDbMutationQueue.loadNextBatchIdFromDb(transaction)\n            .next(function (nextBatchId) {\n            _this.nextBatchId = nextBatchId;\n            return mutationQueuesStore(transaction).get(_this.userId);\n        })\n            .next(function (metadata) {\n            if (!metadata) {\n                metadata = new DbMutationQueue(_this.userId, BATCHID_UNKNOWN, \n                /*lastStreamToken=*/ '');\n            }\n            _this.metadata = metadata;\n            // On restart, nextBatchId may end up lower than\n            // lastAcknowledgedBatchId since it's computed from the queue\n            // contents, and there may be no mutations in the queue. In this\n            // case, we need to reset lastAcknowledgedBatchId (which is safe\n            // since the queue must be empty).\n            if (_this.metadata.lastAcknowledgedBatchId >= _this.nextBatchId) {\n                return _this.checkEmpty(transaction).next(function (empty) {\n                    assert(empty, 'Reset nextBatchID is only possible when the queue is empty');\n                    _this.metadata.lastAcknowledgedBatchId = BATCHID_UNKNOWN;\n                    return mutationQueuesStore(transaction).put(_this.metadata);\n                });\n            }\n            else {\n                return persistence_promise_PersistencePromise.resolve();\n            }\n        });\n    };\n    /**\n     * Returns one larger than the largest batch ID that has been stored. If there\n     * are no mutations returns 0. Note that batch IDs are global.\n     */\n    IndexedDbMutationQueue.loadNextBatchIdFromDb = function (txn) {\n        var maxBatchId = BATCHID_UNKNOWN;\n        return mutationsStore(txn)\n            .iterate({ reverse: true }, function (key, batch, control) {\n            var userId = key[0], batchId = key[1];\n            if (batchId > maxBatchId) {\n                maxBatchId = batch.batchId;\n            }\n            if (userId === '') {\n                // We can't compute a predecessor for the empty string, since it\n                // is lexographically first. That also means that no other\n                // userIds can come before this one, so we can just exit early.\n                control.done();\n            }\n            else {\n                var nextUser = immediatePredecessor(userId);\n                control.skip([nextUser]);\n            }\n        })\n            .next(function () { return maxBatchId + 1; });\n    };\n    IndexedDbMutationQueue.prototype.checkEmpty = function (transaction) {\n        var empty = true;\n        var range = IDBKeyRange.bound(this.keyForBatchId(Number.NEGATIVE_INFINITY), this.keyForBatchId(Number.POSITIVE_INFINITY));\n        return mutationsStore(transaction)\n            .iterate({ range: range }, function (key, value, control) {\n            empty = false;\n            control.done();\n        })\n            .next(function () { return empty; });\n    };\n    IndexedDbMutationQueue.prototype.getNextBatchId = function (transaction) {\n        return persistence_promise_PersistencePromise.resolve(this.nextBatchId);\n    };\n    IndexedDbMutationQueue.prototype.getHighestAcknowledgedBatchId = function (transaction) {\n        return persistence_promise_PersistencePromise.resolve(this.metadata.lastAcknowledgedBatchId);\n    };\n    IndexedDbMutationQueue.prototype.acknowledgeBatch = function (transaction, batch, streamToken) {\n        var batchId = batch.batchId;\n        assert(batchId > this.metadata.lastAcknowledgedBatchId, 'Mutation batchIDs must be acknowledged in order');\n        this.metadata.lastAcknowledgedBatchId = batchId;\n        this.metadata.lastStreamToken = validateStreamToken(streamToken);\n        return mutationQueuesStore(transaction).put(this.metadata);\n    };\n    IndexedDbMutationQueue.prototype.getLastStreamToken = function (transaction) {\n        return persistence_promise_PersistencePromise.resolve(this.metadata.lastStreamToken);\n    };\n    IndexedDbMutationQueue.prototype.setLastStreamToken = function (transaction, streamToken) {\n        this.metadata.lastStreamToken = validateStreamToken(streamToken);\n        return mutationQueuesStore(transaction).put(this.metadata);\n    };\n    IndexedDbMutationQueue.prototype.addMutationBatch = function (transaction, localWriteTime, mutations) {\n        var _this = this;\n        var batchId = this.nextBatchId;\n        this.nextBatchId++;\n        var batch = new mutation_batch_MutationBatch(batchId, localWriteTime, mutations);\n        var dbBatch = this.serializer.toDbMutationBatch(this.userId, batch);\n        return mutationsStore(transaction)\n            .put(dbBatch)\n            .next(function () {\n            var promises = [];\n            for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {\n                var mutation = mutations_1[_i];\n                var indexKey = indexeddb_schema_DbDocumentMutation.key(_this.userId, mutation.key.path, batchId);\n                documentMutationsStore(transaction).put(indexKey, indexeddb_schema_DbDocumentMutation.PLACEHOLDER);\n            }\n            return persistence_promise_PersistencePromise.waitFor(promises);\n        })\n            .next(function () {\n            return batch;\n        });\n    };\n    IndexedDbMutationQueue.prototype.lookupMutationBatch = function (transaction, batchId) {\n        var _this = this;\n        return mutationsStore(transaction)\n            .get(this.keyForBatchId(batchId))\n            .next(function (dbBatch) {\n            return dbBatch ? _this.serializer.fromDbMutationBatch(dbBatch) : null;\n        });\n    };\n    IndexedDbMutationQueue.prototype.getNextMutationBatchAfterBatchId = function (transaction, batchId) {\n        var _this = this;\n        // All batches with batchId <= this.metadata.lastAcknowledgedBatchId have\n        // been acknowledged so the first unacknowledged batch after batchID will\n        // have a batchID larger than both of these values.\n        var nextBatchId = Math.max(batchId, this.metadata.lastAcknowledgedBatchId) + 1;\n        var range = IDBKeyRange.lowerBound(this.keyForBatchId(nextBatchId));\n        var foundBatch = null;\n        return mutationsStore(transaction)\n            .iterate({ range: range }, function (key, dbBatch, control) {\n            if (dbBatch.userId === _this.userId) {\n                assert(dbBatch.batchId >= nextBatchId, 'Should have found mutation after ' + nextBatchId);\n                foundBatch = _this.serializer.fromDbMutationBatch(dbBatch);\n            }\n            control.done();\n        })\n            .next(function () { return foundBatch; });\n    };\n    IndexedDbMutationQueue.prototype.getAllMutationBatches = function (transaction) {\n        var _this = this;\n        var range = IDBKeyRange.bound(this.keyForBatchId(BATCHID_UNKNOWN), this.keyForBatchId(Number.POSITIVE_INFINITY));\n        return mutationsStore(transaction)\n            .loadAll(range)\n            .next(function (dbBatches) {\n            return dbBatches.map(function (dbBatch) { return _this.serializer.fromDbMutationBatch(dbBatch); });\n        });\n    };\n    IndexedDbMutationQueue.prototype.getAllMutationBatchesThroughBatchId = function (transaction, batchId) {\n        var _this = this;\n        var range = IDBKeyRange.bound(this.keyForBatchId(BATCHID_UNKNOWN), this.keyForBatchId(batchId));\n        return mutationsStore(transaction)\n            .loadAll(range)\n            .next(function (dbBatches) {\n            return dbBatches.map(function (dbBatch) { return _this.serializer.fromDbMutationBatch(dbBatch); });\n        });\n    };\n    IndexedDbMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKey = function (transaction, documentKey) {\n        var _this = this;\n        // Scan the document-mutation index starting with a prefix starting with\n        // the given documentKey.\n        var indexPrefix = indexeddb_schema_DbDocumentMutation.prefixForPath(this.userId, documentKey.path);\n        var indexStart = IDBKeyRange.lowerBound(indexPrefix);\n        var results = [];\n        return documentMutationsStore(transaction)\n            .iterate({ range: indexStart }, function (indexKey, _, control) {\n            var userID = indexKey[0], encodedPath = indexKey[1], batchID = indexKey[2];\n            // Only consider rows matching exactly the specific key of\n            // interest. Note that because we order by path first, and we\n            // order terminators before path separators, we'll encounter all\n            // the index rows for documentKey contiguously. In particular, all\n            // the rows for documentKey will occur before any rows for\n            // documents nested in a subcollection beneath documentKey so we\n            // can stop as soon as we hit any such row.\n            var path = decode(encodedPath);\n            if (userID !== _this.userId || !documentKey.path.isEqual(path)) {\n                control.done();\n                return;\n            }\n            var mutationKey = _this.keyForBatchId(batchID);\n            // Look up the mutation batch in the store.\n            // PORTING NOTE: because iteration is callback driven in the web,\n            // we just look up the key instead of keeping an open iterator\n            // like iOS.\n            return mutationsStore(transaction)\n                .get(mutationKey)\n                .next(function (dbBatch) {\n                if (dbBatch === null) {\n                    fail('Dangling document-mutation reference found: ' +\n                        indexKey +\n                        ' which points to ' +\n                        mutationKey);\n                }\n                results.push(_this.serializer.fromDbMutationBatch(dbBatch));\n            });\n        })\n            .next(function () { return results; });\n    };\n    IndexedDbMutationQueue.prototype.getAllMutationBatchesAffectingQuery = function (transaction, query) {\n        var _this = this;\n        assert(!query.isDocumentQuery(), \"Document queries shouldn't go down this path\");\n        var queryPath = query.path;\n        var immediateChildrenLength = queryPath.length + 1;\n        // TODO(mcg): Actually implement a single-collection query\n        //\n        // This is actually executing an ancestor query, traversing the whole\n        // subtree below the collection which can be horrifically inefficient for\n        // some structures. The right way to solve this is to implement the full\n        // value index, but that's not in the cards in the near future so this is\n        // the best we can do for the moment.\n        //\n        // Since we don't yet index the actual properties in the mutations, our\n        // current approach is to just return all mutation batches that affect\n        // documents in the collection being queried.\n        var indexPrefix = indexeddb_schema_DbDocumentMutation.prefixForPath(this.userId, queryPath);\n        var indexStart = IDBKeyRange.lowerBound(indexPrefix);\n        // Collect up unique batchIDs encountered during a scan of the index. Use a\n        // SortedSet to accumulate batch IDs so they can be traversed in order in a\n        // scan of the main table.\n        var uniqueBatchIDs = new sorted_set_SortedSet(primitiveComparator);\n        return documentMutationsStore(transaction)\n            .iterate({ range: indexStart }, function (indexKey, _, control) {\n            var userID = indexKey[0], encodedPath = indexKey[1], batchID = indexKey[2];\n            var path = decode(encodedPath);\n            if (userID !== _this.userId || !queryPath.isPrefixOf(path)) {\n                control.done();\n                return;\n            }\n            // Rows with document keys more than one segment longer than the\n            // query path can't be matches. For example, a query on 'rooms'\n            // can't match the document /rooms/abc/messages/xyx.\n            // TODO(mcg): we'll need a different scanner when we implement\n            // ancestor queries.\n            if (path.length !== immediateChildrenLength) {\n                return;\n            }\n            uniqueBatchIDs = uniqueBatchIDs.add(batchID);\n        })\n            .next(function () {\n            var results = [];\n            var promises = [];\n            // TODO(rockwood): Implement this using iterate.\n            uniqueBatchIDs.forEach(function (batchID) {\n                var mutationKey = _this.keyForBatchId(batchID);\n                promises.push(mutationsStore(transaction)\n                    .get(mutationKey)\n                    .next(function (mutation) {\n                    if (mutation === null) {\n                        fail('Dangling document-mutation reference found, ' +\n                            'which points to ' +\n                            mutationKey);\n                    }\n                    results.push(_this.serializer.fromDbMutationBatch(mutation));\n                }));\n            });\n            return persistence_promise_PersistencePromise.waitFor(promises).next(function () { return results; });\n        });\n    };\n    IndexedDbMutationQueue.prototype.removeMutationBatches = function (transaction, batches) {\n        var txn = mutationsStore(transaction);\n        var indexTxn = documentMutationsStore(transaction);\n        var promises = [];\n        var _loop_1 = function (batch) {\n            var range = IDBKeyRange.only(this_1.keyForBatchId(batch.batchId));\n            var numDeleted = 0;\n            var removePromise = txn.iterate({ range: range }, function (key, value, control) {\n                numDeleted++;\n                return control.delete();\n            });\n            promises.push(removePromise.next(function () {\n                assert(numDeleted === 1, 'Dangling document-mutation reference found: Missing batch ' +\n                    batch.batchId);\n            }));\n            for (var _i = 0, _a = batch.mutations; _i < _a.length; _i++) {\n                var mutation = _a[_i];\n                var indexKey = indexeddb_schema_DbDocumentMutation.key(this_1.userId, mutation.key.path, batch.batchId);\n                promises.push(indexTxn.delete(indexKey));\n                if (this_1.garbageCollector !== null) {\n                    this_1.garbageCollector.addPotentialGarbageKey(mutation.key);\n                }\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {\n            var batch = batches_1[_i];\n            _loop_1(batch);\n        }\n        return persistence_promise_PersistencePromise.waitFor(promises);\n    };\n    IndexedDbMutationQueue.prototype.performConsistencyCheck = function (txn) {\n        var _this = this;\n        return this.checkEmpty(txn).next(function (empty) {\n            if (!empty) {\n                return persistence_promise_PersistencePromise.resolve();\n            }\n            // Verify that there are no entries in the documentMutations index if\n            // the queue is empty.\n            var startRange = IDBKeyRange.lowerBound(indexeddb_schema_DbDocumentMutation.prefixForUser(_this.userId));\n            var danglingMutationReferences = [];\n            return documentMutationsStore(txn)\n                .iterate({ range: startRange }, function (key, _, control) {\n                var userID = key[0];\n                if (userID !== _this.userId) {\n                    control.done();\n                    return;\n                }\n                else {\n                    var path = decode(key[1]);\n                    danglingMutationReferences.push(path);\n                }\n            })\n                .next(function () {\n                assert(danglingMutationReferences.length === 0, 'Document leak -- detected dangling mutation references when queue is empty. Dangling keys: ' +\n                    danglingMutationReferences.map(function (p) { return p.canonicalString(); }));\n            });\n        });\n    };\n    IndexedDbMutationQueue.prototype.setGarbageCollector = function (gc) {\n        this.garbageCollector = gc;\n    };\n    IndexedDbMutationQueue.prototype.containsKey = function (txn, key) {\n        var _this = this;\n        var indexKey = indexeddb_schema_DbDocumentMutation.prefixForPath(this.userId, key.path);\n        var encodedPath = indexKey[1];\n        var startRange = IDBKeyRange.lowerBound(indexKey);\n        var containsKey = false;\n        return documentMutationsStore(txn)\n            .iterate({ range: startRange, keysOnly: true }, function (key, value, control) {\n            var userID = key[0], keyPath = key[1], /*batchID*/ _ = key[2];\n            if (userID === _this.userId && keyPath === encodedPath) {\n                containsKey = true;\n            }\n            control.done();\n        })\n            .next(function () { return containsKey; });\n    };\n    /**\n     * Creates a [userId, batchId] key for use with the DbMutationQueue object\n     * store.\n     */\n    IndexedDbMutationQueue.prototype.keyForBatchId = function (batchId) {\n        return [this.userId, batchId];\n    };\n    return IndexedDbMutationQueue;\n}());\n\nfunction validateStreamToken(token) {\n    assert(typeof token === 'string', 'Persisting non-string stream token not supported.');\n    return token;\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutations object store.\n */\nfunction mutationsStore(txn) {\n    return getStore(txn, DbMutationBatch.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\nfunction documentMutationsStore(txn) {\n    return getStore(txn, indexeddb_schema_DbDocumentMutation.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\nfunction mutationQueuesStore(txn) {\n    return getStore(txn, DbMutationQueue.store);\n}\n/**\n * Helper to get a typed SimpleDbStore from a transaction.\n */\nfunction getStore(txn, store) {\n    if (txn instanceof simple_db_SimpleDbTransaction) {\n        return txn.store(store);\n    }\n    else {\n        return fail('Invalid transaction object provided!');\n    }\n}\n\n//# sourceMappingURL=indexeddb_mutation_queue.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/indexeddb_query_cache.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\n\n\nvar indexeddb_query_cache_IndexedDbQueryCache = /** @class */ (function () {\n    function IndexedDbQueryCache(serializer) {\n        this.serializer = serializer;\n        /**\n         * The last received snapshot version. We store this seperately from the\n         * metadata to avoid the extra conversion to/from DbTimestamp.\n         */\n        this.lastRemoteSnapshotVersion = snapshot_version_SnapshotVersion.MIN;\n        /**\n         * A cached copy of the metadata for the query cache.\n         */\n        this.metadata = null;\n        /** The garbage collector to notify about potential garbage keys. */\n        this.garbageCollector = null;\n    }\n    IndexedDbQueryCache.prototype.start = function (transaction) {\n        var _this = this;\n        return globalTargetStore(transaction)\n            .get(DbTargetGlobal.key)\n            .next(function (metadata) {\n            assert(metadata !== null, 'Missing metadata row that should be added by schema migration.');\n            _this.metadata = metadata;\n            var lastSavedVersion = metadata.lastRemoteSnapshotVersion;\n            _this.lastRemoteSnapshotVersion = snapshot_version_SnapshotVersion.fromTimestamp(new timestamp_Timestamp(lastSavedVersion.seconds, lastSavedVersion.nanos));\n            return persistence_promise_PersistencePromise.resolve();\n        });\n    };\n    IndexedDbQueryCache.prototype.getHighestTargetId = function () {\n        return this.metadata.highestTargetId;\n    };\n    IndexedDbQueryCache.prototype.getLastRemoteSnapshotVersion = function () {\n        return this.lastRemoteSnapshotVersion;\n    };\n    IndexedDbQueryCache.prototype.setLastRemoteSnapshotVersion = function (transaction, snapshotVersion) {\n        this.lastRemoteSnapshotVersion = snapshotVersion;\n        this.metadata.lastRemoteSnapshotVersion = snapshotVersion.toTimestamp();\n        return globalTargetStore(transaction).put(DbTargetGlobal.key, this.metadata);\n    };\n    IndexedDbQueryCache.prototype.addQueryData = function (transaction, queryData) {\n        var _this = this;\n        return this.saveQueryData(transaction, queryData).next(function () {\n            _this.metadata.targetCount += 1;\n            _this.updateMetadataFromQueryData(queryData);\n            return _this.saveMetadata(transaction);\n        });\n    };\n    IndexedDbQueryCache.prototype.updateQueryData = function (transaction, queryData) {\n        var _this = this;\n        return this.saveQueryData(transaction, queryData).next(function () {\n            if (_this.updateMetadataFromQueryData(queryData)) {\n                return _this.saveMetadata(transaction);\n            }\n            else {\n                return persistence_promise_PersistencePromise.resolve();\n            }\n        });\n    };\n    IndexedDbQueryCache.prototype.removeQueryData = function (transaction, queryData) {\n        var _this = this;\n        assert(this.metadata.targetCount > 0, 'Removing from an empty query cache');\n        return this.removeMatchingKeysForTargetId(transaction, queryData.targetId)\n            .next(function () { return targetsStore(transaction).delete(queryData.targetId); })\n            .next(function () {\n            _this.metadata.targetCount -= 1;\n            return _this.saveMetadata(transaction);\n        });\n    };\n    IndexedDbQueryCache.prototype.saveMetadata = function (transaction) {\n        return globalTargetStore(transaction).put(DbTargetGlobal.key, this.metadata);\n    };\n    IndexedDbQueryCache.prototype.saveQueryData = function (transaction, queryData) {\n        return targetsStore(transaction).put(this.serializer.toDbTarget(queryData));\n    };\n    /**\n     * Updates the in-memory version of the metadata to account for values in the\n     * given QueryData. Saving is done separately. Returns true if there were any\n     * changes to the metadata.\n     */\n    IndexedDbQueryCache.prototype.updateMetadataFromQueryData = function (queryData) {\n        var needsUpdate = false;\n        if (queryData.targetId > this.metadata.highestTargetId) {\n            this.metadata.highestTargetId = queryData.targetId;\n            needsUpdate = true;\n        }\n        // TODO(GC): add sequence number check\n        return needsUpdate;\n    };\n    Object.defineProperty(IndexedDbQueryCache.prototype, \"count\", {\n        get: function () {\n            return this.metadata.targetCount;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    IndexedDbQueryCache.prototype.getQueryData = function (transaction, query) {\n        var _this = this;\n        // Iterating by the canonicalId may yield more than one result because\n        // canonicalId values are not required to be unique per target. This query\n        // depends on the queryTargets index to be efficent.\n        var canonicalId = query.canonicalId();\n        var range = IDBKeyRange.bound([canonicalId, Number.NEGATIVE_INFINITY], [canonicalId, Number.POSITIVE_INFINITY]);\n        var result = null;\n        return targetsStore(transaction)\n            .iterate({ range: range, index: DbTarget.queryTargetsIndexName }, function (key, value, control) {\n            var found = _this.serializer.fromDbTarget(value);\n            // After finding a potential match, check that the query is\n            // actually equal to the requested query.\n            if (query.isEqual(found.query)) {\n                result = found;\n                control.done();\n            }\n        })\n            .next(function () { return result; });\n    };\n    IndexedDbQueryCache.prototype.addMatchingKeys = function (txn, keys, targetId) {\n        // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n        // Indexeddb.\n        var promises = [];\n        var store = documentTargetStore(txn);\n        keys.forEach(function (key) {\n            var path = encode(key.path);\n            promises.push(store.put(new DbTargetDocument(targetId, path)));\n        });\n        return persistence_promise_PersistencePromise.waitFor(promises);\n    };\n    IndexedDbQueryCache.prototype.removeMatchingKeys = function (txn, keys, targetId) {\n        var _this = this;\n        // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n        // IndexedDb.\n        var promises = [];\n        var store = documentTargetStore(txn);\n        keys.forEach(function (key) {\n            var path = encode(key.path);\n            promises.push(store.delete([targetId, path]));\n            if (_this.garbageCollector !== null) {\n                _this.garbageCollector.addPotentialGarbageKey(key);\n            }\n        });\n        return persistence_promise_PersistencePromise.waitFor(promises);\n    };\n    IndexedDbQueryCache.prototype.removeMatchingKeysForTargetId = function (txn, targetId) {\n        var store = documentTargetStore(txn);\n        var range = IDBKeyRange.bound([targetId], [targetId + 1], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        return this.notifyGCForRemovedKeys(txn, range).next(function () {\n            return store.delete(range);\n        });\n    };\n    IndexedDbQueryCache.prototype.notifyGCForRemovedKeys = function (txn, range) {\n        var _this = this;\n        var store = documentTargetStore(txn);\n        if (this.garbageCollector !== null && this.garbageCollector.isEager) {\n            // In order to generate garbage events properly, we need to read these\n            // keys before deleting.\n            return store.iterate({ range: range, keysOnly: true }, function (key, _, control) {\n                var path = decode(key[1]);\n                var docKey = new document_key_DocumentKey(path);\n                // Paranoid assertion in case the the collector is set to null\n                // during the iteration.\n                assert(_this.garbageCollector !== null, 'GarbageCollector for query cache set to null during key removal.');\n                _this.garbageCollector.addPotentialGarbageKey(docKey);\n            });\n        }\n        else {\n            return persistence_promise_PersistencePromise.resolve();\n        }\n    };\n    IndexedDbQueryCache.prototype.getMatchingKeysForTargetId = function (txn, targetId) {\n        var range = IDBKeyRange.bound([targetId], [targetId + 1], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        var store = documentTargetStore(txn);\n        var result = documentKeySet();\n        return store\n            .iterate({ range: range, keysOnly: true }, function (key, _, control) {\n            var path = decode(key[1]);\n            var docKey = new document_key_DocumentKey(path);\n            result = result.add(docKey);\n        })\n            .next(function () { return result; });\n    };\n    IndexedDbQueryCache.prototype.setGarbageCollector = function (gc) {\n        this.garbageCollector = gc;\n    };\n    IndexedDbQueryCache.prototype.containsKey = function (txn, key) {\n        assert(txn !== null, 'Persistence Transaction cannot be null for query cache containsKey');\n        var path = encode(key.path);\n        var range = IDBKeyRange.bound([path], [immediateSuccessor(path)], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        var count = 0;\n        return documentTargetStore(txn)\n            .iterate({\n            index: DbTargetDocument.documentTargetsIndex,\n            keysOnly: true,\n            range: range\n        }, function (key, _, control) {\n            count++;\n            control.done();\n        })\n            .next(function () { return count > 0; });\n    };\n    return IndexedDbQueryCache;\n}());\n\n/**\n * Helper to get a typed SimpleDbStore for the queries object store.\n */\nfunction targetsStore(txn) {\n    return indexeddb_query_cache_getStore(txn, DbTarget.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the target globals object store.\n */\nfunction globalTargetStore(txn) {\n    return indexeddb_query_cache_getStore(txn, DbTargetGlobal.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the document target object store.\n */\nfunction documentTargetStore(txn) {\n    return indexeddb_query_cache_getStore(txn, DbTargetDocument.store);\n}\n/**\n * Helper to get a typed SimpleDbStore from a transaction.\n */\nfunction indexeddb_query_cache_getStore(txn, store) {\n    if (txn instanceof simple_db_SimpleDbTransaction) {\n        return txn.store(store);\n    }\n    else {\n        return fail('Invalid transaction object provided!');\n    }\n}\n\n//# sourceMappingURL=indexeddb_query_cache.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/indexeddb_remote_document_cache.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\nvar indexeddb_remote_document_cache_IndexedDbRemoteDocumentCache = /** @class */ (function () {\n    function IndexedDbRemoteDocumentCache(serializer) {\n        this.serializer = serializer;\n    }\n    IndexedDbRemoteDocumentCache.prototype.addEntry = function (transaction, maybeDocument) {\n        return remoteDocumentsStore(transaction).put(dbKey(maybeDocument.key), this.serializer.toDbRemoteDocument(maybeDocument));\n    };\n    IndexedDbRemoteDocumentCache.prototype.removeEntry = function (transaction, documentKey) {\n        return remoteDocumentsStore(transaction).delete(dbKey(documentKey));\n    };\n    IndexedDbRemoteDocumentCache.prototype.getEntry = function (transaction, documentKey) {\n        var _this = this;\n        return remoteDocumentsStore(transaction)\n            .get(dbKey(documentKey))\n            .next(function (dbRemoteDoc) {\n            return dbRemoteDoc\n                ? _this.serializer.fromDbRemoteDocument(dbRemoteDoc)\n                : null;\n        });\n    };\n    IndexedDbRemoteDocumentCache.prototype.getDocumentsMatchingQuery = function (transaction, query) {\n        var _this = this;\n        var results = documentMap();\n        // Documents are ordered by key, so we can use a prefix scan to narrow down\n        // the documents we need to match the query against.\n        var startKey = query.path.toArray();\n        var range = IDBKeyRange.lowerBound(startKey);\n        return remoteDocumentsStore(transaction)\n            .iterate({ range: range }, function (key, dbRemoteDoc, control) {\n            var maybeDoc = _this.serializer.fromDbRemoteDocument(dbRemoteDoc);\n            if (!query.path.isPrefixOf(maybeDoc.key.path)) {\n                control.done();\n            }\n            else if (maybeDoc instanceof document_Document && query.matches(maybeDoc)) {\n                results = results.insert(maybeDoc.key, maybeDoc);\n            }\n        })\n            .next(function () { return results; });\n    };\n    return IndexedDbRemoteDocumentCache;\n}());\n\n/**\n * Helper to get a typed SimpleDbStore for the remoteDocuments object store.\n */\nfunction remoteDocumentsStore(txn) {\n    if (txn instanceof simple_db_SimpleDbTransaction) {\n        return txn.store(DbRemoteDocument.store);\n    }\n    else {\n        return fail('Invalid transaction object provided!');\n    }\n}\nfunction dbKey(docKey) {\n    return docKey.path.toArray();\n}\n\n//# sourceMappingURL=indexeddb_remote_document_cache.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/local_serializer.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\n/** Serializer for values stored in the LocalStore. */\nvar local_serializer_LocalSerializer = /** @class */ (function () {\n    function LocalSerializer(remoteSerializer) {\n        this.remoteSerializer = remoteSerializer;\n    }\n    /** Decodes a remote document from storage locally to a Document. */\n    LocalSerializer.prototype.fromDbRemoteDocument = function (remoteDoc) {\n        if (remoteDoc.document) {\n            return this.remoteSerializer.fromDocument(remoteDoc.document);\n        }\n        else if (remoteDoc.noDocument) {\n            var key = document_key_DocumentKey.fromSegments(remoteDoc.noDocument.path);\n            var readTime = remoteDoc.noDocument.readTime;\n            var timestamp = new timestamp_Timestamp(readTime.seconds, readTime.nanos);\n            return new document_NoDocument(key, snapshot_version_SnapshotVersion.fromTimestamp(timestamp));\n        }\n        else {\n            return fail('Unexpected DbRemoteDocument');\n        }\n    };\n    /** Encodes a document for storage locally. */\n    LocalSerializer.prototype.toDbRemoteDocument = function (maybeDoc) {\n        if (maybeDoc instanceof document_Document) {\n            var doc = this.remoteSerializer.toDocument(maybeDoc);\n            return new DbRemoteDocument(null, doc);\n        }\n        else {\n            var path = maybeDoc.key.path.toArray();\n            var timestamp = maybeDoc.version.toTimestamp();\n            var readTime = new DbTimestamp(timestamp.seconds, timestamp.nanos);\n            return new DbRemoteDocument(new DbNoDocument(path, readTime), null);\n        }\n    };\n    /** Encodes a batch of mutations into a DbMutationBatch for local storage. */\n    LocalSerializer.prototype.toDbMutationBatch = function (userId, batch) {\n        var _this = this;\n        var serializedMutations = batch.mutations.map(function (m) {\n            return _this.remoteSerializer.toMutation(m);\n        });\n        return new DbMutationBatch(userId, batch.batchId, batch.localWriteTime.toEpochMilliseconds(), serializedMutations);\n    };\n    /** Decodes a DbMutationBatch into a MutationBatch */\n    LocalSerializer.prototype.fromDbMutationBatch = function (dbBatch) {\n        var _this = this;\n        var mutations = dbBatch.mutations.map(function (m) {\n            return _this.remoteSerializer.fromMutation(m);\n        });\n        var timestamp = timestamp_Timestamp.fromEpochMilliseconds(dbBatch.localWriteTimeMs);\n        return new mutation_batch_MutationBatch(dbBatch.batchId, timestamp, mutations);\n    };\n    /** Decodes a DbTarget into QueryData */\n    LocalSerializer.prototype.fromDbTarget = function (dbTarget) {\n        var readTime = new timestamp_Timestamp(dbTarget.readTime.seconds, dbTarget.readTime.nanos);\n        var version = snapshot_version_SnapshotVersion.fromTimestamp(readTime);\n        var query;\n        if (isDocumentQuery(dbTarget.query)) {\n            query = this.remoteSerializer.fromDocumentsTarget(dbTarget.query);\n        }\n        else {\n            query = this.remoteSerializer.fromQueryTarget(dbTarget.query);\n        }\n        return new query_data_QueryData(query, dbTarget.targetId, QueryPurpose.Listen, version, dbTarget.resumeToken);\n    };\n    /** Encodes QueryData into a DbTarget for storage locally. */\n    LocalSerializer.prototype.toDbTarget = function (queryData) {\n        assert(QueryPurpose.Listen === queryData.purpose, 'Only queries with purpose ' +\n            QueryPurpose.Listen +\n            ' may be stored, got ' +\n            queryData.purpose);\n        var timestamp = queryData.snapshotVersion.toTimestamp();\n        var dbTimestamp = new DbTimestamp(timestamp.seconds, timestamp.nanos);\n        var queryProto;\n        if (queryData.query.isDocumentQuery()) {\n            queryProto = this.remoteSerializer.toDocumentsTarget(queryData.query);\n        }\n        else {\n            queryProto = this.remoteSerializer.toQueryTarget(queryData.query);\n        }\n        assert(typeof queryData.resumeToken === 'string', 'Persisting non-string resume token not supported.');\n        var resumeToken = queryData.resumeToken;\n        // lastListenSequenceNumber is always 0 until we do real GC.\n        return new DbTarget(queryData.targetId, queryData.query.canonicalId(), dbTimestamp, resumeToken, 0, queryProto);\n    };\n    return LocalSerializer;\n}());\n\n/**\n * A helper function for figuring out what kind of query has been stored.\n */\nfunction isDocumentQuery(dbQuery) {\n    return dbQuery.documents !== undefined;\n}\n\n//# sourceMappingURL=local_serializer.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/indexeddb_persistence.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\n\n\n\nvar indexeddb_persistence_LOG_TAG = 'IndexedDbPersistence';\n/** If the owner lease is older than 5 seconds, try to take ownership. */\nvar OWNER_LEASE_MAX_AGE_MS = 5000;\n/** Refresh the owner lease every 4 seconds while owner. */\nvar OWNER_LEASE_REFRESH_INTERVAL_MS = 4000;\n/** LocalStorage location to indicate a zombied ownerId (see class comment). */\nvar ZOMBIE_OWNER_LOCALSTORAGE_SUFFIX = 'zombiedOwnerId';\n/** Error when the owner lease cannot be acquired or is lost. */\nvar EXISTING_OWNER_ERROR_MSG = 'There is another tab open with offline' +\n    ' persistence enabled. Only one such tab is allowed at a time. The' +\n    ' other tab must be closed or persistence must be disabled.';\nvar UNSUPPORTED_PLATFORM_ERROR_MSG = 'This platform is either missing' +\n    ' IndexedDB or is known to have an incomplete implementation. Offline' +\n    ' persistence has been disabled.';\n/**\n * An IndexedDB-backed instance of Persistence. Data is stored persistently\n * across sessions.\n *\n * Currently the Firestore SDK only supports a single consumer of the database,\n * but browsers obviously support multiple tabs. IndexedDbPersistence ensures a\n * single consumer of the database via an \"owner lease\" stored in the database.\n *\n * On startup, IndexedDbPersistence assigns itself a random \"ownerId\" and writes\n * it to a special \"owner\" object in the database (if no entry exists already or\n * the current entry is expired). This owner lease is then verified inside every\n * transaction to ensure the lease has not been lost.\n *\n * If a tab opts not to acquire the owner lease (because there's an existing\n * non-expired owner) or loses the owner lease, IndexedDbPersistence enters a\n * failed state and all subsequent operations will automatically fail.\n *\n * The current owner regularly refreshes the owner lease with new timestamps to\n * prevent newly-opened tabs from taking over ownership.\n *\n * Additionally there is an optimization so that when a tab is closed, the owner\n * lease is released immediately (this is especially important to make sure that\n * a refreshed tab is able to immediately re-acquire the owner lease).\n * Unfortunately, IndexedDB cannot be reliably used in window.unload since it is\n * an asynchronous API. So in addition to attempting to give up the lease,\n * the owner writes its ownerId to a \"zombiedOwnerId\" entry in LocalStorage\n * which acts as an indicator that another tab should go ahead and take the\n * owner lease immediately regardless of the current lease timestamp.\n */\nvar indexeddb_persistence_IndexedDbPersistence = /** @class */ (function () {\n    function IndexedDbPersistence(prefix, serializer) {\n        this.ownerId = this.generateOwnerId();\n        this.dbName = prefix + IndexedDbPersistence.MAIN_DATABASE;\n        this.serializer = new local_serializer_LocalSerializer(serializer);\n        this.localStoragePrefix = prefix;\n    }\n    IndexedDbPersistence.prototype.start = function () {\n        var _this = this;\n        if (!IndexedDbPersistence.isAvailable()) {\n            this.persistenceError = new error_FirestoreError(Code.UNIMPLEMENTED, UNSUPPORTED_PLATFORM_ERROR_MSG);\n            return Promise.reject(this.persistenceError);\n        }\n        assert(!this.started, 'IndexedDbPersistence double-started!');\n        this.started = true;\n        return simple_db_SimpleDb.openOrCreate(this.dbName, SCHEMA_VERSION, createOrUpgradeDb)\n            .then(function (db) {\n            _this.simpleDb = db;\n        })\n            .then(function () { return _this.tryAcquireOwnerLease(); })\n            .then(function () {\n            _this.scheduleOwnerLeaseRefreshes();\n            _this.attachWindowUnloadHook();\n        });\n    };\n    IndexedDbPersistence.prototype.shutdown = function () {\n        var _this = this;\n        assert(this.started, 'IndexedDbPersistence shutdown without start!');\n        this.started = false;\n        this.detachWindowUnloadHook();\n        this.stopOwnerLeaseRefreshes();\n        return this.releaseOwnerLease().then(function () {\n            _this.simpleDb.close();\n        });\n    };\n    IndexedDbPersistence.prototype.getMutationQueue = function (user) {\n        return indexeddb_mutation_queue_IndexedDbMutationQueue.forUser(user, this.serializer);\n    };\n    IndexedDbPersistence.prototype.getQueryCache = function () {\n        return new indexeddb_query_cache_IndexedDbQueryCache(this.serializer);\n    };\n    IndexedDbPersistence.prototype.getRemoteDocumentCache = function () {\n        return new indexeddb_remote_document_cache_IndexedDbRemoteDocumentCache(this.serializer);\n    };\n    IndexedDbPersistence.prototype.runTransaction = function (action, operation) {\n        var _this = this;\n        if (this.persistenceError) {\n            return Promise.reject(this.persistenceError);\n        }\n        debug(indexeddb_persistence_LOG_TAG, 'Starting transaction:', action);\n        // Do all transactions as readwrite against all object stores, since we\n        // are the only reader/writer.\n        return this.simpleDb.runTransaction('readwrite', ALL_STORES, function (txn) {\n            // Verify that we still have the owner lease as part of every transaction.\n            return _this.ensureOwnerLease(txn).next(function () { return operation(txn); });\n        });\n    };\n    IndexedDbPersistence.isAvailable = function () {\n        return simple_db_SimpleDb.isAvailable();\n    };\n    /**\n     * Generates a string used as a prefix when storing data in IndexedDB and\n     * LocalStorage.\n     */\n    IndexedDbPersistence.buildStoragePrefix = function (databaseInfo) {\n        // Use two different prefix formats:\n        //\n        //   * firestore / persistenceKey / projectID . databaseID / ...\n        //   * firestore / persistenceKey / projectID / ...\n        //\n        // projectIDs are DNS-compatible names and cannot contain dots\n        // so there's no danger of collisions.\n        var database = databaseInfo.databaseId.projectId;\n        if (!databaseInfo.databaseId.isDefaultDatabase) {\n            database += '.' + databaseInfo.databaseId.database;\n        }\n        return 'firestore/' + databaseInfo.persistenceKey + '/' + database + '/';\n    };\n    /**\n     * Acquires the owner lease if there's no valid owner. Else returns a rejected\n     * promise.\n     */\n    IndexedDbPersistence.prototype.tryAcquireOwnerLease = function () {\n        var _this = this;\n        // NOTE: Don't use this.runTransaction, since it requires us to already\n        // have the lease.\n        return this.simpleDb.runTransaction('readwrite', [DbOwner.store], function (txn) {\n            var store = txn.store(DbOwner.store);\n            return store.get('owner').next(function (dbOwner) {\n                if (!_this.validOwner(dbOwner)) {\n                    var newDbOwner = new DbOwner(_this.ownerId, Date.now());\n                    debug(indexeddb_persistence_LOG_TAG, 'No valid owner. Acquiring owner lease. Current owner:', dbOwner, 'New owner:', newDbOwner);\n                    return store.put('owner', newDbOwner);\n                }\n                else {\n                    debug(indexeddb_persistence_LOG_TAG, 'Valid owner already. Failing. Current owner:', dbOwner);\n                    _this.persistenceError = new error_FirestoreError(Code.FAILED_PRECONDITION, EXISTING_OWNER_ERROR_MSG);\n                    return persistence_promise_PersistencePromise.reject(_this.persistenceError);\n                }\n            });\n        });\n    };\n    /** Checks the owner lease and deletes it if we are the current owner. */\n    IndexedDbPersistence.prototype.releaseOwnerLease = function () {\n        var _this = this;\n        // NOTE: Don't use this.runTransaction, since it requires us to already\n        // have the lease.\n        return this.simpleDb.runTransaction('readwrite', [DbOwner.store], function (txn) {\n            var store = txn.store(DbOwner.store);\n            return store.get('owner').next(function (dbOwner) {\n                if (dbOwner !== null && dbOwner.ownerId === _this.ownerId) {\n                    debug(indexeddb_persistence_LOG_TAG, 'Releasing owner lease.');\n                    return store.delete('owner');\n                }\n                else {\n                    return persistence_promise_PersistencePromise.resolve();\n                }\n            });\n        });\n    };\n    /**\n     * Checks the owner lease and returns a rejected promise if we are not the\n     * current owner. This should be included in every transaction to guard\n     * against losing the owner lease.\n     */\n    IndexedDbPersistence.prototype.ensureOwnerLease = function (txn) {\n        var _this = this;\n        var store = txn.store(DbOwner.store);\n        return store.get('owner').next(function (dbOwner) {\n            if (dbOwner === null || dbOwner.ownerId !== _this.ownerId) {\n                _this.persistenceError = new error_FirestoreError(Code.FAILED_PRECONDITION, EXISTING_OWNER_ERROR_MSG);\n                return persistence_promise_PersistencePromise.reject(_this.persistenceError);\n            }\n            else {\n                return persistence_promise_PersistencePromise.resolve();\n            }\n        });\n    };\n    /**\n     * Returns true if the provided owner exists, has a recent timestamp, and\n     * isn't zombied.\n     *\n     * NOTE: To determine if the owner is zombied, this method reads from\n     * LocalStorage which could be mildly expensive.\n     */\n    IndexedDbPersistence.prototype.validOwner = function (dbOwner) {\n        var now = Date.now();\n        var minAcceptable = now - OWNER_LEASE_MAX_AGE_MS;\n        var maxAcceptable = now;\n        if (dbOwner === null) {\n            return false; // no owner.\n        }\n        else if (dbOwner.leaseTimestampMs < minAcceptable) {\n            return false; // owner lease has expired.\n        }\n        else if (dbOwner.leaseTimestampMs > maxAcceptable) {\n            log_error('Persistence owner-lease is in the future. Discarding.', dbOwner);\n            return false;\n        }\n        else if (dbOwner.ownerId === this.getZombiedOwnerId()) {\n            return false; // owner's tab closed.\n        }\n        else {\n            return true;\n        }\n    };\n    /**\n     * Schedules a recurring timer to update the owner lease timestamp to prevent\n     * other tabs from taking the lease.\n     */\n    IndexedDbPersistence.prototype.scheduleOwnerLeaseRefreshes = function () {\n        var _this = this;\n        // NOTE: This doesn't need to be scheduled on the async queue and doing so\n        // would increase the chances of us not refreshing on time if the queue is\n        // backed up for some reason.\n        this.ownerLeaseRefreshHandle = setInterval(function () {\n            var txResult = _this.runTransaction('Refresh owner timestamp', function (txn) {\n                // NOTE: We don't need to validate the current owner contents, since\n                // runTransaction does that automatically.\n                var store = txn.store(DbOwner.store);\n                return store.put('owner', new DbOwner(_this.ownerId, Date.now()));\n            });\n            txResult.catch(function (reason) {\n                // Probably means we lost the lease. Report the error and stop trying to\n                // refresh the lease.\n                log_error(reason);\n                _this.stopOwnerLeaseRefreshes();\n            });\n        }, OWNER_LEASE_REFRESH_INTERVAL_MS);\n    };\n    IndexedDbPersistence.prototype.stopOwnerLeaseRefreshes = function () {\n        if (this.ownerLeaseRefreshHandle) {\n            clearInterval(this.ownerLeaseRefreshHandle);\n            this.ownerLeaseRefreshHandle = null;\n        }\n    };\n    /**\n     * Attaches a window.unload handler that will synchronously write our\n     * ownerId to a \"zombie owner id\" location in localstorage. This can be used\n     * by tabs trying to acquire the lease to determine that the lease should be\n     * acquired immediately even if the timestamp is recent. This is particularly\n     * important for the refresh case (so the tab correctly re-acquires the owner\n     * lease). LocalStorage is used for this rather than IndexedDb because it is\n     * a synchronous API and so can be used reliably from an unload handler.\n     */\n    IndexedDbPersistence.prototype.attachWindowUnloadHook = function () {\n        var _this = this;\n        this.windowUnloadHandler = function () {\n            // Record that we're zombied.\n            _this.setZombiedOwnerId(_this.ownerId);\n            // Attempt graceful shutdown (including releasing our owner lease), but\n            // there's no guarantee it will complete.\n            _this.shutdown();\n        };\n        window.addEventListener('unload', this.windowUnloadHandler);\n    };\n    IndexedDbPersistence.prototype.detachWindowUnloadHook = function () {\n        if (this.windowUnloadHandler) {\n            window.removeEventListener('unload', this.windowUnloadHandler);\n            this.windowUnloadHandler = null;\n        }\n    };\n    /**\n     * Returns any recorded \"zombied owner\" (i.e. a previous owner that became\n     * zombied due to their tab closing) from LocalStorage, or null if no such\n     * record exists.\n     */\n    IndexedDbPersistence.prototype.getZombiedOwnerId = function () {\n        try {\n            var zombiedOwnerId = window.localStorage.getItem(this.zombiedOwnerLocalStorageKey());\n            debug(indexeddb_persistence_LOG_TAG, 'Zombied ownerID from LocalStorage:', zombiedOwnerId);\n            return zombiedOwnerId;\n        }\n        catch (e) {\n            // Gracefully handle if LocalStorage isn't available / working.\n            log_error('Failed to get zombie owner id.', e);\n            return null;\n        }\n    };\n    /**\n     * Records a zombied owner (an owner that had its tab closed) in LocalStorage\n     * or, if passed null, deletes any recorded zombied owner.\n     */\n    IndexedDbPersistence.prototype.setZombiedOwnerId = function (zombieOwnerId) {\n        try {\n            if (zombieOwnerId === null) {\n                window.localStorage.removeItem(this.zombiedOwnerLocalStorageKey());\n            }\n            else {\n                window.localStorage.setItem(this.zombiedOwnerLocalStorageKey(), zombieOwnerId);\n            }\n        }\n        catch (e) {\n            // Gracefully handle if LocalStorage isn't available / working.\n            log_error('Failed to set zombie owner id.', e);\n        }\n    };\n    IndexedDbPersistence.prototype.zombiedOwnerLocalStorageKey = function () {\n        return this.localStoragePrefix + ZOMBIE_OWNER_LOCALSTORAGE_SUFFIX;\n    };\n    IndexedDbPersistence.prototype.generateOwnerId = function () {\n        // For convenience, just use an AutoId.\n        return misc_AutoId.newId();\n    };\n    /**\n     * The name of the main (and currently only) IndexedDB database. this name is\n     * appended to the prefix provided to the IndexedDbPersistence constructor.\n     */\n    IndexedDbPersistence.MAIN_DATABASE = 'main';\n    return IndexedDbPersistence;\n}());\n\n\n//# sourceMappingURL=indexeddb_persistence.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/local_documents_view.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n/**\n * A readonly view of the local state of all documents we're tracking (i.e. we\n * have a cached version in remoteDocumentCache or local mutations for the\n * document). The view is computed by applying the mutations in the\n * MutationQueue to the RemoteDocumentCache.\n */\nvar local_documents_view_LocalDocumentsView = /** @class */ (function () {\n    function LocalDocumentsView(remoteDocumentCache, mutationQueue) {\n        this.remoteDocumentCache = remoteDocumentCache;\n        this.mutationQueue = mutationQueue;\n    }\n    /**\n     * Get the local view of the document identified by `key`.\n     *\n     * @return Local view of the document or null if we don't have any cached\n     * state for it.\n     */\n    LocalDocumentsView.prototype.getDocument = function (transaction, key) {\n        var _this = this;\n        return this.remoteDocumentCache\n            .getEntry(transaction, key)\n            .next(function (remoteDoc) {\n            return _this.computeLocalDocument(transaction, key, remoteDoc);\n        });\n    };\n    /**\n     * Gets the local view of the documents identified by `keys`.\n     *\n     * If we don't have cached state for a document in `keys`, a NoDocument will\n     * be stored for that key in the resulting set.\n     */\n    LocalDocumentsView.prototype.getDocuments = function (transaction, keys) {\n        var _this = this;\n        var promises = [];\n        var results = maybeDocumentMap();\n        keys.forEach(function (key) {\n            promises.push(_this.getDocument(transaction, key).next(function (maybeDoc) {\n                // TODO(http://b/32275378): Don't conflate missing / deleted.\n                if (!maybeDoc) {\n                    maybeDoc = new document_NoDocument(key, snapshot_version_SnapshotVersion.forDeletedDoc());\n                }\n                results = results.insert(key, maybeDoc);\n            }));\n        });\n        return persistence_promise_PersistencePromise.waitFor(promises).next(function () { return results; });\n    };\n    /** Performs a query against the local view of all documents. */\n    LocalDocumentsView.prototype.getDocumentsMatchingQuery = function (transaction, query) {\n        if (document_key_DocumentKey.isDocumentKey(query.path)) {\n            return this.getDocumentsMatchingDocumentQuery(transaction, query.path);\n        }\n        else {\n            return this.getDocumentsMatchingCollectionQuery(transaction, query);\n        }\n    };\n    LocalDocumentsView.prototype.getDocumentsMatchingDocumentQuery = function (transaction, docPath) {\n        // Just do a simple document lookup.\n        return this.getDocument(transaction, new document_key_DocumentKey(docPath)).next(function (maybeDoc) {\n            var result = documentMap();\n            if (maybeDoc instanceof document_Document) {\n                result = result.insert(maybeDoc.key, maybeDoc);\n            }\n            return result;\n        });\n    };\n    LocalDocumentsView.prototype.getDocumentsMatchingCollectionQuery = function (transaction, query) {\n        var _this = this;\n        // Query the remote documents and overlay mutations.\n        // TODO(mikelehen): There may be significant overlap between the mutations\n        // affecting these remote documents and the\n        // getAllMutationBatchesAffectingQuery() mutations. Consider optimizing.\n        var results;\n        return this.remoteDocumentCache\n            .getDocumentsMatchingQuery(transaction, query)\n            .next(function (queryResults) {\n            return _this.computeLocalDocuments(transaction, queryResults);\n        })\n            .next(function (promisedResults) {\n            results = promisedResults;\n            // Now use the mutation queue to discover any other documents that may\n            // match the query after applying mutations.\n            return _this.mutationQueue.getAllMutationBatchesAffectingQuery(transaction, query);\n        })\n            .next(function (matchingMutationBatches) {\n            var matchingKeys = documentKeySet();\n            for (var _i = 0, matchingMutationBatches_1 = matchingMutationBatches; _i < matchingMutationBatches_1.length; _i++) {\n                var batch = matchingMutationBatches_1[_i];\n                for (var _a = 0, _b = batch.mutations; _a < _b.length; _a++) {\n                    var mutation = _b[_a];\n                    // TODO(mikelehen): PERF: Check if this mutation actually\n                    // affects the query to reduce work.\n                    if (!results.get(mutation.key)) {\n                        matchingKeys = matchingKeys.add(mutation.key);\n                    }\n                }\n            }\n            // Now add in the results for the matchingKeys.\n            var promises = [];\n            matchingKeys.forEach(function (key) {\n                promises.push(_this.getDocument(transaction, key).next(function (doc) {\n                    if (doc instanceof document_Document) {\n                        results = results.insert(doc.key, doc);\n                    }\n                }));\n            });\n            return persistence_promise_PersistencePromise.waitFor(promises);\n        })\n            .next(function () {\n            // Finally, filter out any documents that don't actually match\n            // the query.\n            results.forEach(function (key, doc) {\n                if (!query.matches(doc)) {\n                    results = results.remove(key);\n                }\n            });\n            return results;\n        });\n    };\n    /**\n     * Takes a remote document and applies local mutations to generate the local\n     * view of the document.\n     * @param transaction The transaction in which to perform any persistence\n     *     operations.\n     * @param documentKey The key of the document (necessary when remoteDocument\n     *     is null).\n     * @param document The base remote document to apply mutations to or null.\n     */\n    LocalDocumentsView.prototype.computeLocalDocument = function (transaction, documentKey, document) {\n        return this.mutationQueue\n            .getAllMutationBatchesAffectingDocumentKey(transaction, documentKey)\n            .next(function (batches) {\n            for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {\n                var batch = batches_1[_i];\n                document = batch.applyToLocalView(documentKey, document);\n            }\n            return document;\n        });\n    };\n    /**\n     * Takes a set of remote documents and applies local mutations to generate the\n     * local view of the documents.\n     * @param transaction The transaction in which to perform any persistence\n     *     operations.\n     * @param documents The base remote documents to apply mutations to.\n     * @return The local view of the documents.\n     */\n    LocalDocumentsView.prototype.computeLocalDocuments = function (transaction, documents) {\n        var _this = this;\n        var promises = [];\n        documents.forEach(function (key, doc) {\n            promises.push(_this.computeLocalDocument(transaction, key, doc).next(function (mutatedDoc) {\n                if (mutatedDoc instanceof document_Document) {\n                    documents = documents.insert(mutatedDoc.key, mutatedDoc);\n                }\n                else if (mutatedDoc instanceof document_NoDocument) {\n                    documents = documents.remove(mutatedDoc.key);\n                }\n                else {\n                    fail('Unknown MaybeDocument: ' + mutatedDoc);\n                }\n            }));\n        });\n        return persistence_promise_PersistencePromise.waitFor(promises).next(function () { return documents; });\n    };\n    return LocalDocumentsView;\n}());\n\n\n//# sourceMappingURL=local_documents_view.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/remote_document_change_buffer.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n * An in-memory buffer of entries to be written to a RemoteDocumentCache.\n * It can be used to batch up a set of changes to be written to the cache, but\n * additionally supports reading entries back with the `getEntry()` method,\n * falling back to the underlying RemoteDocumentCache if no entry is\n * buffered.\n *\n * NOTE: This class was introduced in iOS to work around a limitation in\n * LevelDB. Given IndexedDb has full transaction support with\n * read-your-own-writes capability, this class is not technically needed, but\n * has been preserved as a convenience and to aid portability.\n */\nvar remote_document_change_buffer_RemoteDocumentChangeBuffer = /** @class */ (function () {\n    function RemoteDocumentChangeBuffer(remoteDocumentCache) {\n        this.remoteDocumentCache = remoteDocumentCache;\n        this.changes = maybeDocumentMap();\n    }\n    /** Buffers a `RemoteDocumentCache.addEntry()` call. */\n    RemoteDocumentChangeBuffer.prototype.addEntry = function (maybeDocument) {\n        var changes = this.assertChanges();\n        this.changes = changes.insert(maybeDocument.key, maybeDocument);\n    };\n    // NOTE: removeEntry() is not presently necessary and so is omitted.\n    /**\n     * Looks up an entry in the cache. The buffered changes will first be checked,\n     * and if no buffered change applies, this will forward to\n     * `RemoteDocumentCache.getEntry()`.\n     *\n     * @param transaction The transaction in which to perform any persistence\n     *     operations.\n     * @param documentKey The key of the entry to look up.\n     * @return The cached Document or NoDocument entry, or null if we have nothing\n     * cached.\n     */\n    RemoteDocumentChangeBuffer.prototype.getEntry = function (transaction, documentKey) {\n        var changes = this.assertChanges();\n        var bufferedEntry = changes.get(documentKey);\n        if (bufferedEntry) {\n            return persistence_promise_PersistencePromise.resolve(bufferedEntry);\n        }\n        else {\n            return this.remoteDocumentCache.getEntry(transaction, documentKey);\n        }\n    };\n    /**\n     * Applies buffered changes to the underlying RemoteDocumentCache, using\n     * the provided transaction.\n     */\n    RemoteDocumentChangeBuffer.prototype.apply = function (transaction) {\n        var _this = this;\n        var changes = this.assertChanges();\n        var promises = [];\n        changes.forEach(function (key, maybeDoc) {\n            promises.push(_this.remoteDocumentCache.addEntry(transaction, maybeDoc));\n        });\n        // We should not be used to buffer any more changes.\n        this.changes = null;\n        return persistence_promise_PersistencePromise.waitFor(promises);\n    };\n    /** Helper to assert this.changes is not null and return it. */\n    RemoteDocumentChangeBuffer.prototype.assertChanges = function () {\n        assert(this.changes !== null, 'Changes have already been applied.');\n        return this.changes;\n    };\n    return RemoteDocumentChangeBuffer;\n}());\n\n\n//# sourceMappingURL=remote_document_change_buffer.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/local_store.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar local_store_LOG_TAG = 'LocalStore';\n/**\n * Local storage in the Firestore client. Coordinates persistence components\n * like the mutation queue and remote document cache to present a\n * latency-compensated view of stored data.\n *\n * The LocalStore is responsible for accepting mutations from the Sync Engine.\n * Writes from the client are put into a queue as provisional Mutations until\n * they are processed by the RemoteStore and confirmed as having been written\n * to the server.\n *\n * The local store provides the local version of documents that have been\n * modified locally. It maintains the constraint:\n *\n *   LocalDocument = RemoteDocument + Active(LocalMutations)\n *\n * (Active mutations are those that are enqueued and have not been previously\n * acknowledged or rejected).\n *\n * The RemoteDocument (\"ground truth\") state is provided via the\n * applyChangeBatch method. It will be some version of a server-provided\n * document OR will be a server-provided document PLUS acknowledged mutations:\n *\n *   RemoteDocument' = RemoteDocument + Acknowledged(LocalMutations)\n *\n * Note that this \"dirty\" version of a RemoteDocument will not be identical to a\n * server base version, since it has LocalMutations added to it pending getting\n * an authoritative copy from the server.\n *\n * Since LocalMutations can be rejected by the server, we have to be able to\n * revert a LocalMutation that has already been applied to the LocalDocument\n * (typically done by replaying all remaining LocalMutations to the\n * RemoteDocument to re-apply).\n *\n * The LocalStore is responsible for the garbage collection of the documents it\n * contains. For now, it every doc referenced by a view, the mutation queue, or\n * the RemoteStore.\n *\n * It also maintains the persistence of mapping queries to resume tokens and\n * target ids. It needs to know this data about queries to properly know what\n * docs it would be allowed to garbage collect.\n *\n * The LocalStore must be able to efficiently execute queries against its local\n * cache of the documents, to provide the initial set of results before any\n * remote changes have been received.\n *\n * Note: In TypeScript, most methods return Promises since the implementation\n * may rely on fetching data from IndexedDB which is async.\n * These Promises will only be rejected on an I/O error or other internal\n * (unexpected) failure (e.g. failed assert) and always represent an\n * unrecoverable error (should be caught / reported by the async_queue).\n */\nvar local_store_LocalStore = /** @class */ (function () {\n    function LocalStore(\n    /** Manages our in-memory or durable persistence. */\n    persistence, initialUser, \n    /**\n     * The garbage collector collects documents that should no longer be\n     * cached (e.g. if they are no longer retained by the above reference sets\n     * and the garbage collector is performing eager collection).\n     */\n    garbageCollector) {\n        this.persistence = persistence;\n        this.garbageCollector = garbageCollector;\n        /**\n         * The set of document references maintained by any local views.\n         */\n        this.localViewReferences = new reference_set_ReferenceSet();\n        /** Maps a targetID to data about its query. */\n        this.targetIds = {};\n        /** Used to generate targetIDs for queries tracked locally. */\n        this.targetIdGenerator = TargetIdGenerator.forLocalStore();\n        /**\n         * A heldBatchResult is a mutation batch result (from a write acknowledgement)\n         * that arrived before the watch stream got notified of a snapshot that\n         * includes the write.So we \"hold\" it until the watch stream catches up. It\n         * ensures that the local write remains visible (latency compensation) and\n         * doesn't temporarily appear reverted because the watch stream is slower than\n         * the write stream and so wasn't reflecting it.\n         *\n         * NOTE: Eventually we want to move this functionality into the remote store.\n         */\n        this.heldBatchResults = [];\n        this.mutationQueue = persistence.getMutationQueue(initialUser);\n        this.remoteDocuments = persistence.getRemoteDocumentCache();\n        this.queryCache = persistence.getQueryCache();\n        this.localDocuments = new local_documents_view_LocalDocumentsView(this.remoteDocuments, this.mutationQueue);\n        this.garbageCollector.addGarbageSource(this.localViewReferences);\n        this.garbageCollector.addGarbageSource(this.queryCache);\n        this.garbageCollector.addGarbageSource(this.mutationQueue);\n    }\n    /** Performs any initial startup actions required by the local store. */\n    LocalStore.prototype.start = function () {\n        var _this = this;\n        return this.persistence.runTransaction('Start LocalStore', function (txn) {\n            return _this.startMutationQueue(txn).next(function () { return _this.startQueryCache(txn); });\n        });\n    };\n    /**\n     * Tells the LocalStore that the currently authenticated user has changed.\n     *\n     * In response the local store switches the mutation queue to the new user and\n     * returns any resulting document changes.\n     */\n    LocalStore.prototype.handleUserChange = function (user) {\n        var _this = this;\n        return this.persistence.runTransaction('Handle user change', function (txn) {\n            // Swap out the mutation queue, grabbing the pending mutation batches\n            // before and after.\n            var oldBatches;\n            return _this.mutationQueue\n                .getAllMutationBatches(txn)\n                .next(function (promisedOldBatches) {\n                oldBatches = promisedOldBatches;\n                _this.garbageCollector.removeGarbageSource(_this.mutationQueue);\n                _this.mutationQueue = _this.persistence.getMutationQueue(user);\n                _this.garbageCollector.addGarbageSource(_this.mutationQueue);\n                return _this.startMutationQueue(txn);\n            })\n                .next(function () {\n                // Recreate our LocalDocumentsView using the new\n                // MutationQueue.\n                _this.localDocuments = new local_documents_view_LocalDocumentsView(_this.remoteDocuments, _this.mutationQueue);\n                return _this.mutationQueue.getAllMutationBatches(txn);\n            })\n                .next(function (newBatches) {\n                // Union the old/new changed keys.\n                var changedKeys = documentKeySet();\n                for (var _i = 0, _a = [oldBatches, newBatches]; _i < _a.length; _i++) {\n                    var batches = _a[_i];\n                    for (var _b = 0, batches_1 = batches; _b < batches_1.length; _b++) {\n                        var batch = batches_1[_b];\n                        for (var _c = 0, _d = batch.mutations; _c < _d.length; _c++) {\n                            var mutation = _d[_c];\n                            changedKeys = changedKeys.add(mutation.key);\n                        }\n                    }\n                }\n                // Return the set of all (potentially) changed documents as the\n                // result of the user change.\n                return _this.localDocuments.getDocuments(txn, changedKeys);\n            });\n        });\n    };\n    LocalStore.prototype.startQueryCache = function (txn) {\n        var _this = this;\n        return this.queryCache.start(txn).next(function () {\n            var targetId = _this.queryCache.getHighestTargetId();\n            _this.targetIdGenerator = TargetIdGenerator.forLocalStore(targetId);\n        });\n    };\n    LocalStore.prototype.startMutationQueue = function (txn) {\n        var _this = this;\n        return this.mutationQueue\n            .start(txn)\n            .next(function () {\n            // If we have any leftover mutation batch results from a prior run,\n            // just drop them.\n            // TODO(http://b/33446471): We probably need to repopulate\n            // heldBatchResults or similar instead, but that is not\n            // straightforward since we're not persisting the write ack versions.\n            _this.heldBatchResults = [];\n            return _this.mutationQueue.getHighestAcknowledgedBatchId(txn);\n        })\n            .next(function (highestAck) {\n            // TODO(mikelehen): This is the only usage of\n            // getAllMutationBatchesThroughBatchId(). Consider removing it in\n            // favor of a getAcknowledgedBatches() method.\n            if (highestAck !== BATCHID_UNKNOWN) {\n                return _this.mutationQueue.getAllMutationBatchesThroughBatchId(txn, highestAck);\n            }\n            else {\n                return persistence_promise_PersistencePromise.resolve([]);\n            }\n        })\n            .next(function (ackedBatches) {\n            if (ackedBatches.length > 0) {\n                return _this.mutationQueue.removeMutationBatches(txn, ackedBatches);\n            }\n            else {\n                return persistence_promise_PersistencePromise.resolve();\n            }\n        });\n    };\n    /* Accept locally generated Mutations and commit them to storage. */\n    LocalStore.prototype.localWrite = function (mutations) {\n        var _this = this;\n        return this.persistence.runTransaction('Locally write mutations', function (txn) {\n            var batch;\n            var localWriteTime = timestamp_Timestamp.now();\n            return _this.mutationQueue\n                .addMutationBatch(txn, localWriteTime, mutations)\n                .next(function (promisedBatch) {\n                batch = promisedBatch;\n                // TODO(koss): This is doing an N^2 update by replaying ALL the\n                // mutations on each document (instead of just the ones added) in\n                // this batch.\n                var keys = batch.keys();\n                return _this.localDocuments.getDocuments(txn, keys);\n            })\n                .next(function (changedDocuments) {\n                return { batchId: batch.batchId, changes: changedDocuments };\n            });\n        });\n    };\n    /**\n     * Acknowledge the given batch.\n     *\n     * On the happy path when a batch is acknowledged, the local store will\n     *\n     *  + remove the batch from the mutation queue;\n     *  + apply the changes to the remote document cache;\n     *  + recalculate the latency compensated view implied by those changes (there\n     *    may be mutations in the queue that affect the documents but haven't been\n     *    acknowledged yet); and\n     *  + give the changed documents back the sync engine\n     *\n     * @returns The resulting (modified) documents.\n     */\n    LocalStore.prototype.acknowledgeBatch = function (batchResult) {\n        var _this = this;\n        return this.persistence.runTransaction('Acknowledge batch', function (txn) {\n            var affected;\n            return _this.mutationQueue\n                .acknowledgeBatch(txn, batchResult.batch, batchResult.streamToken)\n                .next(function () {\n                if (_this.shouldHoldBatchResult(batchResult.commitVersion)) {\n                    _this.heldBatchResults.push(batchResult);\n                    affected = documentKeySet();\n                    return persistence_promise_PersistencePromise.resolve();\n                }\n                else {\n                    var documentBuffer_1 = new remote_document_change_buffer_RemoteDocumentChangeBuffer(_this.remoteDocuments);\n                    return _this.releaseBatchResults(txn, [batchResult], documentBuffer_1).next(function (promisedAffectedKeys) {\n                        affected = promisedAffectedKeys;\n                        return documentBuffer_1.apply(txn);\n                    });\n                }\n            })\n                .next(function () {\n                return _this.mutationQueue.performConsistencyCheck(txn);\n            })\n                .next(function () {\n                return _this.localDocuments.getDocuments(txn, affected);\n            });\n        });\n    };\n    /**\n     * Remove mutations from the MutationQueue for the specified batch;\n     * LocalDocuments will be recalculated.\n     *\n     * @returns The resulting modified documents.\n     */\n    LocalStore.prototype.rejectBatch = function (batchId) {\n        var _this = this;\n        return this.persistence.runTransaction('Reject batch', function (txn) {\n            var toReject;\n            var affectedKeys;\n            return _this.mutationQueue\n                .lookupMutationBatch(txn, batchId)\n                .next(function (promisedToReject) {\n                assert(promisedToReject != null, 'Attempt to reject nonexistent batch!');\n                toReject = promisedToReject;\n                return _this.mutationQueue\n                    .getHighestAcknowledgedBatchId(txn)\n                    .next(function (lastAcked) {\n                    assert(batchId > lastAcked, \"Acknowledged batches can't be rejected.\");\n                    return toReject;\n                });\n            })\n                .next(function () {\n                return _this.removeMutationBatch(txn, toReject);\n            })\n                .next(function (promisedAffectedKeys) {\n                affectedKeys = promisedAffectedKeys;\n                return _this.mutationQueue.performConsistencyCheck(txn);\n            })\n                .next(function () {\n                return _this.localDocuments.getDocuments(txn, affectedKeys);\n            });\n        });\n    };\n    /** Returns the last recorded stream token for the current user. */\n    LocalStore.prototype.getLastStreamToken = function () {\n        var _this = this;\n        return this.persistence.runTransaction('Get last stream token', function (txn) {\n            return _this.mutationQueue.getLastStreamToken(txn);\n        });\n    };\n    /**\n     * Sets the stream token for the current user without acknowledging any\n     * mutation batch. This is usually only useful after a stream handshake or in\n     * response to an error that requires clearing the stream token.\n     */\n    LocalStore.prototype.setLastStreamToken = function (streamToken) {\n        var _this = this;\n        return this.persistence.runTransaction('Set last stream token', function (txn) {\n            return _this.mutationQueue.setLastStreamToken(txn, streamToken);\n        });\n    };\n    /**\n     * Returns the last consistent snapshot processed (used by the RemoteStore to\n     * determine whether to buffer incoming snapshots from the backend).\n     */\n    LocalStore.prototype.getLastRemoteSnapshotVersion = function () {\n        return this.queryCache.getLastRemoteSnapshotVersion();\n    };\n    /**\n     * Update the \"ground-state\" (remote) documents. We assume that the remote\n     * event reflects any write batches that have been acknowledged or rejected\n     * (i.e. we do not re-apply local mutations to updates from this event).\n     *\n     * LocalDocuments are re-calculated if there are remaining mutations in the\n     * queue.\n     */\n    LocalStore.prototype.applyRemoteEvent = function (remoteEvent) {\n        var _this = this;\n        var documentBuffer = new remote_document_change_buffer_RemoteDocumentChangeBuffer(this.remoteDocuments);\n        return this.persistence.runTransaction('Apply remote event', function (txn) {\n            var promises = [];\n            forEachNumber(remoteEvent.targetChanges, function (targetId, change) {\n                // Do not ref/unref unassigned targetIds - it may lead to leaks.\n                var queryData = _this.targetIds[targetId];\n                if (!queryData)\n                    return;\n                var mapping = change.mapping;\n                if (mapping) {\n                    // First make sure that all references are deleted\n                    if (mapping instanceof ResetMapping) {\n                        promises.push(_this.queryCache\n                            .removeMatchingKeysForTargetId(txn, targetId)\n                            .next(function () {\n                            return _this.queryCache.addMatchingKeys(txn, mapping.documents, targetId);\n                        }));\n                    }\n                    else if (mapping instanceof UpdateMapping) {\n                        promises.push(_this.queryCache\n                            .removeMatchingKeys(txn, mapping.removedDocuments, targetId)\n                            .next(function () {\n                            return _this.queryCache.addMatchingKeys(txn, mapping.addedDocuments, targetId);\n                        }));\n                    }\n                    else {\n                        return fail('Unknown mapping type: ' + JSON.stringify(mapping));\n                    }\n                }\n                // Update the resume token if the change includes one. Don't clear\n                // any preexisting value.\n                var resumeToken = change.resumeToken;\n                if (resumeToken.length > 0) {\n                    queryData = queryData.update({\n                        resumeToken: resumeToken,\n                        snapshotVersion: change.snapshotVersion\n                    });\n                    _this.targetIds[targetId] = queryData;\n                    promises.push(_this.queryCache.updateQueryData(txn, queryData));\n                }\n            });\n            var changedDocKeys = documentKeySet();\n            remoteEvent.documentUpdates.forEach(function (key, doc) {\n                changedDocKeys = changedDocKeys.add(key);\n                promises.push(documentBuffer.getEntry(txn, key).next(function (existingDoc) {\n                    // Make sure we don't apply an old document version to the remote\n                    // cache, though we make an exception for SnapshotVersion.MIN which\n                    // can happen for manufactured events (e.g. in the case of a limbo\n                    // document resolution failing).\n                    if (existingDoc == null ||\n                        doc.version.isEqual(snapshot_version_SnapshotVersion.MIN) ||\n                        doc.version.compareTo(existingDoc.version) >= 0) {\n                        documentBuffer.addEntry(doc);\n                    }\n                    else {\n                        debug(local_store_LOG_TAG, 'Ignoring outdated watch update for ', key, '. Current version:', existingDoc.version, ' Watch version:', doc.version);\n                    }\n                    // The document might be garbage because it was unreferenced by\n                    // everything. Make sure to mark it as garbage if it is...\n                    _this.garbageCollector.addPotentialGarbageKey(key);\n                }));\n            });\n            // HACK: The only reason we allow a null snapshot version is so that we\n            // can synthesize remote events when we get permission denied errors while\n            // trying to resolve the state of a locally cached document that is in\n            // limbo.\n            var lastRemoteVersion = _this.queryCache.getLastRemoteSnapshotVersion();\n            var remoteVersion = remoteEvent.snapshotVersion;\n            if (!remoteVersion.isEqual(snapshot_version_SnapshotVersion.MIN)) {\n                assert(remoteVersion.compareTo(lastRemoteVersion) >= 0, 'Watch stream reverted to previous snapshot?? ' +\n                    remoteVersion +\n                    ' < ' +\n                    lastRemoteVersion);\n                promises.push(_this.queryCache.setLastRemoteSnapshotVersion(txn, remoteVersion));\n            }\n            var releasedWriteKeys;\n            return persistence_promise_PersistencePromise.waitFor(promises)\n                .next(function () { return _this.releaseHeldBatchResults(txn, documentBuffer); })\n                .next(function (promisedReleasedWriteKeys) {\n                releasedWriteKeys = promisedReleasedWriteKeys;\n                return documentBuffer.apply(txn);\n            })\n                .next(function () {\n                return _this.localDocuments.getDocuments(txn, changedDocKeys.unionWith(releasedWriteKeys));\n            });\n        });\n    };\n    /**\n     * Notify local store of the changed views to locally pin documents.\n     */\n    LocalStore.prototype.notifyLocalViewChanges = function (viewChanges) {\n        var _this = this;\n        return this.persistence.runTransaction('Notify local view changes', function (txn) {\n            var promises = [];\n            var _loop_1 = function (view) {\n                promises.push(_this.queryCache\n                    .getQueryData(txn, view.query)\n                    .next(function (queryData) {\n                    assert(queryData !== null, 'Local view changes contain unallocated query.');\n                    var targetId = queryData.targetId;\n                    _this.localViewReferences.addReferences(view.addedKeys, targetId);\n                    _this.localViewReferences.removeReferences(view.removedKeys, targetId);\n                }));\n            };\n            for (var _i = 0, viewChanges_1 = viewChanges; _i < viewChanges_1.length; _i++) {\n                var view = viewChanges_1[_i];\n                _loop_1(view);\n            }\n            return persistence_promise_PersistencePromise.waitFor(promises);\n        });\n    };\n    /**\n     * Gets the mutation batch after the passed in batchId in the mutation queue\n     * or null if empty.\n     * @param afterBatchId If provided, the batch to search after.\n     * @returns The next mutation or null if there wasn't one.\n     */\n    LocalStore.prototype.nextMutationBatch = function (afterBatchId) {\n        var _this = this;\n        return this.persistence.runTransaction('Get next mutation batch', function (txn) {\n            if (afterBatchId === undefined) {\n                afterBatchId = BATCHID_UNKNOWN;\n            }\n            return _this.mutationQueue.getNextMutationBatchAfterBatchId(txn, afterBatchId);\n        });\n    };\n    /**\n     * Read the current value of a Document with a given key or null if not\n     * found - used for testing.\n     */\n    LocalStore.prototype.readDocument = function (key) {\n        var _this = this;\n        return this.persistence.runTransaction('read document', function (txn) {\n            return _this.localDocuments.getDocument(txn, key);\n        });\n    };\n    /**\n     * Assigns the given query an internal ID so that its results can be pinned so\n     * they don't get GC'd. A query must be allocated in the local store before\n     * the store can be used to manage its view.\n     */\n    LocalStore.prototype.allocateQuery = function (query) {\n        var _this = this;\n        return this.persistence.runTransaction('Allocate query', function (txn) {\n            var queryData;\n            return _this.queryCache\n                .getQueryData(txn, query)\n                .next(function (cached) {\n                if (cached) {\n                    // This query has been listened to previously, so reuse the\n                    // previous targetID.\n                    // TODO(mcg): freshen last accessed date?\n                    queryData = cached;\n                    return persistence_promise_PersistencePromise.resolve();\n                }\n                else {\n                    var targetId = _this.targetIdGenerator.next();\n                    queryData = new query_data_QueryData(query, targetId, QueryPurpose.Listen);\n                    return _this.queryCache.addQueryData(txn, queryData);\n                }\n            })\n                .next(function () {\n                assert(!_this.targetIds[queryData.targetId], 'Tried to allocate an already allocated query: ' + query);\n                _this.targetIds[queryData.targetId] = queryData;\n                return queryData;\n            });\n        });\n    };\n    /** Unpin all the documents associated with the given query. */\n    LocalStore.prototype.releaseQuery = function (query) {\n        var _this = this;\n        return this.persistence.runTransaction('Release query', function (txn) {\n            return _this.queryCache\n                .getQueryData(txn, query)\n                .next(function (queryData) {\n                assert(queryData != null, 'Tried to release nonexistent query: ' + query);\n                _this.localViewReferences.removeReferencesForId(queryData.targetId);\n                delete _this.targetIds[queryData.targetId];\n                if (_this.garbageCollector.isEager) {\n                    return _this.queryCache.removeQueryData(txn, queryData);\n                }\n                else {\n                    return persistence_promise_PersistencePromise.resolve();\n                }\n            })\n                .next(function () {\n                // If this was the last watch target, then we won't get any more\n                // watch snapshots, so we should release any held batch results.\n                if (isEmpty(_this.targetIds)) {\n                    var documentBuffer_2 = new remote_document_change_buffer_RemoteDocumentChangeBuffer(_this.remoteDocuments);\n                    return _this.releaseHeldBatchResults(txn, documentBuffer_2).next(function () {\n                        documentBuffer_2.apply(txn);\n                    });\n                }\n                else {\n                    return persistence_promise_PersistencePromise.resolve();\n                }\n            });\n        });\n    };\n    /**\n     * Runs the specified query against all the documents in the local store and\n     * returns the results.\n     */\n    LocalStore.prototype.executeQuery = function (query) {\n        var _this = this;\n        return this.persistence.runTransaction('Execute query', function (txn) {\n            return _this.localDocuments.getDocumentsMatchingQuery(txn, query);\n        });\n    };\n    /**\n     * Returns the keys of the documents that are associated with the given\n     * target id in the remote table.\n     */\n    LocalStore.prototype.remoteDocumentKeys = function (targetId) {\n        var _this = this;\n        return this.persistence.runTransaction('Remote document keys', function (txn) {\n            return _this.queryCache.getMatchingKeysForTargetId(txn, targetId);\n        });\n    };\n    /**\n     * Collect garbage if necessary.\n     * Should be called periodically by Sync Engine to recover resources. The\n     * implementation must guarantee that GC won't happen in other places than\n     * this method call.\n     */\n    LocalStore.prototype.collectGarbage = function () {\n        var _this = this;\n        // Call collectGarbage regardless of whether isGCEnabled so the referenceSet\n        // doesn't continue to accumulate the garbage keys.\n        return this.persistence.runTransaction('Garbage collection', function (txn) {\n            return _this.garbageCollector.collectGarbage(txn).next(function (garbage) {\n                var promises = [];\n                garbage.forEach(function (key) {\n                    promises.push(_this.remoteDocuments.removeEntry(txn, key));\n                });\n                return persistence_promise_PersistencePromise.waitFor(promises);\n            });\n        });\n    };\n    LocalStore.prototype.releaseHeldBatchResults = function (txn, documentBuffer) {\n        var toRelease = [];\n        for (var _i = 0, _a = this.heldBatchResults; _i < _a.length; _i++) {\n            var batchResult = _a[_i];\n            if (!this.isRemoteUpToVersion(batchResult.commitVersion)) {\n                break;\n            }\n            toRelease.push(batchResult);\n        }\n        if (toRelease.length === 0) {\n            return persistence_promise_PersistencePromise.resolve(documentKeySet());\n        }\n        else {\n            this.heldBatchResults.splice(0, toRelease.length);\n            return this.releaseBatchResults(txn, toRelease, documentBuffer);\n        }\n    };\n    LocalStore.prototype.isRemoteUpToVersion = function (version) {\n        // If there are no watch targets, then we won't get remote snapshots, and\n        // we are always \"up-to-date.\"\n        var lastRemoteVersion = this.queryCache.getLastRemoteSnapshotVersion();\n        return (version.compareTo(lastRemoteVersion) <= 0 ||\n            isEmpty(this.targetIds));\n    };\n    LocalStore.prototype.shouldHoldBatchResult = function (version) {\n        // Check if watcher isn't up to date or prior results are already held.\n        return (!this.isRemoteUpToVersion(version) || this.heldBatchResults.length > 0);\n    };\n    LocalStore.prototype.releaseBatchResults = function (txn, batchResults, documentBuffer) {\n        var _this = this;\n        var promiseChain = persistence_promise_PersistencePromise.resolve();\n        var _loop_2 = function (batchResult) {\n            promiseChain = promiseChain.next(function () {\n                return _this.applyWriteToRemoteDocuments(txn, batchResult, documentBuffer);\n            });\n        };\n        for (var _i = 0, batchResults_1 = batchResults; _i < batchResults_1.length; _i++) {\n            var batchResult = batchResults_1[_i];\n            _loop_2(batchResult);\n        }\n        return promiseChain.next(function () {\n            return _this.removeMutationBatches(txn, batchResults.map(function (result) { return result.batch; }));\n        });\n    };\n    LocalStore.prototype.removeMutationBatch = function (txn, batch) {\n        return this.removeMutationBatches(txn, [batch]);\n    };\n    /** Removes all the mutation batches named in the given array. */\n    LocalStore.prototype.removeMutationBatches = function (txn, batches) {\n        var affectedDocs = documentKeySet();\n        for (var _i = 0, batches_2 = batches; _i < batches_2.length; _i++) {\n            var batch = batches_2[_i];\n            for (var _a = 0, _b = batch.mutations; _a < _b.length; _a++) {\n                var mutation = _b[_a];\n                var key = mutation.key;\n                affectedDocs = affectedDocs.add(key);\n            }\n        }\n        return this.mutationQueue\n            .removeMutationBatches(txn, batches)\n            .next(function () { return affectedDocs; });\n    };\n    LocalStore.prototype.applyWriteToRemoteDocuments = function (txn, batchResult, documentBuffer) {\n        var batch = batchResult.batch;\n        var docKeys = batch.keys();\n        var promiseChain = persistence_promise_PersistencePromise.resolve();\n        docKeys.forEach(function (docKey) {\n            promiseChain = promiseChain\n                .next(function () {\n                return documentBuffer.getEntry(txn, docKey);\n            })\n                .next(function (remoteDoc) {\n                var doc = remoteDoc;\n                var ackVersion = batchResult.docVersions.get(docKey);\n                assert(ackVersion !== null, 'ackVersions should contain every doc in the write.');\n                if (!doc || doc.version.compareTo(ackVersion) < 0) {\n                    doc = batch.applyToRemoteDocument(docKey, doc, batchResult);\n                    if (!doc) {\n                        assert(!remoteDoc, 'Mutation batch ' +\n                            batch +\n                            ' applied to document ' +\n                            remoteDoc +\n                            ' resulted in null');\n                    }\n                    else {\n                        documentBuffer.addEntry(doc);\n                    }\n                }\n            });\n        });\n        return promiseChain;\n    };\n    return LocalStore;\n}());\n\n\n//# sourceMappingURL=local_store.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/memory_mutation_queue.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\nvar memory_mutation_queue_MemoryMutationQueue = /** @class */ (function () {\n    function MemoryMutationQueue() {\n        /**\n         * The set of all mutations that have been sent but not yet been applied to\n         * the backend.\n         */\n        this.mutationQueue = [];\n        /** Next value to use when assigning sequential IDs to each mutation batch. */\n        this.nextBatchId = 1;\n        /** The highest acknowledged mutation in the queue. */\n        this.highestAcknowledgedBatchId = BATCHID_UNKNOWN;\n        /** The last received stream token from the server, used to acknowledge which\n         * responses the client has processed. Stream tokens are opaque checkpoint\n         * markers whose only real value is their inclusion in the next request.\n         */\n        this.lastStreamToken = emptyByteString();\n        /** The garbage collector to notify about potential garbage keys. */\n        this.garbageCollector = null;\n        /** An ordered mapping between documents and the mutations batch IDs. */\n        this.batchesByDocumentKey = new sorted_set_SortedSet(reference_set_DocReference.compareByKey);\n    }\n    MemoryMutationQueue.prototype.start = function (transaction) {\n        // NOTE: The queue may be shutdown / started multiple times, since we\n        // maintain the queue for the duration of the app session in case a user\n        // logs out / back in. To behave like the LevelDB-backed MutationQueue (and\n        // accommodate tests that expect as much), we reset nextBatchId and\n        // highestAcknowledgedBatchId if the queue is empty.\n        if (this.mutationQueue.length === 0) {\n            this.nextBatchId = 1;\n            this.highestAcknowledgedBatchId = BATCHID_UNKNOWN;\n        }\n        assert(this.highestAcknowledgedBatchId < this.nextBatchId, 'highestAcknowledgedBatchId must be less than the nextBatchId');\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    MemoryMutationQueue.prototype.checkEmpty = function (transaction) {\n        return persistence_promise_PersistencePromise.resolve(this.mutationQueue.length === 0);\n    };\n    MemoryMutationQueue.prototype.getNextBatchId = function (transaction) {\n        return persistence_promise_PersistencePromise.resolve(this.nextBatchId);\n    };\n    MemoryMutationQueue.prototype.getHighestAcknowledgedBatchId = function (transaction) {\n        return persistence_promise_PersistencePromise.resolve(this.highestAcknowledgedBatchId);\n    };\n    MemoryMutationQueue.prototype.acknowledgeBatch = function (transaction, batch, streamToken) {\n        var batchId = batch.batchId;\n        assert(batchId > this.highestAcknowledgedBatchId, 'Mutation batchIDs must be acknowledged in order');\n        var batchIndex = this.indexOfExistingBatchId(batchId, 'acknowledged');\n        // Verify that the batch in the queue is the one to be acknowledged.\n        var check = this.mutationQueue[batchIndex];\n        assert(batchId === check.batchId, 'Queue ordering failure: expected batch ' +\n            batchId +\n            ', got batch ' +\n            check.batchId);\n        assert(!check.isTombstone(), \"Can't acknowledge a previously removed batch\");\n        this.highestAcknowledgedBatchId = batchId;\n        this.lastStreamToken = streamToken;\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    MemoryMutationQueue.prototype.getLastStreamToken = function (transaction) {\n        return persistence_promise_PersistencePromise.resolve(this.lastStreamToken);\n    };\n    MemoryMutationQueue.prototype.setLastStreamToken = function (transaction, streamToken) {\n        this.lastStreamToken = streamToken;\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    MemoryMutationQueue.prototype.addMutationBatch = function (transaction, localWriteTime, mutations) {\n        assert(mutations.length !== 0, 'Mutation batches should not be empty');\n        var batchId = this.nextBatchId;\n        this.nextBatchId++;\n        if (this.mutationQueue.length > 0) {\n            var prior = this.mutationQueue[this.mutationQueue.length - 1];\n            assert(prior.batchId < batchId, 'Mutation batchIDs must be monotonically increasing order');\n        }\n        var batch = new mutation_batch_MutationBatch(batchId, localWriteTime, mutations);\n        this.mutationQueue.push(batch);\n        // Track references by document key.\n        for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {\n            var mutation = mutations_1[_i];\n            this.batchesByDocumentKey = this.batchesByDocumentKey.add(new reference_set_DocReference(mutation.key, batchId));\n        }\n        return persistence_promise_PersistencePromise.resolve(batch);\n    };\n    MemoryMutationQueue.prototype.lookupMutationBatch = function (transaction, batchId) {\n        return persistence_promise_PersistencePromise.resolve(this.findMutationBatch(batchId));\n    };\n    MemoryMutationQueue.prototype.getNextMutationBatchAfterBatchId = function (transaction, batchId) {\n        var size = this.mutationQueue.length;\n        // All batches with batchId <= this.highestAcknowledgedBatchId have been\n        // acknowledged so the first unacknowledged batch after batchID will have a\n        // batchID larger than both of these values.\n        var nextBatchId = Math.max(batchId, this.highestAcknowledgedBatchId) + 1;\n        // The requested batchId may still be out of range so normalize it to the\n        // start of the queue.\n        var rawIndex = this.indexOfBatchId(nextBatchId);\n        var index = rawIndex < 0 ? 0 : rawIndex;\n        // Finally return the first non-tombstone batch.\n        for (; index < size; index++) {\n            var batch = this.mutationQueue[index];\n            if (!batch.isTombstone()) {\n                return persistence_promise_PersistencePromise.resolve(batch);\n            }\n        }\n        return persistence_promise_PersistencePromise.resolve(null);\n    };\n    MemoryMutationQueue.prototype.getAllMutationBatches = function (transaction) {\n        return persistence_promise_PersistencePromise.resolve(this.getAllLiveMutationBatchesBeforeIndex(this.mutationQueue.length));\n    };\n    MemoryMutationQueue.prototype.getAllMutationBatchesThroughBatchId = function (transaction, batchId) {\n        var count = this.mutationQueue.length;\n        var endIndex = this.indexOfBatchId(batchId);\n        if (endIndex < 0) {\n            endIndex = 0;\n        }\n        else if (endIndex >= count) {\n            endIndex = count;\n        }\n        else {\n            // The endIndex is in the queue so increment to pull everything in the\n            // queue including it.\n            endIndex++;\n        }\n        return persistence_promise_PersistencePromise.resolve(this.getAllLiveMutationBatchesBeforeIndex(endIndex));\n    };\n    MemoryMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKey = function (transaction, documentKey) {\n        var _this = this;\n        var start = new reference_set_DocReference(documentKey, 0);\n        var end = new reference_set_DocReference(documentKey, Number.POSITIVE_INFINITY);\n        var result = [];\n        this.batchesByDocumentKey.forEachInRange([start, end], function (ref) {\n            assert(documentKey.isEqual(ref.key), \"Should only iterate over a single key's batches\");\n            var batch = _this.findMutationBatch(ref.targetOrBatchId);\n            assert(batch !== null, 'Batches in the index must exist in the main table');\n            result.push(batch);\n        });\n        return persistence_promise_PersistencePromise.resolve(result);\n    };\n    MemoryMutationQueue.prototype.getAllMutationBatchesAffectingQuery = function (transaction, query) {\n        var _this = this;\n        // Use the query path as a prefix for testing if a document matches the\n        // query.\n        var prefix = query.path;\n        var immediateChildrenPathLength = prefix.length + 1;\n        // Construct a document reference for actually scanning the index. Unlike\n        // the prefix the document key in this reference must have an even number of\n        // segments. The empty segment can be used a suffix of the query path\n        // because it precedes all other segments in an ordered traversal.\n        var startPath = prefix;\n        if (!document_key_DocumentKey.isDocumentKey(startPath)) {\n            startPath = startPath.child('');\n        }\n        var start = new reference_set_DocReference(new document_key_DocumentKey(startPath), 0);\n        // Find unique batchIDs referenced by all documents potentially matching the\n        // query.\n        var uniqueBatchIDs = new sorted_set_SortedSet(primitiveComparator);\n        this.batchesByDocumentKey.forEachWhile(function (ref) {\n            var rowKeyPath = ref.key.path;\n            if (!prefix.isPrefixOf(rowKeyPath)) {\n                return false;\n            }\n            else {\n                // Rows with document keys more than one segment longer than the query\n                // path can't be matches. For example, a query on 'rooms' can't match\n                // the document /rooms/abc/messages/xyx.\n                // TODO(mcg): we'll need a different scanner when we implement\n                // ancestor queries.\n                if (rowKeyPath.length === immediateChildrenPathLength) {\n                    uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);\n                }\n                return true;\n            }\n        }, start);\n        // Construct an array of matching batches, sorted by batchID to ensure that\n        // multiple mutations affecting the same document key are applied in order.\n        var result = [];\n        uniqueBatchIDs.forEach(function (batchId) {\n            var batch = _this.findMutationBatch(batchId);\n            if (batch !== null) {\n                result.push(batch);\n            }\n        });\n        return persistence_promise_PersistencePromise.resolve(result);\n    };\n    MemoryMutationQueue.prototype.removeMutationBatches = function (transaction, batches) {\n        var batchCount = batches.length;\n        assert(batchCount > 0, 'Should not remove mutations when none exist.');\n        var firstBatchId = batches[0].batchId;\n        var queueCount = this.mutationQueue.length;\n        // Find the position of the first batch for removal. This need not be the\n        // first entry in the queue.\n        var startIndex = this.indexOfExistingBatchId(firstBatchId, 'removed');\n        assert(this.mutationQueue[startIndex].batchId === firstBatchId, 'Removed batches must exist in the queue');\n        // Check that removed batches are contiguous (while excluding tombstones).\n        var batchIndex = 1;\n        var queueIndex = startIndex + 1;\n        while (batchIndex < batchCount && queueIndex < queueCount) {\n            var batch = this.mutationQueue[queueIndex];\n            if (batch.isTombstone()) {\n                queueIndex++;\n                continue;\n            }\n            assert(batch.batchId === batches[batchIndex].batchId, 'Removed batches must be contiguous in the queue');\n            batchIndex++;\n            queueIndex++;\n        }\n        // Only actually remove batches if removing at the front of the queue.\n        // Previously rejected batches may have left tombstones in the queue, so\n        // expand the removal range to include any tombstones.\n        if (startIndex === 0) {\n            for (; queueIndex < queueCount; queueIndex++) {\n                var batch = this.mutationQueue[queueIndex];\n                if (!batch.isTombstone()) {\n                    break;\n                }\n            }\n            var length_1 = queueIndex - startIndex;\n            this.mutationQueue.splice(startIndex, length_1);\n        }\n        else {\n            // Mark the tombstones\n            for (var i = startIndex; i < queueIndex; i++) {\n                this.mutationQueue[i] = this.mutationQueue[i].toTombstone();\n            }\n        }\n        var references = this.batchesByDocumentKey;\n        for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {\n            var batch = batches_1[_i];\n            var batchId = batch.batchId;\n            for (var _a = 0, _b = batch.mutations; _a < _b.length; _a++) {\n                var mutation = _b[_a];\n                var key = mutation.key;\n                if (this.garbageCollector !== null) {\n                    this.garbageCollector.addPotentialGarbageKey(key);\n                }\n                var ref = new reference_set_DocReference(key, batchId);\n                references = references.delete(ref);\n            }\n        }\n        this.batchesByDocumentKey = references;\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    MemoryMutationQueue.prototype.setGarbageCollector = function (garbageCollector) {\n        this.garbageCollector = garbageCollector;\n    };\n    MemoryMutationQueue.prototype.containsKey = function (txn, key) {\n        var ref = new reference_set_DocReference(key, 0);\n        var firstRef = this.batchesByDocumentKey.firstAfterOrEqual(ref);\n        return persistence_promise_PersistencePromise.resolve(key.isEqual(firstRef && firstRef.key));\n    };\n    MemoryMutationQueue.prototype.performConsistencyCheck = function (txn) {\n        if (this.mutationQueue.length === 0) {\n            assert(this.batchesByDocumentKey.isEmpty(), 'Document leak -- detected dangling mutation references when queue is empty.');\n        }\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    /**\n     * A private helper that collects all the mutations batches in the queue up to\n     * but not including the given endIndex. All tombstones in the queue are\n     * excluded.\n     */\n    MemoryMutationQueue.prototype.getAllLiveMutationBatchesBeforeIndex = function (endIndex) {\n        var result = [];\n        for (var i = 0; i < endIndex; i++) {\n            var batch = this.mutationQueue[i];\n            if (!batch.isTombstone()) {\n                result.push(batch);\n            }\n        }\n        return result;\n    };\n    /**\n     * Finds the index of the given batchId in the mutation queue and asserts that\n     * the resulting index is within the bounds of the queue.\n     *\n     * @param batchId The batchId to search for\n     * @param action A description of what the caller is doing, phrased in passive\n     * form (e.g. \"acknowledged\" in a routine that acknowledges batches).\n     */\n    MemoryMutationQueue.prototype.indexOfExistingBatchId = function (batchId, action) {\n        var index = this.indexOfBatchId(batchId);\n        assert(index >= 0 && index < this.mutationQueue.length, 'Batches must exist to be ' + action);\n        return index;\n    };\n    /**\n     * Finds the index of the given batchId in the mutation queue. This operation\n     * is O(1).\n     *\n     * @return The computed index of the batch with the given batchId, based on\n     * the state of the queue. Note this index can be negative if the requested\n     * batchId has already been remvoed from the queue or past the end of the\n     * queue if the batchId is larger than the last added batch.\n     */\n    MemoryMutationQueue.prototype.indexOfBatchId = function (batchId) {\n        if (this.mutationQueue.length === 0) {\n            // As an index this is past the end of the queue\n            return 0;\n        }\n        // Examine the front of the queue to figure out the difference between the\n        // batchId and indexes in the array. Note that since the queue is ordered\n        // by batchId, if the first batch has a larger batchId then the requested\n        // batchId doesn't exist in the queue.\n        var firstBatchId = this.mutationQueue[0].batchId;\n        return batchId - firstBatchId;\n    };\n    /**\n     * A version of lookupMutationBatch that doesn't return a promise, this makes\n     * other functions that uses this code easier to read and more efficent.\n     */\n    MemoryMutationQueue.prototype.findMutationBatch = function (batchId) {\n        var index = this.indexOfBatchId(batchId);\n        if (index < 0 || index >= this.mutationQueue.length) {\n            return null;\n        }\n        var batch = this.mutationQueue[index];\n        assert(batch.batchId === batchId, 'If found batch must match');\n        return batch.isTombstone() ? null : batch;\n    };\n    return MemoryMutationQueue;\n}());\n\n\n//# sourceMappingURL=memory_mutation_queue.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/memory_query_cache.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\nvar memory_query_cache_MemoryQueryCache = /** @class */ (function () {\n    function MemoryQueryCache() {\n        /**\n         * Maps a query to the data about that query\n         */\n        this.queries = new obj_map_ObjectMap(function (q) { return q.canonicalId(); });\n        /** The last received snapshot version. */\n        this.lastRemoteSnapshotVersion = snapshot_version_SnapshotVersion.MIN;\n        /** The highest numbered target ID encountered. */\n        this.highestTargetId = 0;\n        /**\n         * A ordered bidirectional mapping between documents and the remote target\n         * IDs.\n         */\n        this.references = new reference_set_ReferenceSet();\n        this.targetCount = 0;\n    }\n    MemoryQueryCache.prototype.start = function (transaction) {\n        // Nothing to do.\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.getLastRemoteSnapshotVersion = function () {\n        return this.lastRemoteSnapshotVersion;\n    };\n    MemoryQueryCache.prototype.getHighestTargetId = function () {\n        return this.highestTargetId;\n    };\n    MemoryQueryCache.prototype.setLastRemoteSnapshotVersion = function (transaction, snapshotVersion) {\n        this.lastRemoteSnapshotVersion = snapshotVersion;\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.saveQueryData = function (queryData) {\n        this.queries.set(queryData.query, queryData);\n        var targetId = queryData.targetId;\n        if (targetId > this.highestTargetId) {\n            this.highestTargetId = targetId;\n        }\n        // TODO(GC): track sequence number\n    };\n    MemoryQueryCache.prototype.addQueryData = function (transaction, queryData) {\n        assert(!this.queries.has(queryData.query), 'Adding a query that already exists');\n        this.saveQueryData(queryData);\n        this.targetCount += 1;\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.updateQueryData = function (transaction, queryData) {\n        assert(this.queries.has(queryData.query), 'Updating a non-existent query');\n        this.saveQueryData(queryData);\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.removeQueryData = function (transaction, queryData) {\n        assert(this.targetCount > 0, 'Removing a target from an empty cache');\n        assert(this.queries.has(queryData.query), 'Removing a non-existent target from the cache');\n        this.queries.delete(queryData.query);\n        this.references.removeReferencesForId(queryData.targetId);\n        this.targetCount -= 1;\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    Object.defineProperty(MemoryQueryCache.prototype, \"count\", {\n        get: function () {\n            return this.targetCount;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MemoryQueryCache.prototype.getQueryData = function (transaction, query) {\n        var queryData = this.queries.get(query) || null;\n        return persistence_promise_PersistencePromise.resolve(queryData);\n    };\n    MemoryQueryCache.prototype.addMatchingKeys = function (txn, keys, targetId) {\n        this.references.addReferences(keys, targetId);\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.removeMatchingKeys = function (txn, keys, targetId) {\n        this.references.removeReferences(keys, targetId);\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.removeMatchingKeysForTargetId = function (txn, targetId) {\n        this.references.removeReferencesForId(targetId);\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.getMatchingKeysForTargetId = function (txn, targetId) {\n        var matchingKeys = this.references.referencesForId(targetId);\n        return persistence_promise_PersistencePromise.resolve(matchingKeys);\n    };\n    MemoryQueryCache.prototype.setGarbageCollector = function (gc) {\n        this.references.setGarbageCollector(gc);\n    };\n    MemoryQueryCache.prototype.containsKey = function (txn, key) {\n        return this.references.containsKey(txn, key);\n    };\n    return MemoryQueryCache;\n}());\n\n\n//# sourceMappingURL=memory_query_cache.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/memory_remote_document_cache.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\nvar memory_remote_document_cache_MemoryRemoteDocumentCache = /** @class */ (function () {\n    function MemoryRemoteDocumentCache() {\n        this.docs = maybeDocumentMap();\n    }\n    MemoryRemoteDocumentCache.prototype.addEntry = function (transaction, maybeDocument) {\n        this.docs = this.docs.insert(maybeDocument.key, maybeDocument);\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    MemoryRemoteDocumentCache.prototype.removeEntry = function (transaction, documentKey) {\n        this.docs = this.docs.remove(documentKey);\n        return persistence_promise_PersistencePromise.resolve();\n    };\n    MemoryRemoteDocumentCache.prototype.getEntry = function (transaction, documentKey) {\n        return persistence_promise_PersistencePromise.resolve(this.docs.get(documentKey));\n    };\n    MemoryRemoteDocumentCache.prototype.getDocumentsMatchingQuery = function (transaction, query) {\n        var results = documentMap();\n        // Documents are ordered by key, so we can use a prefix scan to narrow down\n        // the documents we need to match the query against.\n        var prefix = new document_key_DocumentKey(query.path.child(''));\n        var iterator = this.docs.getIteratorFrom(prefix);\n        while (iterator.hasNext()) {\n            var _a = iterator.getNext(), key = _a.key, maybeDoc = _a.value;\n            if (!query.path.isPrefixOf(key.path)) {\n                break;\n            }\n            if (maybeDoc instanceof document_Document && query.matches(maybeDoc)) {\n                results = results.insert(maybeDoc.key, maybeDoc);\n            }\n        }\n        return persistence_promise_PersistencePromise.resolve(results);\n    };\n    return MemoryRemoteDocumentCache;\n}());\n\n\n//# sourceMappingURL=memory_remote_document_cache.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/memory_persistence.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\nvar memory_persistence_LOG_TAG = 'MemoryPersistence';\n/**\n * A memory-backed instance of Persistence. Data is stored only in RAM and\n * not persisted across sessions.\n */\nvar memory_persistence_MemoryPersistence = /** @class */ (function () {\n    function MemoryPersistence() {\n        /**\n         * Note that these are retained here to make it easier to write tests\n         * affecting both the in-memory and IndexedDB-backed persistence layers. Tests\n         * can create a new LocalStore wrapping this Persistence instance and this\n         * will make the in-memory persistence layer behave as if it were actually\n         * persisting values.\n         */\n        this.mutationQueues = {};\n        this.remoteDocumentCache = new memory_remote_document_cache_MemoryRemoteDocumentCache();\n        this.queryCache = new memory_query_cache_MemoryQueryCache();\n        this.started = false;\n    }\n    MemoryPersistence.prototype.start = function () {\n        return tslib_es6[\"__awaiter\"](this, void 0, void 0, function () {\n            return tslib_es6[\"__generator\"](this, function (_a) {\n                // No durable state to read on startup.\n                assert(!this.started, 'MemoryPersistence double-started!');\n                this.started = true;\n                return [2 /*return*/];\n            });\n        });\n    };\n    MemoryPersistence.prototype.shutdown = function () {\n        return tslib_es6[\"__awaiter\"](this, void 0, void 0, function () {\n            return tslib_es6[\"__generator\"](this, function (_a) {\n                // No durable state to ensure is closed on shutdown.\n                assert(this.started, 'MemoryPersistence shutdown without start!');\n                this.started = false;\n                return [2 /*return*/];\n            });\n        });\n    };\n    MemoryPersistence.prototype.getMutationQueue = function (user) {\n        var queue = this.mutationQueues[user.toKey()];\n        if (!queue) {\n            queue = new memory_mutation_queue_MemoryMutationQueue();\n            this.mutationQueues[user.toKey()] = queue;\n        }\n        return queue;\n    };\n    MemoryPersistence.prototype.getQueryCache = function () {\n        return this.queryCache;\n    };\n    MemoryPersistence.prototype.getRemoteDocumentCache = function () {\n        return this.remoteDocumentCache;\n    };\n    MemoryPersistence.prototype.runTransaction = function (action, operation) {\n        debug(memory_persistence_LOG_TAG, 'Starting transaction:', action);\n        return operation(new MemoryPersistenceTransaction()).toPromise();\n    };\n    return MemoryPersistence;\n}());\n\n/** Dummy class since memory persistence doesn't actually use transactions. */\nvar MemoryPersistenceTransaction = /** @class */ (function () {\n    function MemoryPersistenceTransaction() {\n    }\n    return MemoryPersistenceTransaction;\n}());\n\n//# sourceMappingURL=memory_persistence.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/local/no_op_garbage_collector.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A garbage collector implementation that does absolutely nothing. It ignores\n * all addGarbageSource and addPotentialGarbageKey messages and and never\n * produces any garbage.\n */\nvar no_op_garbage_collector_NoOpGarbageCollector = /** @class */ (function () {\n    function NoOpGarbageCollector() {\n        this.isEager = false;\n    }\n    NoOpGarbageCollector.prototype.addGarbageSource = function (garbageSource) {\n        // Not tracking garbage so don't track sources.\n    };\n    NoOpGarbageCollector.prototype.removeGarbageSource = function (garbageSource) {\n        // Not tracking garbage so don't track sources.\n    };\n    NoOpGarbageCollector.prototype.addPotentialGarbageKey = function (key) {\n        // Not tracking garbage so ignore.\n    };\n    NoOpGarbageCollector.prototype.collectGarbage = function (txn) {\n        return persistence_promise_PersistencePromise.resolve(documentKeySet());\n    };\n    return NoOpGarbageCollector;\n}());\n\n\n//# sourceMappingURL=no_op_garbage_collector.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/promise.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Deferred = /** @class */ (function () {\n    function Deferred() {\n        var _this = this;\n        this.promise = new Promise(function (resolve, reject) {\n            _this.resolve = resolve;\n            _this.reject = reject;\n        });\n    }\n    return Deferred;\n}());\n\n/**\n * Takes an array of values and sequences them using the promise (or value)\n * returned by the supplied callback. The callback for each item is called\n * after the promise is resolved for the previous item.\n * The function returns a promise which is resolved after the promise for\n * the last item is resolved.\n */\nfunction sequence(values, fn, initialValue) {\n    var result = Promise.resolve(initialValue);\n    values.forEach(function (value) {\n        result = result.then(function (lastResult) { return fn(value, lastResult); });\n    });\n    return result;\n}\n\n//# sourceMappingURL=promise.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/async_queue.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n/**\n * Wellknown \"timer\" IDs used when scheduling delayed operations on the\n * AsyncQueue. These IDs can then be used from tests to check for the presence\n * of operations or to run them early.\n *\n * The string values are used when encoding these timer IDs in JSON spec tests.\n */\nvar TimerId;\n(function (TimerId) {\n    /** All can be used with runDelayedOperationsEarly() to run all timers. */\n    TimerId[\"All\"] = \"all\";\n    /**\n     * The following 4 timers are used in persistent_stream.ts for the listen and\n     * write streams. The \"Idle\" timer is used to close the stream due to\n     * inactivity. The \"ConnectionBackoff\" timer is used to restart a stream once\n     * the appropriate backoff delay has elapsed.\n     */\n    TimerId[\"ListenStreamIdle\"] = \"listen_stream_idle\";\n    TimerId[\"ListenStreamConnectionBackoff\"] = \"listen_stream_connection_backoff\";\n    TimerId[\"WriteStreamIdle\"] = \"write_stream_idle\";\n    TimerId[\"WriteStreamConnectionBackoff\"] = \"write_stream_connection_backoff\";\n    /**\n     * A timer used in online_state_tracker.ts to transition from\n     * OnlineState.Unknown to Offline after a set timeout, rather than waiting\n     * indefinitely for success or failure.\n     */\n    TimerId[\"OnlineStateTimeout\"] = \"online_state_timeout\";\n})(TimerId || (TimerId = {}));\n/**\n * Represents an operation scheduled to be run in the future on an AsyncQueue.\n *\n * It is created via DelayedOperation.createAndSchedule().\n *\n * Supports cancellation (via cancel()) and early execution (via skipDelay()).\n */\nvar async_queue_DelayedOperation = /** @class */ (function () {\n    function DelayedOperation(asyncQueue, timerId, targetTimeMs, op, removalCallback) {\n        this.asyncQueue = asyncQueue;\n        this.timerId = timerId;\n        this.targetTimeMs = targetTimeMs;\n        this.op = op;\n        this.removalCallback = removalCallback;\n        this.deferred = new Deferred();\n        this.then = this.deferred.promise.then.bind(this.deferred.promise);\n        this.catch = this.deferred.promise.catch.bind(this.deferred.promise);\n        // It's normal for the deferred promise to be canceled (due to cancellation)\n        // and so we attach a dummy catch callback to avoid\n        // 'UnhandledPromiseRejectionWarning' log spam.\n        this.deferred.promise.catch(function (err) { });\n    }\n    /**\n     * Creates and returns a DelayedOperation that has been scheduled to be\n     * executed on the provided asyncQueue after the provided delayMs.\n     *\n     * @param asyncQueue The queue to schedule the operation on.\n     * @param id A Timer ID identifying the type of operation this is.\n     * @param delayMs The delay (ms) before the operation should be scheduled.\n     * @param op The operation to run.\n     * @param removalCallback A callback to be called synchronously once the\n     *   operation is executed or canceled, notifying the AsyncQueue to remove it\n     *   from its delayedOperations list.\n     *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and\n     *   the DelayedOperation class public.\n     */\n    DelayedOperation.createAndSchedule = function (asyncQueue, timerId, delayMs, op, removalCallback) {\n        var targetTime = Date.now() + delayMs;\n        var delayedOp = new DelayedOperation(asyncQueue, timerId, targetTime, op, removalCallback);\n        delayedOp.start(delayMs);\n        return delayedOp;\n    };\n    /**\n     * Starts the timer. This is called immediately after construction by\n     * createAndSchedule().\n     */\n    DelayedOperation.prototype.start = function (delayMs) {\n        var _this = this;\n        this.timerHandle = setTimeout(function () { return _this.handleDelayElapsed(); }, delayMs);\n    };\n    /**\n     * Queues the operation to run immediately (if it hasn't already been run or\n     * canceled).\n     */\n    DelayedOperation.prototype.skipDelay = function () {\n        return this.handleDelayElapsed();\n    };\n    /**\n     * Cancels the operation if it hasn't already been executed or canceled. The\n     * promise will be rejected.\n     *\n     * As long as the operation has not yet been run, calling cancel() provides a\n     * guarantee that the operation will not be run.\n     */\n    DelayedOperation.prototype.cancel = function (reason) {\n        if (this.timerHandle !== null) {\n            this.clearTimeout();\n            this.deferred.reject(new error_FirestoreError(Code.CANCELLED, 'Operation cancelled' + (reason ? ': ' + reason : '')));\n        }\n    };\n    DelayedOperation.prototype.handleDelayElapsed = function () {\n        var _this = this;\n        this.asyncQueue.enqueue(function () {\n            if (_this.timerHandle !== null) {\n                _this.clearTimeout();\n                return _this.op().then(function (result) {\n                    return _this.deferred.resolve(result);\n                });\n            }\n            else {\n                return Promise.resolve();\n            }\n        });\n    };\n    DelayedOperation.prototype.clearTimeout = function () {\n        if (this.timerHandle !== null) {\n            this.removalCallback(this);\n            clearTimeout(this.timerHandle);\n            this.timerHandle = null;\n        }\n    };\n    return DelayedOperation;\n}());\nvar async_queue_AsyncQueue = /** @class */ (function () {\n    function AsyncQueue() {\n        // The last promise in the queue.\n        this.tail = Promise.resolve();\n        // Operations scheduled to be queued in the future. Operations are\n        // automatically removed after they are run or canceled.\n        this.delayedOperations = [];\n        // Flag set while there's an outstanding AsyncQueue operation, used for\n        // assertion sanity-checks.\n        this.operationInProgress = false;\n    }\n    /**\n     * Adds a new operation to the queue. Returns a promise that will be resolved\n     * when the promise returned by the new operation is (with its value).\n     */\n    AsyncQueue.prototype.enqueue = function (op) {\n        var _this = this;\n        this.verifyNotFailed();\n        var newTail = this.tail.then(function () {\n            _this.operationInProgress = true;\n            return op()\n                .catch(function (error) {\n                _this.failure = error;\n                _this.operationInProgress = false;\n                var message = error.stack || error.message || '';\n                log_error('INTERNAL UNHANDLED ERROR: ', message);\n                // Escape the promise chain and throw the error globally so that\n                // e.g. any global crash reporting library detects and reports it.\n                // (but not for simulated errors in our tests since this breaks mocha)\n                if (message.indexOf('Firestore Test Simulated Error') < 0) {\n                    setTimeout(function () {\n                        throw error;\n                    }, 0);\n                }\n                // Re-throw the error so that this.tail becomes a rejected Promise and\n                // all further attempts to chain (via .then) will just short-circuit\n                // and return the rejected Promise.\n                throw error;\n            })\n                .then(function (result) {\n                _this.operationInProgress = false;\n                return result;\n            });\n        });\n        this.tail = newTail;\n        return newTail;\n    };\n    /**\n     * Schedules an operation to be queued on the AsyncQueue once the specified\n     * `delayMs` has elapsed. The returned CancelablePromise can be used to cancel\n     * the operation prior to its running.\n     */\n    AsyncQueue.prototype.enqueueAfterDelay = function (timerId, delayMs, op) {\n        var _this = this;\n        this.verifyNotFailed();\n        // While not necessarily harmful, we currently don't expect to have multiple\n        // ops with the same timer id in the queue, so defensively reject them.\n        assert(!this.containsDelayedOperation(timerId), \"Attempted to schedule multiple operations with timer id \" + timerId + \".\");\n        var delayedOp = async_queue_DelayedOperation.createAndSchedule(this, timerId, delayMs, op, function (op) { return _this.removeDelayedOperation(op); });\n        this.delayedOperations.push(delayedOp);\n        return delayedOp;\n    };\n    AsyncQueue.prototype.verifyNotFailed = function () {\n        if (this.failure) {\n            fail('AsyncQueue is already failed: ' +\n                (this.failure.stack || this.failure.message));\n        }\n    };\n    /**\n     * Verifies there's an operation currently in-progress on the AsyncQueue.\n     * Unfortunately we can't verify that the running code is in the promise chain\n     * of that operation, so this isn't a foolproof check, but it should be enough\n     * to catch some bugs.\n     */\n    AsyncQueue.prototype.verifyOperationInProgress = function () {\n        assert(this.operationInProgress, 'verifyOpInProgress() called when no op in progress on this queue.');\n    };\n    /**\n     * Waits until all currently queued tasks are finished executing. Delayed\n     * operations are not run.\n     */\n    AsyncQueue.prototype.drain = function () {\n        return this.enqueue(function () { return Promise.resolve(); });\n    };\n    /**\n     * For Tests: Determine if a delayed operation with a particular TimerId\n     * exists.\n     */\n    AsyncQueue.prototype.containsDelayedOperation = function (timerId) {\n        return this.delayedOperations.findIndex(function (op) { return op.timerId === timerId; }) >= 0;\n    };\n    /**\n     * For Tests: Runs some or all delayed operations early.\n     *\n     * @param lastTimerId Delayed operations up to and including this TimerId will\n     *  be drained. Throws if no such operation exists. Pass TimerId.All to run\n     *  all delayed operations.\n     * @returns a Promise that resolves once all operations have been run.\n     */\n    AsyncQueue.prototype.runDelayedOperationsEarly = function (lastTimerId) {\n        var _this = this;\n        // Note that draining may generate more delayed ops, so we do that first.\n        return this.drain().then(function () {\n            assert(lastTimerId === TimerId.All ||\n                _this.containsDelayedOperation(lastTimerId), \"Attempted to drain to missing operation \" + lastTimerId);\n            // Run ops in the same order they'd run if they ran naturally.\n            _this.delayedOperations.sort(function (a, b) { return a.targetTimeMs - b.targetTimeMs; });\n            for (var _i = 0, _a = _this.delayedOperations; _i < _a.length; _i++) {\n                var op = _a[_i];\n                op.skipDelay();\n                if (lastTimerId !== TimerId.All && op.timerId === lastTimerId) {\n                    break;\n                }\n            }\n            return _this.drain();\n        });\n    };\n    /** Called once a DelayedOperation is run or canceled. */\n    AsyncQueue.prototype.removeDelayedOperation = function (op) {\n        // NOTE: indexOf / slice are O(n), but delayedOperations is expected to be small.\n        var index = this.delayedOperations.indexOf(op);\n        assert(index >= 0, 'Delayed operation not found.');\n        this.delayedOperations.splice(index, 1);\n    };\n    return AsyncQueue;\n}());\n\n\n//# sourceMappingURL=async_queue.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/remote/backoff.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar backoff_LOG_TAG = 'ExponentialBackoff';\n/**\n * A helper for running delayed tasks following an exponential backoff curve\n * between attempts.\n *\n * Each delay is made up of a \"base\" delay which follows the exponential\n * backoff curve, and a +/- 50% \"jitter\" that is calculated and added to the\n * base delay. This prevents clients from accidentally synchronizing their\n * delays causing spikes of load to the backend.\n */\nvar backoff_ExponentialBackoff = /** @class */ (function () {\n    function ExponentialBackoff(\n    /**\n     * The AsyncQueue to run backoff operations on.\n     */\n    queue, \n    /**\n     * The ID to use when scheduling backoff operations on the AsyncQueue.\n     */\n    timerId, \n    /**\n     * The initial delay (used as the base delay on the first retry attempt).\n     * Note that jitter will still be applied, so the actual delay could be as\n     * little as 0.5*initialDelayMs.\n     */\n    initialDelayMs, \n    /**\n     * The multiplier to use to determine the extended base delay after each\n     * attempt.\n     */\n    backoffFactor, \n    /**\n     * The maximum base delay after which no further backoff is performed.\n     * Note that jitter will still be applied, so the actual delay could be as\n     * much as 1.5*maxDelayMs.\n     */\n    maxDelayMs) {\n        this.queue = queue;\n        this.timerId = timerId;\n        this.initialDelayMs = initialDelayMs;\n        this.backoffFactor = backoffFactor;\n        this.maxDelayMs = maxDelayMs;\n        this.timerPromise = null;\n        this.reset();\n    }\n    /**\n     * Resets the backoff delay.\n     *\n     * The very next backoffAndWait() will have no delay. If it is called again\n     * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\n     * subsequent ones will increase according to the backoffFactor.\n     */\n    ExponentialBackoff.prototype.reset = function () {\n        this.currentBaseMs = 0;\n    };\n    /**\n     * Resets the backoff delay to the maximum delay (e.g. for use after a\n     * RESOURCE_EXHAUSTED error).\n     */\n    ExponentialBackoff.prototype.resetToMax = function () {\n        this.currentBaseMs = this.maxDelayMs;\n    };\n    /**\n     * Returns a promise that resolves after currentDelayMs, and increases the\n     * delay for any subsequent attempts. If there was a pending backoff operation\n     * already, it will be canceled.\n     */\n    ExponentialBackoff.prototype.backoffAndRun = function (op) {\n        // Cancel any pending backoff operation.\n        this.cancel();\n        // First schedule using the current base (which may be 0 and should be\n        // honored as such).\n        var delayWithJitterMs = this.currentBaseMs + this.jitterDelayMs();\n        if (this.currentBaseMs > 0) {\n            debug(backoff_LOG_TAG, \"Backing off for \" + delayWithJitterMs + \" ms \" +\n                (\"(base delay: \" + this.currentBaseMs + \" ms)\"));\n        }\n        this.timerPromise = this.queue.enqueueAfterDelay(this.timerId, delayWithJitterMs, op);\n        // Apply backoff factor to determine next delay and ensure it is within\n        // bounds.\n        this.currentBaseMs *= this.backoffFactor;\n        if (this.currentBaseMs < this.initialDelayMs) {\n            this.currentBaseMs = this.initialDelayMs;\n        }\n        if (this.currentBaseMs > this.maxDelayMs) {\n            this.currentBaseMs = this.maxDelayMs;\n        }\n    };\n    ExponentialBackoff.prototype.cancel = function () {\n        if (this.timerPromise !== null) {\n            this.timerPromise.cancel();\n            this.timerPromise = null;\n        }\n    };\n    /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */\n    ExponentialBackoff.prototype.jitterDelayMs = function () {\n        return (Math.random() - 0.5) * this.currentBaseMs;\n    };\n    return ExponentialBackoff;\n}());\n\n\n//# sourceMappingURL=backoff.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/remote/persistent_stream.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\nvar persistent_stream_LOG_TAG = 'PersistentStream';\nvar PersistentStreamState;\n(function (PersistentStreamState) {\n    /**\n     * The streaming RPC is not running and there's no error condition.\n     * Calling `start` will start the stream immediately without backoff.\n     * While in this state isStarted will return false.\n     */\n    PersistentStreamState[PersistentStreamState[\"Initial\"] = 0] = \"Initial\";\n    /**\n     * The stream is starting, and is waiting for an auth token to attach to\n     * the initial request. While in this state, isStarted will return\n     * true but isOpen will return false.\n     */\n    PersistentStreamState[PersistentStreamState[\"Auth\"] = 1] = \"Auth\";\n    /**\n     * The streaming RPC is up and running. Requests and responses can flow\n     * freely. Both isStarted and isOpen will return true.\n     */\n    PersistentStreamState[PersistentStreamState[\"Open\"] = 2] = \"Open\";\n    /**\n     * The stream encountered an error. The next start attempt will back off.\n     * While in this state isStarted() will return false.\n     *\n     */\n    PersistentStreamState[PersistentStreamState[\"Error\"] = 3] = \"Error\";\n    /**\n     * An in-between state after an error where the stream is waiting before\n     * re-starting. After\n     * waiting is complete, the stream will try to open. While in this\n     * state isStarted() will return YES but isOpen will return false.\n     */\n    PersistentStreamState[PersistentStreamState[\"Backoff\"] = 4] = \"Backoff\";\n    /**\n     * The stream has been explicitly stopped; no further events will be emitted.\n     */\n    PersistentStreamState[PersistentStreamState[\"Stopped\"] = 5] = \"Stopped\";\n})(PersistentStreamState || (PersistentStreamState = {}));\n/**\n * Initial backoff time in milliseconds after an error.\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\n */\nvar BACKOFF_INITIAL_DELAY_MS = 1000;\n/** Maximum backoff time in milliseconds */\nvar BACKOFF_MAX_DELAY_MS = 60 * 1000;\nvar BACKOFF_FACTOR = 1.5;\n/** The time a stream stays open after it is marked idle. */\nvar IDLE_TIMEOUT_MS = 60 * 1000;\n/**\n * A PersistentStream is an abstract base class that represents a streaming RPC\n * to the Firestore backend. It's built on top of the connections own support\n * for streaming RPCs, and adds several critical features for our clients:\n *\n *   - Exponential backoff on failure\n *   - Authentication via CredentialsProvider\n *   - Dispatching all callbacks into the shared worker queue\n *\n * Subclasses of PersistentStream implement serialization of models to and\n * from the JSON representation of the protocol buffers for a specific\n * streaming RPC.\n *\n * ## Starting and Stopping\n *\n * Streaming RPCs are stateful and need to be `start`ed before messages can\n * be sent and received. The PersistentStream will call the onOpen function\n * of the listener once the stream is ready to accept requests.\n *\n * Should a `start` fail, PersistentStream will call the registered\n * onClose with a FirestoreError indicating what went wrong.\n *\n * A PersistentStream can be started and stopped repeatedly.\n *\n * Generic types:\n *  SendType: The type of the outgoing message of the underlying\n *    connection stream\n *  ReceiveType: The type of the incoming message of the underlying\n *    connection stream\n *  ListenerType: The type of the listener that will be used for callbacks\n */\nvar persistent_stream_PersistentStream = /** @class */ (function () {\n    function PersistentStream(queue, connectionTimerId, idleTimerId, connection, credentialsProvider) {\n        this.queue = queue;\n        this.idleTimerId = idleTimerId;\n        this.connection = connection;\n        this.credentialsProvider = credentialsProvider;\n        this.inactivityTimerPromise = null;\n        this.stream = null;\n        this.listener = null;\n        this.backoff = new backoff_ExponentialBackoff(queue, connectionTimerId, BACKOFF_INITIAL_DELAY_MS, BACKOFF_FACTOR, BACKOFF_MAX_DELAY_MS);\n        this.state = PersistentStreamState.Initial;\n    }\n    /**\n     * Returns true if `start` has been called and no error has occurred. True\n     * indicates the stream is open or in the process of opening (which\n     * encompasses respecting backoff, getting auth tokens, and starting the\n     * actual RPC). Use `isOpen` to determine if the stream is open and ready for\n     * outbound requests.\n     */\n    PersistentStream.prototype.isStarted = function () {\n        return (this.state === PersistentStreamState.Backoff ||\n            this.state === PersistentStreamState.Auth ||\n            this.state === PersistentStreamState.Open);\n    };\n    /**\n     * Returns true if the underlying RPC is open (the openHandler has been\n     * called) and the stream is ready for outbound requests.\n     */\n    PersistentStream.prototype.isOpen = function () {\n        return this.state === PersistentStreamState.Open;\n    };\n    /**\n     * Starts the RPC. Only allowed if isStarted returns false. The stream is\n     * not immediately ready for use: onOpen will be invoked when the RPC is ready\n     * for outbound requests, at which point isOpen will return true.\n     *\n     *  When start returns, isStarted will return true.\n     */\n    PersistentStream.prototype.start = function (listener) {\n        if (this.state === PersistentStreamState.Error) {\n            this.performBackoff(listener);\n            return;\n        }\n        assert(this.state === PersistentStreamState.Initial, 'Already started');\n        this.listener = listener;\n        this.auth();\n    };\n    /**\n     * Stops the RPC. This call is idempotent and allowed regardless of the\n     * current isStarted state.\n     *\n     * When stop returns, isStarted and isOpen will both return false.\n     */\n    PersistentStream.prototype.stop = function () {\n        if (this.isStarted()) {\n            this.close(PersistentStreamState.Stopped);\n        }\n    };\n    /**\n     * After an error the stream will usually back off on the next attempt to\n     * start it. If the error warrants an immediate restart of the stream, the\n     * sender can use this to indicate that the receiver should not back off.\n     *\n     * Each error will call the onClose function. That function can decide to\n     * inhibit backoff if required.\n     */\n    PersistentStream.prototype.inhibitBackoff = function () {\n        assert(!this.isStarted(), 'Can only inhibit backoff in a stopped state');\n        this.state = PersistentStreamState.Initial;\n        this.backoff.reset();\n    };\n    /**\n     * Marks this stream as idle. If no further actions are performed on the\n     * stream for one minute, the stream will automatically close itself and\n     * notify the stream's onClose() handler with Status.OK. The stream will then\n     * be in a !isStarted() state, requiring the caller to start the stream again\n     * before further use.\n     *\n     * Only streams that are in state 'Open' can be marked idle, as all other\n     * states imply pending network operations.\n     */\n    PersistentStream.prototype.markIdle = function () {\n        var _this = this;\n        // Starts the idle time if we are in state 'Open' and are not yet already\n        // running a timer (in which case the previous idle timeout still applies).\n        if (this.isOpen() && this.inactivityTimerPromise === null) {\n            this.inactivityTimerPromise = this.queue.enqueueAfterDelay(this.idleTimerId, IDLE_TIMEOUT_MS, function () { return _this.handleIdleCloseTimer(); });\n        }\n    };\n    /** Sends a message to the underlying stream. */\n    PersistentStream.prototype.sendRequest = function (msg) {\n        this.cancelIdleCheck();\n        this.stream.send(msg);\n    };\n    /** Called by the idle timer when the stream should close due to inactivity. */\n    PersistentStream.prototype.handleIdleCloseTimer = function () {\n        return tslib_es6[\"__awaiter\"](this, void 0, void 0, function () {\n            return tslib_es6[\"__generator\"](this, function (_a) {\n                if (this.isOpen()) {\n                    // When timing out an idle stream there's no reason to force the stream into backoff when\n                    // it restarts so set the stream state to Initial instead of Error.\n                    return [2 /*return*/, this.close(PersistentStreamState.Initial)];\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    /** Marks the stream as active again. */\n    PersistentStream.prototype.cancelIdleCheck = function () {\n        if (this.inactivityTimerPromise) {\n            this.inactivityTimerPromise.cancel();\n            this.inactivityTimerPromise = null;\n        }\n    };\n    /**\n     * Closes the stream and cleans up as necessary:\n     *\n     * * closes the underlying GRPC stream;\n     * * calls the onClose handler with the given 'error';\n     * * sets internal stream state to 'finalState';\n     * * adjusts the backoff timer based on the error\n     *\n     * A new stream can be opened by calling `start` unless `finalState` is set to\n     * `PersistentStreamState.Stopped`.\n     *\n     * @param finalState the intended state of the stream after closing.\n     * @param error the error the connection was closed with.\n     */\n    PersistentStream.prototype.close = function (finalState, error) {\n        return tslib_es6[\"__awaiter\"](this, void 0, void 0, function () {\n            var listener;\n            return tslib_es6[\"__generator\"](this, function (_a) {\n                assert(finalState === PersistentStreamState.Error || isNullOrUndefined(error), \"Can't provide an error when not in an error state.\");\n                // The stream will be closed so we don't need our idle close timer anymore.\n                this.cancelIdleCheck();\n                // Ensure we don't leave a pending backoff operation queued (in case close()\n                // was called while we were waiting to reconnect).\n                this.backoff.cancel();\n                if (finalState !== PersistentStreamState.Error) {\n                    // If this is an intentional close ensure we don't delay our next connection attempt.\n                    this.backoff.reset();\n                }\n                else if (error && error.code === Code.RESOURCE_EXHAUSTED) {\n                    // Log the error. (Probably either 'quota exceeded' or 'max queue length reached'.)\n                    log_error(error.toString());\n                    log_error('Using maximum backoff delay to prevent overloading the backend.');\n                    this.backoff.resetToMax();\n                }\n                // Clean up the underlying stream because we are no longer interested in events.\n                if (this.stream !== null) {\n                    this.tearDown();\n                    this.stream.close();\n                    this.stream = null;\n                }\n                // This state must be assigned before calling onClose() to allow the callback to\n                // inhibit backoff or otherwise manipulate the state in its non-started state.\n                this.state = finalState;\n                listener = this.listener;\n                // Clear the listener to avoid bleeding of events from the underlying streams.\n                this.listener = null;\n                // If the caller explicitly requested a stream stop, don't notify them of a closing stream (it\n                // could trigger undesirable recovery logic, etc.).\n                if (finalState !== PersistentStreamState.Stopped) {\n                    return [2 /*return*/, listener.onClose(error)];\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    /**\n     * Can be overridden to perform additional cleanup before the stream is closed.\n     * Calling super.tearDown() is not required.\n     */\n    PersistentStream.prototype.tearDown = function () { };\n    PersistentStream.prototype.auth = function () {\n        var _this = this;\n        assert(this.state === PersistentStreamState.Initial, 'Must be in initial state to auth');\n        this.state = PersistentStreamState.Auth;\n        this.credentialsProvider.getToken(/*forceRefresh=*/ false).then(function (token) {\n            // Normally we'd have to schedule the callback on the AsyncQueue.\n            // However, the following calls are safe to be called outside the\n            // AsyncQueue since they don't chain asynchronous calls\n            _this.startStream(token);\n        }, function (error) {\n            _this.queue.enqueue(function () { return tslib_es6[\"__awaiter\"](_this, void 0, void 0, function () {\n                var rpcError;\n                return tslib_es6[\"__generator\"](this, function (_a) {\n                    if (this.state !== PersistentStreamState.Stopped) {\n                        rpcError = new error_FirestoreError(Code.UNKNOWN, 'Fetching auth token failed: ' + error.message);\n                        return [2 /*return*/, this.handleStreamClose(rpcError)];\n                    }\n                    return [2 /*return*/];\n                });\n            }); });\n        });\n    };\n    PersistentStream.prototype.startStream = function (token) {\n        var _this = this;\n        if (this.state === PersistentStreamState.Stopped) {\n            // Stream can be stopped while waiting for authorization.\n            return;\n        }\n        assert(this.state === PersistentStreamState.Auth, 'Trying to start stream in a non-auth state');\n        // Helper function to dispatch to AsyncQueue and make sure that any\n        // close will seem instantaneous and events are prevented from being\n        // raised after the close call\n        var dispatchIfStillActive = function (stream, fn) {\n            _this.queue.enqueue(function () { return tslib_es6[\"__awaiter\"](_this, void 0, void 0, function () {\n                return tslib_es6[\"__generator\"](this, function (_a) {\n                    // Only raise events if the stream instance has not changed\n                    if (this.stream === stream) {\n                        return [2 /*return*/, fn()];\n                    }\n                    return [2 /*return*/];\n                });\n            }); });\n        };\n        // Only start stream if listener has not changed\n        if (this.listener !== null) {\n            var currentStream_1 = this.startRpc(token);\n            this.stream = currentStream_1;\n            this.stream.onOpen(function () {\n                dispatchIfStillActive(currentStream_1, function () {\n                    assert(_this.state === PersistentStreamState.Auth, 'Expected stream to be in state auth, but was ' + _this.state);\n                    _this.state = PersistentStreamState.Open;\n                    return _this.listener.onOpen();\n                });\n            });\n            this.stream.onClose(function (error) {\n                dispatchIfStillActive(currentStream_1, function () {\n                    return _this.handleStreamClose(error);\n                });\n            });\n            this.stream.onMessage(function (msg) {\n                dispatchIfStillActive(currentStream_1, function () {\n                    return _this.onMessage(msg);\n                });\n            });\n        }\n    };\n    PersistentStream.prototype.performBackoff = function (listener) {\n        var _this = this;\n        assert(this.state === PersistentStreamState.Error, 'Should only perform backoff in an error case');\n        this.state = PersistentStreamState.Backoff;\n        this.backoff.backoffAndRun(function () { return tslib_es6[\"__awaiter\"](_this, void 0, void 0, function () {\n            return tslib_es6[\"__generator\"](this, function (_a) {\n                if (this.state === PersistentStreamState.Stopped) {\n                    // We should have canceled the backoff timer when the stream was\n                    // closed, but just in case we make this a no-op.\n                    return [2 /*return*/];\n                }\n                this.state = PersistentStreamState.Initial;\n                this.start(listener);\n                assert(this.isStarted(), 'PersistentStream should have started');\n                return [2 /*return*/];\n            });\n        }); });\n    };\n    PersistentStream.prototype.handleStreamClose = function (error) {\n        assert(this.isStarted(), \"Can't handle server close on non-started stream\");\n        debug(persistent_stream_LOG_TAG, \"close with error: \" + error);\n        this.stream = null;\n        // In theory the stream could close cleanly, however, in our current model\n        // we never expect this to happen because if we stop a stream ourselves,\n        // this callback will never be called. To prevent cases where we retry\n        // without a backoff accidentally, we set the stream to error in all cases.\n        return this.close(PersistentStreamState.Error, error);\n    };\n    return PersistentStream;\n}());\n\n/**\n * A PersistentStream that implements the Listen RPC.\n *\n * Once the Listen stream has called the openHandler, any number of listen and\n * unlisten calls calls can be sent to control what changes will be sent from\n * the server for ListenResponses.\n */\nvar persistent_stream_PersistentListenStream = /** @class */ (function (_super) {\n    tslib_es6[\"__extends\"](PersistentListenStream, _super);\n    function PersistentListenStream(queue, connection, credentials, serializer) {\n        var _this = _super.call(this, queue, TimerId.ListenStreamConnectionBackoff, TimerId.ListenStreamIdle, connection, credentials) || this;\n        _this.serializer = serializer;\n        return _this;\n    }\n    PersistentListenStream.prototype.startRpc = function (token) {\n        return this.connection.openStream('Listen', token);\n    };\n    PersistentListenStream.prototype.onMessage = function (watchChangeProto) {\n        // A successful response means the stream is healthy\n        this.backoff.reset();\n        var watchChange = this.serializer.fromWatchChange(watchChangeProto);\n        var snapshot = this.serializer.versionFromListenResponse(watchChangeProto);\n        return this.listener.onWatchChange(watchChange, snapshot);\n    };\n    /**\n     * Registers interest in the results of the given query. If the query\n     * includes a resumeToken it will be included in the request. Results that\n     * affect the query will be streamed back as WatchChange messages that\n     * reference the targetId.\n     */\n    PersistentListenStream.prototype.watch = function (queryData) {\n        var request = {};\n        request.database = this.serializer.encodedDatabaseId;\n        request.addTarget = this.serializer.toTarget(queryData);\n        var labels = this.serializer.toListenRequestLabels(queryData);\n        if (labels) {\n            request.labels = labels;\n        }\n        this.sendRequest(request);\n    };\n    /**\n     * Unregisters interest in the results of the query associated with the\n     * given targetId.\n     */\n    PersistentListenStream.prototype.unwatch = function (targetId) {\n        var request = {};\n        request.database = this.serializer.encodedDatabaseId;\n        request.removeTarget = targetId;\n        this.sendRequest(request);\n    };\n    return PersistentListenStream;\n}(persistent_stream_PersistentStream));\n\n/**\n * A Stream that implements the Write RPC.\n *\n * The Write RPC requires the caller to maintain special streamToken\n * state in between calls, to help the server understand which responses the\n * client has processed by the time the next request is made. Every response\n * will contain a streamToken; this value must be passed to the next\n * request.\n *\n * After calling start() on this stream, the next request must be a handshake,\n * containing whatever streamToken is on hand. Once a response to this\n * request is received, all pending mutations may be submitted. When\n * submitting multiple batches of mutations at the same time, it's\n * okay to use the same streamToken for the calls to writeMutations.\n *\n * TODO(b/33271235): Use proto types\n */\nvar persistent_stream_PersistentWriteStream = /** @class */ (function (_super) {\n    tslib_es6[\"__extends\"](PersistentWriteStream, _super);\n    function PersistentWriteStream(queue, connection, credentials, serializer) {\n        var _this = _super.call(this, queue, TimerId.WriteStreamConnectionBackoff, TimerId.WriteStreamIdle, connection, credentials) || this;\n        _this.serializer = serializer;\n        _this.handshakeComplete_ = false;\n        return _this;\n    }\n    Object.defineProperty(PersistentWriteStream.prototype, \"handshakeComplete\", {\n        /**\n         * Tracks whether or not a handshake has been successfully exchanged and\n         * the stream is ready to accept mutations.\n         */\n        get: function () {\n            return this.handshakeComplete_;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // Override of PersistentStream.start\n    PersistentWriteStream.prototype.start = function (listener) {\n        this.handshakeComplete_ = false;\n        _super.prototype.start.call(this, listener);\n    };\n    PersistentWriteStream.prototype.tearDown = function () {\n        if (this.handshakeComplete_) {\n            this.writeMutations([]);\n        }\n    };\n    PersistentWriteStream.prototype.startRpc = function (token) {\n        return this.connection.openStream('Write', token);\n    };\n    PersistentWriteStream.prototype.onMessage = function (responseProto) {\n        // Always capture the last stream token.\n        assert(!!responseProto.streamToken, 'Got a write response without a stream token');\n        this.lastStreamToken = responseProto.streamToken;\n        if (!this.handshakeComplete_) {\n            // The first response is always the handshake response\n            assert(!responseProto.writeResults || responseProto.writeResults.length === 0, 'Got mutation results for handshake');\n            this.handshakeComplete_ = true;\n            return this.listener.onHandshakeComplete();\n        }\n        else {\n            // A successful first write response means the stream is healthy,\n            // Note, that we could consider a successful handshake healthy, however,\n            // the write itself might be causing an error we want to back off from.\n            this.backoff.reset();\n            var results = this.serializer.fromWriteResults(responseProto.writeResults);\n            var commitVersion = this.serializer.fromVersion(responseProto.commitTime);\n            return this.listener.onMutationResult(commitVersion, results);\n        }\n    };\n    /**\n     * Sends an initial streamToken to the server, performing the handshake\n     * required to make the StreamingWrite RPC work. Subsequent\n     * calls should wait until onHandshakeComplete was called.\n     */\n    PersistentWriteStream.prototype.writeHandshake = function () {\n        assert(this.isOpen(), 'Writing handshake requires an opened stream');\n        assert(!this.handshakeComplete_, 'Handshake already completed');\n        // TODO(dimond): Support stream resumption. We intentionally do not set the\n        // stream token on the handshake, ignoring any stream token we might have.\n        var request = {};\n        request.database = this.serializer.encodedDatabaseId;\n        this.sendRequest(request);\n    };\n    /** Sends a group of mutations to the Firestore backend to apply. */\n    PersistentWriteStream.prototype.writeMutations = function (mutations) {\n        var _this = this;\n        assert(this.isOpen(), 'Writing mutations requires an opened stream');\n        assert(this.handshakeComplete_, 'Handshake must be complete before writing mutations');\n        assert(this.lastStreamToken.length > 0, 'Trying to write mutation without a token');\n        var request = {\n            // Protos are typed with string, but we support UInt8Array on Node\n            // tslint:disable-next-line:no-any\n            streamToken: this.lastStreamToken,\n            writes: mutations.map(function (mutation) { return _this.serializer.toMutation(mutation); })\n        };\n        this.sendRequest(request);\n    };\n    return PersistentWriteStream;\n}(persistent_stream_PersistentStream));\n\n\n//# sourceMappingURL=persistent_stream.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/remote/datastore.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n/**\n * Datastore is a wrapper around the external Google Cloud Datastore grpc API,\n * which provides an interface that is more convenient for the rest of the\n * client SDK architecture to consume.\n */\nvar datastore_Datastore = /** @class */ (function () {\n    function Datastore(queue, connection, credentials, serializer) {\n        this.queue = queue;\n        this.connection = connection;\n        this.credentials = credentials;\n        this.serializer = serializer;\n    }\n    Datastore.prototype.newPersistentWriteStream = function () {\n        return new persistent_stream_PersistentWriteStream(this.queue, this.connection, this.credentials, this.serializer);\n    };\n    Datastore.prototype.newPersistentWatchStream = function () {\n        return new persistent_stream_PersistentListenStream(this.queue, this.connection, this.credentials, this.serializer);\n    };\n    Datastore.prototype.commit = function (mutations) {\n        var _this = this;\n        var params = {\n            database: this.serializer.encodedDatabaseId,\n            writes: mutations.map(function (m) { return _this.serializer.toMutation(m); })\n        };\n        return this.invokeRPC('Commit', params).then(function (response) {\n            return _this.serializer.fromWriteResults(response.writeResults);\n        });\n    };\n    Datastore.prototype.lookup = function (keys) {\n        var _this = this;\n        var params = {\n            database: this.serializer.encodedDatabaseId,\n            documents: keys.map(function (k) { return _this.serializer.toName(k); })\n        };\n        return this.invokeStreamingRPC('BatchGetDocuments', params).then(function (response) {\n            var docs = maybeDocumentMap();\n            response.forEach(function (proto) {\n                var doc = _this.serializer.fromMaybeDocument(proto);\n                docs = docs.insert(doc.key, doc);\n            });\n            var result = [];\n            keys.forEach(function (key) {\n                var doc = docs.get(key);\n                assert(!!doc, 'Missing entity in write response for ' + key);\n                result.push(doc);\n            });\n            return result;\n        });\n    };\n    /** Gets an auth token and invokes the provided RPC. */\n    Datastore.prototype.invokeRPC = function (rpcName, request) {\n        var _this = this;\n        // TODO(mikelehen): Retry (with backoff) on token failures?\n        return this.credentials.getToken(/*forceRefresh=*/ false).then(function (token) {\n            return _this.connection.invokeRPC(rpcName, request, token);\n        });\n    };\n    /** Gets an auth token and invokes the provided RPC with streamed results. */\n    Datastore.prototype.invokeStreamingRPC = function (rpcName, request) {\n        var _this = this;\n        // TODO(mikelehen): Retry (with backoff) on token failures?\n        return this.credentials.getToken(/*forceRefresh=*/ false).then(function (token) {\n            return _this.connection.invokeStreamingRPC(rpcName, request, token);\n        });\n    };\n    return Datastore;\n}());\n\n\n//# sourceMappingURL=datastore.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/core/transaction.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n/**\n * Internal transaction object responsible for accumulating the mutations to\n * perform and the base versions for any documents read.\n */\nvar transaction_Transaction = /** @class */ (function () {\n    function Transaction(datastore) {\n        this.datastore = datastore;\n        // The version of each document that was read during this transaction.\n        this.readVersions = documentVersionMap();\n        this.mutations = [];\n        this.committed = false;\n    }\n    Transaction.prototype.recordVersion = function (doc) {\n        var docVersion = doc.version;\n        if (doc instanceof document_NoDocument) {\n            // For deleted docs, we must use baseVersion 0 when we overwrite them.\n            docVersion = snapshot_version_SnapshotVersion.forDeletedDoc();\n        }\n        var existingVersion = this.readVersions.get(doc.key);\n        if (existingVersion !== null) {\n            if (!docVersion.isEqual(existingVersion)) {\n                // This transaction will fail no matter what.\n                throw new error_FirestoreError(Code.ABORTED, 'Document version changed between two reads.');\n            }\n        }\n        else {\n            this.readVersions = this.readVersions.insert(doc.key, docVersion);\n        }\n    };\n    Transaction.prototype.lookup = function (keys) {\n        var _this = this;\n        if (this.committed) {\n            return Promise.reject('Transaction has already completed.');\n        }\n        if (this.mutations.length > 0) {\n            return Promise.reject('Transactions lookups are invalid after writes.');\n        }\n        return this.datastore.lookup(keys).then(function (docs) {\n            docs.forEach(function (doc) { return _this.recordVersion(doc); });\n            return docs;\n        });\n    };\n    Transaction.prototype.write = function (mutations) {\n        if (this.committed) {\n            throw new error_FirestoreError(Code.FAILED_PRECONDITION, 'Transaction has already completed.');\n        }\n        this.mutations = this.mutations.concat(mutations);\n    };\n    /**\n     * Returns the version of this document when it was read in this transaction,\n     * as a precondition, or no precondition if it was not read.\n     */\n    Transaction.prototype.precondition = function (key) {\n        var version = this.readVersions.get(key);\n        if (version) {\n            return mutation_Precondition.updateTime(version);\n        }\n        else {\n            return mutation_Precondition.NONE;\n        }\n    };\n    /**\n     * Returns the precondition for a document if the operation is an update.\n     */\n    Transaction.prototype.preconditionForUpdate = function (key) {\n        var version = this.readVersions.get(key);\n        if (version && version.isEqual(snapshot_version_SnapshotVersion.forDeletedDoc())) {\n            // The document doesn't exist, so fail the transaction.\n            throw new error_FirestoreError(Code.FAILED_PRECONDITION, \"Can't update a document that doesn't exist.\");\n        }\n        else if (version) {\n            // Document exists, base precondition on document update time.\n            return mutation_Precondition.updateTime(version);\n        }\n        else {\n            // Document was not read, so we just use the preconditions for a blind\n            // update.\n            return mutation_Precondition.exists(true);\n        }\n    };\n    Transaction.prototype.set = function (key, data) {\n        this.write(data.toMutations(key, this.precondition(key)));\n    };\n    Transaction.prototype.update = function (key, data) {\n        this.write(data.toMutations(key, this.preconditionForUpdate(key)));\n    };\n    Transaction.prototype.delete = function (key) {\n        this.write([new mutation_DeleteMutation(key, this.precondition(key))]);\n        // Since the delete will be applied before all following writes, we need to\n        // ensure that the precondition for the next write will be exists: false.\n        this.readVersions = this.readVersions.insert(key, snapshot_version_SnapshotVersion.forDeletedDoc());\n    };\n    Transaction.prototype.commit = function () {\n        var _this = this;\n        var unwritten = this.readVersions;\n        // For each mutation, note that the doc was written.\n        this.mutations.forEach(function (mutation) {\n            unwritten = unwritten.remove(mutation.key);\n        });\n        if (!unwritten.isEmpty()) {\n            return Promise.reject(Error('Every document read in a transaction must also be written.'));\n        }\n        return this.datastore.commit(this.mutations).then(function () {\n            _this.committed = true;\n        });\n    };\n    return Transaction;\n}());\n\n\n//# sourceMappingURL=transaction.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/remote/online_state_tracker.js\n/**\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\nvar online_state_tracker_LOG_TAG = 'OnlineStateTracker';\n// To deal with transient failures, we allow multiple stream attempts before\n// giving up and transitioning from OnlineState.Unknown to Offline.\nvar MAX_WATCH_STREAM_FAILURES = 2;\n// To deal with stream attempts that don't succeed or fail in a timely manner,\n// we have a timeout for OnlineState to reach Online or Offline.\n// If the timeout is reached, we transition to Offline rather than waiting\n// indefinitely.\nvar ONLINE_STATE_TIMEOUT_MS = 10 * 1000;\n/**\n * A component used by the RemoteStore to track the OnlineState (that is,\n * whether or not the client as a whole should be considered to be online or\n * offline), implementing the appropriate heuristics.\n *\n * In particular, when the client is trying to connect to the backend, we\n * allow up to MAX_WATCH_STREAM_FAILURES within ONLINE_STATE_TIMEOUT_MS for\n * a connection to succeed. If we have too many failures or the timeout elapses,\n * then we set the OnlineState to Offline, and the client will behave as if\n * it is offline (get()s will return cached data, etc.).\n */\nvar online_state_tracker_OnlineStateTracker = /** @class */ (function () {\n    function OnlineStateTracker(asyncQueue, onlineStateHandler) {\n        this.asyncQueue = asyncQueue;\n        this.onlineStateHandler = onlineStateHandler;\n        /** The current OnlineState. */\n        this.state = OnlineState.Unknown;\n        /**\n         * A count of consecutive failures to open the stream. If it reaches the\n         * maximum defined by MAX_WATCH_STREAM_FAILURES, we'll set the OnlineState to\n         * Offline.\n         */\n        this.watchStreamFailures = 0;\n        /**\n         * A timer that elapses after ONLINE_STATE_TIMEOUT_MS, at which point we\n         * transition from OnlineState.Unknown to OnlineState.Offline without waiting\n         * for the stream to actually fail (MAX_WATCH_STREAM_FAILURES times).\n         */\n        this.onlineStateTimer = null;\n        /**\n         * Whether the client should log a warning message if it fails to connect to\n         * the backend (initially true, cleared after a successful stream, or if we've\n         * logged the message already).\n         */\n        this.shouldWarnClientIsOffline = true;\n    }\n    /**\n     * Called by RemoteStore when a watch stream is started.\n     *\n     * It sets the OnlineState to Unknown and starts the onlineStateTimer\n     * if necessary.\n     */\n    OnlineStateTracker.prototype.handleWatchStreamStart = function () {\n        var _this = this;\n        this.setAndBroadcast(OnlineState.Unknown);\n        if (this.onlineStateTimer === null) {\n            this.onlineStateTimer = this.asyncQueue.enqueueAfterDelay(TimerId.OnlineStateTimeout, ONLINE_STATE_TIMEOUT_MS, function () {\n                _this.onlineStateTimer = null;\n                assert(_this.state === OnlineState.Unknown, 'Timer should be canceled if we transitioned to a different state.');\n                debug(online_state_tracker_LOG_TAG, \"Watch stream didn't reach online or offline within \" +\n                    (ONLINE_STATE_TIMEOUT_MS + \"ms. Considering client offline.\"));\n                _this.logClientOfflineWarningIfNecessary();\n                _this.setAndBroadcast(OnlineState.Offline);\n                // NOTE: handleWatchStreamFailure() will continue to increment\n                // watchStreamFailures even though we are already marked Offline,\n                // but this is non-harmful.\n                return Promise.resolve();\n            });\n        }\n    };\n    /**\n     * Updates our OnlineState as appropriate after the watch stream reports a\n     * failure. The first failure moves us to the 'Unknown' state. We then may\n     * allow multiple failures (based on MAX_WATCH_STREAM_FAILURES) before we\n     * actually transition to the 'Offline' state.\n     */\n    OnlineStateTracker.prototype.handleWatchStreamFailure = function () {\n        if (this.state === OnlineState.Online) {\n            this.setAndBroadcast(OnlineState.Unknown);\n        }\n        else {\n            this.watchStreamFailures++;\n            if (this.watchStreamFailures >= MAX_WATCH_STREAM_FAILURES) {\n                this.clearOnlineStateTimer();\n                this.logClientOfflineWarningIfNecessary();\n                this.setAndBroadcast(OnlineState.Offline);\n            }\n        }\n    };\n    /**\n     * Explicitly sets the OnlineState to the specified state.\n     *\n     * Note that this resets our timers / failure counters, etc. used by our\n     * Offline heuristics, so must not be used in place of\n     * handleWatchStreamStart() and handleWatchStreamFailure().\n     */\n    OnlineStateTracker.prototype.set = function (newState) {\n        this.clearOnlineStateTimer();\n        this.watchStreamFailures = 0;\n        if (newState === OnlineState.Online) {\n            // We've connected to watch at least once. Don't warn the developer\n            // about being offline going forward.\n            this.shouldWarnClientIsOffline = false;\n        }\n        this.setAndBroadcast(newState);\n    };\n    OnlineStateTracker.prototype.setAndBroadcast = function (newState) {\n        if (newState !== this.state) {\n            this.state = newState;\n            this.onlineStateHandler(newState);\n        }\n    };\n    OnlineStateTracker.prototype.logClientOfflineWarningIfNecessary = function () {\n        if (this.shouldWarnClientIsOffline) {\n            log_error('Could not reach Firestore backend.');\n            this.shouldWarnClientIsOffline = false;\n        }\n    };\n    OnlineStateTracker.prototype.clearOnlineStateTimer = function () {\n        if (this.onlineStateTimer !== null) {\n            this.onlineStateTimer.cancel();\n            this.onlineStateTimer = null;\n        }\n    };\n    return OnlineStateTracker;\n}());\n\n\n//# sourceMappingURL=online_state_tracker.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/remote/remote_store.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar remote_store_LOG_TAG = 'RemoteStore';\n// TODO(b/35853402): Negotiate this with the stream.\nvar MAX_PENDING_WRITES = 10;\n/**\n * RemoteStore - An interface to remotely stored data, basically providing a\n * wrapper around the Datastore that is more reliable for the rest of the\n * system.\n *\n * RemoteStore is responsible for maintaining the connection to the server.\n * - maintaining a list of active listens.\n * - reconnecting when the connection is dropped.\n * - resuming all the active listens on reconnect.\n *\n * RemoteStore handles all incoming events from the Datastore.\n * - listening to the watch stream and repackaging the events as RemoteEvents\n * - notifying SyncEngine of any changes to the active listens.\n *\n * RemoteStore takes writes from other components and handles them reliably.\n * - pulling pending mutations from LocalStore and sending them to Datastore.\n * - retrying mutations that failed because of network problems.\n * - acking mutations to the SyncEngine once they are accepted or rejected.\n */\nvar remote_store_RemoteStore = /** @class */ (function () {\n    function RemoteStore(\n    /**\n     * The local store, used to fill the write pipeline with outbound\n     * mutations and resolve existence filter mismatches.\n     */\n    localStore, \n    /** The client-side proxy for interacting with the backend. */\n    datastore, asyncQueue, onlineStateHandler) {\n        this.localStore = localStore;\n        this.datastore = datastore;\n        this.pendingWrites = [];\n        this.lastBatchSeen = BATCHID_UNKNOWN;\n        /**\n         * A mapping of watched targets that the client cares about tracking and the\n         * user has explicitly called a 'listen' for this target.\n         *\n         * These targets may or may not have been sent to or acknowledged by the\n         * server. On re-establishing the listen stream, these targets should be sent\n         * to the server. The targets removed with unlistens are removed eagerly\n         * without waiting for confirmation from the listen stream.\n         */\n        this.listenTargets = {};\n        /**\n         * A mapping of targetId to pending acks needed.\n         *\n         * If a targetId is present in this map, then we're waiting for watch to\n         * acknowledge a removal or addition of the target. If a target is not in this\n         * mapping, and it's in the listenTargets map, then we consider the target to\n         * be active.\n         *\n         * We increment the count here every time we issue a request over the stream\n         * to watch or unwatch. We then decrement the count every time we get a target\n         * added or target removed message from the server. Once the count is equal to\n         * 0 we know that the client and server are in the same state (once this state\n         * is reached the targetId is removed from the map to free the memory).\n         */\n        this.pendingTargetResponses = {};\n        this.accumulatedWatchChanges = [];\n        this.watchStream = null;\n        this.writeStream = null;\n        this.onlineStateTracker = new online_state_tracker_OnlineStateTracker(asyncQueue, onlineStateHandler);\n    }\n    /**\n     * Starts up the remote store, creating streams, restoring state from\n     * LocalStore, etc.\n     */\n    RemoteStore.prototype.start = function () {\n        return this.enableNetwork();\n    };\n    RemoteStore.prototype.isNetworkEnabled = function () {\n        assert((this.watchStream == null) === (this.writeStream == null), 'WatchStream and WriteStream should both be null or non-null');\n        return this.watchStream != null;\n    };\n    /** Re-enables the network. Idempotent. */\n    RemoteStore.prototype.enableNetwork = function () {\n        var _this = this;\n        if (this.isNetworkEnabled()) {\n            return Promise.resolve();\n        }\n        // Create new streams (but note they're not started yet).\n        this.watchStream = this.datastore.newPersistentWatchStream();\n        this.writeStream = this.datastore.newPersistentWriteStream();\n        // Load any saved stream token from persistent storage\n        return this.localStore.getLastStreamToken().then(function (token) {\n            _this.writeStream.lastStreamToken = token;\n            if (_this.shouldStartWatchStream()) {\n                _this.startWatchStream();\n            }\n            else {\n                _this.onlineStateTracker.set(OnlineState.Unknown);\n            }\n            return _this.fillWritePipeline(); // This may start the writeStream.\n        });\n    };\n    /**\n     * Temporarily disables the network. The network can be re-enabled using\n     * enableNetwork().\n     */\n    RemoteStore.prototype.disableNetwork = function () {\n        return tslib_es6[\"__awaiter\"](this, void 0, void 0, function () {\n            return tslib_es6[\"__generator\"](this, function (_a) {\n                this.disableNetworkInternal();\n                // Set the OnlineState to Offline so get()s return from cache, etc.\n                this.onlineStateTracker.set(OnlineState.Offline);\n                return [2 /*return*/];\n            });\n        });\n    };\n    /**\n     * Disables the network, if it is currently enabled.\n     */\n    RemoteStore.prototype.disableNetworkInternal = function () {\n        if (this.isNetworkEnabled()) {\n            // NOTE: We're guaranteed not to get any further events from these streams (not even a close\n            // event).\n            this.watchStream.stop();\n            this.writeStream.stop();\n            this.cleanUpWatchStreamState();\n            this.cleanUpWriteStreamState();\n            this.writeStream = null;\n            this.watchStream = null;\n        }\n    };\n    RemoteStore.prototype.shutdown = function () {\n        debug(remote_store_LOG_TAG, 'RemoteStore shutting down.');\n        this.disableNetworkInternal();\n        // Set the OnlineState to Unknown (rather than Offline) to avoid potentially\n        // triggering spurious listener events with cached data, etc.\n        this.onlineStateTracker.set(OnlineState.Unknown);\n        return Promise.resolve();\n    };\n    /** Starts new listen for the given query. Uses resume token if provided */\n    RemoteStore.prototype.listen = function (queryData) {\n        assert(!contains(this.listenTargets, queryData.targetId), 'listen called with duplicate targetId!');\n        // Mark this as something the client is currently listening for.\n        this.listenTargets[queryData.targetId] = queryData;\n        if (this.shouldStartWatchStream()) {\n            // The listen will be sent in onWatchStreamOpen\n            this.startWatchStream();\n        }\n        else if (this.isNetworkEnabled() && this.watchStream.isOpen()) {\n            this.sendWatchRequest(queryData);\n        }\n    };\n    /** Removes the listen from server */\n    RemoteStore.prototype.unlisten = function (targetId) {\n        assert(contains(this.listenTargets, targetId), 'unlisten called without assigned target ID!');\n        delete this.listenTargets[targetId];\n        if (this.isNetworkEnabled() && this.watchStream.isOpen()) {\n            this.sendUnwatchRequest(targetId);\n            if (isEmpty(this.listenTargets)) {\n                this.watchStream.markIdle();\n            }\n        }\n    };\n    /**\n     * We need to increment the the expected number of pending responses we're due\n     * from watch so we wait for the ack to process any messages from this target.\n     */\n    RemoteStore.prototype.sendWatchRequest = function (queryData) {\n        this.recordPendingTargetRequest(queryData.targetId);\n        this.watchStream.watch(queryData);\n    };\n    /**\n     * We need to increment the expected number of pending responses we're due\n     * from watch so we wait for the removal on the server before we process any\n     * messages from this target.\n     */\n    RemoteStore.prototype.sendUnwatchRequest = function (targetId) {\n        this.recordPendingTargetRequest(targetId);\n        this.watchStream.unwatch(targetId);\n    };\n    /**\n     * Increment the mapping of how many acks are needed from watch before we can\n     * consider the server to be 'in-sync' with the client's active targets.\n     */\n    RemoteStore.prototype.recordPendingTargetRequest = function (targetId) {\n        // For each request we get we need to record we need a response for it.\n        this.pendingTargetResponses[targetId] =\n            (this.pendingTargetResponses[targetId] || 0) + 1;\n    };\n    RemoteStore.prototype.startWatchStream = function () {\n        assert(this.shouldStartWatchStream(), 'startWriteStream() called when shouldStartWatchStream() is false.');\n        this.watchStream.start({\n            onOpen: this.onWatchStreamOpen.bind(this),\n            onClose: this.onWatchStreamClose.bind(this),\n            onWatchChange: this.onWatchStreamChange.bind(this)\n        });\n        this.onlineStateTracker.handleWatchStreamStart();\n    };\n    /**\n     * Returns whether the watch stream should be started because it's necessary\n     * and has not yet been started.\n     */\n    RemoteStore.prototype.shouldStartWatchStream = function () {\n        return (this.isNetworkEnabled() &&\n            !this.watchStream.isStarted() &&\n            !isEmpty(this.listenTargets));\n    };\n    RemoteStore.prototype.cleanUpWatchStreamState = function () {\n        // If the connection is closed then we'll never get a snapshot version for\n        // the accumulated changes and so we'll never be able to complete the batch.\n        // When we start up again the server is going to resend these changes\n        // anyway, so just toss the accumulated state.\n        this.accumulatedWatchChanges = [];\n        this.pendingTargetResponses = {};\n    };\n    RemoteStore.prototype.onWatchStreamOpen = function () {\n        return tslib_es6[\"__awaiter\"](this, void 0, void 0, function () {\n            var _this = this;\n            return tslib_es6[\"__generator\"](this, function (_a) {\n                // TODO(b/35852690): close the stream again (with some timeout?) if no watch\n                // targets are active\n                forEachNumber(this.listenTargets, function (targetId, queryData) {\n                    _this.sendWatchRequest(queryData);\n                });\n                return [2 /*return*/];\n            });\n        });\n    };\n    RemoteStore.prototype.onWatchStreamClose = function (error) {\n        return tslib_es6[\"__awaiter\"](this, void 0, void 0, function () {\n            return tslib_es6[\"__generator\"](this, function (_a) {\n                assert(this.isNetworkEnabled(), 'onWatchStreamClose() should only be called when the network is enabled');\n                this.cleanUpWatchStreamState();\n                this.onlineStateTracker.handleWatchStreamFailure();\n                // If there was an error, retry the connection.\n                if (this.shouldStartWatchStream()) {\n                    this.startWatchStream();\n                }\n                else {\n                    // No need to restart watch stream because there are no active targets.\n                    // The online state is set to unknown because there is no active attempt\n                    // at establishing a connection\n                    this.onlineStateTracker.set(OnlineState.Unknown);\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    RemoteStore.prototype.onWatchStreamChange = function (watchChange, snapshotVersion) {\n        return tslib_es6[\"__awaiter\"](this, void 0, void 0, function () {\n            var changes;\n            return tslib_es6[\"__generator\"](this, function (_a) {\n                // Mark the client as online since we got a message from the server\n                this.onlineStateTracker.set(OnlineState.Online);\n                if (watchChange instanceof watch_change_WatchTargetChange &&\n                    watchChange.state === WatchTargetChangeState.Removed &&\n                    watchChange.cause) {\n                    // There was an error on a target, don't wait for a consistent snapshot\n                    // to raise events\n                    return [2 /*return*/, this.handleTargetError(watchChange)];\n                }\n                // Accumulate watch changes but don't process them if there's no\n                // snapshotVersion or it's older than a previous snapshot we've processed\n                // (can happen after we resume a target using a resume token).\n                this.accumulatedWatchChanges.push(watchChange);\n                if (!snapshotVersion.isEqual(snapshot_version_SnapshotVersion.MIN) &&\n                    snapshotVersion.compareTo(this.localStore.getLastRemoteSnapshotVersion()) >= 0) {\n                    changes = this.accumulatedWatchChanges;\n                    this.accumulatedWatchChanges = [];\n                    return [2 /*return*/, this.handleWatchChangeBatch(snapshotVersion, changes)];\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    /**\n     * Takes a batch of changes from the Datastore, repackages them as a\n     * RemoteEvent, and passes that on to the listener, which is typically the\n     * SyncEngine.\n     */\n    RemoteStore.prototype.handleWatchChangeBatch = function (snapshotVersion, changes) {\n        var _this = this;\n        var aggregator = new watch_change_WatchChangeAggregator(snapshotVersion, this.listenTargets, this.pendingTargetResponses);\n        aggregator.addChanges(changes);\n        var remoteEvent = aggregator.createRemoteEvent();\n        // Get the new response counts from the aggregator\n        this.pendingTargetResponses = aggregator.pendingTargetResponses;\n        var promises = [];\n        // Handle existence filters and existence filter mismatches.\n        forEachNumber(aggregator.existenceFilters, function (targetId, filter) {\n            var queryData = _this.listenTargets[targetId];\n            if (!queryData) {\n                // A watched target might have been removed already.\n                return;\n            }\n            var query = queryData.query;\n            if (query.isDocumentQuery()) {\n                if (filter.count === 0) {\n                    // The existence filter told us the document does not exist.\n                    // We need to deduce that this document does not exist and apply\n                    // a deleted document to our updates. Without applying a deleted\n                    // document there might be another query that will raise this\n                    // document as part of a snapshot until it is resolved,\n                    // essentially exposing inconsistency between queries.\n                    var key = new document_key_DocumentKey(query.path);\n                    var deletedDoc = new document_NoDocument(key, snapshotVersion);\n                    remoteEvent.addDocumentUpdate(deletedDoc);\n                }\n                else {\n                    assert(filter.count === 1, 'Single document existence filter with count: ' + filter.count);\n                }\n            }\n            else {\n                // Not a document query.\n                var promise = _this.localStore\n                    .remoteDocumentKeys(targetId)\n                    .then(function (trackedRemote) {\n                    if (remoteEvent.targetChanges[targetId]) {\n                        var mapping = remoteEvent.targetChanges[targetId].mapping;\n                        if (mapping !== null) {\n                            if (mapping instanceof UpdateMapping) {\n                                trackedRemote = mapping.applyToKeySet(trackedRemote);\n                            }\n                            else {\n                                assert(mapping instanceof ResetMapping, 'Expected either reset or update mapping but got something else: ' +\n                                    mapping);\n                                trackedRemote = mapping.documents;\n                            }\n                        }\n                    }\n                    if (trackedRemote.size !== filter.count) {\n                        // Existence filter mismatch, resetting mapping.\n                        // Make sure the mismatch is exposed in the remote event.\n                        remoteEvent.handleExistenceFilterMismatch(targetId);\n                        // Clear the resume token for the query, since we're in a\n                        // known mismatch state.\n                        var newQueryData = new query_data_QueryData(query, targetId, queryData.purpose);\n                        _this.listenTargets[targetId] = newQueryData;\n                        // Cause a hard reset by unwatching and rewatching\n                        // immediately, but deliberately don't send a resume token\n                        // so that we get a full update.\n                        // Make sure we expect that this acks are going to happen.\n                        _this.sendUnwatchRequest(targetId);\n                        // Mark the query we send as being on behalf of an existence\n                        // filter mismatch, but don't actually retain that in\n                        // listenTargets. This ensures that we flag the first\n                        // re-listen this way without impacting future listens of\n                        // this target (that might happen e.g. on reconnect).\n                        var requestQueryData = new query_data_QueryData(query, targetId, QueryPurpose.ExistenceFilterMismatch);\n                        _this.sendWatchRequest(requestQueryData);\n                    }\n                });\n                promises.push(promise);\n            }\n        });\n        return Promise.all(promises).then(function () {\n            // Update in-memory resume tokens. LocalStore will update the\n            // persistent view of these when applying the completed RemoteEvent.\n            forEachNumber(remoteEvent.targetChanges, function (targetId, change) {\n                if (change.resumeToken.length > 0) {\n                    var queryData = _this.listenTargets[targetId];\n                    // A watched target might have been removed already.\n                    if (queryData) {\n                        _this.listenTargets[targetId] = queryData.update({\n                            resumeToken: change.resumeToken,\n                            snapshotVersion: change.snapshotVersion\n                        });\n                    }\n                }\n            });\n            // Finally handle remote event\n            return _this.syncEngine.applyRemoteEvent(remoteEvent);\n        });\n    };\n    /** Handles an error on a target */\n    RemoteStore.prototype.handleTargetError = function (watchChange) {\n        var _this = this;\n        assert(!!watchChange.cause, 'Handling target error without a cause');\n        var error = watchChange.cause;\n        var promiseChain = Promise.resolve();\n        watchChange.targetIds.forEach(function (targetId) {\n            promiseChain = promiseChain.then(function () { return tslib_es6[\"__awaiter\"](_this, void 0, void 0, function () {\n                return tslib_es6[\"__generator\"](this, function (_a) {\n                    // A watched target might have been removed already.\n                    if (contains(this.listenTargets, targetId)) {\n                        delete this.listenTargets[targetId];\n                        return [2 /*return*/, this.syncEngine.rejectListen(targetId, error)];\n                    }\n                    return [2 /*return*/];\n                });\n            }); });\n        });\n        return promiseChain;\n    };\n    RemoteStore.prototype.cleanUpWriteStreamState = function () {\n        this.lastBatchSeen = BATCHID_UNKNOWN;\n        debug(remote_store_LOG_TAG, 'Stopping write stream with ' +\n            this.pendingWrites.length +\n            ' pending writes');\n        this.pendingWrites = [];\n    };\n    /**\n     * Notifies that there are new mutations to process in the queue. This is\n     * typically called by SyncEngine after it has sent mutations to LocalStore.\n     */\n    RemoteStore.prototype.fillWritePipeline = function () {\n        return tslib_es6[\"__awaiter\"](this, void 0, void 0, function () {\n            var _this = this;\n            return tslib_es6[\"__generator\"](this, function (_a) {\n                if (this.canWriteMutations()) {\n                    return [2 /*return*/, this.localStore\n                            .nextMutationBatch(this.lastBatchSeen)\n                            .then(function (batch) {\n                            if (batch === null) {\n                                if (_this.pendingWrites.length === 0) {\n                                    _this.writeStream.markIdle();\n                                }\n                            }\n                            else {\n                                _this.commit(batch);\n                                return _this.fillWritePipeline();\n                            }\n                        })];\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    /**\n     * Returns true if the backend can accept additional write requests.\n     *\n     * When sending mutations to the write stream (e.g. in fillWritePipeline),\n     * call this method first to check if more mutations can be sent.\n     *\n     * Currently the only thing that can prevent the backend from accepting\n     * write requests is if there are too many requests already outstanding. As\n     * writes complete the backend will be able to accept more.\n     */\n    RemoteStore.prototype.canWriteMutations = function () {\n        return (this.isNetworkEnabled() && this.pendingWrites.length < MAX_PENDING_WRITES);\n    };\n    // For testing\n    RemoteStore.prototype.outstandingWrites = function () {\n        return this.pendingWrites.length;\n    };\n    /**\n     * Given mutations to commit, actually commits them to the Datastore. Note\n     * that this does *not* return a Promise specifically because the AsyncQueue\n     * should not block operations for this.\n     */\n    RemoteStore.prototype.commit = function (batch) {\n        assert(this.canWriteMutations(), \"commit called when batches can't be written\");\n        this.lastBatchSeen = batch.batchId;\n        this.pendingWrites.push(batch);\n        if (this.shouldStartWriteStream()) {\n            this.startWriteStream();\n        }\n        else if (this.isNetworkEnabled() && this.writeStream.handshakeComplete) {\n            this.writeStream.writeMutations(batch.mutations);\n        }\n    };\n    RemoteStore.prototype.shouldStartWriteStream = function () {\n        return (this.isNetworkEnabled() &&\n            !this.writeStream.isStarted() &&\n            this.pendingWrites.length > 0);\n    };\n    RemoteStore.prototype.startWriteStream = function () {\n        assert(this.shouldStartWriteStream(), 'startWriteStream() called when shouldStartWriteStream() is false.');\n        this.writeStream.start({\n            onOpen: this.onWriteStreamOpen.bind(this),\n            onClose: this.onWriteStreamClose.bind(this),\n            onHandshakeComplete: this.onWriteHandshakeComplete.bind(this),\n            onMutationResult: this.onMutationResult.bind(this)\n        });\n    };\n    RemoteStore.prototype.onWriteStreamOpen = function () {\n        return tslib_es6[\"__awaiter\"](this, void 0, void 0, function () {\n            return tslib_es6[\"__generator\"](this, function (_a) {\n                this.writeStream.writeHandshake();\n                return [2 /*return*/];\n            });\n        });\n    };\n    RemoteStore.prototype.onWriteHandshakeComplete = function () {\n        var _this = this;\n        // Record the stream token.\n        return this.localStore\n            .setLastStreamToken(this.writeStream.lastStreamToken)\n            .then(function () {\n            // Drain any pending writes.\n            //\n            // Note that at this point pendingWrites contains mutations that\n            // have already been accepted by fillWritePipeline/commitBatch. If\n            // the pipeline is full, canWriteMutations will be false, despite\n            // the fact that we actually need to send mutations over.\n            //\n            // This also means that this method indirectly respects the limits\n            // imposed by canWriteMutations since writes can't be added to the\n            // pendingWrites array when canWriteMutations is false. If the\n            // limits imposed by canWriteMutations actually protect us from\n            // DOSing ourselves then those limits won't be exceeded here and\n            // we'll continue to make progress.\n            for (var _i = 0, _a = _this.pendingWrites; _i < _a.length; _i++) {\n                var batch = _a[_i];\n                _this.writeStream.writeMutations(batch.mutations);\n            }\n        });\n    };\n    RemoteStore.prototype.onMutationResult = function (commitVersion, results) {\n        var _this = this;\n        // This is a response to a write containing mutations and should be\n        // correlated to the first pending write.\n        assert(this.pendingWrites.length > 0, 'Got result for empty pending writes');\n        var batch = this.pendingWrites.shift();\n        var success = mutation_batch_MutationBatchResult.from(batch, commitVersion, results, this.writeStream.lastStreamToken);\n        return this.syncEngine.applySuccessfulWrite(success).then(function () {\n            // It's possible that with the completion of this mutation another\n            // slot has freed up.\n            return _this.fillWritePipeline();\n        });\n    };\n    RemoteStore.prototype.onWriteStreamClose = function (error) {\n        return tslib_es6[\"__awaiter\"](this, void 0, void 0, function () {\n            var _this = this;\n            var errorHandling;\n            return tslib_es6[\"__generator\"](this, function (_a) {\n                assert(this.isNetworkEnabled(), 'onWriteStreamClose() should only be called when the network is enabled');\n                // If the write stream closed due to an error, invoke the error callbacks if\n                // there are pending writes.\n                if (error && this.pendingWrites.length > 0) {\n                    assert(!!error, 'We have pending writes, but the write stream closed without an error');\n                    errorHandling = void 0;\n                    if (this.writeStream.handshakeComplete) {\n                        // This error affects the actual write.\n                        errorHandling = this.handleWriteError(error);\n                    }\n                    else {\n                        // If there was an error before the handshake has finished, it's\n                        // possible that the server is unable to process the stream token\n                        // we're sending. (Perhaps it's too old?)\n                        errorHandling = this.handleHandshakeError(error);\n                    }\n                    return [2 /*return*/, errorHandling.then(function () {\n                            // The write stream might have been started by refilling the write\n                            // pipeline for failed writes\n                            if (_this.shouldStartWriteStream()) {\n                                _this.startWriteStream();\n                            }\n                        })];\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    RemoteStore.prototype.handleHandshakeError = function (error) {\n        return tslib_es6[\"__awaiter\"](this, void 0, void 0, function () {\n            return tslib_es6[\"__generator\"](this, function (_a) {\n                // Reset the token if it's a permanent error or the error code is\n                // ABORTED, signaling the write stream is no longer valid.\n                if (isPermanentError(error.code) || error.code === Code.ABORTED) {\n                    debug(remote_store_LOG_TAG, 'RemoteStore error before completed handshake; resetting stream token: ', this.writeStream.lastStreamToken);\n                    this.writeStream.lastStreamToken = emptyByteString();\n                    return [2 /*return*/, this.localStore.setLastStreamToken(emptyByteString())];\n                }\n                else {\n                    // Some other error, don't reset stream token. Our stream logic will\n                    // just retry with exponential backoff.\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    RemoteStore.prototype.handleWriteError = function (error) {\n        return tslib_es6[\"__awaiter\"](this, void 0, void 0, function () {\n            var _this = this;\n            var batch;\n            return tslib_es6[\"__generator\"](this, function (_a) {\n                if (isPermanentError(error.code)) {\n                    batch = this.pendingWrites.shift();\n                    // In this case it's also unlikely that the server itself is melting\n                    // down -- this was just a bad request so inhibit backoff on the next\n                    // restart.\n                    this.writeStream.inhibitBackoff();\n                    return [2 /*return*/, this.syncEngine\n                            .rejectFailedWrite(batch.batchId, error)\n                            .then(function () {\n                            // It's possible that with the completion of this mutation\n                            // another slot has freed up.\n                            return _this.fillWritePipeline();\n                        })];\n                }\n                else {\n                    // Transient error, just let the retry logic kick in.\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    RemoteStore.prototype.createTransaction = function () {\n        return new transaction_Transaction(this.datastore);\n    };\n    RemoteStore.prototype.handleUserChange = function (user) {\n        debug(remote_store_LOG_TAG, 'RemoteStore changing users: uid=', user.uid);\n        // If the network has been explicitly disabled, make sure we don't\n        // accidentally re-enable it.\n        if (this.isNetworkEnabled()) {\n            // Tear down and re-create our network streams. This will ensure we get a fresh auth token\n            // for the new user and re-fill the write pipeline with new mutations from the LocalStore\n            // (since mutations are per-user).\n            this.disableNetworkInternal();\n            this.onlineStateTracker.set(OnlineState.Unknown);\n            return this.enableNetwork();\n        }\n    };\n    return RemoteStore;\n}());\n\n\n//# sourceMappingURL=remote_store.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/core/firestore_client.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar firestore_client_LOG_TAG = 'FirestoreClient';\n/**\n * FirestoreClient is a top-level class that constructs and owns all of the\n * pieces of the client SDK architecture. It is responsible for creating the\n * async queue that is shared by all of the other components in the system.\n */\nvar firestore_client_FirestoreClient = /** @class */ (function () {\n    function FirestoreClient(platform, databaseInfo, credentials, \n    /**\n     * Asynchronous queue responsible for all of our internal processing. When\n     * we get incoming work from the user (via public API) or the network\n     * (incoming GRPC messages), we should always schedule onto this queue.\n     * This ensures all of our work is properly serialized (e.g. we don't\n     * start processing a new operation while the previous one is waiting for\n     * an async I/O to complete).\n     */\n    asyncQueue) {\n        this.platform = platform;\n        this.databaseInfo = databaseInfo;\n        this.credentials = credentials;\n        this.asyncQueue = asyncQueue;\n    }\n    /**\n     * Starts up the FirestoreClient, returning only whether or not enabling\n     * persistence succeeded.\n     *\n     * The intent here is to \"do the right thing\" as far as users are concerned.\n     * Namely, in cases where offline persistence is requested and possible,\n     * enable it, but otherwise fall back to persistence disabled. For the most\n     * part we expect this to succeed one way or the other so we don't expect our\n     * users to actually wait on the firestore.enablePersistence Promise since\n     * they generally won't care.\n     *\n     * Of course some users actually do care about whether or not persistence\n     * was successfully enabled, so the Promise returned from this method\n     * indicates this outcome.\n     *\n     * This presents a problem though: even before enablePersistence resolves or\n     * rejects, users may have made calls to e.g. firestore.collection() which\n     * means that the FirestoreClient in there will be available and will be\n     * enqueuing actions on the async queue.\n     *\n     * Meanwhile any failure of an operation on the async queue causes it to\n     * panic and reject any further work, on the premise that unhandled errors\n     * are fatal.\n     *\n     * Consequently the fallback is handled internally here in start, and if the\n     * fallback succeeds we signal success to the async queue even though the\n     * start() itself signals failure.\n     *\n     * @param usePersistence Whether or not to attempt to enable persistence.\n     * @returns A deferred result indicating the user-visible result of enabling\n     *     offline persistence. This method will reject this if IndexedDB fails to\n     *     start for any reason. If usePersistence is false this is\n     *     unconditionally resolved.\n     */\n    FirestoreClient.prototype.start = function (usePersistence) {\n        var _this = this;\n        // We defer our initialization until we get the current user from\n        // setUserChangeListener(). We block the async queue until we got the\n        // initial user and the initialization is completed. This will prevent\n        // any scheduled work from happening before initialization is completed.\n        //\n        // If initializationDone resolved then the FirestoreClient is in a usable\n        // state.\n        var initializationDone = new Deferred();\n        // If usePersistence is true, certain classes of errors while starting are\n        // recoverable but only by falling back to persistence disabled.\n        //\n        // If there's an error in the first case but not in recovery we cannot\n        // reject the promise blocking the async queue because this will cause the\n        // async queue to panic.\n        var persistenceResult = new Deferred();\n        var initialized = false;\n        this.credentials.setUserChangeListener(function (user) {\n            if (!initialized) {\n                initialized = true;\n                _this.initializePersistence(usePersistence, persistenceResult)\n                    .then(function () { return _this.initializeRest(user); })\n                    .then(initializationDone.resolve, initializationDone.reject);\n            }\n            else {\n                _this.asyncQueue.enqueue(function () {\n                    return _this.handleUserChange(user);\n                });\n            }\n        });\n        // Block the async queue until initialization is done\n        this.asyncQueue.enqueue(function () {\n            return initializationDone.promise;\n        });\n        // Return only the result of enabling persistence. Note that this does not\n        // need to await the completion of initializationDone because the result of\n        // this method should not reflect any other kind of failure to start.\n        return persistenceResult.promise;\n    };\n    /** Enables the network connection and requeues all pending operations. */\n    FirestoreClient.prototype.enableNetwork = function () {\n        var _this = this;\n        return this.asyncQueue.enqueue(function () {\n            return _this.remoteStore.enableNetwork();\n        });\n    };\n    /**\n     * Initializes persistent storage, attempting to use IndexedDB if\n     * usePersistence is true or memory-only if false.\n     *\n     * If IndexedDB fails because it's already open in another tab or because the\n     * platform can't possibly support our implementation then this method rejects\n     * the persistenceResult and falls back on memory-only persistence.\n     *\n     * @param usePersistence indicates whether or not to use offline persistence\n     * @param persistenceResult A deferred result indicating the user-visible\n     *     result of enabling offline persistence. This method will reject this if\n     *     IndexedDB fails to start for any reason. If usePersistence is false\n     *     this is unconditionally resolved.\n     * @returns a Promise indicating whether or not initialization should\n     *     continue, i.e. that one of the persistence implementations actually\n     *     succeeded.\n     */\n    FirestoreClient.prototype.initializePersistence = function (usePersistence, persistenceResult) {\n        var _this = this;\n        if (usePersistence) {\n            return this.startIndexedDbPersistence()\n                .then(persistenceResult.resolve)\n                .catch(function (error) {\n                // Regardless of whether or not the retry succeeds, from an user\n                // perspective, offline persistence has failed.\n                persistenceResult.reject(error);\n                // An unknown failure on the first stage shuts everything down.\n                if (!_this.canFallback(error)) {\n                    return Promise.reject(error);\n                }\n                console.warn('Error enabling offline storage. Falling back to' +\n                    ' storage disabled: ' +\n                    error);\n                return _this.startMemoryPersistence();\n            });\n        }\n        else {\n            // When usePersistence == false, enabling offline persistence is defined\n            // to unconditionally succeed. This allows start() to have the same\n            // signature for both cases, despite the fact that the returned promise\n            // is only used in the enablePersistence call.\n            persistenceResult.resolve();\n            return this.startMemoryPersistence();\n        }\n    };\n    FirestoreClient.prototype.canFallback = function (error) {\n        return (error.code === Code.FAILED_PRECONDITION ||\n            error.code === Code.UNIMPLEMENTED);\n    };\n    /**\n     * Starts IndexedDB-based persistence.\n     *\n     * @returns A promise indicating success or failure.\n     */\n    FirestoreClient.prototype.startIndexedDbPersistence = function () {\n        // TODO(http://b/33384523): For now we just disable garbage collection\n        // when persistence is enabled.\n        this.garbageCollector = new no_op_garbage_collector_NoOpGarbageCollector();\n        var storagePrefix = indexeddb_persistence_IndexedDbPersistence.buildStoragePrefix(this.databaseInfo);\n        // Opt to use proto3 JSON in case the platform doesn't support Uint8Array.\n        var serializer = new serializer_JsonProtoSerializer(this.databaseInfo.databaseId, {\n            useProto3Json: true\n        });\n        this.persistence = new indexeddb_persistence_IndexedDbPersistence(storagePrefix, serializer);\n        return this.persistence.start();\n    };\n    /**\n     * Starts Memory-backed persistence. In practice this cannot fail.\n     *\n     * @returns A promise that will successfully resolve.\n     */\n    FirestoreClient.prototype.startMemoryPersistence = function () {\n        this.garbageCollector = new eager_garbage_collector_EagerGarbageCollector();\n        this.persistence = new memory_persistence_MemoryPersistence();\n        return this.persistence.start();\n    };\n    /**\n     * Initializes the rest of the FirestoreClient, assuming the initial user\n     * has been obtained from the credential provider and some persistence\n     * implementation is available in this.persistence.\n     */\n    FirestoreClient.prototype.initializeRest = function (user) {\n        var _this = this;\n        return this.platform\n            .loadConnection(this.databaseInfo)\n            .then(function (connection) {\n            _this.localStore = new local_store_LocalStore(_this.persistence, user, _this.garbageCollector);\n            var serializer = _this.platform.newSerializer(_this.databaseInfo.databaseId);\n            var datastore = new datastore_Datastore(_this.asyncQueue, connection, _this.credentials, serializer);\n            var onlineStateChangedHandler = function (onlineState) {\n                _this.syncEngine.applyOnlineStateChange(onlineState);\n                _this.eventMgr.applyOnlineStateChange(onlineState);\n            };\n            _this.remoteStore = new remote_store_RemoteStore(_this.localStore, datastore, _this.asyncQueue, onlineStateChangedHandler);\n            _this.syncEngine = new sync_engine_SyncEngine(_this.localStore, _this.remoteStore, user);\n            // Setup wiring between sync engine and remote store\n            _this.remoteStore.syncEngine = _this.syncEngine;\n            _this.eventMgr = new event_manager_EventManager(_this.syncEngine);\n            // NOTE: RemoteStore depends on LocalStore (for persisting stream\n            // tokens, refilling mutation queue, etc.) so must be started after\n            // LocalStore.\n            return _this.localStore.start();\n        })\n            .then(function () {\n            return _this.remoteStore.start();\n        });\n    };\n    FirestoreClient.prototype.handleUserChange = function (user) {\n        this.asyncQueue.verifyOperationInProgress();\n        debug(firestore_client_LOG_TAG, 'User Changed: ' + user.uid);\n        return this.syncEngine.handleUserChange(user);\n    };\n    /** Disables the network connection. Pending operations will not complete. */\n    FirestoreClient.prototype.disableNetwork = function () {\n        var _this = this;\n        return this.asyncQueue.enqueue(function () {\n            return _this.remoteStore.disableNetwork();\n        });\n    };\n    FirestoreClient.prototype.shutdown = function () {\n        var _this = this;\n        return this.asyncQueue\n            .enqueue(function () {\n            _this.credentials.removeUserChangeListener();\n            return _this.remoteStore.shutdown();\n        })\n            .then(function () {\n            // PORTING NOTE: LocalStore does not need an explicit shutdown on web.\n            return _this.persistence.shutdown();\n        });\n    };\n    FirestoreClient.prototype.listen = function (query, observer, options) {\n        var _this = this;\n        var listener = new event_manager_QueryListener(query, observer, options);\n        this.asyncQueue.enqueue(function () {\n            return _this.eventMgr.listen(listener);\n        });\n        return listener;\n    };\n    FirestoreClient.prototype.unlisten = function (listener) {\n        var _this = this;\n        this.asyncQueue.enqueue(function () {\n            return _this.eventMgr.unlisten(listener);\n        });\n    };\n    FirestoreClient.prototype.write = function (mutations) {\n        var _this = this;\n        var deferred = new Deferred();\n        this.asyncQueue.enqueue(function () { return _this.syncEngine.write(mutations, deferred); });\n        return deferred.promise;\n    };\n    FirestoreClient.prototype.databaseId = function () {\n        return this.databaseInfo.databaseId;\n    };\n    FirestoreClient.prototype.transaction = function (updateFunction) {\n        var _this = this;\n        // We have to wait for the async queue to be sure syncEngine is initialized.\n        return this.asyncQueue\n            .enqueue(function () { return tslib_es6[\"__awaiter\"](_this, void 0, void 0, function () { return tslib_es6[\"__generator\"](this, function (_a) {\n            return [2 /*return*/];\n        }); }); })\n            .then(function () { return _this.syncEngine.runTransaction(updateFunction); });\n    };\n    return FirestoreClient;\n}());\n\n\n//# sourceMappingURL=firestore_client.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/util/async_observer.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * A wrapper implementation of Observer<T> that will dispatch events\n * asynchronously. To allow immediate silencing, a mute call is added which\n * causes events scheduled to no longer be raised.\n */\nvar AsyncObserver = /** @class */ (function () {\n    function AsyncObserver(observer) {\n        this.observer = observer;\n        /**\n         * When set to true, will not raise future events. Necessary to deal with\n         * async detachment of listener.\n         */\n        this.muted = false;\n    }\n    AsyncObserver.prototype.next = function (value) {\n        this.scheduleEvent(this.observer.next, value);\n    };\n    AsyncObserver.prototype.error = function (error) {\n        this.scheduleEvent(this.observer.error, error);\n    };\n    AsyncObserver.prototype.mute = function () {\n        this.muted = true;\n    };\n    AsyncObserver.prototype.scheduleEvent = function (eventHandler, event) {\n        var _this = this;\n        if (!this.muted) {\n            setTimeout(function () {\n                if (!_this.muted) {\n                    eventHandler(event);\n                }\n            }, 0);\n        }\n    };\n    return AsyncObserver;\n}());\n\n\n//# sourceMappingURL=async_observer.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/auth/user.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Simple wrapper around a nullable UID. Mostly exists to make code more\n * readable.\n */\nvar User = /** @class */ (function () {\n    function User(uid) {\n        this.uid = uid;\n    }\n    User.prototype.isAuthenticated = function () {\n        return this.uid != null;\n    };\n    /**\n     * Returns a key representing this user, suitable for inclusion in a\n     * dictionary.\n     */\n    User.prototype.toKey = function () {\n        if (this.isAuthenticated()) {\n            return 'uid:' + this.uid;\n        }\n        else {\n            return 'anonymous-user';\n        }\n    };\n    User.prototype.isEqual = function (otherUser) {\n        return otherUser.uid === this.uid;\n    };\n    /** A user with a null UID. */\n    User.UNAUTHENTICATED = new User(null);\n    // TODO(mikelehen): Look into getting a proper uid-equivalent for\n    // non-FirebaseAuth providers.\n    User.GOOGLE_CREDENTIALS = new User('google-credentials-uid');\n    User.FIRST_PARTY = new User('first-party-uid');\n    return User;\n}());\n\n\n//# sourceMappingURL=user.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/api/credentials.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\nvar OAuthToken = /** @class */ (function () {\n    function OAuthToken(value, user) {\n        this.user = user;\n        this.type = 'OAuth';\n        this.authHeaders = { Authorization: \"Bearer \" + value };\n    }\n    return OAuthToken;\n}());\n\n/** A CredentialsProvider that always yields an empty token. */\nvar credentials_EmptyCredentialsProvider = /** @class */ (function () {\n    function EmptyCredentialsProvider() {\n        /**\n         * Stores the User listener registered with setUserChangeListener()\n         * This isn't actually necessary since the UID never changes, but we use this\n         * to verify the listen contract is adhered to in tests.\n         */\n        this.userListener = null;\n    }\n    EmptyCredentialsProvider.prototype.getToken = function (forceRefresh) {\n        return Promise.resolve(null);\n    };\n    EmptyCredentialsProvider.prototype.setUserChangeListener = function (listener) {\n        assert(!this.userListener, 'Can only call setUserChangeListener() once.');\n        this.userListener = listener;\n        // Fire with initial user.\n        listener(User.UNAUTHENTICATED);\n    };\n    EmptyCredentialsProvider.prototype.removeUserChangeListener = function () {\n        assert(this.userListener !== null, 'removeUserChangeListener() when no listener registered');\n        this.userListener = null;\n    };\n    return EmptyCredentialsProvider;\n}());\n\nvar credentials_FirebaseCredentialsProvider = /** @class */ (function () {\n    function FirebaseCredentialsProvider(app) {\n        var _this = this;\n        this.app = app;\n        /**\n         * The auth token listener registered with FirebaseApp, retained here so we\n         * can unregister it.\n         */\n        this.tokenListener = null;\n        /**\n         * Counter used to detect if the user changed while a getToken request was\n         * outstanding.\n         */\n        this.userCounter = 0;\n        /** The User listener registered with setUserChangeListener(). */\n        this.userListener = null;\n        // We listen for token changes but all we really care about is knowing when\n        // the uid may have changed.\n        this.tokenListener = function () {\n            var newUser = _this.getUser();\n            if (!_this.currentUser || !newUser.isEqual(_this.currentUser)) {\n                _this.currentUser = newUser;\n                _this.userCounter++;\n                if (_this.userListener) {\n                    _this.userListener(_this.currentUser);\n                }\n            }\n        };\n        this.userCounter = 0;\n        // Will fire at least once where we set this.currentUser\n        this.app.INTERNAL.addAuthTokenListener(this.tokenListener);\n    }\n    FirebaseCredentialsProvider.prototype.getToken = function (forceRefresh) {\n        var _this = this;\n        assert(this.tokenListener != null, 'getToken cannot be called after listener removed.');\n        // Take note of the current value of the userCounter so that this method can\n        // fail (with an ABORTED error) if there is a user change while the request\n        // is outstanding.\n        var initialUserCounter = this.userCounter;\n        return this.app.INTERNAL.getToken(forceRefresh).then(function (tokenData) {\n            // Cancel the request since the user changed while the request was\n            // outstanding so the response is likely for a previous user (which\n            // user, we can't be sure).\n            if (_this.userCounter !== initialUserCounter) {\n                throw new error_FirestoreError(Code.ABORTED, 'getToken aborted due to uid change.');\n            }\n            else {\n                if (tokenData) {\n                    assert(typeof tokenData.accessToken === 'string', 'Invalid tokenData returned from getToken():' + tokenData);\n                    return new OAuthToken(tokenData.accessToken, _this.currentUser);\n                }\n                else {\n                    return null;\n                }\n            }\n        });\n    };\n    FirebaseCredentialsProvider.prototype.setUserChangeListener = function (listener) {\n        assert(!this.userListener, 'Can only call setUserChangeListener() once.');\n        this.userListener = listener;\n        // Fire the initial event, but only if we received the initial user\n        if (this.currentUser) {\n            listener(this.currentUser);\n        }\n    };\n    FirebaseCredentialsProvider.prototype.removeUserChangeListener = function () {\n        assert(this.tokenListener != null, 'removeUserChangeListener() called twice');\n        assert(this.userListener !== null, 'removeUserChangeListener() called when no listener registered');\n        this.app.INTERNAL.removeAuthTokenListener(this.tokenListener);\n        this.tokenListener = null;\n        this.userListener = null;\n    };\n    FirebaseCredentialsProvider.prototype.getUser = function () {\n        // TODO(mikelehen): Remove this check once we're shipping with firebase.js.\n        if (typeof this.app.INTERNAL.getUid !== 'function') {\n            fail('This version of the Firestore SDK requires at least version' +\n                ' 3.7.0 of firebase.js.');\n        }\n        var currentUid = this.app.INTERNAL.getUid();\n        assert(currentUid === null || typeof currentUid === 'string', 'Received invalid UID: ' + currentUid);\n        return new User(currentUid);\n    };\n    return FirebaseCredentialsProvider;\n}());\n\n/*\n * FirstPartyToken provides a fresh token each time its value\n * is requested, because if the token is too old, requests will be rejected.\n * TODO(b/33147818) this implementation violates the current assumption that\n * tokens are immutable.  We need to either revisit this assumption or come\n * up with some way for FPA to use the listen/unlisten interface.\n */\nvar credentials_FirstPartyToken = /** @class */ (function () {\n    function FirstPartyToken(gapi, sessionIndex) {\n        this.gapi = gapi;\n        this.sessionIndex = sessionIndex;\n        this.type = 'FirstParty';\n        this.user = User.FIRST_PARTY;\n        assert(this.gapi &&\n            this.gapi['auth'] &&\n            this.gapi['auth']['getAuthHeaderValueForFirstParty'], 'unexpected gapi interface');\n    }\n    Object.defineProperty(FirstPartyToken.prototype, \"authHeaders\", {\n        get: function () {\n            return {\n                Authorization: this.gapi['auth']['getAuthHeaderValueForFirstParty']([]),\n                'X-Goog-AuthUser': this.sessionIndex\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return FirstPartyToken;\n}());\n\n/*\n * Provides user credentials required for the Firestore JavaScript SDK\n * to authenticate the user, using technique that is only available\n * to applications hosted by Google.\n */\nvar credentials_FirstPartyCredentialsProvider = /** @class */ (function () {\n    function FirstPartyCredentialsProvider(gapi, sessionIndex) {\n        this.gapi = gapi;\n        this.sessionIndex = sessionIndex;\n        assert(this.gapi &&\n            this.gapi['auth'] &&\n            this.gapi['auth']['getAuthHeaderValueForFirstParty'], 'unexpected gapi interface');\n    }\n    FirstPartyCredentialsProvider.prototype.getToken = function (forceRefresh) {\n        return Promise.resolve(new credentials_FirstPartyToken(this.gapi, this.sessionIndex));\n    };\n    // TODO(33108925): can someone switch users w/o a page refresh?\n    // TODO(33110621): need to understand token/session lifecycle\n    FirstPartyCredentialsProvider.prototype.setUserChangeListener = function (listener) {\n        // Fire with initial uid.\n        listener(User.FIRST_PARTY);\n    };\n    FirstPartyCredentialsProvider.prototype.removeUserChangeListener = function () { };\n    return FirstPartyCredentialsProvider;\n}());\n\n/**\n * Builds a CredentialsProvider depending on the type of\n * the credentials passed in.\n */\nfunction makeCredentialsProvider(credentials) {\n    if (!credentials) {\n        return new credentials_EmptyCredentialsProvider();\n    }\n    switch (credentials.type) {\n        case 'gapi':\n            return new credentials_FirstPartyCredentialsProvider(credentials.client, credentials.sessionIndex || '0');\n        case 'provider':\n            return credentials.client;\n        default:\n            throw new error_FirestoreError(Code.INVALID_ARGUMENT, 'makeCredentialsProvider failed due to invalid credential type');\n    }\n}\n\n//# sourceMappingURL=credentials.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/api/observer.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction isPartialObserver(obj) {\n    return implementsAnyMethods(obj, ['next', 'error', 'complete']);\n}\n/**\n * Returns true if obj is an object and contains at least one of the specified\n * methods.\n */\nfunction implementsAnyMethods(obj, methods) {\n    if (typeof obj !== 'object' || obj === null) {\n        return false;\n    }\n    var object = obj;\n    for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {\n        var method = methods_1[_i];\n        if (method in object && typeof object[method] === 'function') {\n            return true;\n        }\n    }\n    return false;\n}\n\n//# sourceMappingURL=observer.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/api/field_value.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * An opaque base class for FieldValue sentinel objects in our public API,\n * with public static methods for creating said sentinel objects.\n */\n// tslint:disable-next-line:class-as-namespace  We use this as a base class.\nvar FieldValueImpl = /** @class */ (function () {\n    function FieldValueImpl() {\n    }\n    FieldValueImpl.delete = function () {\n        return field_value_DeleteFieldValueImpl.instance;\n    };\n    FieldValueImpl.serverTimestamp = function () {\n        return field_value_ServerTimestampFieldValueImpl.instance;\n    };\n    FieldValueImpl.prototype.isEqual = function (other) {\n        return this === other;\n    };\n    return FieldValueImpl;\n}());\n\nvar field_value_DeleteFieldValueImpl = /** @class */ (function (_super) {\n    tslib_es6[\"__extends\"](DeleteFieldValueImpl, _super);\n    function DeleteFieldValueImpl() {\n        return _super.call(this) || this;\n    }\n    /** Singleton instance. */\n    DeleteFieldValueImpl.instance = new DeleteFieldValueImpl();\n    return DeleteFieldValueImpl;\n}(FieldValueImpl));\n\nvar field_value_ServerTimestampFieldValueImpl = /** @class */ (function (_super) {\n    tslib_es6[\"__extends\"](ServerTimestampFieldValueImpl, _super);\n    function ServerTimestampFieldValueImpl() {\n        return _super.call(this) || this;\n    }\n    /** Singleton instance. */\n    ServerTimestampFieldValueImpl.instance = new ServerTimestampFieldValueImpl();\n    return ServerTimestampFieldValueImpl;\n}(FieldValueImpl));\n\n// Public instance that disallows construction at runtime. This constructor is\n// used when exporting FieldValueImpl on firebase.firestore.FieldValue and will\n// be called FieldValue publicly. Internally we still use FieldValueImpl which\n// has a type-checked private constructor. Note that FieldValueImpl and\n// PublicFieldValue can be used interchangeably in instanceof checks.\n// For our internal TypeScript code PublicFieldValue doesn't exist as a type,\n// and so we need to use FieldValueImpl as type and export it too.\n// tslint:disable-next-line:variable-name  We treat this as a class name.\nvar PublicFieldValue = makeConstructorPrivate(FieldValueImpl, 'Use FieldValue.<field>() instead.');\n\n//# sourceMappingURL=field_value.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/api/user_data_converter.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar RESERVED_FIELD_REGEX = /^__.*__$/;\n/** The result of parsing document data (e.g. for a setData call). */\nvar user_data_converter_ParsedSetData = /** @class */ (function () {\n    function ParsedSetData(data, fieldMask, fieldTransforms) {\n        this.data = data;\n        this.fieldMask = fieldMask;\n        this.fieldTransforms = fieldTransforms;\n    }\n    ParsedSetData.prototype.toMutations = function (key, precondition) {\n        var mutations = [];\n        if (this.fieldMask !== null) {\n            mutations.push(new mutation_PatchMutation(key, this.data, this.fieldMask, precondition));\n        }\n        else {\n            mutations.push(new mutation_SetMutation(key, this.data, precondition));\n        }\n        if (this.fieldTransforms.length > 0) {\n            mutations.push(new mutation_TransformMutation(key, this.fieldTransforms));\n        }\n        return mutations;\n    };\n    return ParsedSetData;\n}());\n\n/** The result of parsing \"update\" data (i.e. for an updateData call). */\nvar user_data_converter_ParsedUpdateData = /** @class */ (function () {\n    function ParsedUpdateData(data, fieldMask, fieldTransforms) {\n        this.data = data;\n        this.fieldMask = fieldMask;\n        this.fieldTransforms = fieldTransforms;\n    }\n    ParsedUpdateData.prototype.toMutations = function (key, precondition) {\n        var mutations = [\n            new mutation_PatchMutation(key, this.data, this.fieldMask, precondition)\n        ];\n        if (this.fieldTransforms.length > 0) {\n            mutations.push(new mutation_TransformMutation(key, this.fieldTransforms));\n        }\n        return mutations;\n    };\n    return ParsedUpdateData;\n}());\n\n/*\n * Represents what type of API method provided the data being parsed; useful\n * for determining which error conditions apply during parsing and providing\n * better error messages.\n */\nvar UserDataSource;\n(function (UserDataSource) {\n    UserDataSource[UserDataSource[\"Set\"] = 0] = \"Set\";\n    UserDataSource[UserDataSource[\"Update\"] = 1] = \"Update\";\n    UserDataSource[UserDataSource[\"MergeSet\"] = 2] = \"MergeSet\";\n    UserDataSource[UserDataSource[\"QueryValue\"] = 3] = \"QueryValue\"; // from a where clause or cursor bound\n})(UserDataSource || (UserDataSource = {}));\nfunction isWrite(dataSource) {\n    switch (dataSource) {\n        case UserDataSource.Set: // fall through\n        case UserDataSource.MergeSet: // fall through\n        case UserDataSource.Update:\n            return true;\n        case UserDataSource.QueryValue:\n            return false;\n        default:\n            throw fail(\"Unexpected case for UserDataSource: \" + dataSource);\n    }\n}\n/** A \"context\" object passed around while parsing user data. */\nvar user_data_converter_ParseContext = /** @class */ (function () {\n    /**\n     * Initializes a ParseContext with the given source and path.\n     *\n     * @param dataSource Indicates what kind of API method this data came from.\n     * @param methodName The name of the method the user called to create this\n     *     ParseContext.\n     * @param path A path within the object being parsed. This could be an empty\n     *     path (in which case the context represents the root of the data being\n     *     parsed), or a nonempty path (indicating the context represents a nested\n     *     location within the data).\n     * @param arrayElement Whether or not this context corresponds to an element\n     *     of an array.\n     * @param fieldTransforms A mutable list of field transforms encountered while\n     *     parsing the data.\n     * @param fieldMask A mutable list of field paths encountered while parsing\n     *     the data.\n     *\n     * TODO(b/34871131): We don't support array paths right now, so path can be\n     * null to indicate the context represents any location within an array (in\n     * which case certain features will not work and errors will be somewhat\n     * compromised).\n     */\n    function ParseContext(dataSource, methodName, path, arrayElement, fieldTransforms, fieldMask) {\n        this.dataSource = dataSource;\n        this.methodName = methodName;\n        this.path = path;\n        this.arrayElement = arrayElement;\n        // Minor hack: If fieldTransforms is undefined, we assume this is an\n        // external call and we need to validate the entire path.\n        if (fieldTransforms === undefined) {\n            this.validatePath();\n        }\n        this.arrayElement = arrayElement !== undefined ? arrayElement : false;\n        this.fieldTransforms = fieldTransforms || [];\n        this.fieldMask = fieldMask || [];\n    }\n    ParseContext.prototype.childContextForField = function (field) {\n        var childPath = this.path == null ? null : this.path.child(field);\n        var context = new ParseContext(this.dataSource, this.methodName, childPath, \n        /*arrayElement=*/ false, this.fieldTransforms, this.fieldMask);\n        context.validatePathSegment(field);\n        return context;\n    };\n    ParseContext.prototype.childContextForFieldPath = function (field) {\n        var childPath = this.path == null ? null : this.path.child(field);\n        var context = new ParseContext(this.dataSource, this.methodName, childPath, \n        /*arrayElement=*/ false, this.fieldTransforms, this.fieldMask);\n        context.validatePath();\n        return context;\n    };\n    ParseContext.prototype.childContextForArray = function (index) {\n        // TODO(b/34871131): We don't support array paths right now; so make path\n        // null.\n        return new ParseContext(this.dataSource, this.methodName, \n        /*path=*/ null, \n        /*arrayElement=*/ true, this.fieldTransforms, this.fieldMask);\n    };\n    ParseContext.prototype.createError = function (reason) {\n        var fieldDescription = this.path === null || this.path.isEmpty()\n            ? ''\n            : \" (found in field \" + this.path.toString() + \")\";\n        return new error_FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + this.methodName + \"() called with invalid data. \" +\n            reason +\n            fieldDescription);\n    };\n    ParseContext.prototype.validatePath = function () {\n        // TODO(b/34871131): Remove null check once we have proper paths for fields\n        // within arrays.\n        if (this.path === null) {\n            return;\n        }\n        for (var i = 0; i < this.path.length; i++) {\n            this.validatePathSegment(this.path.get(i));\n        }\n    };\n    ParseContext.prototype.validatePathSegment = function (segment) {\n        if (isWrite(this.dataSource) && RESERVED_FIELD_REGEX.test(segment)) {\n            throw this.createError('Document fields cannot begin and end with __');\n        }\n    };\n    return ParseContext;\n}());\n/**\n * A placeholder object for DocumentReferences in this file, in order to\n * avoid a circular dependency. See the comments for `DataPreConverter` for\n * the full context.\n */\nvar DocumentKeyReference = /** @class */ (function () {\n    function DocumentKeyReference(databaseId, key) {\n        this.databaseId = databaseId;\n        this.key = key;\n    }\n    return DocumentKeyReference;\n}());\n\n/**\n * Helper for parsing raw user input (provided via the API) into internal model\n * classes.\n */\nvar user_data_converter_UserDataConverter = /** @class */ (function () {\n    function UserDataConverter(preConverter) {\n        this.preConverter = preConverter;\n    }\n    /** Parse document data from a non-merge set() call. */\n    UserDataConverter.prototype.parseSetData = function (methodName, input) {\n        var context = new user_data_converter_ParseContext(UserDataSource.Set, methodName, path_FieldPath.EMPTY_PATH);\n        validatePlainObject('Data must be an object, but it was:', context, input);\n        var updateData = this.parseData(input, context);\n        return new user_data_converter_ParsedSetData(updateData, \n        /* fieldMask= */ null, context.fieldTransforms);\n    };\n    /** Parse document data from a set() call with '{merge:true}'. */\n    UserDataConverter.prototype.parseMergeData = function (methodName, input) {\n        var context = new user_data_converter_ParseContext(UserDataSource.MergeSet, methodName, path_FieldPath.EMPTY_PATH);\n        validatePlainObject('Data must be an object, but it was:', context, input);\n        var updateData = this.parseData(input, context);\n        var fieldMask = new mutation_FieldMask(context.fieldMask);\n        return new user_data_converter_ParsedSetData(updateData, fieldMask, context.fieldTransforms);\n    };\n    /** Parse update data from an update() call. */\n    UserDataConverter.prototype.parseUpdateData = function (methodName, input) {\n        var _this = this;\n        var context = new user_data_converter_ParseContext(UserDataSource.Update, methodName, path_FieldPath.EMPTY_PATH);\n        validatePlainObject('Data must be an object, but it was:', context, input);\n        var fieldMaskPaths = [];\n        var updateData = field_value_ObjectValue.EMPTY;\n        forEach(input, function (key, value) {\n            var path = fieldPathFromDotSeparatedString(methodName, key);\n            var childContext = context.childContextForFieldPath(path);\n            value = _this.runPreConverter(value, childContext);\n            if (value instanceof field_value_DeleteFieldValueImpl) {\n                // Add it to the field mask, but don't add anything to updateData.\n                fieldMaskPaths.push(path);\n            }\n            else {\n                var parsedValue = _this.parseData(value, childContext);\n                if (parsedValue != null) {\n                    fieldMaskPaths.push(path);\n                    updateData = updateData.set(path, parsedValue);\n                }\n            }\n        });\n        var mask = new mutation_FieldMask(fieldMaskPaths);\n        return new user_data_converter_ParsedUpdateData(updateData, mask, context.fieldTransforms);\n    };\n    /** Parse update data from a list of field/value arguments. */\n    UserDataConverter.prototype.parseUpdateVarargs = function (methodName, field, value, moreFieldsAndValues) {\n        var context = new user_data_converter_ParseContext(UserDataSource.Update, methodName, path_FieldPath.EMPTY_PATH);\n        var keys = [fieldPathFromArgument(methodName, field)];\n        var values = [value];\n        if (moreFieldsAndValues.length % 2 !== 0) {\n            throw new error_FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + methodName + \"() needs to be called with an even number \" +\n                'of arguments that alternate between field names and values.');\n        }\n        for (var i = 0; i < moreFieldsAndValues.length; i += 2) {\n            keys.push(fieldPathFromArgument(methodName, moreFieldsAndValues[i]));\n            values.push(moreFieldsAndValues[i + 1]);\n        }\n        var fieldMaskPaths = [];\n        var updateData = field_value_ObjectValue.EMPTY;\n        for (var i = 0; i < keys.length; ++i) {\n            var path = keys[i];\n            var childContext = context.childContextForFieldPath(path);\n            var value_1 = this.runPreConverter(values[i], childContext);\n            if (value_1 instanceof field_value_DeleteFieldValueImpl) {\n                // Add it to the field mask, but don't add anything to updateData.\n                fieldMaskPaths.push(path);\n            }\n            else {\n                var parsedValue = this.parseData(value_1, childContext);\n                if (parsedValue != null) {\n                    fieldMaskPaths.push(path);\n                    updateData = updateData.set(path, parsedValue);\n                }\n            }\n        }\n        var mask = new mutation_FieldMask(fieldMaskPaths);\n        return new user_data_converter_ParsedUpdateData(updateData, mask, context.fieldTransforms);\n    };\n    /**\n     * Parse a \"query value\" (e.g. value in a where filter or a value in a cursor\n     * bound).\n     */\n    UserDataConverter.prototype.parseQueryValue = function (methodName, input) {\n        var context = new user_data_converter_ParseContext(UserDataSource.QueryValue, methodName, path_FieldPath.EMPTY_PATH);\n        var parsed = this.parseData(input, context);\n        assert(parsed != null, 'Parsed data should not be null.');\n        assert(context.fieldTransforms.length === 0, 'Field transforms should have been disallowed.');\n        return parsed;\n    };\n    /** Sends data through this.preConverter, handling any thrown errors. */\n    UserDataConverter.prototype.runPreConverter = function (input, context) {\n        try {\n            return this.preConverter(input);\n        }\n        catch (e) {\n            var message = errorMessage(e);\n            throw context.createError(message);\n        }\n    };\n    /**\n     * Internal helper for parsing user data.\n     *\n     * @param input Data to be parsed.\n     * @param context A context object representing the current path being parsed,\n     * the source of the data being parsed, etc.\n     * @return The parsed value, or null if the value was a FieldValue sentinel\n     * that should not be included in the resulting parsed data.\n     */\n    UserDataConverter.prototype.parseData = function (input, context) {\n        input = this.runPreConverter(input, context);\n        if (input instanceof Array) {\n            // TODO(b/34871131): Include the path containing the array in the error\n            // message.\n            if (context.arrayElement) {\n                throw context.createError('Nested arrays are not supported');\n            }\n            // If context.path is null we are already inside an array and we don't\n            // support field mask paths more granular than the top-level array.\n            if (context.path) {\n                context.fieldMask.push(context.path);\n            }\n            return this.parseArray(input, context);\n        }\n        else if (looksLikeJsonObject(input)) {\n            validatePlainObject('Unsupported field value:', context, input);\n            return this.parseObject(input, context);\n        }\n        else {\n            // If context.path is null, we are inside an array and we should have\n            // already added the root of the array to the field mask.\n            if (context.path) {\n                context.fieldMask.push(context.path);\n            }\n            return this.parseScalarValue(input, context);\n        }\n    };\n    UserDataConverter.prototype.parseArray = function (array, context) {\n        var result = [];\n        var entryIndex = 0;\n        for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\n            var entry = array_1[_i];\n            var parsedEntry = this.parseData(entry, context.childContextForArray(entryIndex));\n            if (parsedEntry == null) {\n                // Just include nulls in the array for fields being replaced with a\n                // sentinel.\n                parsedEntry = field_value_NullValue.INSTANCE;\n            }\n            result.push(parsedEntry);\n            entryIndex++;\n        }\n        return new field_value_ArrayValue(result);\n    };\n    UserDataConverter.prototype.parseObject = function (obj, context) {\n        var _this = this;\n        var result = new SortedMap(primitiveComparator);\n        forEach(obj, function (key, val) {\n            var parsedValue = _this.parseData(val, context.childContextForField(key));\n            if (parsedValue != null) {\n                result = result.insert(key, parsedValue);\n            }\n        });\n        return new field_value_ObjectValue(result);\n    };\n    /**\n     * Helper to parse a scalar value (i.e. not an Object or Array)\n     *\n     * @return The parsed value, or null if the value was a FieldValue sentinel\n     * that should not be included in the resulting parsed data.\n     */\n    UserDataConverter.prototype.parseScalarValue = function (value, context) {\n        if (value === null) {\n            return field_value_NullValue.INSTANCE;\n        }\n        else if (typeof value === 'number') {\n            if (isSafeInteger(value)) {\n                return new field_value_IntegerValue(value);\n            }\n            else {\n                return new field_value_DoubleValue(value);\n            }\n        }\n        else if (typeof value === 'boolean') {\n            return field_value_BooleanValue.of(value);\n        }\n        else if (typeof value === 'string') {\n            return new field_value_StringValue(value);\n        }\n        else if (value instanceof Date) {\n            return new field_value_TimestampValue(timestamp_Timestamp.fromDate(value));\n        }\n        else if (value instanceof geo_point_GeoPoint) {\n            return new field_value_GeoPointValue(value);\n        }\n        else if (value instanceof blob_Blob) {\n            return new field_value_BlobValue(value);\n        }\n        else if (value instanceof DocumentKeyReference) {\n            return new field_value_RefValue(value.databaseId, value.key);\n        }\n        else if (value instanceof FieldValueImpl) {\n            if (value instanceof field_value_DeleteFieldValueImpl) {\n                if (context.dataSource === UserDataSource.MergeSet) {\n                    return null;\n                }\n                else if (context.dataSource === UserDataSource.Update) {\n                    assert(context.path == null || context.path.length > 0, 'FieldValue.delete() at the top level should have already' +\n                        ' been handled.');\n                    throw context.createError('FieldValue.delete() can only appear at the top level ' +\n                        'of your update data');\n                }\n                else {\n                    // We shouldn't encounter delete sentinels for queries or non-merge set() calls.\n                    throw context.createError('FieldValue.delete() can only be used with update() and set() with {merge:true}');\n                }\n            }\n            else if (value instanceof field_value_ServerTimestampFieldValueImpl) {\n                if (!isWrite(context.dataSource)) {\n                    throw context.createError('FieldValue.serverTimestamp() can only be used with set()' +\n                        ' and update()');\n                }\n                if (context.path === null) {\n                    throw context.createError('FieldValue.serverTimestamp() is not currently' +\n                        ' supported inside arrays');\n                }\n                context.fieldTransforms.push(new FieldTransform(context.path, ServerTimestampTransform.instance));\n                // Return null so this value is omitted from the parsed result.\n                return null;\n            }\n            else {\n                return fail('Unknown FieldValue type: ' + value);\n            }\n        }\n        else {\n            throw context.createError(\"Unsupported field value: \" + valueDescription(value));\n        }\n    };\n    return UserDataConverter;\n}());\n\n/**\n * Checks whether an object looks like a JSON object that should be converted\n * into a struct. Normal class/prototype instances are considered to look like\n * JSON objects since they should be converted to a struct value. Arrays, Dates,\n * GeoPoints, etc. are not considered to look like JSON objects since they map\n * to specific FieldValue types other than ObjectValue.\n */\nfunction looksLikeJsonObject(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        !(input instanceof Array) &&\n        !(input instanceof Date) &&\n        !(input instanceof geo_point_GeoPoint) &&\n        !(input instanceof blob_Blob) &&\n        !(input instanceof DocumentKeyReference) &&\n        !(input instanceof FieldValueImpl));\n}\nfunction validatePlainObject(message, context, input) {\n    if (!looksLikeJsonObject(input) || !isPlainObject(input)) {\n        var description = valueDescription(input);\n        if (description === 'an object') {\n            // Massage the error if it was an object.\n            throw context.createError(message + ' a custom object');\n        }\n        else {\n            throw context.createError(message + ' ' + description);\n        }\n    }\n}\n/**\n * Helper that calls fromDotSeparatedString() but wraps any error thrown.\n */\nfunction fieldPathFromArgument(methodName, path) {\n    if (path instanceof field_path_FieldPath) {\n        return path._internalPath;\n    }\n    else if (typeof path === 'string') {\n        return fieldPathFromDotSeparatedString(methodName, path);\n    }\n    else {\n        var message = 'Field path arguments must be of type string or FieldPath.';\n        throw new error_FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + methodName + \"() called with invalid data. \" + message);\n    }\n}\n/**\n * Wraps fromDotSeparatedString with an error message about the method that\n * was thrown.\n * @param methodName The publicly visible method name\n * @param path The dot-separated string form of a field path which will be split\n * on dots.\n */\nfunction fieldPathFromDotSeparatedString(methodName, path) {\n    try {\n        return fromDotSeparatedString(path)._internalPath;\n    }\n    catch (e) {\n        var message = errorMessage(e);\n        throw new error_FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + methodName + \"() called with invalid data. \" + message);\n    }\n}\n/**\n * Extracts the message from a caught exception, which should be an Error object\n * though JS doesn't guarantee that.\n */\nfunction errorMessage(error) {\n    return error instanceof Error ? error.message : error.toString();\n}\n\n//# sourceMappingURL=user_data_converter.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/api/database.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// The objects that are a part of this API are exposed to third-parties as\n// compiled javascript so we want to flag our private members with a leading\n// underscore to discourage their use.\n// tslint:disable:strip-private-property-underscore\nvar DEFAULT_HOST = 'firestore.googleapis.com';\nvar DEFAULT_SSL = true;\n/**\n * A concrete type describing all the values that can be applied via a\n * user-supplied firestore.Settings object. This is a separate type so that\n * defaults can be supplied and the value can be checked for equality.\n */\nvar database_FirestoreSettings = /** @class */ (function () {\n    function FirestoreSettings(settings) {\n        if (settings.host === undefined) {\n            if (settings.ssl !== undefined) {\n                throw new error_FirestoreError(Code.INVALID_ARGUMENT, \"Can't provide ssl option if host option is not set\");\n            }\n            this.host = DEFAULT_HOST;\n            this.ssl = DEFAULT_SSL;\n        }\n        else {\n            validateNamedType('settings', 'string', 'host', settings.host);\n            this.host = settings.host;\n            validateNamedOptionalType('settings', 'boolean', 'ssl', settings.ssl);\n            this.ssl = defaulted(settings.ssl, DEFAULT_SSL);\n        }\n        validateOptionNames('settings', settings, ['host', 'ssl', 'credentials']);\n        validateNamedOptionalType('settings', 'object', 'credentials', settings.credentials);\n        this.credentials = settings.credentials;\n    }\n    FirestoreSettings.prototype.isEqual = function (other) {\n        return (this.host === other.host &&\n            this.ssl === other.ssl &&\n            this.credentials === other.credentials);\n    };\n    return FirestoreSettings;\n}());\nvar FirestoreConfig = /** @class */ (function () {\n    function FirestoreConfig() {\n    }\n    return FirestoreConfig;\n}());\n/**\n * The root reference to the database.\n */\nvar database_Firestore = /** @class */ (function () {\n    function Firestore(databaseIdOrApp) {\n        var _this = this;\n        // Public for use in tests.\n        // TODO(mikelehen): Use modularized initialization instead.\n        this._queue = new async_queue_AsyncQueue();\n        this.INTERNAL = {\n            delete: function () { return tslib_es6[\"__awaiter\"](_this, void 0, void 0, function () {\n                return tslib_es6[\"__generator\"](this, function (_a) {\n                    if (this._firestoreClient) {\n                        return [2 /*return*/, this._firestoreClient.shutdown()];\n                    }\n                    return [2 /*return*/];\n                });\n            }); }\n        };\n        var config = new FirestoreConfig();\n        if (typeof databaseIdOrApp.options === 'object') {\n            // This is very likely a Firebase app object\n            // TODO(b/34177605): Can we somehow use instanceof?\n            var app = databaseIdOrApp;\n            config.firebaseApp = app;\n            config.databaseId = Firestore.databaseIdFromApp(app);\n            config.persistenceKey = config.firebaseApp.name;\n            config.credentials = new credentials_FirebaseCredentialsProvider(app);\n        }\n        else {\n            var external_1 = databaseIdOrApp;\n            if (!external_1.projectId) {\n                throw new error_FirestoreError(Code.INVALID_ARGUMENT, 'Must provide projectId');\n            }\n            config.databaseId = new database_info_DatabaseId(external_1.projectId, external_1.database);\n            // Use a default persistenceKey that lines up with FirebaseApp.\n            config.persistenceKey = '[DEFAULT]';\n            config.credentials = new credentials_EmptyCredentialsProvider();\n        }\n        config.settings = new database_FirestoreSettings({});\n        this._config = config;\n        this._databaseId = config.databaseId;\n    }\n    Firestore.prototype.settings = function (settingsLiteral) {\n        validateExactNumberOfArgs('Firestore.settings', arguments, 1);\n        validateArgType('Firestore.settings', 'object', 1, settingsLiteral);\n        if (contains(settingsLiteral, 'persistence')) {\n            throw new error_FirestoreError(Code.INVALID_ARGUMENT, '\"persistence\" is now specified with a separate call to ' +\n                'firestore.enablePersistence().');\n        }\n        var newSettings = new database_FirestoreSettings(settingsLiteral);\n        if (this._firestoreClient && !this._config.settings.isEqual(newSettings)) {\n            throw new error_FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and its settings can no longer ' +\n                'be changed. You can only call settings() before calling any other ' +\n                'methods on a Firestore object.');\n        }\n        this._config.settings = newSettings;\n        if (newSettings.credentials !== undefined) {\n            this._config.credentials = makeCredentialsProvider(newSettings.credentials);\n        }\n    };\n    Firestore.prototype.enableNetwork = function () {\n        this.ensureClientConfigured();\n        return this._firestoreClient.enableNetwork();\n    };\n    Firestore.prototype.disableNetwork = function () {\n        this.ensureClientConfigured();\n        return this._firestoreClient.disableNetwork();\n    };\n    Firestore.prototype.enablePersistence = function () {\n        if (this._firestoreClient) {\n            throw new error_FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and persistence can no longer ' +\n                'be enabled. You can only call enablePersistence() before calling ' +\n                'any other methods on a Firestore object.');\n        }\n        return this.configureClient(/* persistence= */ true);\n    };\n    Firestore.prototype.ensureClientConfigured = function () {\n        if (!this._firestoreClient) {\n            this.configureClient(/* persistence= */ false);\n        }\n        return this._firestoreClient;\n    };\n    Firestore.prototype.configureClient = function (persistence) {\n        var _this = this;\n        assert(!!this._config.settings.host, 'FirestoreSettings.host cannot be falsey');\n        assert(!this._firestoreClient, 'configureClient() called multiple times');\n        var databaseInfo = new DatabaseInfo(this._config.databaseId, this._config.persistenceKey, this._config.settings.host, this._config.settings.ssl);\n        var preConverter = function (value) {\n            if (value instanceof database_DocumentReference) {\n                var thisDb = _this._config.databaseId;\n                var otherDb = value.firestore._config.databaseId;\n                if (!otherDb.isEqual(thisDb)) {\n                    throw new error_FirestoreError(Code.INVALID_ARGUMENT, 'Document reference is for database ' +\n                        (otherDb.projectId + \"/\" + otherDb.database + \" but should be \") +\n                        (\"for database \" + thisDb.projectId + \"/\" + thisDb.database));\n                }\n                return new DocumentKeyReference(_this._config.databaseId, value._key);\n            }\n            else {\n                return value;\n            }\n        };\n        this._dataConverter = new user_data_converter_UserDataConverter(preConverter);\n        this._firestoreClient = new firestore_client_FirestoreClient(platform_PlatformSupport.getPlatform(), databaseInfo, this._config.credentials, this._queue);\n        return this._firestoreClient.start(persistence);\n    };\n    Firestore.databaseIdFromApp = function (app) {\n        var options = app.options;\n        if (!contains(options, 'projectId')) {\n            // TODO(b/62673263): We can safely remove the special handling of\n            // 'firestoreId' once alpha testers have upgraded.\n            if (contains(options, 'firestoreId')) {\n                throw new error_FirestoreError(Code.INVALID_ARGUMENT, '\"firestoreId\" is now specified as \"projectId\" in ' +\n                    'firebase.initializeApp.');\n            }\n            throw new error_FirestoreError(Code.INVALID_ARGUMENT, '\"projectId\" not provided in firebase.initializeApp.');\n        }\n        if (contains(options, 'firestoreOptions')) {\n            // TODO(b/62673263): We can safely remove the special handling of\n            // 'firestoreOptions' once alpha testers have upgraded.\n            throw new error_FirestoreError(Code.INVALID_ARGUMENT, '\"firestoreOptions\" values are now specified with ' +\n                'Firestore.settings()');\n        }\n        var projectId = options['projectId'];\n        if (!projectId || typeof projectId !== 'string') {\n            throw new error_FirestoreError(Code.INVALID_ARGUMENT, 'projectId must be a string in FirebaseApp.options');\n        }\n        return new database_info_DatabaseId(projectId);\n    };\n    Object.defineProperty(Firestore.prototype, \"app\", {\n        get: function () {\n            if (!this._config.firebaseApp) {\n                throw new error_FirestoreError(Code.FAILED_PRECONDITION, \"Firestore was not initialized using the Firebase SDK. 'app' is \" +\n                    'not available');\n            }\n            return this._config.firebaseApp;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Firestore.prototype.collection = function (pathString) {\n        validateExactNumberOfArgs('Firestore.collection', arguments, 1);\n        validateArgType('Firestore.collection', 'string', 1, pathString);\n        if (!pathString) {\n            throw new error_FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty collection path to collection()');\n        }\n        this.ensureClientConfigured();\n        return new database_CollectionReference(path_ResourcePath.fromString(pathString), this);\n    };\n    Firestore.prototype.doc = function (pathString) {\n        validateExactNumberOfArgs('Firestore.doc', arguments, 1);\n        validateArgType('Firestore.doc', 'string', 1, pathString);\n        if (!pathString) {\n            throw new error_FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty document path to doc()');\n        }\n        this.ensureClientConfigured();\n        return database_DocumentReference.forPath(path_ResourcePath.fromString(pathString), this);\n    };\n    Firestore.prototype.runTransaction = function (updateFunction) {\n        var _this = this;\n        validateExactNumberOfArgs('Firestore.runTransaction', arguments, 1);\n        validateArgType('Firestore.runTransaction', 'function', 1, updateFunction);\n        return this.ensureClientConfigured().transaction(function (transaction) {\n            return updateFunction(new database_Transaction(_this, transaction));\n        });\n    };\n    Firestore.prototype.batch = function () {\n        this.ensureClientConfigured();\n        return new database_WriteBatch(this);\n    };\n    Object.defineProperty(Firestore, \"logLevel\", {\n        get: function () {\n            switch (getLogLevel()) {\n                case LogLevel.DEBUG:\n                    return 'debug';\n                case LogLevel.ERROR:\n                    return 'error';\n                case LogLevel.SILENT:\n                    return 'silent';\n                default:\n                    return fail('Unknown log level: ' + getLogLevel());\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Firestore.setLogLevel = function (level) {\n        validateExactNumberOfArgs('Firestore.setLogLevel', arguments, 1);\n        validateArgType('Firestore.setLogLevel', 'string', 1, level);\n        switch (level) {\n            case 'debug':\n                setLogLevel(LogLevel.DEBUG);\n                break;\n            case 'error':\n                setLogLevel(LogLevel.ERROR);\n                break;\n            case 'silent':\n                setLogLevel(LogLevel.SILENT);\n                break;\n            default:\n                throw new error_FirestoreError(Code.INVALID_ARGUMENT, 'Invalid log level: ' + level);\n        }\n    };\n    return Firestore;\n}());\n\n/**\n * A reference to a transaction.\n */\nvar database_Transaction = /** @class */ (function () {\n    function Transaction(_firestore, _transaction) {\n        this._firestore = _firestore;\n        this._transaction = _transaction;\n    }\n    Transaction.prototype.get = function (documentRef) {\n        var _this = this;\n        validateExactNumberOfArgs('Transaction.get', arguments, 1);\n        var ref = validateReference('Transaction.get', documentRef, this._firestore);\n        return this._transaction\n            .lookup([ref._key])\n            .then(function (docs) {\n            if (!docs || docs.length !== 1) {\n                return fail('Mismatch in docs returned from document lookup.');\n            }\n            var doc = docs[0];\n            if (doc instanceof document_NoDocument) {\n                return new database_DocumentSnapshot(_this._firestore, ref._key, null, false);\n            }\n            return new database_DocumentSnapshot(_this._firestore, ref._key, doc, false);\n        });\n    };\n    Transaction.prototype.set = function (documentRef, value, options) {\n        validateBetweenNumberOfArgs('Transaction.set', arguments, 2, 3);\n        var ref = validateReference('Transaction.set', documentRef, this._firestore);\n        options = validateSetOptions('Transaction.set', options);\n        var parsed = options.merge\n            ? this._firestore._dataConverter.parseMergeData('Transaction.set', value)\n            : this._firestore._dataConverter.parseSetData('Transaction.set', value);\n        this._transaction.set(ref._key, parsed);\n        return this;\n    };\n    Transaction.prototype.update = function (documentRef, fieldOrUpdateData, value) {\n        var moreFieldsAndValues = [];\n        for (var _i = 3; _i < arguments.length; _i++) {\n            moreFieldsAndValues[_i - 3] = arguments[_i];\n        }\n        var ref;\n        var parsed;\n        if (typeof fieldOrUpdateData === 'string' ||\n            fieldOrUpdateData instanceof field_path_FieldPath) {\n            validateAtLeastNumberOfArgs('Transaction.update', arguments, 3);\n            ref = validateReference('Transaction.update', documentRef, this._firestore);\n            parsed = this._firestore._dataConverter.parseUpdateVarargs('Transaction.update', fieldOrUpdateData, value, moreFieldsAndValues);\n        }\n        else {\n            validateExactNumberOfArgs('Transaction.update', arguments, 2);\n            ref = validateReference('Transaction.update', documentRef, this._firestore);\n            parsed = this._firestore._dataConverter.parseUpdateData('Transaction.update', fieldOrUpdateData);\n        }\n        this._transaction.update(ref._key, parsed);\n        return this;\n    };\n    Transaction.prototype.delete = function (documentRef) {\n        validateExactNumberOfArgs('Transaction.delete', arguments, 1);\n        var ref = validateReference('Transaction.delete', documentRef, this._firestore);\n        this._transaction.delete(ref._key);\n        return this;\n    };\n    return Transaction;\n}());\n\nvar database_WriteBatch = /** @class */ (function () {\n    function WriteBatch(_firestore) {\n        this._firestore = _firestore;\n        this._mutations = [];\n        this._committed = false;\n    }\n    WriteBatch.prototype.set = function (documentRef, value, options) {\n        validateBetweenNumberOfArgs('WriteBatch.set', arguments, 2, 3);\n        this.verifyNotCommitted();\n        var ref = validateReference('WriteBatch.set', documentRef, this._firestore);\n        options = validateSetOptions('WriteBatch.set', options);\n        var parsed = options.merge\n            ? this._firestore._dataConverter.parseMergeData('WriteBatch.set', value)\n            : this._firestore._dataConverter.parseSetData('WriteBatch.set', value);\n        this._mutations = this._mutations.concat(parsed.toMutations(ref._key, mutation_Precondition.NONE));\n        return this;\n    };\n    WriteBatch.prototype.update = function (documentRef, fieldOrUpdateData, value) {\n        var moreFieldsAndValues = [];\n        for (var _i = 3; _i < arguments.length; _i++) {\n            moreFieldsAndValues[_i - 3] = arguments[_i];\n        }\n        this.verifyNotCommitted();\n        var ref;\n        var parsed;\n        if (typeof fieldOrUpdateData === 'string' ||\n            fieldOrUpdateData instanceof field_path_FieldPath) {\n            validateAtLeastNumberOfArgs('WriteBatch.update', arguments, 3);\n            ref = validateReference('WriteBatch.update', documentRef, this._firestore);\n            parsed = this._firestore._dataConverter.parseUpdateVarargs('WriteBatch.update', fieldOrUpdateData, value, moreFieldsAndValues);\n        }\n        else {\n            validateExactNumberOfArgs('WriteBatch.update', arguments, 2);\n            ref = validateReference('WriteBatch.update', documentRef, this._firestore);\n            parsed = this._firestore._dataConverter.parseUpdateData('WriteBatch.update', fieldOrUpdateData);\n        }\n        this._mutations = this._mutations.concat(parsed.toMutations(ref._key, mutation_Precondition.exists(true)));\n        return this;\n    };\n    WriteBatch.prototype.delete = function (documentRef) {\n        validateExactNumberOfArgs('WriteBatch.delete', arguments, 1);\n        this.verifyNotCommitted();\n        var ref = validateReference('WriteBatch.delete', documentRef, this._firestore);\n        this._mutations = this._mutations.concat(new mutation_DeleteMutation(ref._key, mutation_Precondition.NONE));\n        return this;\n    };\n    WriteBatch.prototype.commit = function () {\n        return tslib_es6[\"__awaiter\"](this, void 0, void 0, function () {\n            return tslib_es6[\"__generator\"](this, function (_a) {\n                this.verifyNotCommitted();\n                this._committed = true;\n                if (this._mutations.length > 0) {\n                    return [2 /*return*/, this._firestore.ensureClientConfigured().write(this._mutations)];\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    WriteBatch.prototype.verifyNotCommitted = function () {\n        if (this._committed) {\n            throw new error_FirestoreError(Code.FAILED_PRECONDITION, 'A write batch can no longer be used after commit() ' +\n                'has been called.');\n        }\n    };\n    return WriteBatch;\n}());\n\n/**\n * A reference to a particular document in a collection in the database.\n */\nvar database_DocumentReference = /** @class */ (function () {\n    function DocumentReference(_key, firestore) {\n        this._key = _key;\n        this.firestore = firestore;\n        this._firestoreClient = this.firestore.ensureClientConfigured();\n    }\n    DocumentReference.forPath = function (path, firestore) {\n        if (path.length % 2 !== 0) {\n            throw new error_FirestoreError(Code.INVALID_ARGUMENT, 'Invalid document reference. Document ' +\n                'references must have an even number of segments, but ' +\n                (path.canonicalString() + \" has \" + path.length));\n        }\n        return new DocumentReference(new document_key_DocumentKey(path), firestore);\n    };\n    Object.defineProperty(DocumentReference.prototype, \"id\", {\n        get: function () {\n            return this._key.path.lastSegment();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentReference.prototype, \"parent\", {\n        get: function () {\n            return new database_CollectionReference(this._key.path.popLast(), this.firestore);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentReference.prototype, \"path\", {\n        get: function () {\n            return this._key.path.canonicalString();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DocumentReference.prototype.collection = function (pathString) {\n        validateExactNumberOfArgs('DocumentReference.collection', arguments, 1);\n        validateArgType('DocumentReference.collection', 'string', 1, pathString);\n        if (!pathString) {\n            throw new error_FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty collection name to collection()');\n        }\n        var path = path_ResourcePath.fromString(pathString);\n        return new database_CollectionReference(this._key.path.child(path), this.firestore);\n    };\n    DocumentReference.prototype.isEqual = function (other) {\n        if (!(other instanceof DocumentReference)) {\n            throw invalidClassError('isEqual', 'DocumentReference', 1, other);\n        }\n        return this.firestore === other.firestore && this._key.isEqual(other._key);\n    };\n    DocumentReference.prototype.set = function (value, options) {\n        validateBetweenNumberOfArgs('DocumentReference.set', arguments, 1, 2);\n        options = validateSetOptions('DocumentReference.set', options);\n        var parsed = options.merge\n            ? this.firestore._dataConverter.parseMergeData('DocumentReference.set', value)\n            : this.firestore._dataConverter.parseSetData('DocumentReference.set', value);\n        return this._firestoreClient.write(parsed.toMutations(this._key, mutation_Precondition.NONE));\n    };\n    DocumentReference.prototype.update = function (fieldOrUpdateData, value) {\n        var moreFieldsAndValues = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            moreFieldsAndValues[_i - 2] = arguments[_i];\n        }\n        var parsed;\n        if (typeof fieldOrUpdateData === 'string' ||\n            fieldOrUpdateData instanceof field_path_FieldPath) {\n            validateAtLeastNumberOfArgs('DocumentReference.update', arguments, 2);\n            parsed = this.firestore._dataConverter.parseUpdateVarargs('DocumentReference.update', fieldOrUpdateData, value, moreFieldsAndValues);\n        }\n        else {\n            validateExactNumberOfArgs('DocumentReference.update', arguments, 1);\n            parsed = this.firestore._dataConverter.parseUpdateData('DocumentReference.update', fieldOrUpdateData);\n        }\n        return this._firestoreClient.write(parsed.toMutations(this._key, mutation_Precondition.exists(true)));\n    };\n    DocumentReference.prototype.delete = function () {\n        validateExactNumberOfArgs('DocumentReference.delete', arguments, 0);\n        return this._firestoreClient.write([\n            new mutation_DeleteMutation(this._key, mutation_Precondition.NONE)\n        ]);\n    };\n    DocumentReference.prototype.onSnapshot = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        validateBetweenNumberOfArgs('DocumentReference.onSnapshot', arguments, 1, 4);\n        var options = {\n            includeMetadataChanges: false\n        };\n        var observer;\n        var currArg = 0;\n        if (typeof args[currArg] === 'object' &&\n            !isPartialObserver(args[currArg])) {\n            options = args[currArg];\n            validateOptionNames('DocumentReference.onSnapshot', options, [\n                'includeMetadataChanges'\n            ]);\n            validateNamedOptionalType('DocumentReference.onSnapshot', 'boolean', 'includeMetadataChanges', options.includeMetadataChanges);\n            currArg++;\n        }\n        var internalOptions = {\n            includeDocumentMetadataChanges: options.includeMetadataChanges,\n            includeQueryMetadataChanges: options.includeMetadataChanges\n        };\n        if (isPartialObserver(args[currArg])) {\n            observer = args[currArg];\n        }\n        else {\n            validateArgType('DocumentReference.onSnapshot', 'function', currArg, args[currArg]);\n            validateOptionalArgType('DocumentReference.onSnapshot', 'function', currArg + 1, args[currArg + 1]);\n            validateOptionalArgType('DocumentReference.onSnapshot', 'function', currArg + 2, args[currArg + 2]);\n            observer = {\n                next: args[currArg],\n                error: args[currArg + 1],\n                complete: args[currArg + 2]\n            };\n        }\n        return this.onSnapshotInternal(internalOptions, observer);\n    };\n    DocumentReference.prototype.onSnapshotInternal = function (options, observer) {\n        var _this = this;\n        var errHandler = function (err) {\n            console.error('Uncaught Error in onSnapshot:', err);\n        };\n        if (observer.error) {\n            errHandler = observer.error.bind(observer);\n        }\n        var asyncObserver = new AsyncObserver({\n            next: function (snapshot) {\n                if (observer.next) {\n                    assert(snapshot.docs.size <= 1, 'Too many documents returned on a document query');\n                    var doc = snapshot.docs.get(_this._key);\n                    observer.next(new database_DocumentSnapshot(_this.firestore, _this._key, doc, snapshot.fromCache));\n                }\n            },\n            error: errHandler\n        });\n        var internalListener = this._firestoreClient.listen(query_Query.atPath(this._key.path), asyncObserver, options);\n        return function () {\n            asyncObserver.mute();\n            _this._firestoreClient.unlisten(internalListener);\n        };\n    };\n    DocumentReference.prototype.get = function () {\n        var _this = this;\n        validateExactNumberOfArgs('DocumentReference.get', arguments, 0);\n        return new Promise(function (resolve, reject) {\n            var unlisten = _this.onSnapshotInternal({\n                includeQueryMetadataChanges: true,\n                includeDocumentMetadataChanges: true,\n                waitForSyncWhenOnline: true\n            }, {\n                next: function (snap) {\n                    // Remove query first before passing event to user to avoid\n                    // user actions affecting the now stale query.\n                    unlisten();\n                    if (!snap.exists && snap.metadata.fromCache) {\n                        // TODO(dimond): If we're online and the document doesn't\n                        // exist then we resolve with a doc.exists set to false. If\n                        // we're offline however, we reject the Promise in this\n                        // case. Two options: 1) Cache the negative response from\n                        // the server so we can deliver that even when you're\n                        // offline 2) Actually reject the Promise in the online case\n                        // if the document doesn't exist.\n                        reject(new error_FirestoreError(Code.ABORTED, 'Failed to get document because the client is ' + 'offline.'));\n                    }\n                    else {\n                        resolve(snap);\n                    }\n                },\n                error: reject\n            });\n        });\n    };\n    return DocumentReference;\n}());\n\nvar SnapshotMetadata = /** @class */ (function () {\n    function SnapshotMetadata(hasPendingWrites, fromCache) {\n        this.hasPendingWrites = hasPendingWrites;\n        this.fromCache = fromCache;\n    }\n    SnapshotMetadata.prototype.isEqual = function (other) {\n        return (this.hasPendingWrites === other.hasPendingWrites &&\n            this.fromCache === other.fromCache);\n    };\n    return SnapshotMetadata;\n}());\nvar database_DocumentSnapshot = /** @class */ (function () {\n    function DocumentSnapshot(_firestore, _key, _document, _fromCache) {\n        this._firestore = _firestore;\n        this._key = _key;\n        this._document = _document;\n        this._fromCache = _fromCache;\n    }\n    DocumentSnapshot.prototype.data = function (options) {\n        validateBetweenNumberOfArgs('DocumentSnapshot.data', arguments, 0, 1);\n        options = validateSnapshotOptions('DocumentSnapshot.data', options);\n        return !this._document\n            ? undefined\n            : this.convertObject(this._document.data, field_value_FieldValueOptions.fromSnapshotOptions(options));\n    };\n    DocumentSnapshot.prototype.get = function (fieldPath, options) {\n        validateBetweenNumberOfArgs('DocumentSnapshot.get', arguments, 1, 2);\n        options = validateSnapshotOptions('DocumentSnapshot.get', options);\n        if (this._document) {\n            var value = this._document.data.field(fieldPathFromArgument('DocumentSnapshot.get', fieldPath));\n            if (value !== undefined) {\n                return this.convertValue(value, field_value_FieldValueOptions.fromSnapshotOptions(options));\n            }\n        }\n        return undefined;\n    };\n    Object.defineProperty(DocumentSnapshot.prototype, \"id\", {\n        get: function () {\n            return this._key.path.lastSegment();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentSnapshot.prototype, \"ref\", {\n        get: function () {\n            return new database_DocumentReference(this._key, this._firestore);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentSnapshot.prototype, \"exists\", {\n        get: function () {\n            return this._document !== null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentSnapshot.prototype, \"metadata\", {\n        get: function () {\n            return new SnapshotMetadata(this._document !== null && this._document.hasLocalMutations, this._fromCache);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DocumentSnapshot.prototype.isEqual = function (other) {\n        if (!(other instanceof DocumentSnapshot)) {\n            throw invalidClassError('isEqual', 'DocumentSnapshot', 1, other);\n        }\n        return (this._firestore === other._firestore &&\n            this._fromCache === other._fromCache &&\n            this._key.isEqual(other._key) &&\n            (this._document === null\n                ? other._document === null\n                : this._document.isEqual(other._document)));\n    };\n    DocumentSnapshot.prototype.convertObject = function (data, options) {\n        var _this = this;\n        var result = {};\n        data.forEach(function (key, value) {\n            result[key] = _this.convertValue(value, options);\n        });\n        return result;\n    };\n    DocumentSnapshot.prototype.convertValue = function (value, options) {\n        if (value instanceof field_value_ObjectValue) {\n            return this.convertObject(value, options);\n        }\n        else if (value instanceof field_value_ArrayValue) {\n            return this.convertArray(value, options);\n        }\n        else if (value instanceof field_value_RefValue) {\n            var key = value.value(options);\n            var database = this._firestore.ensureClientConfigured().databaseId();\n            if (!value.databaseId.isEqual(database)) {\n                // TODO(b/64130202): Somehow support foreign references.\n                log_error(\"Document \" + this._key.path + \" contains a document \" +\n                    \"reference within a different database (\" +\n                    (value.databaseId.projectId + \"/\" + value.databaseId.database + \") which is not \") +\n                    \"supported. It will be treated as a reference in the current \" +\n                    (\"database (\" + database.projectId + \"/\" + database.database + \") \") +\n                    \"instead.\");\n            }\n            return new database_DocumentReference(key, this._firestore);\n        }\n        else {\n            return value.value(options);\n        }\n    };\n    DocumentSnapshot.prototype.convertArray = function (data, options) {\n        var _this = this;\n        return data.internalValue.map(function (value) {\n            return _this.convertValue(value, options);\n        });\n    };\n    return DocumentSnapshot;\n}());\n\nvar database_QueryDocumentSnapshot = /** @class */ (function (_super) {\n    tslib_es6[\"__extends\"](QueryDocumentSnapshot, _super);\n    function QueryDocumentSnapshot(firestore, key, document, fromCache) {\n        return _super.call(this, firestore, key, document, fromCache) || this;\n    }\n    QueryDocumentSnapshot.prototype.data = function (options) {\n        var data = _super.prototype.data.call(this, options);\n        assert(typeof data === 'object', 'Document in a QueryDocumentSnapshot should exist');\n        return data;\n    };\n    return QueryDocumentSnapshot;\n}(database_DocumentSnapshot));\n\nvar database_Query = /** @class */ (function () {\n    function Query(_query, firestore) {\n        this._query = _query;\n        this.firestore = firestore;\n    }\n    Query.prototype.where = function (field, opStr, value) {\n        validateExactNumberOfArgs('Query.where', arguments, 3);\n        validateArgType('Query.where', 'string', 2, opStr);\n        validateDefined('Query.where', 3, value);\n        var fieldValue;\n        var fieldPath = fieldPathFromArgument('Query.where', field);\n        if (fieldPath.isKeyField()) {\n            if (typeof value === 'string') {\n                if (value.indexOf('/') !== -1) {\n                    // TODO(dimond): Allow slashes once ancestor queries are supported\n                    throw new error_FirestoreError(Code.INVALID_ARGUMENT, 'Function Query.where() requires its third parameter to be a ' +\n                        'valid document ID if the first parameter is ' +\n                        'FieldPath.documentId(), but it contains a slash.');\n                }\n                if (value === '') {\n                    throw new error_FirestoreError(Code.INVALID_ARGUMENT, 'Function Query.where() requires its third parameter to be a ' +\n                        'valid document ID if the first parameter is ' +\n                        'FieldPath.documentId(), but it was an empty string.');\n                }\n                var path = this._query.path.child(new path_ResourcePath([value]));\n                assert(path.length % 2 === 0, 'Path should be a document key');\n                fieldValue = new field_value_RefValue(this.firestore._databaseId, new document_key_DocumentKey(path));\n            }\n            else if (value instanceof database_DocumentReference) {\n                var ref = value;\n                fieldValue = new field_value_RefValue(this.firestore._databaseId, ref._key);\n            }\n            else {\n                throw new error_FirestoreError(Code.INVALID_ARGUMENT, \"Function Query.where() requires its third parameter to be a \" +\n                    \"string or a DocumentReference if the first parameter is \" +\n                    \"FieldPath.documentId(), but it was: \" +\n                    (valueDescription(value) + \".\"));\n            }\n        }\n        else {\n            fieldValue = this.firestore._dataConverter.parseQueryValue('Query.where', value);\n        }\n        var filter = fieldFilter(fieldPath, query_RelationOp.fromString(opStr), fieldValue);\n        this.validateNewFilter(filter);\n        return new Query(this._query.addFilter(filter), this.firestore);\n    };\n    Query.prototype.orderBy = function (field, directionStr) {\n        validateBetweenNumberOfArgs('Query.orderBy', arguments, 1, 2);\n        validateOptionalArgType('Query.orderBy', 'string', 2, directionStr);\n        var direction;\n        if (directionStr === undefined || directionStr === 'asc') {\n            direction = Direction.ASCENDING;\n        }\n        else if (directionStr === 'desc') {\n            direction = Direction.DESCENDING;\n        }\n        else {\n            throw new error_FirestoreError(Code.INVALID_ARGUMENT, \"Function Query.orderBy() has unknown direction '\" + directionStr + \"', \" +\n                \"expected 'asc' or 'desc'.\");\n        }\n        if (this._query.startAt !== null) {\n            throw new error_FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call Query.startAt() or ' +\n                'Query.startAfter() before calling Query.orderBy().');\n        }\n        if (this._query.endAt !== null) {\n            throw new error_FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call Query.endAt() or ' +\n                'Query.endBefore() before calling Query.orderBy().');\n        }\n        var fieldPath = fieldPathFromArgument('Query.orderBy', field);\n        var orderBy = new query_OrderBy(fieldPath, direction);\n        this.validateNewOrderBy(orderBy);\n        return new Query(this._query.addOrderBy(orderBy), this.firestore);\n    };\n    Query.prototype.limit = function (n) {\n        validateExactNumberOfArgs('Query.limit', arguments, 1);\n        validateArgType('Query.limit', 'number', 1, n);\n        if (n <= 0) {\n            throw new error_FirestoreError(Code.INVALID_ARGUMENT, \"Invalid Query. Query limit (\" + n + \") is invalid. Limit must be \" +\n                'positive.');\n        }\n        return new Query(this._query.withLimit(n), this.firestore);\n    };\n    Query.prototype.startAt = function (docOrField) {\n        var fields = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            fields[_i - 1] = arguments[_i];\n        }\n        validateAtLeastNumberOfArgs('Query.startAt', arguments, 1);\n        var bound = this.boundFromDocOrFields('Query.startAt', docOrField, fields, \n        /*before=*/ true);\n        return new Query(this._query.withStartAt(bound), this.firestore);\n    };\n    Query.prototype.startAfter = function (docOrField) {\n        var fields = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            fields[_i - 1] = arguments[_i];\n        }\n        validateAtLeastNumberOfArgs('Query.startAfter', arguments, 1);\n        var bound = this.boundFromDocOrFields('Query.startAfter', docOrField, fields, \n        /*before=*/ false);\n        return new Query(this._query.withStartAt(bound), this.firestore);\n    };\n    Query.prototype.endBefore = function (docOrField) {\n        var fields = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            fields[_i - 1] = arguments[_i];\n        }\n        validateAtLeastNumberOfArgs('Query.endBefore', arguments, 1);\n        var bound = this.boundFromDocOrFields('Query.endBefore', docOrField, fields, \n        /*before=*/ true);\n        return new Query(this._query.withEndAt(bound), this.firestore);\n    };\n    Query.prototype.endAt = function (docOrField) {\n        var fields = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            fields[_i - 1] = arguments[_i];\n        }\n        validateAtLeastNumberOfArgs('Query.endAt', arguments, 1);\n        var bound = this.boundFromDocOrFields('Query.endAt', docOrField, fields, \n        /*before=*/ false);\n        return new Query(this._query.withEndAt(bound), this.firestore);\n    };\n    Query.prototype.isEqual = function (other) {\n        if (!(other instanceof Query)) {\n            throw invalidClassError('isEqual', 'Query', 1, other);\n        }\n        return (this.firestore === other.firestore && this._query.isEqual(other._query));\n    };\n    /** Helper function to create a bound from a document or fields */\n    Query.prototype.boundFromDocOrFields = function (methodName, docOrField, fields, before) {\n        validateDefined(methodName, 1, docOrField);\n        if (docOrField instanceof database_DocumentSnapshot) {\n            if (fields.length > 0) {\n                throw new error_FirestoreError(Code.INVALID_ARGUMENT, \"Too many arguments provided to \" + methodName + \"().\");\n            }\n            var snap = docOrField;\n            if (!snap.exists) {\n                throw new error_FirestoreError(Code.NOT_FOUND, \"Can't use a DocumentSnapshot that doesn't exist for \" +\n                    (methodName + \"().\"));\n            }\n            return this.boundFromDocument(methodName, snap._document, before);\n        }\n        else {\n            var allFields = [docOrField].concat(fields);\n            return this.boundFromFields(methodName, allFields, before);\n        }\n    };\n    /**\n     * Create a Bound from a query and a document.\n     *\n     * Note that the Bound will always include the key of the document\n     * and so only the provided document will compare equal to the returned\n     * position.\n     *\n     * Will throw if the document does not contain all fields of the order by\n     * of the query.\n     */\n    Query.prototype.boundFromDocument = function (methodName, doc, before) {\n        var components = [];\n        // Because people expect to continue/end a query at the exact document\n        // provided, we need to use the implicit sort order rather than the explicit\n        // sort order, because it's guaranteed to contain the document key. That way\n        // the position becomes unambiguous and the query continues/ends exactly at\n        // the provided document. Without the key (by using the explicit sort\n        // orders), multiple documents could match the position, yielding duplicate\n        // results.\n        for (var _i = 0, _a = this._query.orderBy; _i < _a.length; _i++) {\n            var orderBy = _a[_i];\n            if (orderBy.field.isKeyField()) {\n                components.push(new field_value_RefValue(this.firestore._databaseId, doc.key));\n            }\n            else {\n                var value = doc.field(orderBy.field);\n                if (value !== undefined) {\n                    components.push(value);\n                }\n                else {\n                    var field = orderBy.field.canonicalString();\n                    throw new error_FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. You are trying to start or end a query using a \" +\n                        (\"document for which the field '\" + field + \"' (used as the \") +\n                        \"orderBy) does not exist.\");\n                }\n            }\n        }\n        return new query_Bound(components, before);\n    };\n    /**\n     * Converts a list of field values to a Bound for the given query.\n     */\n    Query.prototype.boundFromFields = function (methodName, values, before) {\n        // Use explicit order by's because it has to match the query the user made\n        var orderBy = this._query.explicitOrderBy;\n        if (values.length > orderBy.length) {\n            throw new error_FirestoreError(Code.INVALID_ARGUMENT, \"Too many arguments provided to \" + methodName + \"(). \" +\n                \"The number of arguments must be less than or equal to the \" +\n                \"number of Query.orderBy() clauses\");\n        }\n        var components = [];\n        for (var i = 0; i < values.length; i++) {\n            var rawValue = values[i];\n            var orderByComponent = orderBy[i];\n            if (orderByComponent.field.isKeyField()) {\n                if (typeof rawValue !== 'string') {\n                    throw new error_FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. Expected a string for document ID in \" +\n                        (methodName + \"(), but got a \" + typeof rawValue));\n                }\n                if (rawValue.indexOf('/') !== -1) {\n                    throw new error_FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. Document ID '\" + rawValue + \"' contains a slash in \" +\n                        (methodName + \"()\"));\n                }\n                var key = new document_key_DocumentKey(this._query.path.child(rawValue));\n                components.push(new field_value_RefValue(this.firestore._databaseId, key));\n            }\n            else {\n                var wrapped = this.firestore._dataConverter.parseQueryValue(methodName, rawValue);\n                components.push(wrapped);\n            }\n        }\n        return new query_Bound(components, before);\n    };\n    Query.prototype.onSnapshot = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        validateBetweenNumberOfArgs('Query.onSnapshot', arguments, 1, 4);\n        var options = {};\n        var observer;\n        var currArg = 0;\n        if (typeof args[currArg] === 'object' &&\n            !isPartialObserver(args[currArg])) {\n            options = args[currArg];\n            validateOptionNames('Query.onSnapshot', options, [\n                'includeQueryMetadataChanges',\n                'includeDocumentMetadataChanges'\n            ]);\n            validateNamedOptionalType('Query.onSnapshot', 'boolean', 'includeDocumentMetadataChanges', options.includeDocumentMetadataChanges);\n            validateNamedOptionalType('Query.onSnapshot', 'boolean', 'includeQueryMetadataChanges', options.includeQueryMetadataChanges);\n            currArg++;\n        }\n        if (isPartialObserver(args[currArg])) {\n            observer = args[currArg];\n        }\n        else {\n            validateArgType('Query.onSnapshot', 'function', currArg, args[currArg]);\n            validateOptionalArgType('Query.onSnapshot', 'function', currArg + 1, args[currArg + 1]);\n            validateOptionalArgType('Query.onSnapshot', 'function', currArg + 2, args[currArg + 2]);\n            observer = {\n                next: args[currArg],\n                error: args[currArg + 1],\n                complete: args[currArg + 2]\n            };\n        }\n        return this.onSnapshotInternal(options, observer);\n    };\n    Query.prototype.onSnapshotInternal = function (options, observer) {\n        var _this = this;\n        var errHandler = function (err) {\n            console.error('Uncaught Error in onSnapshot:', err);\n        };\n        if (observer.error) {\n            errHandler = observer.error.bind(observer);\n        }\n        var asyncObserver = new AsyncObserver({\n            next: function (result) {\n                if (observer.next) {\n                    observer.next(new database_QuerySnapshot(_this.firestore, _this._query, result));\n                }\n            },\n            error: errHandler\n        });\n        var firestoreClient = this.firestore.ensureClientConfigured();\n        var internalListener = firestoreClient.listen(this._query, asyncObserver, options);\n        return function () {\n            asyncObserver.mute();\n            firestoreClient.unlisten(internalListener);\n        };\n    };\n    Query.prototype.get = function () {\n        var _this = this;\n        validateExactNumberOfArgs('Query.get', arguments, 0);\n        return new Promise(function (resolve, reject) {\n            var unlisten = _this.onSnapshotInternal({\n                includeDocumentMetadataChanges: false,\n                includeQueryMetadataChanges: true,\n                waitForSyncWhenOnline: true\n            }, {\n                next: function (result) {\n                    // Remove query first before passing event to user to avoid\n                    // user actions affecting the now stale query.\n                    unlisten();\n                    resolve(result);\n                },\n                error: reject\n            });\n        });\n    };\n    Query.prototype.validateNewFilter = function (filter) {\n        if (filter instanceof query_RelationFilter && filter.isInequality()) {\n            var existingField = this._query.getInequalityFilterField();\n            if (existingField !== null && !existingField.isEqual(filter.field)) {\n                throw new error_FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. All where filters with an inequality' +\n                    ' (<, <=, >, or >=) must be on the same field. But you have' +\n                    (\" inequality filters on '\" + existingField.toString() + \"'\") +\n                    (\" and '\" + filter.field.toString() + \"'\"));\n            }\n            var firstOrderByField = this._query.getFirstOrderByField();\n            if (firstOrderByField !== null) {\n                this.validateOrderByAndInequalityMatch(filter.field, firstOrderByField);\n            }\n        }\n    };\n    Query.prototype.validateNewOrderBy = function (orderBy) {\n        if (this._query.getFirstOrderByField() === null) {\n            // This is the first order by. It must match any inequality.\n            var inequalityField = this._query.getInequalityFilterField();\n            if (inequalityField !== null) {\n                this.validateOrderByAndInequalityMatch(inequalityField, orderBy.field);\n            }\n        }\n    };\n    Query.prototype.validateOrderByAndInequalityMatch = function (inequality, orderBy) {\n        if (!orderBy.isEqual(inequality)) {\n            throw new error_FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. You have a where filter with an inequality \" +\n                (\"(<, <=, >, or >=) on field '\" + inequality.toString() + \"' \") +\n                (\"and so you must also use '\" + inequality.toString() + \"' \") +\n                \"as your first Query.orderBy(), but your first Query.orderBy() \" +\n                (\"is on field '\" + orderBy.toString() + \"' instead.\"));\n        }\n    };\n    return Query;\n}());\n\nvar database_QuerySnapshot = /** @class */ (function () {\n    function QuerySnapshot(_firestore, _originalQuery, _snapshot) {\n        this._firestore = _firestore;\n        this._originalQuery = _originalQuery;\n        this._snapshot = _snapshot;\n        this._cachedChanges = null;\n        this.metadata = new SnapshotMetadata(_snapshot.hasPendingWrites, _snapshot.fromCache);\n    }\n    Object.defineProperty(QuerySnapshot.prototype, \"docs\", {\n        get: function () {\n            var result = [];\n            this.forEach(function (doc) { return result.push(doc); });\n            return result;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(QuerySnapshot.prototype, \"empty\", {\n        get: function () {\n            return this._snapshot.docs.isEmpty();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(QuerySnapshot.prototype, \"size\", {\n        get: function () {\n            return this._snapshot.docs.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    QuerySnapshot.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        validateBetweenNumberOfArgs('QuerySnapshot.forEach', arguments, 1, 2);\n        validateArgType('QuerySnapshot.forEach', 'function', 1, callback);\n        this._snapshot.docs.forEach(function (doc) {\n            callback.call(thisArg, _this.convertToDocumentImpl(doc));\n        });\n    };\n    Object.defineProperty(QuerySnapshot.prototype, \"query\", {\n        get: function () {\n            return new database_Query(this._originalQuery, this._firestore);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(QuerySnapshot.prototype, \"docChanges\", {\n        get: function () {\n            if (!this._cachedChanges) {\n                this._cachedChanges = changesFromSnapshot(this._firestore, this._snapshot);\n            }\n            return this._cachedChanges;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Check the equality. The call can be very expensive. */\n    QuerySnapshot.prototype.isEqual = function (other) {\n        if (!(other instanceof QuerySnapshot)) {\n            throw invalidClassError('isEqual', 'QuerySnapshot', 1, other);\n        }\n        return (this._firestore === other._firestore &&\n            this._originalQuery.isEqual(other._originalQuery) &&\n            this._snapshot.isEqual(other._snapshot));\n    };\n    QuerySnapshot.prototype.convertToDocumentImpl = function (doc) {\n        return new database_QueryDocumentSnapshot(this._firestore, doc.key, doc, this.metadata.fromCache);\n    };\n    return QuerySnapshot;\n}());\n\nvar database_CollectionReference = /** @class */ (function (_super) {\n    tslib_es6[\"__extends\"](CollectionReference, _super);\n    function CollectionReference(path, firestore) {\n        var _this = _super.call(this, query_Query.atPath(path), firestore) || this;\n        if (path.length % 2 !== 1) {\n            throw new error_FirestoreError(Code.INVALID_ARGUMENT, 'Invalid collection reference. Collection ' +\n                'references must have an odd number of segments, but ' +\n                (path.canonicalString() + \" has \" + path.length));\n        }\n        return _this;\n    }\n    Object.defineProperty(CollectionReference.prototype, \"id\", {\n        get: function () {\n            return this._query.path.lastSegment();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CollectionReference.prototype, \"parent\", {\n        get: function () {\n            var parentPath = this._query.path.popLast();\n            if (parentPath.isEmpty()) {\n                return null;\n            }\n            else {\n                return new database_DocumentReference(new document_key_DocumentKey(parentPath), this.firestore);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CollectionReference.prototype, \"path\", {\n        get: function () {\n            return this._query.path.canonicalString();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CollectionReference.prototype.doc = function (pathString) {\n        validateBetweenNumberOfArgs('CollectionReference.doc', arguments, 0, 1);\n        // We allow omission of 'pathString' but explicitly prohibit passing in both\n        // 'undefined' and 'null'.\n        if (arguments.length === 0) {\n            pathString = misc_AutoId.newId();\n        }\n        validateArgType('CollectionReference.doc', 'string', 1, pathString);\n        if (pathString === '') {\n            throw new error_FirestoreError(Code.INVALID_ARGUMENT, 'Document path must be a non-empty string');\n        }\n        var path = path_ResourcePath.fromString(pathString);\n        return database_DocumentReference.forPath(this._query.path.child(path), this.firestore);\n    };\n    CollectionReference.prototype.add = function (value) {\n        validateExactNumberOfArgs('CollectionReference.add', arguments, 1);\n        validateArgType('CollectionReference.add', 'object', 1, value);\n        var docRef = this.doc();\n        return docRef.set(value).then(function () { return docRef; });\n    };\n    return CollectionReference;\n}(database_Query));\n\nfunction validateSetOptions(methodName, options) {\n    if (options === undefined) {\n        return {\n            merge: false\n        };\n    }\n    validateOptionNames(methodName, options, ['merge']);\n    validateNamedOptionalType(methodName, 'boolean', 'merge', options.merge);\n    return options;\n}\nfunction validateSnapshotOptions(methodName, options) {\n    if (options === undefined) {\n        return {};\n    }\n    validateOptionNames(methodName, options, ['serverTimestamps']);\n    validateNamedOptionalPropertyEquals(methodName, 'options', 'serverTimestamps', options.serverTimestamps, ['estimate', 'previous', 'none']);\n    return options;\n}\nfunction validateReference(methodName, documentRef, firestore) {\n    if (!(documentRef instanceof database_DocumentReference)) {\n        throw invalidClassError(methodName, 'DocumentReference', 1, documentRef);\n    }\n    else if (documentRef.firestore !== firestore) {\n        throw new error_FirestoreError(Code.INVALID_ARGUMENT, 'Provided document reference is from a different Firestore instance.');\n    }\n    else {\n        return documentRef;\n    }\n}\n/**\n * Calculates the array of firestore.DocumentChange's for a given ViewSnapshot.\n *\n * Exported for testing.\n */\nfunction changesFromSnapshot(firestore, snapshot) {\n    if (snapshot.oldDocs.isEmpty()) {\n        // Special case the first snapshot because index calculation is easy and\n        // fast\n        var lastDoc_1;\n        var index_1 = 0;\n        return snapshot.docChanges.map(function (change) {\n            var doc = new database_QueryDocumentSnapshot(firestore, change.doc.key, change.doc, snapshot.fromCache);\n            assert(change.type === ChangeType.Added, 'Invalid event type for first snapshot');\n            assert(!lastDoc_1 || snapshot.query.docComparator(lastDoc_1, change.doc) < 0, 'Got added events in wrong order');\n            lastDoc_1 = change.doc;\n            return {\n                type: 'added',\n                doc: doc,\n                oldIndex: -1,\n                newIndex: index_1++\n            };\n        });\n    }\n    else {\n        // A DocumentSet that is updated incrementally as changes are applied to use\n        // to lookup the index of a document.\n        var indexTracker_1 = snapshot.oldDocs;\n        return snapshot.docChanges.map(function (change) {\n            var doc = new database_QueryDocumentSnapshot(firestore, change.doc.key, change.doc, snapshot.fromCache);\n            var oldIndex = -1;\n            var newIndex = -1;\n            if (change.type !== ChangeType.Added) {\n                oldIndex = indexTracker_1.indexOf(change.doc.key);\n                assert(oldIndex >= 0, 'Index for document not found');\n                indexTracker_1 = indexTracker_1.delete(change.doc.key);\n            }\n            if (change.type !== ChangeType.Removed) {\n                indexTracker_1 = indexTracker_1.add(change.doc);\n                newIndex = indexTracker_1.indexOf(change.doc.key);\n            }\n            return { type: resultChangeType(change.type), doc: doc, oldIndex: oldIndex, newIndex: newIndex };\n        });\n    }\n}\nfunction resultChangeType(type) {\n    switch (type) {\n        case ChangeType.Added:\n            return 'added';\n        case ChangeType.Modified:\n        case ChangeType.Metadata:\n            return 'modified';\n        case ChangeType.Removed:\n            return 'removed';\n        default:\n            return fail('Unknown change type: ' + type);\n    }\n}\n// Export the classes with a private constructor (it will fail if invoked\n// at runtime). Note that this still allows instanceof checks.\n// We're treating the variables as class names, so disable checking for lower\n// case variable names.\n// tslint:disable:variable-name\nvar PublicFirestore = makeConstructorPrivate(database_Firestore, 'Use firebase.firestore() instead.');\nvar PublicTransaction = makeConstructorPrivate(database_Transaction, 'Use firebase.firestore().runTransaction() instead.');\nvar PublicWriteBatch = makeConstructorPrivate(database_WriteBatch, 'Use firebase.firestore().batch() instead.');\nvar PublicDocumentReference = makeConstructorPrivate(database_DocumentReference, 'Use firebase.firestore().doc() instead.');\nvar PublicDocumentSnapshot = makeConstructorPrivate(database_DocumentSnapshot);\nvar PublicQueryDocumentSnapshot = makeConstructorPrivate(database_QueryDocumentSnapshot);\nvar PublicQuery = makeConstructorPrivate(database_Query);\nvar PublicQuerySnapshot = makeConstructorPrivate(database_QuerySnapshot);\nvar PublicCollectionReference = makeConstructorPrivate(database_CollectionReference, 'Use firebase.firestore().collection() instead.');\n// tslint:enable:variable-name\n\n//# sourceMappingURL=database.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/src/platform/config.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\n\n\n\nvar firestoreNamespace = {\n    Firestore: PublicFirestore,\n    GeoPoint: geo_point_GeoPoint,\n    Blob: PublicBlob,\n    Transaction: PublicTransaction,\n    WriteBatch: PublicWriteBatch,\n    DocumentReference: PublicDocumentReference,\n    DocumentSnapshot: PublicDocumentSnapshot,\n    Query: PublicQuery,\n    QueryDocumentSnapshot: PublicQueryDocumentSnapshot,\n    QuerySnapshot: PublicQuerySnapshot,\n    CollectionReference: PublicCollectionReference,\n    FieldPath: field_path_FieldPath,\n    FieldValue: PublicFieldValue,\n    setLogLevel: database_Firestore.setLogLevel\n};\n/**\n * Configures Firestore as part of the Firebase SDK by calling registerService.\n */\nfunction configureForFirebase(firebase) {\n    firebase.INTERNAL.registerService('firestore', function (app) { return new database_Firestore(app); }, shallowCopy(firestoreNamespace));\n}\n/**\n * Exports the Firestore namespace into the provided `exportObject` object under\n * the key 'firestore'. This is used for wrapped binary that exposes Firestore\n * as a goog module.\n */\nfunction configureForStandalone(exportObject) {\n    var copiedNamespace = shallowCopy(firestoreNamespace);\n    // Unlike the use with Firebase, the standalone allows the use of the\n    // constructor, so export it's internal class\n    copiedNamespace['Firestore'] = database_Firestore;\n    exportObject['firestore'] = copiedNamespace;\n}\n\n//# sourceMappingURL=config.js.map\n\n// CONCATENATED MODULE: ../firestore/dist/esm/index.js\n/* harmony export (immutable) */ __webpack_exports__[\"registerFirestore\"] = registerFirestore;\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n\nfunction registerFirestore(instance) {\n    configureForFirebase(instance);\n}\nregisterFirestore(esm[\"default\"]);\n\n//# sourceMappingURL=index.js.map\n\n\n/***/ }),\n\n/***/ 117:\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {(function() {var g,goog=goog||{},k=this;function l(a){return\"string\"==typeof a}function aa(){}\nfunction ba(a){var b=typeof a;if(\"object\"==b)if(a){if(a instanceof Array)return\"array\";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if(\"[object Window]\"==c)return\"object\";if(\"[object Array]\"==c||\"number\"==typeof a.length&&\"undefined\"!=typeof a.splice&&\"undefined\"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable(\"splice\"))return\"array\";if(\"[object Function]\"==c||\"undefined\"!=typeof a.call&&\"undefined\"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable(\"call\"))return\"function\"}else return\"null\";\nelse if(\"function\"==b&&\"undefined\"==typeof a.call)return\"object\";return b}function n(a){return\"array\"==ba(a)}function ca(a){var b=ba(a);return\"array\"==b||\"object\"==b&&\"number\"==typeof a.length}function da(a){return\"function\"==ba(a)}function ea(a){var b=typeof a;return\"object\"==b&&null!=a||\"function\"==b}var p=\"closure_uid_\"+(1E9*Math.random()>>>0),fa=0;function ha(a,b,c){return a.call.apply(a.bind,arguments)}\nfunction ia(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function q(a,b,c){Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf(\"native code\")?q=ha:q=ia;return q.apply(null,arguments)}\nfunction ja(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=c.slice();b.push.apply(b,arguments);return a.apply(this,b)}}var r=Date.now||function(){return+new Date};function t(a,b){function c(){}c.prototype=b.prototype;a.H=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.Db=function(a,c,f){for(var d=Array(arguments.length-2),e=2;e<arguments.length;e++)d[e-2]=arguments[e];return b.prototype[c].apply(a,d)}};function ka(a){if(Error.captureStackTrace)Error.captureStackTrace(this,ka);else{var b=Error().stack;b&&(this.stack=b)}a&&(this.message=String(a))}t(ka,Error);ka.prototype.name=\"CustomError\";function la(a,b){a=a.split(\"%s\");for(var c=\"\",d=a.length-1,e=0;e<d;e++)c+=a[e]+(e<b.length?b[e]:\"%s\");ka.call(this,c+a[d])}t(la,ka);la.prototype.name=\"AssertionError\";function ma(a,b){throw new la(\"Failure\"+(a?\": \"+a:\"\"),Array.prototype.slice.call(arguments,1));};function u(){0!=na&&(pa[this[p]||(this[p]=++fa)]=this);this.i=this.i;this.m=this.m}var na=0,pa={};u.prototype.i=!1;u.prototype.$=function(){if(!this.i&&(this.i=!0,this.w(),0!=na)){var a=this[p]||(this[p]=++fa);if(0!=na&&this.m&&0<this.m.length)throw Error(this+\" did not empty its onDisposeCallbacks queue. This probably means it overrode dispose() or disposeInternal() without calling the superclass' method.\");delete pa[a]}};u.prototype.w=function(){if(this.m)for(;this.m.length;)this.m.shift()()};var qa=Array.prototype.indexOf?function(a,b){return Array.prototype.indexOf.call(a,b,void 0)}:function(a,b){if(l(a))return l(b)&&1==b.length?a.indexOf(b,0):-1;for(var c=0;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1},ra=Array.prototype.forEach?function(a,b,c){Array.prototype.forEach.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=l(a)?a.split(\"\"):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a)};\nfunction sa(a){a:{var b=ta;for(var c=a.length,d=l(a)?a.split(\"\"):a,e=0;e<c;e++)if(e in d&&b.call(void 0,d[e],e,a)){b=e;break a}b=-1}return 0>b?null:l(a)?a.charAt(b):a[b]}function ua(a){if(!n(a))for(var b=a.length-1;0<=b;b--)delete a[b];a.length=0}function va(a){return Array.prototype.concat.apply([],arguments)}function wa(a){var b=a.length;if(0<b){for(var c=Array(b),d=0;d<b;d++)c[d]=a[d];return c}return[]};function xa(a){return/^[\\s\\xa0]*$/.test(a)}var ya=String.prototype.trim?function(a){return a.trim()}:function(a){return/^[\\s\\xa0]*([\\s\\S]*?)[\\s\\xa0]*$/.exec(a)[1]};function za(a,b){return a<b?-1:a>b?1:0};var w;a:{var Aa=k.navigator;if(Aa){var Ba=Aa.userAgent;if(Ba){w=Ba;break a}}w=\"\"}function x(a){return-1!=w.indexOf(a)};function Ca(a,b,c){for(var d in a)b.call(c,a[d],d,a)}function Da(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b}function Ea(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b}function Fa(a){var b={},c;for(c in a)b[c]=a[c];return b}var Ga=\"constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf\".split(\" \");\nfunction Ha(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<Ga.length;f++)c=Ga[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c])}};function Ia(a){Ia[\" \"](a);return a}Ia[\" \"]=aa;function Ja(a,b){var c=Ka;return Object.prototype.hasOwnProperty.call(c,a)?c[a]:c[a]=b(a)};var La=x(\"Opera\"),y=x(\"Trident\")||x(\"MSIE\"),Ma=x(\"Edge\"),Na=Ma||y,Oa=x(\"Gecko\")&&!(-1!=w.toLowerCase().indexOf(\"webkit\")&&!x(\"Edge\"))&&!(x(\"Trident\")||x(\"MSIE\"))&&!x(\"Edge\"),Pa=-1!=w.toLowerCase().indexOf(\"webkit\")&&!x(\"Edge\");function Qa(){var a=k.document;return a?a.documentMode:void 0}var Ra;\na:{var Sa=\"\",Ta=function(){var a=w;if(Oa)return/rv:([^\\);]+)(\\)|;)/.exec(a);if(Ma)return/Edge\\/([\\d\\.]+)/.exec(a);if(y)return/\\b(?:MSIE|rv)[: ]([^\\);]+)(\\)|;)/.exec(a);if(Pa)return/WebKit\\/(\\S+)/.exec(a);if(La)return/(?:Version)[ \\/]?(\\S+)/.exec(a)}();Ta&&(Sa=Ta?Ta[1]:\"\");if(y){var Ua=Qa();if(null!=Ua&&Ua>parseFloat(Sa)){Ra=String(Ua);break a}}Ra=Sa}var Ka={};\nfunction Va(a){return Ja(a,function(){for(var b=0,c=ya(String(Ra)).split(\".\"),d=ya(String(a)).split(\".\"),e=Math.max(c.length,d.length),f=0;0==b&&f<e;f++){var h=c[f]||\"\",m=d[f]||\"\";do{h=/(\\d*)(\\D*)(.*)/.exec(h)||[\"\",\"\",\"\",\"\"];m=/(\\d*)(\\D*)(.*)/.exec(m)||[\"\",\"\",\"\",\"\"];if(0==h[0].length&&0==m[0].length)break;b=za(0==h[1].length?0:parseInt(h[1],10),0==m[1].length?0:parseInt(m[1],10))||za(0==h[2].length,0==m[2].length)||za(h[2],m[2]);h=h[3];m=m[3]}while(0==b)}return 0<=b})}var Wa;var Xa=k.document;\nWa=Xa&&y?Qa()||(\"CSS1Compat\"==Xa.compatMode?parseInt(Ra,10):5):void 0;var Ya=Object.freeze||function(a){return a};var Za=!y||9<=Number(Wa),$a=y&&!Va(\"9\"),ab=function(){if(!k.addEventListener||!Object.defineProperty)return!1;var a=!1,b=Object.defineProperty({},\"passive\",{get:function(){a=!0}});k.addEventListener(\"test\",aa,b);k.removeEventListener(\"test\",aa,b);return a}();function z(a,b){this.type=a;this.a=this.target=b;this.Qa=!0}z.prototype.b=function(){this.Qa=!1};function bb(a,b){z.call(this,a?a.type:\"\");this.relatedTarget=this.a=this.target=null;this.button=this.screenY=this.screenX=this.clientY=this.clientX=0;this.key=\"\";this.metaKey=this.shiftKey=this.altKey=this.ctrlKey=!1;this.pointerId=0;this.pointerType=\"\";this.c=null;if(a){var c=this.type=a.type,d=a.changedTouches?a.changedTouches[0]:null;this.target=a.target||a.srcElement;this.a=b;if(b=a.relatedTarget){if(Oa){a:{try{Ia(b.nodeName);var e=!0;break a}catch(f){}e=!1}e||(b=null)}}else\"mouseover\"==c?b=\na.fromElement:\"mouseout\"==c&&(b=a.toElement);this.relatedTarget=b;null===d?(this.clientX=void 0!==a.clientX?a.clientX:a.pageX,this.clientY=void 0!==a.clientY?a.clientY:a.pageY,this.screenX=a.screenX||0,this.screenY=a.screenY||0):(this.clientX=void 0!==d.clientX?d.clientX:d.pageX,this.clientY=void 0!==d.clientY?d.clientY:d.pageY,this.screenX=d.screenX||0,this.screenY=d.screenY||0);this.button=a.button;this.key=a.key||\"\";this.ctrlKey=a.ctrlKey;this.altKey=a.altKey;this.shiftKey=a.shiftKey;this.metaKey=\na.metaKey;this.pointerId=a.pointerId||0;this.pointerType=l(a.pointerType)?a.pointerType:cb[a.pointerType]||\"\";this.c=a;a.defaultPrevented&&this.b()}}t(bb,z);var cb=Ya({2:\"touch\",3:\"pen\",4:\"mouse\"});bb.prototype.b=function(){bb.H.b.call(this);var a=this.c;if(a.preventDefault)a.preventDefault();else if(a.returnValue=!1,$a)try{if(a.ctrlKey||112<=a.keyCode&&123>=a.keyCode)a.keyCode=-1}catch(b){}};var db=\"closure_listenable_\"+(1E6*Math.random()|0),eb=0;function fb(a,b,c,d,e){this.listener=a;this.proxy=null;this.src=b;this.type=c;this.capture=!!d;this.ga=e;this.key=++eb;this.Z=this.ba=!1}function gb(a){a.Z=!0;a.listener=null;a.proxy=null;a.src=null;a.ga=null};function hb(a){this.src=a;this.a={};this.b=0}hb.prototype.add=function(a,b,c,d,e){var f=a.toString();a=this.a[f];a||(a=this.a[f]=[],this.b++);var h=ib(a,b,d,e);-1<h?(b=a[h],c||(b.ba=!1)):(b=new fb(b,this.src,f,!!d,e),b.ba=c,a.push(b));return b};function jb(a,b){var c=b.type;if(c in a.a){var d=a.a[c],e=qa(d,b),f;(f=0<=e)&&Array.prototype.splice.call(d,e,1);f&&(gb(b),0==a.a[c].length&&(delete a.a[c],a.b--))}}\nfunction ib(a,b,c,d){for(var e=0;e<a.length;++e){var f=a[e];if(!f.Z&&f.listener==b&&f.capture==!!c&&f.ga==d)return e}return-1};var kb=\"closure_lm_\"+(1E6*Math.random()|0),lb={},mb=0;function nb(a,b,c,d,e){if(d&&d.once)return ob(a,b,c,d,e);if(n(b)){for(var f=0;f<b.length;f++)nb(a,b[f],c,d,e);return null}c=pb(c);return a&&a[db]?a.Ha(b,c,ea(d)?!!d.capture:!!d,e):qb(a,b,c,!1,d,e)}\nfunction qb(a,b,c,d,e,f){if(!b)throw Error(\"Invalid event type\");var h=ea(e)?!!e.capture:!!e,m=rb(a);m||(a[kb]=m=new hb(a));c=m.add(b,c,d,h,f);if(c.proxy)return c;d=sb();c.proxy=d;d.src=a;d.listener=c;if(a.addEventListener)ab||(e=h),void 0===e&&(e=!1),a.addEventListener(b.toString(),d,e);else if(a.attachEvent)a.attachEvent(tb(b.toString()),d);else if(a.addListener&&a.removeListener)a.addListener(d);else throw Error(\"addEventListener and attachEvent are unavailable.\");mb++;return c}\nfunction sb(){var a=ub,b=Za?function(c){return a.call(b.src,b.listener,c)}:function(c){c=a.call(b.src,b.listener,c);if(!c)return c};return b}function ob(a,b,c,d,e){if(n(b)){for(var f=0;f<b.length;f++)ob(a,b[f],c,d,e);return null}c=pb(c);return a&&a[db]?a.Ia(b,c,ea(d)?!!d.capture:!!d,e):qb(a,b,c,!0,d,e)}\nfunction vb(a,b,c,d,e){if(n(b))for(var f=0;f<b.length;f++)vb(a,b[f],c,d,e);else(d=ea(d)?!!d.capture:!!d,c=pb(c),a&&a[db])?(a=a.f,b=String(b).toString(),b in a.a&&(f=a.a[b],c=ib(f,c,d,e),-1<c&&(gb(f[c]),Array.prototype.splice.call(f,c,1),0==f.length&&(delete a.a[b],a.b--)))):a&&(a=rb(a))&&(b=a.a[b.toString()],a=-1,b&&(a=ib(b,c,d,e)),(c=-1<a?b[a]:null)&&wb(c))}\nfunction wb(a){if(\"number\"!=typeof a&&a&&!a.Z){var b=a.src;if(b&&b[db])jb(b.f,a);else{var c=a.type,d=a.proxy;b.removeEventListener?b.removeEventListener(c,d,a.capture):b.detachEvent?b.detachEvent(tb(c),d):b.addListener&&b.removeListener&&b.removeListener(d);mb--;(c=rb(b))?(jb(c,a),0==c.b&&(c.src=null,b[kb]=null)):gb(a)}}}function tb(a){return a in lb?lb[a]:lb[a]=\"on\"+a}\nfunction xb(a,b,c,d){var e=!0;if(a=rb(a))if(b=a.a[b.toString()])for(b=b.concat(),a=0;a<b.length;a++){var f=b[a];f&&f.capture==c&&!f.Z&&(f=yb(f,d),e=e&&!1!==f)}return e}function yb(a,b){var c=a.listener,d=a.ga||a.src;a.ba&&wb(a);return c.call(d,b)}\nfunction ub(a,b){if(a.Z)return!0;if(!Za){if(!b)a:{b=[\"window\",\"event\"];for(var c=k,d=0;d<b.length;d++)if(c=c[b[d]],null==c){b=null;break a}b=c}d=b;b=new bb(d,this);c=!0;if(!(0>d.keyCode||void 0!=d.returnValue)){a:{var e=!1;if(0==d.keyCode)try{d.keyCode=-1;break a}catch(h){e=!0}if(e||void 0==d.returnValue)d.returnValue=!0}d=[];for(e=b.a;e;e=e.parentNode)d.push(e);a=a.type;for(e=d.length-1;0<=e;e--){b.a=d[e];var f=xb(d[e],a,!0,b);c=c&&f}for(e=0;e<d.length;e++)b.a=d[e],f=xb(d[e],a,!1,b),c=c&&f}return c}return yb(a,\nnew bb(b,this))}function rb(a){a=a[kb];return a instanceof hb?a:null}var zb=\"__closure_events_fn_\"+(1E9*Math.random()>>>0);function pb(a){if(da(a))return a;a[zb]||(a[zb]=function(b){return a.handleEvent(b)});return a[zb]};function A(){u.call(this);this.f=new hb(this);this.N=this;this.J=null}t(A,u);A.prototype[db]=!0;g=A.prototype;g.addEventListener=function(a,b,c,d){nb(this,a,b,c,d)};g.removeEventListener=function(a,b,c,d){vb(this,a,b,c,d)};\ng.dispatchEvent=function(a){var b,c=this.J;if(c)for(b=[];c;c=c.J)b.push(c);c=this.N;var d=a.type||a;if(l(a))a=new z(a,c);else if(a instanceof z)a.target=a.target||c;else{var e=a;a=new z(d,c);Ha(a,e)}e=!0;if(b)for(var f=b.length-1;0<=f;f--){var h=a.a=b[f];e=Ab(h,d,!0,a)&&e}h=a.a=c;e=Ab(h,d,!0,a)&&e;e=Ab(h,d,!1,a)&&e;if(b)for(f=0;f<b.length;f++)h=a.a=b[f],e=Ab(h,d,!1,a)&&e;return e};\ng.w=function(){A.H.w.call(this);if(this.f){var a=this.f,b=0,c;for(c in a.a){for(var d=a.a[c],e=0;e<d.length;e++)++b,gb(d[e]);delete a.a[c];a.b--}}this.J=null};g.Ha=function(a,b,c,d){return this.f.add(String(a),b,!1,c,d)};g.Ia=function(a,b,c,d){return this.f.add(String(a),b,!0,c,d)};\nfunction Ab(a,b,c,d){b=a.f.a[String(b)];if(!b)return!0;b=b.concat();for(var e=!0,f=0;f<b.length;++f){var h=b[f];if(h&&!h.Z&&h.capture==c){var m=h.listener,v=h.ga||h.src;h.ba&&jb(a.f,h);e=!1!==m.call(v,d)&&e}}return e&&0!=d.Qa};function Bb(a){return/^\\s*$/.test(a)?!1:/^[\\],:{}\\s\\u2028\\u2029]*$/.test(a.replace(/\\\\[\"\\\\\\/bfnrtu]/g,\"@\").replace(/(?:\"[^\"\\\\\\n\\r\\u2028\\u2029\\x00-\\x08\\x0a-\\x1f]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)[\\s\\u2028\\u2029]*(?=:|,|]|}|$)/g,\"]\").replace(/(?:^|:|,)(?:[\\s\\u2028\\u2029]*\\[)+/g,\"\"))}function Cb(a){a=String(a);if(Bb(a))try{return eval(\"(\"+a+\")\")}catch(b){}throw Error(\"Invalid JSON string: \"+a);}function Db(a){var b=[];Eb(new Fb,a,b);return b.join(\"\")}function Fb(){}\nfunction Eb(a,b,c){if(null==b)c.push(\"null\");else{if(\"object\"==typeof b){if(n(b)){var d=b;b=d.length;c.push(\"[\");for(var e=\"\",f=0;f<b;f++)c.push(e),Eb(a,d[f],c),e=\",\";c.push(\"]\");return}if(b instanceof String||b instanceof Number||b instanceof Boolean)b=b.valueOf();else{c.push(\"{\");e=\"\";for(d in b)Object.prototype.hasOwnProperty.call(b,d)&&(f=b[d],\"function\"!=typeof f&&(c.push(e),Gb(d,c),c.push(\":\"),Eb(a,f,c),e=\",\"));c.push(\"}\");return}}switch(typeof b){case \"string\":Gb(b,c);break;case \"number\":c.push(isFinite(b)&&\n!isNaN(b)?String(b):\"null\");break;case \"boolean\":c.push(String(b));break;case \"function\":c.push(\"null\");break;default:throw Error(\"Unknown type: \"+typeof b);}}}var Hb={'\"':'\\\\\"',\"\\\\\":\"\\\\\\\\\",\"/\":\"\\\\/\",\"\\b\":\"\\\\b\",\"\\f\":\"\\\\f\",\"\\n\":\"\\\\n\",\"\\r\":\"\\\\r\",\"\\t\":\"\\\\t\",\"\\x0B\":\"\\\\u000b\"},Ib=/\\uffff/.test(\"\\uffff\")?/[\\\\\"\\x00-\\x1f\\x7f-\\uffff]/g:/[\\\\\"\\x00-\\x1f\\x7f-\\xff]/g;\nfunction Gb(a,b){b.push('\"',a.replace(Ib,function(a){var b=Hb[a];b||(b=\"\\\\u\"+(a.charCodeAt(0)|65536).toString(16).substr(1),Hb[a]=b);return b}),'\"')};function Jb(a,b){this.c=a;this.f=b;this.b=0;this.a=null}Jb.prototype.get=function(){if(0<this.b){this.b--;var a=this.a;this.a=a.next;a.next=null}else a=this.c();return a};function Kb(){this.b=this.a=null}var Nb=new Jb(function(){return new Mb},function(a){a.reset()});Kb.prototype.add=function(a,b){var c=Nb.get();c.set(a,b);this.b?this.b.next=c:this.a=c;this.b=c};function Ob(){var a=Pb,b=null;a.a&&(b=a.a,a.a=a.a.next,a.a||(a.b=null),b.next=null);return b}function Mb(){this.next=this.b=this.a=null}Mb.prototype.set=function(a,b){this.a=a;this.b=b;this.next=null};Mb.prototype.reset=function(){this.next=this.b=this.a=null};function Qb(a){k.setTimeout(function(){throw a;},0)}var Rb;\nfunction Sb(){var a=k.MessageChannel;\"undefined\"===typeof a&&\"undefined\"!==typeof window&&window.postMessage&&window.addEventListener&&!x(\"Presto\")&&(a=function(){var a=document.createElement(\"IFRAME\");a.style.display=\"none\";a.src=\"\";document.documentElement.appendChild(a);var b=a.contentWindow;a=b.document;a.open();a.write(\"\");a.close();var c=\"callImmediate\"+Math.random(),d=\"file:\"==b.location.protocol?\"*\":b.location.protocol+\"//\"+b.location.host;a=q(function(a){if((\"*\"==d||a.origin==d)&&a.data==\nc)this.port1.onmessage()},this);b.addEventListener(\"message\",a,!1);this.port1={};this.port2={postMessage:function(){b.postMessage(c,d)}}});if(\"undefined\"!==typeof a&&!x(\"Trident\")&&!x(\"MSIE\")){var b=new a,c={},d=c;b.port1.onmessage=function(){if(void 0!==c.next){c=c.next;var a=c.ya;c.ya=null;a()}};return function(a){d.next={ya:a};d=d.next;b.port2.postMessage(0)}}return\"undefined\"!==typeof document&&\"onreadystatechange\"in document.createElement(\"SCRIPT\")?function(a){var b=document.createElement(\"SCRIPT\");\nb.onreadystatechange=function(){b.onreadystatechange=null;b.parentNode.removeChild(b);b=null;a();a=null};document.documentElement.appendChild(b)}:function(a){k.setTimeout(a,0)}};var Tb;function Ub(){if(-1!=String(k.Promise).indexOf(\"[native code]\")){var a=k.Promise.resolve(void 0);Tb=function(){a.then(Vb)}}else Tb=function(){var a=Vb;!da(k.setImmediate)||k.Window&&k.Window.prototype&&!x(\"Edge\")&&k.Window.prototype.setImmediate==k.setImmediate?(Rb||(Rb=Sb()),Rb(a)):k.setImmediate(a)}}var Wb=!1,Pb=new Kb;function Vb(){for(var a;a=Ob();){try{a.a.call(a.b)}catch(c){Qb(c)}var b=Nb;b.f(a);100>b.b&&(b.b++,a.next=b.a,b.a=a)}Wb=!1};function Xb(a,b){A.call(this);this.b=a||1;this.a=b||k;this.c=q(this.lb,this);this.g=r()}t(Xb,A);g=Xb.prototype;g.ea=!1;g.O=null;g.lb=function(){if(this.ea){var a=r()-this.g;0<a&&a<.8*this.b?this.O=this.a.setTimeout(this.c,this.b-a):(this.O&&(this.a.clearTimeout(this.O),this.O=null),this.dispatchEvent(\"tick\"),this.ea&&(this.O=this.a.setTimeout(this.c,this.b),this.g=r()))}};g.start=function(){this.ea=!0;this.O||(this.O=this.a.setTimeout(this.c,this.b),this.g=r())};\nfunction Yb(a){a.ea=!1;a.O&&(a.a.clearTimeout(a.O),a.O=null)}g.w=function(){Xb.H.w.call(this);Yb(this);delete this.a};function Zb(a,b,c){if(da(a))c&&(a=q(a,c));else if(a&&\"function\"==typeof a.handleEvent)a=q(a.handleEvent,a);else throw Error(\"Invalid listener argument\");return 2147483647<Number(b)?-1:k.setTimeout(a,b||0)};function $b(a,b,c){u.call(this);this.f=null!=c?q(a,c):a;this.c=b;this.b=q(this.fb,this);this.a=[]}t($b,u);g=$b.prototype;g.ha=!1;g.Y=null;g.Ya=function(a){this.a=arguments;this.Y?this.ha=!0:ac(this)};g.w=function(){$b.H.w.call(this);this.Y&&(k.clearTimeout(this.Y),this.Y=null,this.ha=!1,this.a=[])};g.fb=function(){this.Y=null;this.ha&&(this.ha=!1,ac(this))};function ac(a){a.Y=Zb(a.b,a.c);a.f.apply(null,a.a)};function bc(a){u.call(this);this.b=a;this.a={}}t(bc,u);var cc=[];function dc(a,b,c,d){n(c)||(c&&(cc[0]=c.toString()),c=cc);for(var e=0;e<c.length;e++){var f=nb(b,c[e],d||a.handleEvent,!1,a.b||a);if(!f)break;a.a[f.key]=f}}function ec(a){Ca(a.a,function(a,c){this.a.hasOwnProperty(c)&&wb(a)},a);a.a={}}bc.prototype.w=function(){bc.H.w.call(this);ec(this)};bc.prototype.handleEvent=function(){throw Error(\"EventHandler.handleEvent not implemented\");};function fc(a,b,c){this.reset(a,b,c,void 0,void 0)}fc.prototype.a=null;var gc=0;fc.prototype.reset=function(a,b,c,d,e){\"number\"==typeof e||gc++;d||r();delete this.a};function hc(a){this.f=a;this.b=this.c=this.a=null}function B(a,b){this.name=a;this.value=b}B.prototype.toString=function(){return this.name};var ic=new B(\"SEVERE\",1E3),jc=new B(\"WARNING\",900),kc=new B(\"INFO\",800),lc=new B(\"CONFIG\",700),mc=new B(\"FINE\",500);function nc(a){if(a.c)return a.c;if(a.a)return nc(a.a);ma(\"Root logger has no level set.\");return null}hc.prototype.log=function(a,b,c){if(a.value>=nc(this).value)for(da(b)&&(b=b()),a=new fc(a,String(b),this.f),c&&(a.a=c),c=this;c;)c=c.a};\nvar oc={},pc=null;function qc(a){pc||(pc=new hc(\"\"),oc[\"\"]=pc,pc.c=lc);var b;if(!(b=oc[a])){b=new hc(a);var c=a.lastIndexOf(\".\"),d=a.substr(c+1);c=qc(a.substr(0,c));c.b||(c.b={});c.b[d]=b;b.a=c;oc[a]=b}return b};function C(a,b){a&&a.log(jc,b,void 0)}function rc(a,b){a&&a.log(kc,b,void 0)}function D(a,b){a&&a.log(mc,b,void 0)};function sc(){this.a=qc(\"goog.labs.net.webChannel.WebChannelDebug\");this.b=!0}sc.prototype.Ea=function(){this.b=!1};function tc(a,b,c,d,e,f){E(a,function(){if(a.b)if(f){var h=\"\";for(var m=f.split(\"&\"),v=0;v<m.length;v++){var I=m[v].split(\"=\");if(1<I.length){var W=I[0];I=I[1];var Lb=W.split(\"_\");h=2<=Lb.length&&\"type\"==Lb[1]?h+(W+\"=\"+I+\"&\"):h+(W+\"=redacted&\")}}}else h=null;else h=f;return\"XMLHTTP REQ (\"+d+\") [attempt \"+e+\"]: \"+b+\"\\n\"+c+\"\\n\"+h})}\nfunction uc(a,b,c,d,e,f,h){E(a,function(){return\"XMLHTTP RESP (\"+d+\") [ attempt \"+e+\"]: \"+b+\"\\n\"+c+\"\\n\"+f+\" \"+h})}function F(a,b,c,d){E(a,function(){return\"XMLHTTP TEXT (\"+b+\"): \"+vc(a,c)+(d?\" \"+d:\"\")})}function wc(a,b){E(a,function(){return\"TIMEOUT: \"+b})}function G(a,b){D(a.a,b)}function xc(a,b,c){(a=a.a)&&a.log(ic,c||\"Exception\",b)}function E(a,b){rc(a.a,b)}function H(a,b){(a=a.a)&&a.log(ic,b,void 0)}\nfunction vc(a,b){if(!a.b)return b;if(!b)return null;try{var c=JSON.parse(b);if(c)for(var d=0;d<c.length;d++)if(n(c[d])){var e=c[d];if(!(2>e.length)){var f=e[1];if(n(f)&&!(1>f.length)){var h=f[0];if(\"noop\"!=h&&\"stop\"!=h&&\"close\"!=h)for(var m=1;m<f.length;m++)f[m]=\"\"}}}return Db(c)}catch(v){return G(a,\"Exception parsing expected JS array - probably was not JS\"),b}};var J=new A;function yc(a){z.call(this,\"serverreachability\",a)}t(yc,z);function zc(a){J.dispatchEvent(new yc(J,a))}function Ac(a){z.call(this,\"statevent\",a)}t(Ac,z);function K(a){J.dispatchEvent(new Ac(J,a))}function Bc(a){z.call(this,\"timingevent\",a)}t(Bc,z);function Cc(a,b,c){J.dispatchEvent(new Bc(J,a,b,c))}function Dc(a,b){if(!da(a))throw Error(\"Fn must not be null and must be a function\");return k.setTimeout(function(){a()},b)};var Ec={NO_ERROR:0,mb:1,tb:2,sb:3,pb:4,rb:5,ub:6,Sa:7,TIMEOUT:8,xb:9};var Fc={ob:\"complete\",Bb:\"success\",Ta:\"error\",Sa:\"abort\",zb:\"ready\",Ab:\"readystatechange\",TIMEOUT:\"timeout\",vb:\"incrementaldata\",yb:\"progress\",qb:\"downloadprogress\",Cb:\"uploadprogress\"};function Gc(){}var Hc={OPEN:\"a\",nb:\"b\",Ta:\"c\",wb:\"d\"};function Ic(){z.call(this,\"d\")}t(Ic,z);function Jc(){z.call(this,\"c\")}t(Jc,z);function Kc(){}Kc.prototype.a=null;function Lc(a){var b;(b=a.a)||(b={},Mc(a)&&(b[0]=!0,b[1]=!0),b=a.a=b);return b};var Nc;function Oc(){}t(Oc,Kc);function Pc(a){return(a=Mc(a))?new ActiveXObject(a):new XMLHttpRequest}function Mc(a){if(!a.b&&\"undefined\"==typeof XMLHttpRequest&&\"undefined\"!=typeof ActiveXObject){for(var b=[\"MSXML2.XMLHTTP.6.0\",\"MSXML2.XMLHTTP.3.0\",\"MSXML2.XMLHTTP\",\"Microsoft.XMLHTTP\"],c=0;c<b.length;c++){var d=b[c];try{return new ActiveXObject(d),a.b=d}catch(e){}}throw Error(\"Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed\");}return a.b}Nc=new Oc;function L(a,b,c,d){this.i=a;this.b=b;this.c=c;this.T=d||1;this.L=new bc(this);this.R=Qc;a=Na?125:void 0;this.S=new Xb(a);this.j=null;this.f=!1;this.l=this.g=this.h=this.J=this.D=this.U=this.s=null;this.u=[];this.a=null;this.G=0;this.m=this.o=null;this.C=-1;this.B=!1;this.N=0;this.I=null;this.v=this.X=this.K=!1}var Qc=45E3;\nfunction Rc(a,b){switch(a){case 0:return\"Non-200 return code (\"+b+\")\";case 1:return\"XMLHTTP failure (no data)\";case 2:return\"HttpConnection timeout\";default:return\"Unknown error\"}}var Sc={},Tc={};g=L.prototype;g.setTimeout=function(a){this.R=a};function Uc(a,b,c){a.J=1;a.h=Vc(M(b));a.l=c;a.K=!0;Wc(a,null)}function Xc(a,b,c,d){a.J=1;a.h=Vc(M(b));a.l=null;a.K=c;Wc(a,d)}\nfunction Wc(a,b){a.D=r();Yc(a);a.g=M(a.h);Zc(a.g,\"t\",a.T);a.G=0;a.a=a.i.ca(a.i.ia()?b:null);0<a.N&&(a.I=new $b(q(a.Ra,a,a.a),a.N));dc(a.L,a.a,\"readystatechange\",a.ib);b=a.j?Fa(a.j):{};a.l?(a.o||(a.o=\"POST\"),b[\"Content-Type\"]=\"application/x-www-form-urlencoded\",a.a.fa(a.g,a.o,a.l,b)):(a.o=\"GET\",a.a.fa(a.g,a.o,null,b));zc(1);tc(a.b,a.o,a.g,a.c,a.T,a.l)}g.ib=function(a){a=a.target;var b=this.I;b&&3==N(a)?(G(this.b,\"Throttling readystatechange.\"),b.Ya()):this.Ra(a)};\ng.Ra=function(a){try{a==this.a?$c(this):C(this.b.a,\"Called back with an unexpected xmlhttp\")}catch(c){if(G(this.b,\"Failed call to OnXmlHttpReadyStateChanged_\"),this.a&&this.a.V()){var b=this;xc(this.b,c,function(){return\"ResponseText: \"+b.a.V()})}else xc(this.b,c,\"No response text\")}finally{}};\nfunction $c(a){var b=N(a.a),c=a.a.Fa(),d=a.a.W();if(!(3>b||3==b&&!Na&&!a.a.V())){a.B||4!=b||7==c||(8==c||0>=d?zc(3):zc(2));ad(a);var e=a.a.W();a.C=e;(c=a.a.V())||G(a.b,function(){return\"No response text for uri \"+a.g+\" status \"+e});a.f=200==e;uc(a.b,a.o,a.g,a.c,a.T,b,e);if(a.f){if(d=bd(a))F(a.b,a.c,d,\"Initial handshake response via X-HTTP-Initial-Response\"),a.v=!0,cd(a,d);a.K?(dd(a,b,c),Na&&a.f&&3==b&&ed(a)):(F(a.b,a.c,c,null),cd(a,c));4==b&&fd(a);a.f&&!a.B&&(4==b?a.i.ta(a):(a.f=!1,Yc(a)))}else 400==\ne&&0<c.indexOf(\"Unknown SID\")?(a.m=3,K(12),C(a.b.a,\"XMLHTTP Unknown SID (\"+a.c+\")\")):(a.m=0,K(13),C(a.b.a,\"XMLHTTP Bad status \"+e+\" (\"+a.c+\")\")),fd(a),gd(a)}}function bd(a){return!a.X||a.v?null:a.a&&(a=hd(a.a,\"X-HTTP-Initial-Response\"))&&!xa(a)?a:null}\nfunction dd(a,b,c){for(var d=!0;!a.B&&a.G<c.length;){var e=id(a,c);if(e==Tc){4==b&&(a.m=4,K(14),d=!1);F(a.b,a.c,null,\"[Incomplete Response]\");break}else if(e==Sc){a.m=4;K(15);F(a.b,a.c,c,\"[Invalid Chunk]\");d=!1;break}else F(a.b,a.c,e,null),cd(a,e)}4==b&&0==c.length&&(a.m=1,K(16),d=!1);a.f=a.f&&d;d||(F(a.b,a.c,c,\"[Invalid Chunked Response]\"),fd(a),gd(a))}g.hb=function(){if(this.a){var a=N(this.a),b=this.a.V();this.G<b.length&&(ad(this),dd(this,a,b),this.f&&4!=a&&Yc(this))}};\nfunction ed(a){dc(a.L,a.S,\"tick\",a.hb);a.S.start()}function id(a,b){var c=a.G,d=b.indexOf(\"\\n\",c);if(-1==d)return Tc;c=Number(b.substring(c,d));if(isNaN(c))return Sc;d+=1;if(d+c>b.length)return Tc;b=b.substr(d,c);a.G=d+c;return b}g.cancel=function(){this.B=!0;fd(this)};function Yc(a){a.U=r()+a.R;jd(a,a.R)}function jd(a,b){if(null!=a.s)throw Error(\"WatchDog timer not null\");a.s=Dc(q(a.gb,a),b)}function ad(a){a.s&&(k.clearTimeout(a.s),a.s=null)}\ng.gb=function(){this.s=null;var a=r();0<=a-this.U?(this.f&&H(this.b,\"Received watchdog timeout even though request loaded successfully\"),wc(this.b,this.g),2!=this.J&&(zc(3),K(17)),fd(this),this.m=2,gd(this)):(C(this.b.a,\"WatchDog timer called too early\"),jd(this,this.U-a))};function gd(a){a.i.Ka()||a.B||a.i.ta(a)}function fd(a){ad(a);var b=a.I;b&&\"function\"==typeof b.$&&b.$();a.I=null;Yb(a.S);ec(a.L);a.a&&(b=a.a,a.a=null,b.abort(),b.$())}\nfunction cd(a,b){try{a.i.Na(a,b),zc(4)}catch(c){xc(a.b,c,\"Error in httprequest callback\")}};function kd(a){if(a.A&&\"function\"==typeof a.A)return a.A();if(l(a))return a.split(\"\");if(ca(a)){for(var b=[],c=a.length,d=0;d<c;d++)b.push(a[d]);return b}return Da(a)}\nfunction ld(a,b){if(a.forEach&&\"function\"==typeof a.forEach)a.forEach(b,void 0);else if(ca(a)||l(a))ra(a,b,void 0);else{if(a.M&&\"function\"==typeof a.M)var c=a.M();else if(a.A&&\"function\"==typeof a.A)c=void 0;else if(ca(a)||l(a)){c=[];for(var d=a.length,e=0;e<d;e++)c.push(e)}else c=Ea(a);d=kd(a);e=d.length;for(var f=0;f<e;f++)b.call(void 0,d[f],c&&c[f],a)}};function O(a,b){this.b={};this.a=[];this.c=0;var c=arguments.length;if(1<c){if(c%2)throw Error(\"Uneven number of arguments\");for(var d=0;d<c;d+=2)this.set(arguments[d],arguments[d+1])}else if(a)if(a instanceof O)for(c=a.M(),d=0;d<c.length;d++)this.set(c[d],a.get(c[d]));else for(d in a)this.set(d,a[d])}g=O.prototype;g.A=function(){md(this);for(var a=[],b=0;b<this.a.length;b++)a.push(this.b[this.a[b]]);return a};g.M=function(){md(this);return this.a.concat()};\nfunction nd(a){a.b={};a.a.length=0;a.c=0}function od(a,b){return P(a.b,b)?(delete a.b[b],a.c--,a.a.length>2*a.c&&md(a),!0):!1}function md(a){if(a.c!=a.a.length){for(var b=0,c=0;b<a.a.length;){var d=a.a[b];P(a.b,d)&&(a.a[c++]=d);b++}a.a.length=c}if(a.c!=a.a.length){var e={};for(c=b=0;b<a.a.length;)d=a.a[b],P(e,d)||(a.a[c++]=d,e[d]=1),b++;a.a.length=c}}g.get=function(a,b){return P(this.b,a)?this.b[a]:b};g.set=function(a,b){P(this.b,a)||(this.c++,this.a.push(a));this.b[a]=b};\ng.forEach=function(a,b){for(var c=this.M(),d=0;d<c.length;d++){var e=c[d],f=this.get(e);a.call(b,f,e,this)}};function P(a,b){return Object.prototype.hasOwnProperty.call(a,b)};var pd=/^(?:([^:/?#.]+):)?(?:\\/\\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$/;function qd(a,b){if(a){a=a.split(\"&\");for(var c=0;c<a.length;c++){var d=a[c].indexOf(\"=\"),e=null;if(0<=d){var f=a[c].substring(0,d);e=a[c].substring(d+1)}else f=a[c];b(f,e?decodeURIComponent(e.replace(/\\+/g,\" \")):\"\")}}};function Q(a,b){this.b=this.j=this.f=\"\";this.i=null;this.g=this.a=\"\";this.h=!1;var c;a instanceof Q?(this.h=void 0!==b?b:a.h,rd(this,a.f),this.j=a.j,sd(this,a.b),td(this,a.i),this.a=a.a,ud(this,vd(a.c)),this.g=a.g):a&&(c=String(a).match(pd))?(this.h=!!b,rd(this,c[1]||\"\",!0),this.j=wd(c[2]||\"\"),sd(this,c[3]||\"\",!0),td(this,c[4]),this.a=wd(c[5]||\"\",!0),ud(this,c[6]||\"\",!0),this.g=wd(c[7]||\"\")):(this.h=!!b,this.c=new xd(null,this.h))}\nQ.prototype.toString=function(){var a=[],b=this.f;b&&a.push(yd(b,zd,!0),\":\");var c=this.b;if(c||\"file\"==b)a.push(\"//\"),(b=this.j)&&a.push(yd(b,zd,!0),\"@\"),a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g,\"%$1\")),c=this.i,null!=c&&a.push(\":\",String(c));if(c=this.a)this.b&&\"/\"!=c.charAt(0)&&a.push(\"/\"),a.push(yd(c,\"/\"==c.charAt(0)?Ad:Bd,!0));(c=this.c.toString())&&a.push(\"?\",c);(c=this.g)&&a.push(\"#\",yd(c,Cd));return a.join(\"\")};\nQ.prototype.resolve=function(a){var b=M(this),c=!!a.f;c?rd(b,a.f):c=!!a.j;c?b.j=a.j:c=!!a.b;c?sd(b,a.b):c=null!=a.i;var d=a.a;if(c)td(b,a.i);else if(c=!!a.a){if(\"/\"!=d.charAt(0))if(this.b&&!this.a)d=\"/\"+d;else{var e=b.a.lastIndexOf(\"/\");-1!=e&&(d=b.a.substr(0,e+1)+d)}e=d;if(\"..\"==e||\".\"==e)d=\"\";else if(-1!=e.indexOf(\"./\")||-1!=e.indexOf(\"/.\")){d=0==e.lastIndexOf(\"/\",0);e=e.split(\"/\");for(var f=[],h=0;h<e.length;){var m=e[h++];\".\"==m?d&&h==e.length&&f.push(\"\"):\"..\"==m?((1<f.length||1==f.length&&\"\"!=\nf[0])&&f.pop(),d&&h==e.length&&f.push(\"\")):(f.push(m),d=!0)}d=f.join(\"/\")}else d=e}c?b.a=d:c=\"\"!==a.c.toString();c?ud(b,vd(a.c)):c=!!a.g;c&&(b.g=a.g);return b};function M(a){return new Q(a)}function rd(a,b,c){a.f=c?wd(b,!0):b;a.f&&(a.f=a.f.replace(/:$/,\"\"))}function sd(a,b,c){a.b=c?wd(b,!0):b}function td(a,b){if(b){b=Number(b);if(isNaN(b)||0>b)throw Error(\"Bad port number \"+b);a.i=b}else a.i=null}function ud(a,b,c){b instanceof xd?(a.c=b,Dd(a.c,a.h)):(c||(b=yd(b,Ed)),a.c=new xd(b,a.h))}\nfunction R(a,b,c){a.c.set(b,c)}function Zc(a,b,c){n(c)||(c=[String(c)]);Fd(a.c,b,c)}function Vc(a){R(a,\"zx\",Math.floor(2147483648*Math.random()).toString(36)+Math.abs(Math.floor(2147483648*Math.random())^r()).toString(36));return a}function Gd(a){return a instanceof Q?M(a):new Q(a,void 0)}function Hd(a,b,c,d){var e=new Q(null,void 0);a&&rd(e,a);b&&sd(e,b);c&&td(e,c);d&&(e.a=d);return e}function wd(a,b){return a?b?decodeURI(a.replace(/%25/g,\"%2525\")):decodeURIComponent(a):\"\"}\nfunction yd(a,b,c){return l(a)?(a=encodeURI(a).replace(b,Id),c&&(a=a.replace(/%25([0-9a-fA-F]{2})/g,\"%$1\")),a):null}function Id(a){a=a.charCodeAt(0);return\"%\"+(a>>4&15).toString(16)+(a&15).toString(16)}var zd=/[#\\/\\?@]/g,Bd=/[#\\?:]/g,Ad=/[#\\?]/g,Ed=/[#\\?@]/g,Cd=/#/g;function xd(a,b){this.b=this.a=null;this.c=a||null;this.f=!!b}function S(a){a.a||(a.a=new O,a.b=0,a.c&&qd(a.c,function(b,c){a.add(decodeURIComponent(b.replace(/\\+/g,\" \")),c)}))}g=xd.prototype;\ng.add=function(a,b){S(this);this.c=null;a=Jd(this,a);var c=this.a.get(a);c||this.a.set(a,c=[]);c.push(b);this.b+=1;return this};function Kd(a,b){S(a);b=Jd(a,b);P(a.a.b,b)&&(a.c=null,a.b-=a.a.get(b).length,od(a.a,b))}function Ld(a,b){S(a);b=Jd(a,b);return P(a.a.b,b)}g.forEach=function(a,b){S(this);this.a.forEach(function(c,d){ra(c,function(c){a.call(b,c,d,this)},this)},this)};\ng.M=function(){S(this);for(var a=this.a.A(),b=this.a.M(),c=[],d=0;d<b.length;d++)for(var e=a[d],f=0;f<e.length;f++)c.push(b[d]);return c};g.A=function(a){S(this);var b=[];if(l(a))Ld(this,a)&&(b=va(b,this.a.get(Jd(this,a))));else{a=this.a.A();for(var c=0;c<a.length;c++)b=va(b,a[c])}return b};g.set=function(a,b){S(this);this.c=null;a=Jd(this,a);Ld(this,a)&&(this.b-=this.a.get(a).length);this.a.set(a,[b]);this.b+=1;return this};g.get=function(a,b){a=a?this.A(a):[];return 0<a.length?String(a[0]):b};\nfunction Fd(a,b,c){Kd(a,b);0<c.length&&(a.c=null,a.a.set(Jd(a,b),wa(c)),a.b+=c.length)}g.toString=function(){if(this.c)return this.c;if(!this.a)return\"\";for(var a=[],b=this.a.M(),c=0;c<b.length;c++){var d=b[c],e=encodeURIComponent(String(d));d=this.A(d);for(var f=0;f<d.length;f++){var h=e;\"\"!==d[f]&&(h+=\"=\"+encodeURIComponent(String(d[f])));a.push(h)}}return this.c=a.join(\"&\")};function vd(a){var b=new xd;b.c=a.c;a.a&&(b.a=new O(a.a),b.b=a.b);return b}\nfunction Jd(a,b){b=String(b);a.f&&(b=b.toLowerCase());return b}function Dd(a,b){b&&!a.f&&(S(a),a.c=null,a.a.forEach(function(a,b){var c=b.toLowerCase();b!=c&&(Kd(this,b),Fd(this,c,a))},a));a.f=b};function Md(){this.a=r()}var Nd=null;Md.prototype.set=function(a){this.a=a};Md.prototype.reset=function(){this.set(r())};Md.prototype.get=function(){return this.a};function Od(){Nd||(Nd=new Md)}function Pd(){Nd||(Nd=new Md)}t(Pd,Od);function Qd(a,b){this.a=a;this.b=b;this.c=this.i=null;this.h=!1;this.m=null;this.f=-1;this.l=this.g=null}g=Qd.prototype;g.P=null;\nfunction Rd(a){G(a.b,\"TestConnection: starting stage 2\");var b=a.a.I.a;if(null!=b)G(a.b,function(){return true?\"Buffered\":\"Unbuffered\"}),K(4),b?(K(10),Sd(a.a,a,!1)):(K(11),Sd(a.a,a,!0));else{a.c=new L(a,a.b,void 0,void 0);a.c.j=a.i;var c=Td(a.a,a.g,a.m);K(4);Zc(c,\"TYPE\",\"xmlhttp\");var d=a.a.j,e=a.a.K;d&&e&&R(c,d,e);Xc(a.c,c,!1,a.g)}}g.ca=function(a){return this.a.ca(a)};g.abort=function(){this.c&&(this.c.cancel(),this.c=null);this.f=-1};\ng.Ka=function(){return!1};\ng.Na=function(a,b){this.f=a.C;if(0==this.P){G(this.b,\"TestConnection: Got data for stage 1\");if(!this.a.o&&(a=a.a)){var c=hd(a,\"X-Client-Wire-Protocol\");this.l=c?c:null;this.a.j&&((a=hd(a,\"X-HTTP-Session-Id\"))?this.a.K=a:C(this.b.a,\"Missing X_HTTP_SESSION_ID in the handshake response\"))}if(b){try{var d=this.a.la.a.parse(b)}catch(e){xc(this.b,e);Ud(this.a,this);return}this.g=d[0]}else G(this.b,\"TestConnection: Null responseText\"),Ud(this.a,this)}else if(1==this.P)if(this.h)K(6);else if(\"11111\"==b){if(K(5),\nthis.h=!0,!y||10<=Number(Wa))this.f=200,this.c.cancel(),G(this.b,\"Test connection succeeded; using streaming connection\"),K(11),Sd(this.a,this,!0)}else K(7),this.h=!1};\ng.ta=function(){this.f=this.c.C;this.c.f?0==this.P?(this.P=1,G(this.b,\"TestConnection: request complete for initial check\"),Rd(this)):1==this.P&&(G(this.b,\"TestConnection: request complete for stage 2\"),this.h?(G(this.b,\"Test connection succeeded; using streaming connection\"),K(11),Sd(this.a,this,!0)):(G(this.b,\"Test connection failed; not using streaming\"),K(10),Sd(this.a,this,!1))):(G(this.b,\"TestConnection: request failed, in state \"+this.P),0==this.P?K(8):1==this.P&&K(9),Ud(this.a,this))};\ng.ia=function(){return this.a.ia()};g.qa=function(){return this.a.qa()};function Vd(){this.a=this.b=null};function Wd(){this.a=new O}function Xd(a){var b=typeof a;return\"object\"==b&&a||\"function\"==b?\"o\"+(a[p]||(a[p]=++fa)):b.charAt(0)+a}Wd.prototype.add=function(a){this.a.set(Xd(a),a)};Wd.prototype.A=function(){return this.a.A()};function Yd(a,b){this.a=a;this.b=b};function Zd(a){this.g=a||$d;this.f=k.oa&&k.oa.La&&k.oa.La()&&k.oa.La().Fb?this.g:1;this.a=null;1<this.f&&(this.a=new Wd);this.b=null;this.c=[]}var $d=10;function ae(a,b){a.a||-1==b.indexOf(\"spdy\")&&-1==b.indexOf(\"quic\")&&-1==b.indexOf(\"h2\")||(a.f=a.g,a.a=new Wd,a.b&&(be(a,a.b),a.b=null))}function ce(a){return a.b?!0:a.a?a.a.a.c>=a.f:!1}function de(a,b){a.b?a=a.b==b:a.a?(b=Xd(b),a=P(a.a.a.b,b)):a=!1;return a}function be(a,b){a.a?a.a.add(b):a.b=b}\nfunction ee(a,b){if(a.b&&a.b==b)a.b=null;else{var c;if(c=a.a)c=Xd(b),c=P(a.a.a.b,c);c&&od(a.a.a,Xd(b))}}Zd.prototype.cancel=function(){this.c=fe(this);this.b?(this.b.cancel(),this.b=null):this.a&&0!=this.a.a.c&&(ra(this.a.A(),function(a){a.cancel()}),nd(this.a.a))};function fe(a){if(null!=a.b)return a.c.concat(a.b.u);if(null!=a.a&&0!=a.a.a.c){var b=a.c;ra(a.a.A(),function(a){b=b.concat(a.u)});return b}return wa(a.c)}function ge(a,b){a.c=a.c.concat(b)};function he(){}he.prototype.stringify=function(a){return k.JSON.stringify(a,void 0)};he.prototype.parse=function(a){return k.JSON.parse(a,void 0)};function ie(){this.a=new he}function je(a,b,c){var d=c||\"\";try{ld(a,function(a,c){var e=a;ea(a)&&(e=Db(a));b.push(d+c+\"=\"+encodeURIComponent(e))})}catch(e){throw b.push(d+\"type=\"+encodeURIComponent(\"_badmap\")),e;}};function ke(a,b){var c=new sc;G(c,\"TestLoadImage: loading \"+a);var d=new Image;d.onload=ja(le,c,d,\"TestLoadImage: loaded\",!0,b);d.onerror=ja(le,c,d,\"TestLoadImage: error\",!1,b);d.onabort=ja(le,c,d,\"TestLoadImage: abort\",!1,b);d.ontimeout=ja(le,c,d,\"TestLoadImage: timeout\",!1,b);k.setTimeout(function(){if(d.ontimeout)d.ontimeout()},1E4);d.src=a}function le(a,b,c,d,e){try{G(a,c),b.onload=null,b.onerror=null,b.onabort=null,b.ontimeout=null,e(d)}catch(f){xc(a,f)}};function T(a){A.call(this);this.headers=new O;this.D=a||null;this.c=!1;this.v=this.a=null;this.K=this.u=\"\";this.j=0;this.g=\"\";this.h=this.I=this.s=this.G=!1;this.l=0;this.B=null;this.L=me;this.C=this.o=!1}t(T,A);var me=\"\";T.prototype.b=qc(\"goog.net.XhrIo\");var ne=/^https?$/i,oe=[\"POST\",\"PUT\"];g=T.prototype;\ng.fa=function(a,b,c,d){if(this.a)throw Error(\"[goog.net.XhrIo] Object is active with another request=\"+this.u+\"; newUri=\"+a);b=b?b.toUpperCase():\"GET\";this.u=a;this.g=\"\";this.j=0;this.K=b;this.G=!1;this.c=!0;this.a=this.D?Pc(this.D):Pc(Nc);this.v=this.D?Lc(this.D):Lc(Nc);this.a.onreadystatechange=q(this.Ma,this);try{D(this.b,U(this,\"Opening Xhr\")),this.I=!0,this.a.open(b,String(a),!0),this.I=!1}catch(f){D(this.b,U(this,\"Error opening Xhr: \"+f.message));pe(this,f);return}a=c||\"\";var e=new O(this.headers);\nd&&ld(d,function(a,b){e.set(b,a)});d=sa(e.M());c=k.FormData&&a instanceof k.FormData;!(0<=qa(oe,b))||d||c||e.set(\"Content-Type\",\"application/x-www-form-urlencoded;charset=utf-8\");e.forEach(function(a,b){this.a.setRequestHeader(b,a)},this);this.L&&(this.a.responseType=this.L);\"withCredentials\"in this.a&&this.a.withCredentials!==this.o&&(this.a.withCredentials=this.o);try{qe(this),0<this.l&&(this.C=re(this.a),D(this.b,U(this,\"Will abort after \"+this.l+\"ms if incomplete, xhr2 \"+this.C)),this.C?(this.a.timeout=\nthis.l,this.a.ontimeout=q(this.Ja,this)):this.B=Zb(this.Ja,this.l,this)),D(this.b,U(this,\"Sending request\")),this.s=!0,this.a.send(a),this.s=!1}catch(f){D(this.b,U(this,\"Send error: \"+f.message)),pe(this,f)}};function re(a){return y&&Va(9)&&\"number\"==typeof a.timeout&&void 0!==a.ontimeout}function ta(a){return\"content-type\"==a.toLowerCase()}\ng.Ja=function(){\"undefined\"!=typeof goog&&this.a&&(this.g=\"Timed out after \"+this.l+\"ms, aborting\",this.j=8,D(this.b,U(this,this.g)),this.dispatchEvent(\"timeout\"),this.abort(8))};function pe(a,b){a.c=!1;a.a&&(a.h=!0,a.a.abort(),a.h=!1);a.g=b;a.j=5;se(a);te(a)}function se(a){a.G||(a.G=!0,a.dispatchEvent(\"complete\"),a.dispatchEvent(\"error\"))}\ng.abort=function(a){this.a&&this.c&&(D(this.b,U(this,\"Aborting\")),this.c=!1,this.h=!0,this.a.abort(),this.h=!1,this.j=a||7,this.dispatchEvent(\"complete\"),this.dispatchEvent(\"abort\"),te(this))};g.w=function(){this.a&&(this.c&&(this.c=!1,this.h=!0,this.a.abort(),this.h=!1),te(this,!0));T.H.w.call(this)};g.Ma=function(){this.i||(this.I||this.s||this.h?ue(this):this.eb())};g.eb=function(){ue(this)};\nfunction ue(a){if(a.c&&\"undefined\"!=typeof goog)if(a.v[1]&&4==N(a)&&2==a.W())D(a.b,U(a,\"Local request error detected and ignored\"));else if(a.s&&4==N(a))Zb(a.Ma,0,a);else if(a.dispatchEvent(\"readystatechange\"),4==N(a)){D(a.b,U(a,\"Request complete\"));a.c=!1;try{var b=a.W();a:switch(b){case 200:case 201:case 202:case 204:case 206:case 304:case 1223:var c=!0;break a;default:c=!1}var d;if(!(d=c)){var e;if(e=0===b){var f=String(a.u).match(pd)[1]||null;if(!f&&k.self&&k.self.location){var h=k.self.location.protocol;\nf=h.substr(0,h.length-1)}e=!ne.test(f?f.toLowerCase():\"\")}d=e}d?(a.dispatchEvent(\"complete\"),a.dispatchEvent(\"success\")):(a.j=6,a.g=a.Ga()+\" [\"+a.W()+\"]\",se(a))}finally{te(a)}}}function te(a,b){if(a.a){qe(a);var c=a.a,d=a.v[0]?aa:null;a.a=null;a.v=null;b||a.dispatchEvent(\"ready\");try{c.onreadystatechange=d}catch(e){(a=a.b)&&a.log(ic,\"Problem encountered resetting onreadystatechange: \"+e.message,void 0)}}}function qe(a){a.a&&a.C&&(a.a.ontimeout=null);a.B&&(k.clearTimeout(a.B),a.B=null)}\nfunction N(a){return a.a?a.a.readyState:0}g.W=function(){try{return 2<N(this)?this.a.status:-1}catch(a){return-1}};g.Ga=function(){try{return 2<N(this)?this.a.statusText:\"\"}catch(a){return D(this.b,\"Can not get status: \"+a.message),\"\"}};g.V=function(){try{return this.a?this.a.responseText:\"\"}catch(a){return D(this.b,\"Can not get responseText: \"+a.message),\"\"}};\ng.Za=function(a){if(this.a){var b=this.a.responseText;a&&0==b.indexOf(a)&&(b=b.substring(a.length));a:{a=b;if(k.JSON)try{var c=k.JSON.parse(a);break a}catch(d){}c=Cb(a)}return c}};function hd(a,b){return a.a?a.a.getResponseHeader(b):null}g.Fa=function(){return this.j};g.bb=function(){return l(this.g)?this.g:String(this.g)};function U(a,b){return b+\" [\"+a.K+\" \"+a.u+\" \"+a.W()+\"]\"};function ve(a){var b=\"\";Ca(a,function(a,d){b+=d;b+=\":\";b+=a;b+=\"\\r\\n\"});return b}function we(a,b,c){a:{for(d in c){var d=!1;break a}d=!0}if(d)return a;c=ve(c);if(l(a)){b=encodeURIComponent(String(b));c=null!=c?\"=\"+encodeURIComponent(String(c)):\"\";if(b+=c){c=a.indexOf(\"#\");0>c&&(c=a.length);d=a.indexOf(\"?\");if(0>d||d>c){d=c;var e=\"\"}else e=a.substring(d+1,c);a=[a.substr(0,d),e,a.substr(c)];c=a[1];a[1]=b?c?c+\"&\"+b:b:c;a=a[0]+(a[1]?\"?\"+a[1]:\"\")+a[2]}return a}R(a,b,c);return a};function xe(a){this.xa=0;this.g=[];this.a=new sc;this.I=new Vd;this.X=this.ua=this.D=this.ja=this.b=this.K=this.j=this.U=this.h=this.L=this.i=null;this.Va=this.R=0;this.Ua=a&&a.Eb||!1;this.ka=this.C=this.s=this.l=this.m=this.f=null;this.u=this.wa=this.N=-1;this.T=this.B=this.v=0;this.G=void 0;this.S=a&&a.supportsCrossDomainXhr||!1;this.J=\"\";this.c=new Zd(a&&a.concurrentRequestLimit);this.la=new ie;this.o=a&&void 0!==a.backgroundChannelTest?a.backgroundChannelTest:!0;(this.va=a&&a.fastHandshake||!1)&&\n!this.o&&(C(this.a.a,\"Force backgroundChannelTest when fastHandshake is enabled.\"),this.o=!0);a&&a.Ea&&this.a.Ea()}g=xe.prototype;g.na=8;g.F=1;\nfunction ye(a){G(a.a,\"disconnect()\");ze(a);if(3==a.F){var b=a.R++,c=M(a.D);R(c,\"SID\",a.J);R(c,\"RID\",b);R(c,\"TYPE\",\"terminate\");Ae(a,c);b=new L(a,a.a,b,void 0);b.J=2;b.h=Vc(M(c));c=!1;k.navigator&&k.navigator.sendBeacon&&(c=k.navigator.sendBeacon(b.h.toString(),\"\"));!c&&k.Image&&((new Image).src=b.h,c=!0);c||(b.a=b.i.ca(null),b.a.fa(b.h));b.D=r();Yc(b)}Be(a)}\nfunction ze(a){a.C&&(a.C.abort(),a.C=null);a.b&&(a.b.cancel(),a.b=null);a.l&&(k.clearTimeout(a.l),a.l=null);Ce(a);a.c.cancel();a.m&&(k.clearTimeout(a.m),a.m=null)}function De(a,b){1E3==a.g.length&&H(a.a,function(){return\"Already have 1000 queued maps upon queueing \"+Db(b)});a.g.push(new Yd(a.Va++,b));3==a.F&&Ee(a)}g.Ka=function(){return 0==this.F};function Ee(a){ce(a.c)||a.m||(a.m=Dc(q(a.Pa,a),0),a.v=0)}\nfunction Fe(a,b){var c=a.c;if((c.b?1:c.a?c.a.a.c:0)>=a.c.f-(a.m?1:0))return H(a.a,\"Unexpected retry request is scheduled.\"),!1;if(a.m)return G(a.a,\"Use the retry request that is already scheduled.\"),a.g=b.u.concat(a.g),!0;if(1==a.F||2==a.F||a.v>=(a.Ua?0:2))return!1;G(a.a,\"Going to retry POST\");a.m=Dc(q(a.Pa,a,b),Ge(a,a.v));a.v++;return!0}\ng.Pa=function(a){this.m=null;G(this.a,\"startForwardChannel_\");if(1==this.F)if(a)H(this.a,\"Not supposed to retry the open\");else{G(this.a,\"open_()\");this.R=Math.floor(1E5*Math.random());a=this.R++;var b=new L(this,this.a,a,void 0),c=this.i;this.L&&(c?(c=Fa(c),Ha(c,this.L)):c=this.L);null===this.h&&(b.j=c);var d=He(this,b),e=M(this.D);R(e,\"RID\",a);R(e,\"CVER\",22);this.o&&this.j&&R(e,\"X-HTTP-Session-Id\",this.j);Ae(this,e);this.h&&c&&we(e,this.h,c);be(this.c,b);this.va?(R(e,\"$req\",d),R(e,\"SID\",\"null\"),\nb.X=!0,Uc(b,e,null)):Uc(b,e,d);this.F=2}else 3==this.F&&(a?Ie(this,a):0==this.g.length?G(this.a,\"startForwardChannel_ returned: nothing to send\"):ce(this.c)?H(this.a,\"startForwardChannel_ returned: connection already in progress\"):(Ie(this),G(this.a,\"startForwardChannel_ finished, sent request\")))};\nfunction Ie(a,b){var c;b?c=b.c:c=a.R++;var d=M(a.D);R(d,\"SID\",a.J);R(d,\"RID\",c);R(d,\"AID\",a.N);Ae(a,d);a.h&&a.i&&we(d,a.h,a.i);c=new L(a,a.a,c,a.v+1);null===a.h&&(c.j=a.i);b&&(a.g=b.u.concat(a.g));b=He(a,c);c.setTimeout(1E4+Math.round(1E4*Math.random()));be(a.c,c);Uc(c,d,b)}function Ae(a,b){a.f&&ld({},function(a,d){R(b,d,a)})}\nfunction He(a,b){var c=Math.min(a.g.length,1E3),d=a.f?q(a.f.Wa,a.f,a):null;a:for(var e=a.g,f=-1;;){var h=[\"count=\"+c];-1==f?0<c?(f=e[0].a,h.push(\"ofs=\"+f)):f=0:h.push(\"ofs=\"+f);for(var m=!0,v=0;v<c;v++){var I=e[v].a,W=e[v].b;I-=f;if(0>I)f=Math.max(0,e[v].a-100),m=!1;else try{je(W,h,\"req\"+I+\"_\")}catch(Lb){d&&d(W)}}if(m){d=h.join(\"&\");break a}}a=a.g.splice(0,c);b.u=a;return d}function Je(a){if(!a.b&&!a.l){a.T=1;var b=a.Oa;Tb||Ub();Wb||(Tb(),Wb=!0);Pb.add(b,a);a.B=0}}\nfunction Ke(a){if(a.b||a.l)return H(a.a,\"Request already in progress\"),!1;if(3<=a.B)return!1;G(a.a,\"Going to retry GET\");a.T++;a.l=Dc(q(a.Oa,a),Ge(a,a.B));a.B++;return!0}\ng.Oa=function(){this.l=null;G(this.a,\"Creating new HttpRequest\");this.b=new L(this,this.a,\"rpc\",this.T);null===this.h&&(this.b.j=this.i);this.b.N=0;var a=M(this.ua);R(a,\"RID\",\"rpc\");R(a,\"SID\",this.J);R(a,\"CI\",this.ka?\"0\":\"1\");R(a,\"AID\",this.N);Ae(this,a);R(a,\"TYPE\",\"xmlhttp\");this.h&&this.i&&we(a,this.h,this.i);this.G&&this.b.setTimeout(this.G);Xc(this.b,a,!0,this.X);G(this.a,\"New Request created\")};\nfunction Sd(a,b,c){G(a.a,\"Test Connection Finished\");var d=b.l;d&&ae(a.c,d);a.ka=c;a.u=b.f;G(a.a,\"connectChannel_()\");a.D=Le(a,a.ja);Ee(a)}function Ud(a,b){G(a.a,\"Test Connection Failed\");a.u=b.f;V(a,2)}\ng.Na=function(a,b){if(0!=this.F&&(this.b==a||de(this.c,a)))if(this.u=a.C,!a.v&&de(this.c,a)&&3==this.F){try{var c=this.la.a.parse(b)}catch(f){c=null}if(n(c)&&3==c.length)if(b=c,0==b[0])a:if(G(this.a,\"Server claims our backchannel is missing.\"),this.l)G(this.a,\"But we are currently starting the request.\");else{if(this.b)if(this.b.D+3E3<a.D)Ce(this),this.b.cancel(),this.b=null;else break a;else C(this.a.a,\"We do not have a BackChannel established\");Ke(this);K(18)}else this.wa=b[1],a=this.wa-this.N,\n0<a&&(b=b[2],G(this.a,b+\" bytes (in \"+a+\" arrays) are outstanding on the BackChannel\"),37500>b&&this.ka&&0==this.B&&!this.s&&(this.s=Dc(q(this.cb,this),6E3)));else G(this.a,\"Bad POST response data returned\"),V(this,11)}else if((a.v||this.b==a)&&Ce(this),!xa(b))for(b=c=this.la.a.parse(b),c=0;c<b.length;c++){var d=b[c];this.N=d[0];d=d[1];if(2==this.F)if(\"c\"==d[0]){this.J=d[1];this.X=d[2];var e=d[3];null!=e&&(this.na=e,E(this.a,\"VER=\"+this.na));e=d[4];null!=e&&(this.xa=e,E(this.a,\"SVER=\"+this.xa));d=\nd[5];null!=d&&\"number\"==typeof d&&0<d&&(this.G=d*=1.5,E(this.a,\"backChannelRequestTimeoutMs_=\"+d));this.o&&(d=a.a)&&((e=hd(d,\"X-Client-Wire-Protocol\"))&&ae(this.c,e),this.j&&((d=hd(d,\"X-HTTP-Session-Id\"))?(this.K=d,R(this.D,this.j,d)):C(this.a.a,\"Missing X_HTTP_SESSION_ID in the handshake response\")));this.F=3;this.f&&this.f.Ca();d=a;this.ua=Td(this,this.X,this.ja);d.v?(G(this.a,\"Upgrade the handshake request to a backchannel.\"),ee(this.c,d),(e=this.G)&&d.setTimeout(e),d.s&&(ad(d),Yc(d)),this.b=d):\nJe(this)}else\"stop\"!=d[0]&&\"close\"!=d[0]||V(this,7);else 3==this.F&&(\"stop\"==d[0]||\"close\"==d[0]?\"stop\"==d[0]?V(this,7):ye(this):\"noop\"!=d[0]&&this.f&&this.f.Ba(d),this.B=0)}};g.cb=function(){null!=this.s&&(this.s=null,this.b.cancel(),this.b=null,Ke(this),K(19))};function Ce(a){null!=a.s&&(k.clearTimeout(a.s),a.s=null)}\ng.ta=function(a){G(this.a,\"Request complete\");var b=null;if(this.b==a){Ce(this);this.b=null;var c=2}else if(de(this.c,a))b=a.u,ee(this.c,a),c=1;else return;this.u=a.C;if(0!=this.F)if(a.f)1==c?(Cc(a.l?a.l.length:0,r()-a.D,this.v),Ee(this)):Je(this);else{var d=a.m;if(3==d||0==d&&0<this.u)G(this.a,\"Not retrying due to error type\");else{var e=this;G(this.a,function(){return\"Maybe retrying, last error: \"+Rc(d,e.u)});if(1==c&&Fe(this,a)||2==c&&Ke(this))return;G(this.a,\"Exceeded max number of retries\")}b&&\n0<b.length&&ge(this.c,b);G(this.a,\"Error: HTTP request failed\");switch(d){case 1:V(this,5);break;case 4:V(this,10);break;case 3:V(this,6);break;default:V(this,2)}}};function Ge(a,b){var c=5E3+Math.floor(1E4*Math.random());a.qa()||(G(a.a,\"Inactive channel\"),c*=2);return c*b}\nfunction V(a,b){E(a.a,\"Error code \"+b);if(2==b){var c=null;a.f&&(c=null);var d=q(a.kb,a);c||(c=new Q(\"//www.google.com/images/cleardot.gif\"),k.location&&\"http\"==k.location.protocol||rd(c,\"https\"),Vc(c));ke(c.toString(),d)}else K(2);G(a.a,\"HttpChannel: error - \"+b);a.F=0;a.f&&a.f.Aa(b);Be(a);ze(a)}g.kb=function(a){a?(E(this.a,\"Successfully pinged google.com\"),K(2)):(E(this.a,\"Failed to ping google.com\"),K(1))};\nfunction Be(a){a.F=0;a.u=-1;if(a.f){var b=fe(a.c);if(0!=b.length||0!=a.g.length)G(a.a,function(){return\"Number of undelivered maps, pending: \"+b.length+\", outgoing: \"+a.g.length}),a.c.c.length=0,wa(a.g),a.g.length=0;a.f.za()}}function Le(a,b){b=Me(a,null,b);G(a.a,\"GetForwardChannelUri: \"+b);return b}function Td(a,b,c){b=Me(a,a.ia()?b:null,c);G(a.a,\"GetBackChannelUri: \"+b);return b}\nfunction Me(a,b,c){var d=Gd(c);if(\"\"!=d.b)b&&sd(d,b+\".\"+d.b),td(d,d.i);else{var e=k.location,f;b?f=b+\".\"+e.hostname:f=e.hostname;d=Hd(e.protocol,f,e.port,c)}a.U&&Ca(a.U,function(a,b){R(d,b,a)});b=a.j;c=a.K;b&&c&&R(d,b,c);R(d,\"VER\",a.na);Ae(a,d);return d}g.ca=function(a){if(a&&!this.S)throw Error(\"Can't create secondary domain capable XhrIo object.\");a=new T;a.o=this.S;return a};g.qa=function(){return!!this.f&&!0};g.ia=function(){return this.S};new Pd;function Ne(){}g=Ne.prototype;g.Ca=function(){};\ng.Ba=function(){};g.Aa=function(){};g.za=function(){};g.Wa=function(){};function Oe(a){for(var b=arguments[0],c=1;c<arguments.length;c++){var d=arguments[c];if(0==d.lastIndexOf(\"/\",0))b=d;else{var e;(e=\"\"==b)||(e=b.length-1,e=0<=e&&b.indexOf(\"/\",e)==e);e?b+=d:b+=\"/\"+d}}return b};function Pe(){if(y&&!(10<=Number(Wa)))throw Error(\"Environmental error: no available transport.\");}Pe.prototype.a=function(a,b){return new X(a,b)};\nfunction X(a,b){A.call(this);this.a=new xe(b);this.b=a;this.o=b&&b.testUrl?b.testUrl:Oe(this.b,\"test\");this.c=qc(\"goog.labs.net.webChannel.WebChannelBaseTransport\");this.g=b&&b.messageUrlParams||null;a=b&&b.messageHeaders||null;b&&b.clientProtocolHeaderRequired&&(a?a[\"X-Client-Protocol\"]=\"webchannel\":a={\"X-Client-Protocol\":\"webchannel\"});this.a.i=a;a=b&&b.initMessageHeaders||null;b&&b.messageContentType&&(a?a[\"X-WebChannel-Content-Type\"]=b.messageContentType:a={\"X-WebChannel-Content-Type\":b.messageContentType});\nb&&b.Da&&(a?a[\"X-WebChannel-Client-Profile\"]=b.Da:a={\"X-WebChannel-Client-Profile\":b.Da});this.a.L=a;(a=b&&b.httpHeadersOverwriteParam)&&!xa(a)&&(this.a.h=a);this.l=b&&b.supportsCrossDomainXhr||!1;this.j=b&&b.sendRawJson||!1;(b=b&&b.httpSessionIdParam)&&!xa(b)&&(this.a.j=b,a=this.g,null!==a&&b in a&&(a=this.g,b in a&&delete a[b],C(this.c,\"Ignore httpSessionIdParam also specified with messageUrlParams: \"+b)));this.h=new Qe(this)}t(X,A);g=X.prototype;\ng.addEventListener=function(a,b,c,d){X.H.addEventListener.call(this,a,b,c,d)};g.removeEventListener=function(a,b,c,d){X.H.removeEventListener.call(this,a,b,c,d)};\ng.$a=function(){this.a.f=this.h;this.l&&(this.a.S=!0);var a=this.a,b=this.o,c=this.b,d=this.g||void 0;G(a.a,\"connect()\");K(0);a.ja=c;a.U=d||{};a.o&&(G(a.a,\"connect() bypassed channel-test.\"),a.I.b=[],a.I.a=!1);G(a.a,\"connectTest_()\");a.C=new Qd(a,a.a);null===a.h&&(a.C.i=a.i);c=b;a.h&&a.i&&(c=we(b,a.h,a.i));a=a.C;a.m=c;b=Le(a.a,a.m);K(3);c=a.a.I.b;null!=c?(a.g=c[0],a.P=1,Rd(a)):(Zc(b,\"MODE\",\"init\"),!a.a.o&&a.a.j&&Zc(b,\"X-HTTP-Session-Id\",a.a.j),a.c=new L(a,a.b,void 0,void 0),a.c.j=a.i,Xc(a.c,b,!1,\nnull),a.P=0)};g.close=function(){ye(this.a)};g.ab=function(a){if(l(a)){var b={};b.__data__=a;De(this.a,b)}else this.j?(b={},b.__data__=Db(a),De(this.a,b)):De(this.a,a)};g.w=function(){this.a.f=null;delete this.h;ye(this.a);delete this.a;X.H.w.call(this)};function Re(a){Ic.call(this);var b=a.__sm__;if(b){a:{for(var c in b){a=c;break a}a=void 0}(this.c=a)?(a=this.c,this.data=null!==b&&a in b?b[a]:void 0):this.data=b}else this.data=a}t(Re,Ic);function Se(){Jc.call(this);this.status=1}t(Se,Jc);\nfunction Qe(a){this.a=a}t(Qe,Ne);Qe.prototype.Ca=function(){rc(this.a.c,\"WebChannel opened on \"+this.a.b);this.a.dispatchEvent(\"a\")};Qe.prototype.Ba=function(a){this.a.dispatchEvent(new Re(a))};Qe.prototype.Aa=function(a){rc(this.a.c,\"WebChannel aborted on \"+this.a.b+\" due to channel error: \"+a);this.a.dispatchEvent(new Se(a))};Qe.prototype.za=function(){rc(this.a.c,\"WebChannel closed on \"+this.a.b);this.a.dispatchEvent(\"b\")};var Te=ja(function(a,b){function c(){}c.prototype=a.prototype;var d=new c;a.apply(d,Array.prototype.slice.call(arguments,1));return d},Pe);function Ue(){this.b=[];this.a=[]}function Ve(a){0==a.b.length&&(a.b=a.a,a.b.reverse(),a.a=[]);return a.b.pop()}function We(a){return a.b.length+a.a.length}Ue.prototype.A=function(){for(var a=[],b=this.b.length-1;0<=b;--b)a.push(this.b[b]);var c=this.a.length;for(b=0;b<c;++b)a.push(this.a[b]);return a};function Xe(a,b){u.call(this);this.h=a||0;this.c=b||10;if(this.h>this.c)throw Error(Ye);this.a=new Ue;this.b=new Wd;this.g=null;this.aa()}t(Xe,u);var Ye=\"[goog.structs.Pool] Min can not be greater than max\";g=Xe.prototype;g.da=function(){var a=r();if(!(null!=this.g&&0>a-this.g)){for(var b;0<We(this.a)&&(b=Ve(this.a),!this.sa(b));)this.aa();!b&&Ze(this)<this.c&&(b=this.pa());b&&(this.g=a,this.b.add(b));return b}};g.jb=function(a){return od(this.b.a,Xd(a))?(this.ma(a),!0):!1};\ng.ma=function(a){od(this.b.a,Xd(a));this.sa(a)&&Ze(this)<this.c?this.a.a.push(a):$e(a)};g.aa=function(){for(var a=this.a;Ze(this)<this.h;){var b=this.pa();a.a.push(b)}for(;Ze(this)>this.c&&0<We(this.a);)$e(Ve(a))};g.pa=function(){return{}};function $e(a){if(\"function\"==typeof a.$)a.$();else for(var b in a)a[b]=null}g.sa=function(a){return\"function\"==typeof a.Xa?a.Xa():!0};function Ze(a){return We(a.a)+a.b.a.c}\ng.w=function(){Xe.H.w.call(this);if(0<this.b.a.c)throw Error(\"[goog.structs.Pool] Objects not released\");delete this.b;for(var a=this.a;0!=a.b.length||0!=a.a.length;)$e(Ve(a));delete this.a};function af(a,b){this.a=a;this.b=b};function bf(a){this.a=[];if(a)a:{if(a instanceof bf){var b=a.M();a=a.A();if(0>=this.a.length){for(var c=this.a,d=0;d<b.length;d++)c.push(new af(b[d],a[d]));break a}}else b=Ea(a),a=Da(a);for(d=0;d<b.length;d++)cf(this,b[d],a[d])}}function cf(a,b,c){var d=a.a;d.push(new af(b,c));b=d.length-1;a=a.a;for(c=a[b];0<b;)if(d=b-1>>1,a[d].a>c.a)a[b]=a[d],b=d;else break;a[b]=c}bf.prototype.A=function(){for(var a=this.a,b=[],c=a.length,d=0;d<c;d++)b.push(a[d].b);return b};\nbf.prototype.M=function(){for(var a=this.a,b=[],c=a.length,d=0;d<c;d++)b.push(a[d].a);return b};function df(){bf.call(this)}t(df,bf);function Y(a,b){this.f=new df;Xe.call(this,a,b)}t(Y,Xe);g=Y.prototype;g.da=function(a,b){if(!a)return Y.H.da.call(this);cf(this.f,void 0!==b?b:100,a);this.ra()};g.ra=function(){for(var a=this.f;0<a.a.length;){var b=this.da();if(b){var c=a,d=c.a,e=d.length;var f=d[0];if(0>=e)f=void 0;else{if(1==e)ua(d);else{d[0]=d.pop();d=0;c=c.a;e=c.length;for(var h=c[d];d<e>>1;){var m=2*d+1,v=2*d+2;m=v<e&&c[v].a<c[m].a?v:m;if(c[m].a>h.a)break;c[d]=c[m];d=m}c[d]=h}f=f.b}f.apply(this,[b])}else break}};\ng.ma=function(a){Y.H.ma.call(this,a);this.ra()};g.aa=function(){Y.H.aa.call(this);this.ra()};g.w=function(){Y.H.w.call(this);k.clearTimeout(void 0);ua(this.f.a);this.f=null};function Z(a,b,c,d){this.l=a;this.j=!!d;Y.call(this,b,c)}t(Z,Y);Z.prototype.pa=function(){var a=new T,b=this.l;b&&b.forEach(function(b,d){a.headers.set(d,b)});this.j&&(a.o=!0);return a};Z.prototype.sa=function(a){return!a.i&&!a.a};Pe.prototype.createWebChannel=Pe.prototype.a;X.prototype.send=X.prototype.ab;X.prototype.open=X.prototype.$a;X.prototype.close=X.prototype.close;Ec.NO_ERROR=0;Ec.TIMEOUT=8;Ec.HTTP_ERROR=6;Fc.COMPLETE=\"complete\";Gc.EventType=Hc;Hc.OPEN=\"a\";Hc.CLOSE=\"b\";Hc.ERROR=\"c\";Hc.MESSAGE=\"d\";A.prototype.listen=A.prototype.Ha;Z.prototype.getObject=Z.prototype.da;Z.prototype.releaseObject=Z.prototype.jb;T.prototype.listenOnce=T.prototype.Ia;T.prototype.getLastError=T.prototype.bb;T.prototype.getLastErrorCode=T.prototype.Fa;\nT.prototype.getStatus=T.prototype.W;T.prototype.getStatusText=T.prototype.Ga;T.prototype.getResponseJson=T.prototype.Za;T.prototype.getResponseText=T.prototype.V;T.prototype.getResponseText=T.prototype.V;T.prototype.send=T.prototype.fa;module.exports={createWebChannelTransport:Te,ErrorCode:Ec,EventType:Fc,WebChannel:Gc,XhrIoPool:Z};}).call(typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {})\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))\n\n/***/ }),\n\n/***/ 22:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n\n// CONCATENATED MODULE: ../logger/dist/esm/src/logger.js\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A container for all of the Logger instances\n */\nvar instances = [];\n/**\n * The JS SDK supports 5 log levels and also allows a user the ability to\n * silence the logs altogether.\n *\n * The order is a follows:\n * DEBUG < VERBOSE < INFO < WARN < ERROR\n *\n * All of the log types above the current log level will be captured (i.e. if\n * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and\n * `VERBOSE` logs will not)\n */\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogLevel[LogLevel[\"VERBOSE\"] = 1] = \"VERBOSE\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"WARN\"] = 3] = \"WARN\";\n    LogLevel[LogLevel[\"ERROR\"] = 4] = \"ERROR\";\n    LogLevel[LogLevel[\"SILENT\"] = 5] = \"SILENT\";\n})(LogLevel || (LogLevel = {}));\n/**\n * The default log level\n */\nvar defaultLogLevel = LogLevel.INFO;\n/**\n * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR\n * messages on to their corresponding console counterparts (if the log method\n * is supported by the current log level)\n */\nvar defaultLogHandler = function (instance, logType) {\n    var args = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        args[_i - 2] = arguments[_i];\n    }\n    if (logType < instance.logLevel)\n        return;\n    var now = new Date().toISOString();\n    switch (logType) {\n        /**\n         * By default, `console.debug` is not displayed in the developer console (in\n         * chrome). To avoid forcing users to have to opt-in to these logs twice\n         * (i.e. once for firebase, and once in the console), we are sending `DEBUG`\n         * logs to the `console.log` function.\n         */\n        case LogLevel.DEBUG:\n            console.log.apply(console, [\"[\" + now + \"]  \" + instance.name + \":\"].concat(args));\n            break;\n        case LogLevel.VERBOSE:\n            console.log.apply(console, [\"[\" + now + \"]  \" + instance.name + \":\"].concat(args));\n            break;\n        case LogLevel.INFO:\n            console.info.apply(console, [\"[\" + now + \"]  \" + instance.name + \":\"].concat(args));\n            break;\n        case LogLevel.WARN:\n            console.warn.apply(console, [\"[\" + now + \"]  \" + instance.name + \":\"].concat(args));\n            break;\n        case LogLevel.ERROR:\n            console.error.apply(console, [\"[\" + now + \"]  \" + instance.name + \":\"].concat(args));\n            break;\n        default:\n            throw new Error(\"Attempted to log a message with an invalid logType (value: \" + logType + \")\");\n    }\n};\nvar Logger = /** @class */ (function () {\n    /**\n     * Gives you an instance of a Logger to capture messages according to\n     * Firebase's logging scheme.\n     *\n     * @param name The name that the logs will be associated with\n     */\n    function Logger(name) {\n        this.name = name;\n        /**\n         * The log level of the given Logger instance.\n         */\n        this._logLevel = defaultLogLevel;\n        /**\n         * The log handler for the Logger instance.\n         */\n        this._logHandler = defaultLogHandler;\n        /**\n         * Capture the current instance for later use\n         */\n        instances.push(this);\n    }\n    Object.defineProperty(Logger.prototype, \"logLevel\", {\n        get: function () {\n            return this._logLevel;\n        },\n        set: function (val) {\n            if (!(val in LogLevel)) {\n                throw new TypeError('Invalid value assigned to `logLevel`');\n            }\n            this._logLevel = val;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Logger.prototype, \"logHandler\", {\n        get: function () {\n            return this._logHandler;\n        },\n        set: function (val) {\n            if (typeof val !== 'function') {\n                throw new TypeError('Value assigned to `logHandler` must be a function');\n            }\n            this._logHandler = val;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * The functions below are all based on the `console` interface\n     */\n    Logger.prototype.debug = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        this._logHandler.apply(this, [this, LogLevel.DEBUG].concat(args));\n    };\n    Logger.prototype.log = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        this._logHandler.apply(this, [this, LogLevel.VERBOSE].concat(args));\n    };\n    Logger.prototype.info = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        this._logHandler.apply(this, [this, LogLevel.INFO].concat(args));\n    };\n    Logger.prototype.warn = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        this._logHandler.apply(this, [this, LogLevel.WARN].concat(args));\n    };\n    Logger.prototype.error = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        this._logHandler.apply(this, [this, LogLevel.ERROR].concat(args));\n    };\n    return Logger;\n}());\n\n\n//# sourceMappingURL=logger.js.map\n\n// CONCATENATED MODULE: ../logger/dist/esm/index.js\n/* harmony export (immutable) */ __webpack_exports__[\"setLogLevel\"] = setLogLevel;\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"Logger\", function() { return Logger; });\n/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, \"LogLevel\", function() { return LogLevel; });\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction setLogLevel(level) {\n    instances.forEach(function (inst) {\n        inst.logLevel = level;\n    });\n}\n\n\n//# sourceMappingURL=index.js.map\n\n\n/***/ })\n\n},[115]);\n        } catch(error) {\n          throw new Error(\n            'Cannot instantiate firebase-firestore.js - ' +\n            'be sure to load firebase-app.js first.'\n          )\n        }\n\n\n// WEBPACK FOOTER //\n// firebase-firestore.js","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nrequire('@firebase/firestore');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./firestore/index.js\n// module id = 115\n// module chunks = 1","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* tslint:disable:no-console */\nimport { SDK_VERSION } from '../core/version';\nimport { PlatformSupport } from '../platform/platform';\nimport { Logger, LogLevel as FirebaseLogLevel } from '@firebase/logger';\nvar logClient = new Logger('@firebase/firestore');\nexport var LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogLevel[LogLevel[\"ERROR\"] = 1] = \"ERROR\";\n    LogLevel[LogLevel[\"SILENT\"] = 2] = \"SILENT\";\n})(LogLevel || (LogLevel = {}));\n// Helper methods are needed because variables can't be exported as read/write\nexport function getLogLevel() {\n    if (logClient.logLevel === FirebaseLogLevel.DEBUG) {\n        return LogLevel.DEBUG;\n    }\n    else if (logClient.logLevel === FirebaseLogLevel.SILENT) {\n        return LogLevel.SILENT;\n    }\n    else {\n        return LogLevel.ERROR;\n    }\n}\nexport function setLogLevel(newLevel) {\n    /**\n     * Map the new log level to the associated Firebase Log Level\n     */\n    switch (newLevel) {\n        case LogLevel.DEBUG:\n            logClient.logLevel = FirebaseLogLevel.DEBUG;\n            break;\n        case LogLevel.ERROR:\n            logClient.logLevel = FirebaseLogLevel.ERROR;\n            break;\n        case LogLevel.SILENT:\n            logClient.logLevel = FirebaseLogLevel.SILENT;\n            break;\n        default:\n            logClient.error(\"Firestore (\" + SDK_VERSION + \"): Invalid value passed to `setLogLevel`\");\n    }\n}\nexport function debug(tag, msg) {\n    var obj = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        obj[_i - 2] = arguments[_i];\n    }\n    if (logClient.logLevel <= FirebaseLogLevel.DEBUG) {\n        var args = obj.map(argToString);\n        logClient.debug.apply(logClient, [\"Firestore (\" + SDK_VERSION + \") [\" + tag + \"]: \" + msg].concat(args));\n    }\n}\nexport function error(msg) {\n    var obj = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        obj[_i - 1] = arguments[_i];\n    }\n    if (logClient.logLevel <= FirebaseLogLevel.ERROR) {\n        var args = obj.map(argToString);\n        logClient.error.apply(logClient, [\"Firestore (\" + SDK_VERSION + \"): \" + msg].concat(args));\n    }\n}\n/**\n * Converts an additional log parameter to a string representation.\n */\nfunction argToString(obj) {\n    if (typeof obj === 'string') {\n        return obj;\n    }\n    else {\n        var platform = PlatformSupport.getPlatform();\n        try {\n            return platform.formatJSON(obj);\n        }\n        catch (e) {\n            // Converting to JSON failed, just log the object directly\n            return obj;\n        }\n    }\n}\n\n//# sourceMappingURL=log.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/log.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SDK_VERSION } from '../core/version';\nimport { error } from './log';\n/**\n * Unconditionally fails, throwing an Error with the given message.\n *\n * Returns any so it can be used in expressions:\n * @example\n * let futureVar = fail('not implemented yet');\n */\nexport function fail(failure) {\n    // Log the failure in addition to throw an exception, just in case the\n    // exception is swallowed.\n    var message = \"FIRESTORE (\" + SDK_VERSION + \") INTERNAL ASSERTION FAILED: \" + failure;\n    error(message);\n    // NOTE: We don't use FirestoreError here because these are internal failures\n    // that cannot be handled by the user. (Also it would create a circular\n    // dependency between the error and assert modules which doesn't work.)\n    throw new Error(message);\n}\n/**\n * Fails if the given assertion condition is false, throwing an Error with the\n * given message if it did.\n */\nexport function assert(assertion, message) {\n    if (!assertion) {\n        fail(message);\n    }\n}\n\n//# sourceMappingURL=assert.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/assert.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { fail } from '../util/assert';\n/**\n * Provides singleton helpers where setup code can inject a platform at runtime.\n * setPlatform needs to be set before Firestore is used and must be set exactly\n * once.\n */\nvar PlatformSupport = /** @class */ (function () {\n    function PlatformSupport() {\n    }\n    PlatformSupport.setPlatform = function (platform) {\n        if (PlatformSupport.platform) {\n            fail('Platform already defined');\n        }\n        PlatformSupport.platform = platform;\n    };\n    PlatformSupport.getPlatform = function () {\n        if (!PlatformSupport.platform) {\n            fail('Platform not set');\n        }\n        return PlatformSupport.platform;\n    };\n    return PlatformSupport;\n}());\nexport { PlatformSupport };\n/**\n * Returns the representation of an empty \"proto\" byte string for the\n * platform.\n */\nexport function emptyByteString() {\n    return PlatformSupport.getPlatform().emptyByteString;\n}\n\n//# sourceMappingURL=platform.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/platform/platform.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// We are doing some heavy reflective stuff, lots of any casting necessary\n/* tslint:disable:no-any */\nimport { Code, FirestoreError } from './error';\n/**\n * Helper function to prevent instantiation through the constructor.\n *\n * This method creates a new constructor that throws when it's invoked.\n * The prototype of that constructor is then set to the prototype of the hidden\n * \"class\" to expose all the prototype methods and allow for instanceof\n * checks.\n *\n * To also make all the static methods available, all properties of the\n * original constructor are copied to the new constructor.\n */\nexport function makeConstructorPrivate(cls, optionalMessage) {\n    function PublicConstructor() {\n        var error = 'This constructor is private.';\n        if (optionalMessage) {\n            error += ' ';\n            error += optionalMessage;\n        }\n        throw new FirestoreError(Code.INVALID_ARGUMENT, error);\n    }\n    // Make sure instanceof checks work and all methods are exposed on the public\n    // constructor\n    PublicConstructor.prototype = cls.prototype;\n    // Copy any static methods/members\n    for (var staticProperty in cls) {\n        if (cls.hasOwnProperty(staticProperty)) {\n            PublicConstructor[staticProperty] = cls[staticProperty];\n        }\n    }\n    return PublicConstructor;\n}\n\n//# sourceMappingURL=api.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/api.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from './assert';\nexport function contains(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\nexport function get(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key) ? obj[key] : null;\n}\nexport function size(obj) {\n    var count = 0;\n    for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            count++;\n        }\n    }\n    return count;\n}\n/** Returns the given value if it's defined or the defaultValue otherwise. */\nexport function defaulted(value, defaultValue) {\n    return value !== undefined ? value : defaultValue;\n}\nexport function forEachNumber(obj, fn) {\n    for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            var num = Number(key);\n            if (!isNaN(num)) {\n                fn(num, obj[key]);\n            }\n        }\n    }\n}\nexport function forEach(obj, fn) {\n    for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            fn(key, obj[key]);\n        }\n    }\n}\nexport function lookupOrInsert(obj, key, valFn) {\n    if (!contains(obj, key)) {\n        obj[key] = valFn();\n    }\n    return obj[key];\n}\nexport function isEmpty(obj) {\n    assert(obj != null && typeof obj === 'object', 'isEmpty() expects object parameter.');\n    for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function shallowCopy(obj) {\n    assert(obj && typeof obj === 'object', 'shallowCopy() expects object parameter.');\n    var result = {};\n    for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            result[key] = obj[key];\n        }\n    }\n    return result;\n}\n\n//# sourceMappingURL=obj.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/obj.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { fail } from './assert';\nimport { Code, FirestoreError } from './error';\nimport * as obj from './obj';\n/**\n * Validates the invocation of functionName has the exact number of arguments.\n *\n * Forward the magic \"arguments\" variable as second parameter on which the\n * parameter validation is performed:\n * validateExactNumberOfArgs('myFunction', arguments, 2);\n */\nexport function validateExactNumberOfArgs(functionName, args, numberOfArgs) {\n    if (args.length !== numberOfArgs) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires \" +\n            formatPlural(numberOfArgs, 'argument') +\n            ', but was called with ' +\n            formatPlural(args.length, 'argument') +\n            '.');\n    }\n}\n/**\n * Validates the invocation of functionName has at least the provided number of\n * arguments (but can have many more).\n *\n * Forward the magic \"arguments\" variable as second parameter on which the\n * parameter validation is performed:\n * validateAtLeastNumberOfArgs('myFunction', arguments, 2);\n */\nexport function validateAtLeastNumberOfArgs(functionName, args, minNumberOfArgs) {\n    if (args.length < minNumberOfArgs) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires at least \" +\n            formatPlural(minNumberOfArgs, 'argument') +\n            ', but was called with ' +\n            formatPlural(args.length, 'argument') +\n            '.');\n    }\n}\n/**\n * Validates the invocation of functionName has number of arguments between\n * the values provided.\n *\n * Forward the magic \"arguments\" variable as second parameter on which the\n * parameter validation is performed:\n * validateBetweenNumberOfArgs('myFunction', arguments, 2, 3);\n */\nexport function validateBetweenNumberOfArgs(functionName, args, minNumberOfArgs, maxNumberOfArgs) {\n    if (args.length < minNumberOfArgs || args.length > maxNumberOfArgs) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires between \" + minNumberOfArgs + \" and \" +\n            (maxNumberOfArgs + \" arguments, but was called with \") +\n            formatPlural(args.length, 'argument') +\n            '.');\n    }\n}\n/**\n * Validates the provided argument is an array and has as least the expected\n * number of elements.\n */\nexport function validateNamedArrayAtLeastNumberOfElements(functionName, value, name, minNumberOfElements) {\n    if (!(value instanceof Array) || value.length < minNumberOfElements) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires its \" + name + \" argument to be an \" +\n            'array with at least ' +\n            (formatPlural(minNumberOfElements, 'element') + \".\"));\n    }\n}\n/**\n * Validates the provided positional argument has the native JavaScript type\n * using typeof checks.\n */\nexport function validateArgType(functionName, type, position, argument) {\n    validateType(functionName, type, ordinal(position) + \" argument\", argument);\n}\n/**\n * Validates the provided argument has the native JavaScript type using\n * typeof checks or is undefined.\n */\nexport function validateOptionalArgType(functionName, type, position, argument) {\n    if (argument !== undefined) {\n        validateArgType(functionName, type, position, argument);\n    }\n}\n/**\n * Validates the provided named option has the native JavaScript type using\n * typeof checks.\n */\nexport function validateNamedType(functionName, type, optionName, argument) {\n    validateType(functionName, type, optionName + \" option\", argument);\n}\n/**\n * Validates the provided named option has the native JavaScript type using\n * typeof checks or is undefined.\n */\nexport function validateNamedOptionalType(functionName, type, optionName, argument) {\n    if (argument !== undefined) {\n        validateNamedType(functionName, type, optionName, argument);\n    }\n}\n/**\n * Validates that the provided named option equals one of the expected values.\n */\nexport function validateNamedPropertyEquals(functionName, inputName, optionName, input, expected) {\n    var expectedDescription = [];\n    for (var _i = 0, expected_1 = expected; _i < expected_1.length; _i++) {\n        var val = expected_1[_i];\n        if (val === input) {\n            return;\n        }\n        expectedDescription.push(valueDescription(val));\n    }\n    var actualDescription = valueDescription(input);\n    throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid value \" + actualDescription + \" provided to function \" + functionName + \"() for option \\\"\" + optionName + \"\\\". Acceptable values: \" + expectedDescription.join(', '));\n}\n/**\n * Validates that the provided named option equals one of the expected values or\n * is undefined.\n */\nexport function validateNamedOptionalPropertyEquals(functionName, inputName, optionName, input, expected) {\n    if (input !== undefined) {\n        validateNamedPropertyEquals(functionName, inputName, optionName, input, expected);\n    }\n}\n/** Helper to validate the type of a provided input. */\nfunction validateType(functionName, type, inputName, input) {\n    if (typeof input !== type || (type === 'object' && !isPlainObject(input))) {\n        var description = valueDescription(input);\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires its \" + inputName + \" \" +\n            (\"to be of type \" + type + \", but it was: \" + description));\n    }\n}\n/**\n * Returns true iff it's a non-null object without a custom prototype\n * (i.e. excludes Array, Date, etc.).\n */\nexport function isPlainObject(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        Object.getPrototypeOf(input) === Object.prototype);\n}\n/** Returns a string describing the type / value of the provided input. */\nexport function valueDescription(input) {\n    if (input === undefined) {\n        return 'undefined';\n    }\n    else if (input === null) {\n        return 'null';\n    }\n    else if (typeof input === 'string') {\n        if (input.length > 20) {\n            input = input.substring(0, 20) + \"...\";\n        }\n        return JSON.stringify(input);\n    }\n    else if (typeof input === 'number' || typeof input === 'boolean') {\n        return '' + input;\n    }\n    else if (typeof input === 'object') {\n        if (input instanceof Array) {\n            return 'an array';\n        }\n        else {\n            var customObjectName = tryGetCustomObjectType(input);\n            if (customObjectName) {\n                return \"a custom \" + customObjectName + \" object\";\n            }\n            else {\n                return 'an object';\n            }\n        }\n    }\n    else if (typeof input === 'function') {\n        return 'a function';\n    }\n    else {\n        return fail('Unknown wrong type: ' + typeof input);\n    }\n}\n/** Hacky method to try to get the constructor name for an object. */\nexport function tryGetCustomObjectType(input) {\n    if (input.constructor) {\n        var funcNameRegex = /function\\s+([^\\s(]+)\\s*\\(/;\n        var results = funcNameRegex.exec(input.constructor.toString());\n        if (results && results.length > 1) {\n            return results[1];\n        }\n    }\n    return null;\n}\n/** Validates the provided argument is defined. */\nexport function validateDefined(functionName, position, argument) {\n    if (argument === undefined) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires a valid \" + ordinal(position) + \" \" +\n            \"argument, but it was undefined.\");\n    }\n}\n/**\n * Validates the provided positional argument is an object, and its keys and\n * values match the expected keys and types provided in optionTypes.\n */\nexport function validateOptionNames(functionName, options, optionNames) {\n    obj.forEach(options, function (key, _) {\n        if (optionNames.indexOf(key) < 0) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Unknown option '\" + key + \"' passed to function \" + functionName + \"(). \" +\n                'Available options: ' +\n                optionNames.join(', '));\n        }\n    });\n}\n/**\n * Helper method to throw an error that the provided argument did not pass\n * an instanceof check.\n */\nexport function invalidClassError(functionName, type, position, argument) {\n    var description = valueDescription(argument);\n    return new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + functionName + \"() requires its \" + ordinal(position) + \" \" +\n        (\"argument to be a \" + type + \", but it was: \" + description));\n}\n/** Converts a number to its english word representation */\nfunction ordinal(num) {\n    switch (num) {\n        case 1:\n            return 'first';\n        case 2:\n            return 'second';\n        case 3:\n            return 'third';\n        default:\n            return num + 'th';\n    }\n}\n/**\n * Formats the given word as plural conditionally given the preceding number.\n */\nfunction formatPlural(num, str) {\n    return num + \" \" + str + (num === 1 ? '' : 's');\n}\n\n//# sourceMappingURL=input_validation.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/input_validation.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from './assert';\n// tslint:disable-next-line:class-as-namespace\nvar AutoId = /** @class */ (function () {\n    function AutoId() {\n    }\n    AutoId.newId = function () {\n        // Alphanumeric characters\n        var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n        var autoId = '';\n        for (var i = 0; i < 20; i++) {\n            autoId += chars.charAt(Math.floor(Math.random() * chars.length));\n        }\n        assert(autoId.length === 20, 'Invalid auto ID: ' + autoId);\n        return autoId;\n    };\n    return AutoId;\n}());\nexport { AutoId };\nexport function primitiveComparator(left, right) {\n    if (left < right)\n        return -1;\n    if (left > right)\n        return 1;\n    return 0;\n}\n/** Helper to compare nullable (or undefined-able) objects using isEqual(). */\nexport function equals(left, right) {\n    if (left !== null && left !== undefined) {\n        return !!(right && left.isEqual(right));\n    }\n    else {\n        // HACK: Explicitly cast since TypeScript's type narrowing apparently isn't\n        // smart enough.\n        return left === right;\n    }\n}\n/** Helper to compare arrays using isEqual(). */\nexport function arrayEquals(left, right) {\n    if (left.length !== right.length) {\n        return false;\n    }\n    for (var i = 0; i < left.length; i++) {\n        if (!left[i].isEqual(right[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Returns the largest lexicographically smaller string of equal or smaller\n * length. Returns an empty string if there is no such predecessor (if the input\n * is empty).\n *\n * Strings returned from this method can be invalid UTF-16 but this is sufficent\n * in use for indexeddb because that depends on lexicographical ordering but\n * shouldn't be used elsewhere.\n */\nexport function immediatePredecessor(s) {\n    // We can decrement the last character in the string and be done\n    // unless that character is 0 (0x0000), in which case we have to erase the\n    // last character.\n    var lastIndex = s.length - 1;\n    if (s.length === 0) {\n        // Special case the empty string.\n        return '';\n    }\n    else if (s.charAt(lastIndex) === '\\0') {\n        return s.substring(0, lastIndex);\n    }\n    else {\n        return (s.substring(0, lastIndex) +\n            String.fromCharCode(s.charCodeAt(lastIndex) - 1));\n    }\n}\n/**\n * Returns the immediate lexicographically-following string. This is useful to\n * construct an inclusive range for indexeddb iterators.\n */\nexport function immediateSuccessor(s) {\n    // Return the input string, with an additional NUL byte appended.\n    return s + '\\0';\n}\n\n//# sourceMappingURL=misc.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/misc.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { PlatformSupport } from '../platform/platform';\nimport { makeConstructorPrivate } from '../util/api';\nimport { Code, FirestoreError } from '../util/error';\nimport { invalidClassError, validateArgType, validateExactNumberOfArgs } from '../util/input_validation';\nimport { primitiveComparator } from '../util/misc';\n/** Helper function to assert Uint8Array is available at runtime. */\nfunction assertUint8ArrayAvailable() {\n    if (typeof Uint8Array === 'undefined') {\n        throw new FirestoreError(Code.UNIMPLEMENTED, 'Uint8Arrays are not available in this environment.');\n    }\n}\n/** Helper function to assert Base64 functions are available at runtime. */\nfunction assertBase64Available() {\n    if (!PlatformSupport.getPlatform().base64Available) {\n        throw new FirestoreError(Code.UNIMPLEMENTED, 'Blobs are unavailable in Firestore in this environment.');\n    }\n}\n/**\n * Immutable class holding a blob (binary data).\n * This class is directly exposed in the public API.\n *\n * Note that while you can't hide the constructor in JavaScript code, we are\n * using the hack above to make sure no-one outside this module can call it.\n */\nvar Blob = /** @class */ (function () {\n    function Blob(binaryString) {\n        assertBase64Available();\n        this._binaryString = binaryString;\n    }\n    Blob.fromBase64String = function (base64) {\n        validateExactNumberOfArgs('Blob.fromBase64String', arguments, 1);\n        validateArgType('Blob.fromBase64String', 'string', 1, base64);\n        assertBase64Available();\n        try {\n            var binaryString = PlatformSupport.getPlatform().atob(base64);\n            return new Blob(binaryString);\n        }\n        catch (e) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Failed to construct Blob from Base64 string: ' + e);\n        }\n    };\n    Blob.fromUint8Array = function (array) {\n        validateExactNumberOfArgs('Blob.fromUint8Array', arguments, 1);\n        assertUint8ArrayAvailable();\n        if (!(array instanceof Uint8Array)) {\n            throw invalidClassError('Blob.fromUint8Array', 'Uint8Array', 1, array);\n        }\n        // We can't call array.map directly because it expects the return type to\n        // be a Uint8Array, whereas we can convert it to a regular array by invoking\n        // map on the Array prototype.\n        var binaryString = Array.prototype.map\n            .call(array, function (char) {\n            return String.fromCharCode(char);\n        })\n            .join('');\n        return new Blob(binaryString);\n    };\n    Blob.prototype.toBase64 = function () {\n        validateExactNumberOfArgs('Blob.toBase64', arguments, 0);\n        assertBase64Available();\n        return PlatformSupport.getPlatform().btoa(this._binaryString);\n    };\n    Blob.prototype.toUint8Array = function () {\n        validateExactNumberOfArgs('Blob.toUint8Array', arguments, 0);\n        assertUint8ArrayAvailable();\n        var buffer = new Uint8Array(this._binaryString.length);\n        for (var i = 0; i < this._binaryString.length; i++) {\n            buffer[i] = this._binaryString.charCodeAt(i);\n        }\n        return buffer;\n    };\n    Blob.prototype.toString = function () {\n        return 'Blob(base64: ' + this.toBase64() + ')';\n    };\n    Blob.prototype.isEqual = function (other) {\n        return this._binaryString === other._binaryString;\n    };\n    /**\n     * Actually private to JS consumers of our API, so this function is prefixed\n     * with an underscore.\n     */\n    Blob.prototype._compareTo = function (other) {\n        return primitiveComparator(this._binaryString, other._binaryString);\n    };\n    return Blob;\n}());\nexport { Blob };\n// Public instance that disallows construction at runtime. This constructor is\n// used when exporting Blob on firebase.firestore.Blob and will be called Blob\n// publicly. Internally we still use Blob which has a type checked private\n// constructor. Note that Blob and PublicBlob can be used interchangeably in\n// instanceof checks.\n// For our internal TypeScript code PublicBlob doesn't exist as a type, and so\n// we need to use Blob as type and export it too.\n// tslint:disable-next-line:variable-name We're treating this as a class name.\nexport var PublicBlob = makeConstructorPrivate(Blob, 'Use Blob.fromUint8Array() or Blob.fromBase64String() instead.');\n\n//# sourceMappingURL=blob.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/api/blob.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { assert, fail } from '../util/assert';\nimport { primitiveComparator } from '../util/misc';\nimport { SortedMap } from '../util/sorted_map';\nimport { DocumentKey } from './document_key';\nexport var TypeOrder;\n(function (TypeOrder) {\n    // This order is defined by the backend.\n    TypeOrder[TypeOrder[\"NullValue\"] = 0] = \"NullValue\";\n    TypeOrder[TypeOrder[\"BooleanValue\"] = 1] = \"BooleanValue\";\n    TypeOrder[TypeOrder[\"NumberValue\"] = 2] = \"NumberValue\";\n    TypeOrder[TypeOrder[\"TimestampValue\"] = 3] = \"TimestampValue\";\n    TypeOrder[TypeOrder[\"StringValue\"] = 4] = \"StringValue\";\n    TypeOrder[TypeOrder[\"BlobValue\"] = 5] = \"BlobValue\";\n    TypeOrder[TypeOrder[\"RefValue\"] = 6] = \"RefValue\";\n    TypeOrder[TypeOrder[\"GeoPointValue\"] = 7] = \"GeoPointValue\";\n    TypeOrder[TypeOrder[\"ArrayValue\"] = 8] = \"ArrayValue\";\n    TypeOrder[TypeOrder[\"ObjectValue\"] = 9] = \"ObjectValue\";\n})(TypeOrder || (TypeOrder = {}));\n/** Defines the return value for pending server timestamps. */\nexport var ServerTimestampBehavior;\n(function (ServerTimestampBehavior) {\n    ServerTimestampBehavior[ServerTimestampBehavior[\"Default\"] = 0] = \"Default\";\n    ServerTimestampBehavior[ServerTimestampBehavior[\"Estimate\"] = 1] = \"Estimate\";\n    ServerTimestampBehavior[ServerTimestampBehavior[\"Previous\"] = 2] = \"Previous\";\n})(ServerTimestampBehavior || (ServerTimestampBehavior = {}));\n/** Holds properties that define field value deserialization options. */\nvar FieldValueOptions = /** @class */ (function () {\n    function FieldValueOptions(serverTimestampBehavior) {\n        this.serverTimestampBehavior = serverTimestampBehavior;\n    }\n    FieldValueOptions.fromSnapshotOptions = function (options) {\n        switch (options.serverTimestamps) {\n            case 'estimate':\n                return new FieldValueOptions(ServerTimestampBehavior.Estimate);\n            case 'previous':\n                return new FieldValueOptions(ServerTimestampBehavior.Previous);\n            case 'none': // Fall-through intended.\n            case undefined:\n                return FieldValueOptions.defaultOptions;\n            default:\n                return fail('fromSnapshotOptions() called with invalid options.');\n        }\n    };\n    FieldValueOptions.defaultOptions = new FieldValueOptions(ServerTimestampBehavior.Default);\n    return FieldValueOptions;\n}());\nexport { FieldValueOptions };\n/**\n * A field value represents a datatype as stored by Firestore.\n */\nvar FieldValue = /** @class */ (function () {\n    function FieldValue() {\n    }\n    FieldValue.prototype.toString = function () {\n        var val = this.value();\n        return val === null ? 'null' : val.toString();\n    };\n    FieldValue.prototype.defaultCompareTo = function (other) {\n        assert(this.typeOrder !== other.typeOrder, 'Default compareTo should not be used for values of same type.');\n        var cmp = primitiveComparator(this.typeOrder, other.typeOrder);\n        return cmp;\n    };\n    return FieldValue;\n}());\nexport { FieldValue };\nvar NullValue = /** @class */ (function (_super) {\n    tslib_1.__extends(NullValue, _super);\n    function NullValue() {\n        var _this = _super.call(this) || this;\n        _this.typeOrder = TypeOrder.NullValue;\n        // internalValue is unused but we add it to work around\n        // https://github.com/Microsoft/TypeScript/issues/15585\n        _this.internalValue = null;\n        return _this;\n    }\n    NullValue.prototype.value = function (options) {\n        return null;\n    };\n    NullValue.prototype.isEqual = function (other) {\n        return other instanceof NullValue;\n    };\n    NullValue.prototype.compareTo = function (other) {\n        if (other instanceof NullValue) {\n            return 0;\n        }\n        return this.defaultCompareTo(other);\n    };\n    NullValue.INSTANCE = new NullValue();\n    return NullValue;\n}(FieldValue));\nexport { NullValue };\nvar BooleanValue = /** @class */ (function (_super) {\n    tslib_1.__extends(BooleanValue, _super);\n    function BooleanValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.BooleanValue;\n        return _this;\n    }\n    BooleanValue.prototype.value = function (options) {\n        return this.internalValue;\n    };\n    BooleanValue.prototype.isEqual = function (other) {\n        return (other instanceof BooleanValue &&\n            this.internalValue === other.internalValue);\n    };\n    BooleanValue.prototype.compareTo = function (other) {\n        if (other instanceof BooleanValue) {\n            return primitiveComparator(this, other);\n        }\n        return this.defaultCompareTo(other);\n    };\n    BooleanValue.of = function (value) {\n        return value ? BooleanValue.TRUE : BooleanValue.FALSE;\n    };\n    BooleanValue.TRUE = new BooleanValue(true);\n    BooleanValue.FALSE = new BooleanValue(false);\n    return BooleanValue;\n}(FieldValue));\nexport { BooleanValue };\n/** Base class for IntegerValue and DoubleValue. */\nvar NumberValue = /** @class */ (function (_super) {\n    tslib_1.__extends(NumberValue, _super);\n    function NumberValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.NumberValue;\n        return _this;\n    }\n    NumberValue.prototype.value = function (options) {\n        return this.internalValue;\n    };\n    NumberValue.prototype.compareTo = function (other) {\n        if (other instanceof NumberValue) {\n            return numericComparator(this.internalValue, other.internalValue);\n        }\n        return this.defaultCompareTo(other);\n    };\n    return NumberValue;\n}(FieldValue));\nexport { NumberValue };\n/** Utility function to compare doubles (using Firestore semantics for NaN). */\nfunction numericComparator(left, right) {\n    if (left < right) {\n        return -1;\n    }\n    else if (left > right) {\n        return 1;\n    }\n    else if (left === right) {\n        return 0;\n    }\n    else {\n        // one or both are NaN.\n        if (isNaN(left)) {\n            return isNaN(right) ? 0 : -1;\n        }\n        else {\n            return 1;\n        }\n    }\n}\n/**\n * Utility function to check numbers for equality using Firestore semantics\n * (NaN === NaN, -0.0 !== 0.0).\n */\nfunction numericEquals(left, right) {\n    // Implemented based on Object.is() polyfill from\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n    if (left === right) {\n        // +0 != -0\n        return left !== 0 || 1 / left === 1 / right;\n    }\n    else {\n        // NaN == NaN\n        return left !== left && right !== right;\n    }\n}\nvar IntegerValue = /** @class */ (function (_super) {\n    tslib_1.__extends(IntegerValue, _super);\n    function IntegerValue(internalValue) {\n        return _super.call(this, internalValue) || this;\n    }\n    IntegerValue.prototype.isEqual = function (other) {\n        // NOTE: DoubleValue and IntegerValue instances may compareTo() the same,\n        // but that doesn't make them equal via isEqual().\n        if (other instanceof IntegerValue) {\n            return numericEquals(this.internalValue, other.internalValue);\n        }\n        else {\n            return false;\n        }\n    };\n    return IntegerValue;\n}(NumberValue));\nexport { IntegerValue };\nvar DoubleValue = /** @class */ (function (_super) {\n    tslib_1.__extends(DoubleValue, _super);\n    function DoubleValue(internalValue) {\n        var _this = _super.call(this, internalValue) || this;\n        _this.internalValue = internalValue;\n        return _this;\n    }\n    DoubleValue.prototype.isEqual = function (other) {\n        // NOTE: DoubleValue and IntegerValue instances may compareTo() the same,\n        // but that doesn't make them equal via isEqual().\n        if (other instanceof DoubleValue) {\n            return numericEquals(this.internalValue, other.internalValue);\n        }\n        else {\n            return false;\n        }\n    };\n    DoubleValue.NAN = new DoubleValue(NaN);\n    DoubleValue.POSITIVE_INFINITY = new DoubleValue(Infinity);\n    DoubleValue.NEGATIVE_INFINITY = new DoubleValue(-Infinity);\n    return DoubleValue;\n}(NumberValue));\nexport { DoubleValue };\n// TODO(b/37267885): Add truncation support\nvar StringValue = /** @class */ (function (_super) {\n    tslib_1.__extends(StringValue, _super);\n    function StringValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.StringValue;\n        return _this;\n    }\n    StringValue.prototype.value = function (options) {\n        return this.internalValue;\n    };\n    StringValue.prototype.isEqual = function (other) {\n        return (other instanceof StringValue && this.internalValue === other.internalValue);\n    };\n    StringValue.prototype.compareTo = function (other) {\n        if (other instanceof StringValue) {\n            return primitiveComparator(this.internalValue, other.internalValue);\n        }\n        return this.defaultCompareTo(other);\n    };\n    return StringValue;\n}(FieldValue));\nexport { StringValue };\nvar TimestampValue = /** @class */ (function (_super) {\n    tslib_1.__extends(TimestampValue, _super);\n    function TimestampValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.TimestampValue;\n        return _this;\n    }\n    TimestampValue.prototype.value = function (options) {\n        return this.internalValue.toDate();\n    };\n    TimestampValue.prototype.isEqual = function (other) {\n        return (other instanceof TimestampValue &&\n            this.internalValue.isEqual(other.internalValue));\n    };\n    TimestampValue.prototype.compareTo = function (other) {\n        if (other instanceof TimestampValue) {\n            return this.internalValue.compareTo(other.internalValue);\n        }\n        else if (other instanceof ServerTimestampValue) {\n            // Concrete timestamps come before server timestamps.\n            return -1;\n        }\n        else {\n            return this.defaultCompareTo(other);\n        }\n    };\n    return TimestampValue;\n}(FieldValue));\nexport { TimestampValue };\n/**\n * Represents a locally-applied ServerTimestamp.\n *\n * Notes:\n * - ServerTimestampValue instances are created as the result of applying a\n *   TransformMutation (see TransformMutation.applyTo()). They can only exist in\n *   the local view of a document. Therefore they do not need to be parsed or\n *   serialized.\n * - When evaluated locally (e.g. for snapshot.data()), they by default\n *   evaluate to `null`. This behavior can be configured by passing custom\n *   FieldValueOptions to value().\n * - With respect to other ServerTimestampValues, they sort by their\n *   localWriteTime.\n */\nvar ServerTimestampValue = /** @class */ (function (_super) {\n    tslib_1.__extends(ServerTimestampValue, _super);\n    function ServerTimestampValue(localWriteTime, previousValue) {\n        var _this = _super.call(this) || this;\n        _this.localWriteTime = localWriteTime;\n        _this.previousValue = previousValue;\n        _this.typeOrder = TypeOrder.TimestampValue;\n        return _this;\n    }\n    ServerTimestampValue.prototype.value = function (options) {\n        if (options &&\n            options.serverTimestampBehavior === ServerTimestampBehavior.Estimate) {\n            return this.localWriteTime.toDate();\n        }\n        else if (options &&\n            options.serverTimestampBehavior === ServerTimestampBehavior.Previous) {\n            return this.previousValue ? this.previousValue.value(options) : null;\n        }\n        else {\n            return null;\n        }\n    };\n    ServerTimestampValue.prototype.isEqual = function (other) {\n        return (other instanceof ServerTimestampValue &&\n            this.localWriteTime.isEqual(other.localWriteTime));\n    };\n    ServerTimestampValue.prototype.compareTo = function (other) {\n        if (other instanceof ServerTimestampValue) {\n            return this.localWriteTime.compareTo(other.localWriteTime);\n        }\n        else if (other instanceof TimestampValue) {\n            // Server timestamps come after all concrete timestamps.\n            return 1;\n        }\n        else {\n            return this.defaultCompareTo(other);\n        }\n    };\n    ServerTimestampValue.prototype.toString = function () {\n        return '<ServerTimestamp localTime=' + this.localWriteTime.toString() + '>';\n    };\n    return ServerTimestampValue;\n}(FieldValue));\nexport { ServerTimestampValue };\nvar BlobValue = /** @class */ (function (_super) {\n    tslib_1.__extends(BlobValue, _super);\n    function BlobValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.BlobValue;\n        return _this;\n    }\n    BlobValue.prototype.value = function (options) {\n        return this.internalValue;\n    };\n    BlobValue.prototype.isEqual = function (other) {\n        return (other instanceof BlobValue &&\n            this.internalValue.isEqual(other.internalValue));\n    };\n    BlobValue.prototype.compareTo = function (other) {\n        if (other instanceof BlobValue) {\n            return this.internalValue._compareTo(other.internalValue);\n        }\n        return this.defaultCompareTo(other);\n    };\n    return BlobValue;\n}(FieldValue));\nexport { BlobValue };\nvar RefValue = /** @class */ (function (_super) {\n    tslib_1.__extends(RefValue, _super);\n    function RefValue(databaseId, key) {\n        var _this = _super.call(this) || this;\n        _this.databaseId = databaseId;\n        _this.key = key;\n        _this.typeOrder = TypeOrder.RefValue;\n        return _this;\n    }\n    RefValue.prototype.value = function (options) {\n        return this.key;\n    };\n    RefValue.prototype.isEqual = function (other) {\n        if (other instanceof RefValue) {\n            return (this.key.isEqual(other.key) && this.databaseId.isEqual(other.databaseId));\n        }\n        else {\n            return false;\n        }\n    };\n    RefValue.prototype.compareTo = function (other) {\n        if (other instanceof RefValue) {\n            var cmp = this.databaseId.compareTo(other.databaseId);\n            return cmp !== 0 ? cmp : DocumentKey.comparator(this.key, other.key);\n        }\n        return this.defaultCompareTo(other);\n    };\n    return RefValue;\n}(FieldValue));\nexport { RefValue };\nvar GeoPointValue = /** @class */ (function (_super) {\n    tslib_1.__extends(GeoPointValue, _super);\n    function GeoPointValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.GeoPointValue;\n        return _this;\n    }\n    GeoPointValue.prototype.value = function (options) {\n        return this.internalValue;\n    };\n    GeoPointValue.prototype.isEqual = function (other) {\n        return (other instanceof GeoPointValue &&\n            this.internalValue.isEqual(other.internalValue));\n    };\n    GeoPointValue.prototype.compareTo = function (other) {\n        if (other instanceof GeoPointValue) {\n            return this.internalValue._compareTo(other.internalValue);\n        }\n        return this.defaultCompareTo(other);\n    };\n    return GeoPointValue;\n}(FieldValue));\nexport { GeoPointValue };\nvar ObjectValue = /** @class */ (function (_super) {\n    tslib_1.__extends(ObjectValue, _super);\n    function ObjectValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.ObjectValue;\n        return _this;\n    }\n    ObjectValue.prototype.value = function (options) {\n        var result = {};\n        this.internalValue.inorderTraversal(function (key, val) {\n            result[key] = val.value(options);\n        });\n        return result;\n    };\n    ObjectValue.prototype.forEach = function (action) {\n        this.internalValue.inorderTraversal(action);\n    };\n    ObjectValue.prototype.isEqual = function (other) {\n        if (other instanceof ObjectValue) {\n            var it1 = this.internalValue.getIterator();\n            var it2 = other.internalValue.getIterator();\n            while (it1.hasNext() && it2.hasNext()) {\n                var next1 = it1.getNext();\n                var next2 = it2.getNext();\n                if (next1.key !== next2.key || !next1.value.isEqual(next2.value)) {\n                    return false;\n                }\n            }\n            return !it1.hasNext() && !it2.hasNext();\n        }\n        return false;\n    };\n    ObjectValue.prototype.compareTo = function (other) {\n        if (other instanceof ObjectValue) {\n            var it1 = this.internalValue.getIterator();\n            var it2 = other.internalValue.getIterator();\n            while (it1.hasNext() && it2.hasNext()) {\n                var next1 = it1.getNext();\n                var next2 = it2.getNext();\n                var cmp = primitiveComparator(next1.key, next2.key) ||\n                    next1.value.compareTo(next2.value);\n                if (cmp) {\n                    return cmp;\n                }\n            }\n            // Only equal if both iterators are exhausted\n            return primitiveComparator(it1.hasNext(), it2.hasNext());\n        }\n        else {\n            return this.defaultCompareTo(other);\n        }\n    };\n    ObjectValue.prototype.set = function (path, to) {\n        assert(!path.isEmpty(), 'Cannot set field for empty path on ObjectValue');\n        if (path.length === 1) {\n            return this.setChild(path.firstSegment(), to);\n        }\n        else {\n            var child = this.child(path.firstSegment());\n            if (!(child instanceof ObjectValue)) {\n                child = ObjectValue.EMPTY;\n            }\n            var newChild = child.set(path.popFirst(), to);\n            return this.setChild(path.firstSegment(), newChild);\n        }\n    };\n    ObjectValue.prototype.delete = function (path) {\n        assert(!path.isEmpty(), 'Cannot delete field for empty path on ObjectValue');\n        if (path.length === 1) {\n            return new ObjectValue(this.internalValue.remove(path.firstSegment()));\n        }\n        else {\n            // nested field\n            var child = this.child(path.firstSegment());\n            if (child instanceof ObjectValue) {\n                var newChild = child.delete(path.popFirst());\n                return new ObjectValue(this.internalValue.insert(path.firstSegment(), newChild));\n            }\n            else {\n                // Don't actually change a primitive value to an object for a delete\n                return this;\n            }\n        }\n    };\n    ObjectValue.prototype.contains = function (path) {\n        return this.field(path) !== undefined;\n    };\n    ObjectValue.prototype.field = function (path) {\n        assert(!path.isEmpty(), \"Can't get field of empty path\");\n        var field = this;\n        path.forEach(function (pathSegment) {\n            if (field instanceof ObjectValue) {\n                field = field.internalValue.get(pathSegment) || undefined;\n            }\n            else {\n                field = undefined;\n            }\n        });\n        return field;\n    };\n    ObjectValue.prototype.toString = function () {\n        return JSON.stringify(this.value());\n    };\n    ObjectValue.prototype.child = function (childName) {\n        return this.internalValue.get(childName) || undefined;\n    };\n    ObjectValue.prototype.setChild = function (childName, value) {\n        return new ObjectValue(this.internalValue.insert(childName, value));\n    };\n    ObjectValue.EMPTY = new ObjectValue(new SortedMap(primitiveComparator));\n    return ObjectValue;\n}(FieldValue));\nexport { ObjectValue };\nvar ArrayValue = /** @class */ (function (_super) {\n    tslib_1.__extends(ArrayValue, _super);\n    function ArrayValue(internalValue) {\n        var _this = _super.call(this) || this;\n        _this.internalValue = internalValue;\n        _this.typeOrder = TypeOrder.ArrayValue;\n        return _this;\n    }\n    ArrayValue.prototype.value = function (options) {\n        return this.internalValue.map(function (v) { return v.value(options); });\n    };\n    ArrayValue.prototype.forEach = function (action) {\n        this.internalValue.forEach(action);\n    };\n    ArrayValue.prototype.isEqual = function (other) {\n        if (other instanceof ArrayValue) {\n            if (this.internalValue.length !== other.internalValue.length) {\n                return false;\n            }\n            for (var i = 0; i < this.internalValue.length; i++) {\n                if (!this.internalValue[i].isEqual(other.internalValue[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    };\n    ArrayValue.prototype.compareTo = function (other) {\n        if (other instanceof ArrayValue) {\n            var minLength = Math.min(this.internalValue.length, other.internalValue.length);\n            for (var i = 0; i < minLength; i++) {\n                var cmp = this.internalValue[i].compareTo(other.internalValue[i]);\n                if (cmp) {\n                    return cmp;\n                }\n            }\n            return primitiveComparator(this.internalValue.length, other.internalValue.length);\n        }\n        else {\n            return this.defaultCompareTo(other);\n        }\n    };\n    ArrayValue.prototype.toString = function () {\n        return JSON.stringify(this.value());\n    };\n    return ArrayValue;\n}(FieldValue));\nexport { ArrayValue };\n\n//# sourceMappingURL=field_value.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/model/field_value.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Untyped Number alias we can use to check for ES6 methods / properties.\n// tslint:disable-next-line:no-any variable-name\nvar NumberAsAny = Number;\n/**\n * Minimum safe integer in Javascript because of floating point precision.\n * Added to not rely on ES6 features.\n */\nexport var MIN_SAFE_INTEGER = NumberAsAny.MIN_SAFE_INTEGER || -(Math.pow(2, 53) - 1);\n/**\n * Maximum safe integer in Javascript because of floating point precision.\n * Added to not rely on ES6 features.\n */\nexport var MAX_SAFE_INTEGER = NumberAsAny.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;\n/**\n * Returns whether an number is an integer, uses native implementation if\n * available.\n * Added to not rely on ES6 features.\n * @param value The value to test for being an integer\n */\nexport var isInteger = NumberAsAny.isInteger ||\n    (function (value) {\n        return typeof value === 'number' &&\n            isFinite(value) &&\n            Math.floor(value) === value;\n    });\n/**\n * Returns whether a variable is either undefined or null.\n */\nexport function isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\n/**\n * Returns whether a value is an integer and in the safe integer range\n * @param value The value to test for being an integer and in the safe range\n */\nexport function isSafeInteger(value) {\n    return (isInteger(value) &&\n        value <= MAX_SAFE_INTEGER &&\n        value >= MIN_SAFE_INTEGER);\n}\n/**\n * Safely checks if the number is NaN.\n */\nexport function safeIsNaN(value) {\n    if (NumberAsAny.IsNaN) {\n        return NumberAsAny.IsNaN(value);\n    }\n    else {\n        return typeof value === 'number' && isNaN(value);\n    }\n}\n\n//# sourceMappingURL=types.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/types.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Document } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { DoubleValue, NullValue, RefValue } from '../model/field_value';\nimport { FieldPath } from '../model/path';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { isNullOrUndefined } from '../util/types';\nvar Query = /** @class */ (function () {\n    function Query(path, explicitOrderBy, filters, limit, startAt, endAt) {\n        if (explicitOrderBy === void 0) { explicitOrderBy = []; }\n        if (filters === void 0) { filters = []; }\n        if (limit === void 0) { limit = null; }\n        if (startAt === void 0) { startAt = null; }\n        if (endAt === void 0) { endAt = null; }\n        this.path = path;\n        this.explicitOrderBy = explicitOrderBy;\n        this.filters = filters;\n        this.limit = limit;\n        this.startAt = startAt;\n        this.endAt = endAt;\n        this.memoizedCanonicalId = null;\n        this.memoizedOrderBy = null;\n        if (this.startAt) {\n            this.assertValidBound(this.startAt);\n        }\n        if (this.endAt) {\n            this.assertValidBound(this.endAt);\n        }\n    }\n    Query.atPath = function (path) {\n        return new Query(path);\n    };\n    Object.defineProperty(Query.prototype, \"orderBy\", {\n        get: function () {\n            if (this.memoizedOrderBy === null) {\n                var inequalityField = this.getInequalityFilterField();\n                var firstOrderByField = this.getFirstOrderByField();\n                if (inequalityField !== null && firstOrderByField === null) {\n                    // In order to implicitly add key ordering, we must also add the\n                    // inequality filter field for it to be a valid query.\n                    // Note that the default inequality field and key ordering is ascending.\n                    if (inequalityField.isKeyField()) {\n                        this.memoizedOrderBy = [KEY_ORDERING_ASC];\n                    }\n                    else {\n                        this.memoizedOrderBy = [\n                            new OrderBy(inequalityField),\n                            KEY_ORDERING_ASC\n                        ];\n                    }\n                }\n                else {\n                    assert(inequalityField === null ||\n                        (firstOrderByField !== null &&\n                            inequalityField.isEqual(firstOrderByField)), 'First orderBy should match inequality field.');\n                    this.memoizedOrderBy = [];\n                    var foundKeyOrdering = false;\n                    for (var _i = 0, _a = this.explicitOrderBy; _i < _a.length; _i++) {\n                        var orderBy = _a[_i];\n                        this.memoizedOrderBy.push(orderBy);\n                        if (orderBy.field.isKeyField()) {\n                            foundKeyOrdering = true;\n                        }\n                    }\n                    if (!foundKeyOrdering) {\n                        // The order of the implicit key ordering always matches the last\n                        // explicit order by\n                        var lastDirection = this.explicitOrderBy.length > 0\n                            ? this.explicitOrderBy[this.explicitOrderBy.length - 1].dir\n                            : Direction.ASCENDING;\n                        this.memoizedOrderBy.push(lastDirection === Direction.ASCENDING\n                            ? KEY_ORDERING_ASC\n                            : KEY_ORDERING_DESC);\n                    }\n                }\n            }\n            return this.memoizedOrderBy;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Query.prototype.addFilter = function (filter) {\n        assert(this.getInequalityFilterField() == null ||\n            !(filter instanceof RelationFilter) ||\n            !filter.isInequality() ||\n            filter.field.isEqual(this.getInequalityFilterField()), 'Query must only have one inequality field.');\n        assert(!DocumentKey.isDocumentKey(this.path), 'No filtering allowed for document query');\n        var newFilters = this.filters.concat([filter]);\n        return new Query(this.path, this.explicitOrderBy.slice(), newFilters, this.limit, this.startAt, this.endAt);\n    };\n    Query.prototype.addOrderBy = function (orderBy) {\n        assert(!DocumentKey.isDocumentKey(this.path), 'No ordering allowed for document query');\n        assert(!this.startAt && !this.endAt, 'Bounds must be set after orderBy');\n        // TODO(dimond): validate that orderBy does not list the same key twice.\n        var newOrderBy = this.explicitOrderBy.concat([orderBy]);\n        return new Query(this.path, newOrderBy, this.filters.slice(), this.limit, this.startAt, this.endAt);\n    };\n    Query.prototype.withLimit = function (limit) {\n        return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), limit, this.startAt, this.endAt);\n    };\n    Query.prototype.withStartAt = function (bound) {\n        return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, bound, this.endAt);\n    };\n    Query.prototype.withEndAt = function (bound) {\n        return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, this.startAt, bound);\n    };\n    // TODO(b/29183165): This is used to get a unique string from a query to, for\n    // example, use as a dictionary key, but the implementation is subject to\n    // collisions. Make it collision-free.\n    Query.prototype.canonicalId = function () {\n        if (this.memoizedCanonicalId === null) {\n            var canonicalId = this.path.canonicalString();\n            canonicalId += '|f:';\n            for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {\n                var filter = _a[_i];\n                canonicalId += filter.canonicalId();\n                canonicalId += ',';\n            }\n            canonicalId += '|ob:';\n            // TODO(dimond): make this collision resistant\n            for (var _b = 0, _c = this.orderBy; _b < _c.length; _b++) {\n                var orderBy = _c[_b];\n                canonicalId += orderBy.canonicalId();\n                canonicalId += ',';\n            }\n            if (!isNullOrUndefined(this.limit)) {\n                canonicalId += '|l:';\n                canonicalId += this.limit;\n            }\n            if (this.startAt) {\n                canonicalId += '|lb:';\n                canonicalId += this.startAt.canonicalId();\n            }\n            if (this.endAt) {\n                canonicalId += '|ub:';\n                canonicalId += this.endAt.canonicalId();\n            }\n            this.memoizedCanonicalId = canonicalId;\n        }\n        return this.memoizedCanonicalId;\n    };\n    Query.prototype.toString = function () {\n        var str = 'Query(' + this.path.canonicalString();\n        if (this.filters.length > 0) {\n            str += \", filters: [\" + this.filters.join(', ') + \"]\";\n        }\n        if (!isNullOrUndefined(this.limit)) {\n            str += ', limit: ' + this.limit;\n        }\n        if (this.explicitOrderBy.length > 0) {\n            str += \", orderBy: [\" + this.explicitOrderBy.join(', ') + \"]\";\n        }\n        if (this.startAt) {\n            str += ', startAt: ' + this.startAt.canonicalId();\n        }\n        if (this.endAt) {\n            str += ', endAt: ' + this.endAt.canonicalId();\n        }\n        return str + ')';\n    };\n    Query.prototype.isEqual = function (other) {\n        if (this.limit !== other.limit) {\n            return false;\n        }\n        if (this.orderBy.length !== other.orderBy.length) {\n            return false;\n        }\n        for (var i = 0; i < this.orderBy.length; i++) {\n            if (!this.orderBy[i].isEqual(other.orderBy[i])) {\n                return false;\n            }\n        }\n        if (this.filters.length !== other.filters.length) {\n            return false;\n        }\n        for (var i = 0; i < this.filters.length; i++) {\n            if (!this.filters[i].isEqual(other.filters[i])) {\n                return false;\n            }\n        }\n        if (!this.path.isEqual(other.path)) {\n            return false;\n        }\n        if (this.startAt !== null\n            ? !this.startAt.isEqual(other.startAt)\n            : other.startAt !== null) {\n            return false;\n        }\n        return this.endAt !== null\n            ? this.endAt.isEqual(other.endAt)\n            : other.endAt === null;\n    };\n    Query.prototype.docComparator = function (d1, d2) {\n        var comparedOnKeyField = false;\n        for (var _i = 0, _a = this.orderBy; _i < _a.length; _i++) {\n            var orderBy = _a[_i];\n            var comp = orderBy.compare(d1, d2);\n            if (comp !== 0)\n                return comp;\n            comparedOnKeyField = comparedOnKeyField || orderBy.field.isKeyField();\n        }\n        // Assert that we actually compared by key\n        assert(comparedOnKeyField, \"orderBy used that doesn't compare on key field\");\n        return 0;\n    };\n    Query.prototype.matches = function (doc) {\n        return (this.matchesAncestor(doc) &&\n            this.matchesOrderBy(doc) &&\n            this.matchesFilters(doc) &&\n            this.matchesBounds(doc));\n    };\n    Query.prototype.hasLimit = function () {\n        return !isNullOrUndefined(this.limit);\n    };\n    Query.prototype.getFirstOrderByField = function () {\n        return this.explicitOrderBy.length > 0\n            ? this.explicitOrderBy[0].field\n            : null;\n    };\n    Query.prototype.getInequalityFilterField = function () {\n        for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {\n            var filter = _a[_i];\n            if (filter instanceof RelationFilter && filter.isInequality()) {\n                return filter.field;\n            }\n        }\n        return null;\n    };\n    Query.prototype.isDocumentQuery = function () {\n        return DocumentKey.isDocumentKey(this.path) && this.filters.length === 0;\n    };\n    Query.prototype.matchesAncestor = function (doc) {\n        var docPath = doc.key.path;\n        if (DocumentKey.isDocumentKey(this.path)) {\n            // exact match for document queries\n            return this.path.isEqual(docPath);\n        }\n        else {\n            // shallow ancestor queries by default\n            return (this.path.isPrefixOf(docPath) && this.path.length === docPath.length - 1);\n        }\n    };\n    /**\n     * A document must have a value for every ordering clause in order to show up\n     * in the results.\n     */\n    Query.prototype.matchesOrderBy = function (doc) {\n        for (var _i = 0, _a = this.explicitOrderBy; _i < _a.length; _i++) {\n            var orderBy = _a[_i];\n            // order by key always matches\n            if (!orderBy.field.isKeyField() &&\n                doc.field(orderBy.field) === undefined) {\n                return false;\n            }\n        }\n        return true;\n    };\n    Query.prototype.matchesFilters = function (doc) {\n        for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {\n            var filter = _a[_i];\n            if (!filter.matches(doc)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * Makes sure a document is within the bounds, if provided.\n     */\n    Query.prototype.matchesBounds = function (doc) {\n        if (this.startAt && !this.startAt.sortsBeforeDocument(this.orderBy, doc)) {\n            return false;\n        }\n        if (this.endAt && this.endAt.sortsBeforeDocument(this.orderBy, doc)) {\n            return false;\n        }\n        return true;\n    };\n    Query.prototype.assertValidBound = function (bound) {\n        assert(bound.position.length <= this.orderBy.length, 'Bound is longer than orderBy');\n    };\n    return Query;\n}());\nexport { Query };\nvar RelationOp = /** @class */ (function () {\n    function RelationOp(name) {\n        this.name = name;\n    }\n    RelationOp.fromString = function (op) {\n        switch (op) {\n            case '<':\n                return RelationOp.LESS_THAN;\n            case '<=':\n                return RelationOp.LESS_THAN_OR_EQUAL;\n            case '==':\n                return RelationOp.EQUAL;\n            case '>=':\n                return RelationOp.GREATER_THAN_OR_EQUAL;\n            case '>':\n                return RelationOp.GREATER_THAN;\n            default:\n                return fail('Unknown relation: ' + op);\n        }\n    };\n    RelationOp.prototype.toString = function () {\n        return this.name;\n    };\n    RelationOp.prototype.isEqual = function (other) {\n        return this.name === other.name;\n    };\n    RelationOp.LESS_THAN = new RelationOp('<');\n    RelationOp.LESS_THAN_OR_EQUAL = new RelationOp('<=');\n    RelationOp.EQUAL = new RelationOp('==');\n    RelationOp.GREATER_THAN = new RelationOp('>');\n    RelationOp.GREATER_THAN_OR_EQUAL = new RelationOp('>=');\n    return RelationOp;\n}());\nexport { RelationOp };\nvar RelationFilter = /** @class */ (function () {\n    function RelationFilter(field, op, value) {\n        this.field = field;\n        this.op = op;\n        this.value = value;\n    }\n    RelationFilter.prototype.matches = function (doc) {\n        if (this.field.isKeyField()) {\n            assert(this.value instanceof RefValue, 'Comparing on key, but filter value not a RefValue');\n            var refValue = this.value;\n            var comparison = DocumentKey.comparator(doc.key, refValue.key);\n            return this.matchesComparison(comparison);\n        }\n        else {\n            var val = doc.field(this.field);\n            return val !== undefined && this.matchesValue(val);\n        }\n    };\n    RelationFilter.prototype.matchesValue = function (value) {\n        // Only compare types with matching backend order (such as double and int).\n        if (this.value.typeOrder !== value.typeOrder) {\n            return false;\n        }\n        return this.matchesComparison(value.compareTo(this.value));\n    };\n    RelationFilter.prototype.matchesComparison = function (comparison) {\n        switch (this.op) {\n            case RelationOp.LESS_THAN:\n                return comparison < 0;\n            case RelationOp.LESS_THAN_OR_EQUAL:\n                return comparison <= 0;\n            case RelationOp.EQUAL:\n                return comparison === 0;\n            case RelationOp.GREATER_THAN:\n                return comparison > 0;\n            case RelationOp.GREATER_THAN_OR_EQUAL:\n                return comparison >= 0;\n            default:\n                return fail('Unknown relation op' + this.op);\n        }\n    };\n    RelationFilter.prototype.isInequality = function () {\n        return this.op !== RelationOp.EQUAL;\n    };\n    RelationFilter.prototype.canonicalId = function () {\n        // TODO(b/29183165): Technically, this won't be unique if two values have\n        // the same description, such as the int 3 and the string \"3\". So we should\n        // add the types in here somehow, too.\n        return (this.field.canonicalString() + this.op.toString() + this.value.toString());\n    };\n    RelationFilter.prototype.isEqual = function (other) {\n        if (other instanceof RelationFilter) {\n            return (this.op.isEqual(other.op) &&\n                this.field.isEqual(other.field) &&\n                this.value.isEqual(other.value));\n        }\n        else {\n            return false;\n        }\n    };\n    RelationFilter.prototype.toString = function () {\n        return this.field.canonicalString() + \" \" + this.op + \" \" + this.value.value();\n    };\n    return RelationFilter;\n}());\nexport { RelationFilter };\n/**\n * Filter that matches 'null' values.\n */\nvar NullFilter = /** @class */ (function () {\n    function NullFilter(field) {\n        this.field = field;\n    }\n    NullFilter.prototype.matches = function (doc) {\n        var val = doc.field(this.field);\n        return val !== undefined && val.value() === null;\n    };\n    NullFilter.prototype.canonicalId = function () {\n        return this.field.canonicalString() + ' IS null';\n    };\n    NullFilter.prototype.toString = function () {\n        return this.field.canonicalString() + \" IS null\";\n    };\n    NullFilter.prototype.isEqual = function (other) {\n        if (other instanceof NullFilter) {\n            return this.field.isEqual(other.field);\n        }\n        else {\n            return false;\n        }\n    };\n    return NullFilter;\n}());\nexport { NullFilter };\n/**\n * Filter that matches 'NaN' values.\n */\nvar NanFilter = /** @class */ (function () {\n    function NanFilter(field) {\n        this.field = field;\n    }\n    NanFilter.prototype.matches = function (doc) {\n        var val = doc.field(this.field).value();\n        return typeof val === 'number' && isNaN(val);\n    };\n    NanFilter.prototype.canonicalId = function () {\n        return this.field.canonicalString() + ' IS NaN';\n    };\n    NanFilter.prototype.toString = function () {\n        return this.field.canonicalString() + \" IS NaN\";\n    };\n    NanFilter.prototype.isEqual = function (other) {\n        if (other instanceof NanFilter) {\n            return this.field.isEqual(other.field);\n        }\n        else {\n            return false;\n        }\n    };\n    return NanFilter;\n}());\nexport { NanFilter };\n/**\n * Creates a filter based on the provided arguments.\n */\nexport function fieldFilter(field, op, value) {\n    if (value.isEqual(NullValue.INSTANCE)) {\n        if (op !== RelationOp.EQUAL) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You can only perform equals ' + 'comparisons on null.');\n        }\n        return new NullFilter(field);\n    }\n    else if (value.isEqual(DoubleValue.NAN)) {\n        if (op !== RelationOp.EQUAL) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You can only perform equals ' + 'comparisons on NaN.');\n        }\n        return new NanFilter(field);\n    }\n    else {\n        return new RelationFilter(field, op, value);\n    }\n}\n/**\n * The direction of sorting in an order by.\n */\nvar Direction = /** @class */ (function () {\n    function Direction(name) {\n        this.name = name;\n    }\n    Direction.prototype.toString = function () {\n        return this.name;\n    };\n    Direction.ASCENDING = new Direction('asc');\n    Direction.DESCENDING = new Direction('desc');\n    return Direction;\n}());\nexport { Direction };\n/**\n * Represents a bound of a query.\n *\n * The bound is specified with the given components representing a position and\n * whether it's just before or just after the position (relative to whatever the\n * query order is).\n *\n * The position represents a logical index position for a query. It's a prefix\n * of values for the (potentially implicit) order by clauses of a query.\n *\n * Bound provides a function to determine whether a document comes before or\n * after a bound. This is influenced by whether the position is just before or\n * just after the provided values.\n */\nvar Bound = /** @class */ (function () {\n    function Bound(position, before) {\n        this.position = position;\n        this.before = before;\n    }\n    Bound.prototype.canonicalId = function () {\n        // TODO(b/29183165): Make this collision robust.\n        var canonicalId = this.before ? 'b:' : 'a:';\n        for (var _i = 0, _a = this.position; _i < _a.length; _i++) {\n            var component = _a[_i];\n            canonicalId += component.toString();\n        }\n        return canonicalId;\n    };\n    /**\n     * Returns true if a document sorts before a bound using the provided sort\n     * order.\n     */\n    Bound.prototype.sortsBeforeDocument = function (orderBy, doc) {\n        assert(this.position.length <= orderBy.length, \"Bound has more components than query's orderBy\");\n        var comparison = 0;\n        for (var i = 0; i < this.position.length; i++) {\n            var orderByComponent = orderBy[i];\n            var component = this.position[i];\n            if (orderByComponent.field.isKeyField()) {\n                assert(component instanceof RefValue, 'Bound has a non-key value where the key path is being used.');\n                comparison = DocumentKey.comparator(component.key, doc.key);\n            }\n            else {\n                var docValue = doc.field(orderByComponent.field);\n                assert(docValue !== undefined, 'Field should exist since document matched the orderBy already.');\n                comparison = component.compareTo(docValue);\n            }\n            if (orderByComponent.dir === Direction.DESCENDING) {\n                comparison = comparison * -1;\n            }\n            if (comparison !== 0) {\n                break;\n            }\n        }\n        return this.before ? comparison <= 0 : comparison < 0;\n    };\n    Bound.prototype.isEqual = function (other) {\n        if (other === null) {\n            return false;\n        }\n        if (this.before !== other.before ||\n            this.position.length !== other.position.length) {\n            return false;\n        }\n        for (var i = 0; i < this.position.length; i++) {\n            var thisPosition = this.position[i];\n            var otherPosition = other.position[i];\n            return thisPosition.isEqual(otherPosition);\n        }\n        return true;\n    };\n    return Bound;\n}());\nexport { Bound };\n/**\n * An ordering on a field, in some Direction. Direction defaults to ASCENDING.\n */\nvar OrderBy = /** @class */ (function () {\n    function OrderBy(field, dir) {\n        this.field = field;\n        if (dir === undefined) {\n            dir = Direction.ASCENDING;\n        }\n        this.dir = dir;\n        this.isKeyOrderBy = field.isKeyField();\n    }\n    OrderBy.prototype.compare = function (d1, d2) {\n        var comparison = this.isKeyOrderBy\n            ? Document.compareByKey(d1, d2)\n            : Document.compareByField(this.field, d1, d2);\n        switch (this.dir) {\n            case Direction.ASCENDING:\n                return comparison;\n            case Direction.DESCENDING:\n                return -1 * comparison;\n            default:\n                return fail('Unknown direction: ' + this.dir);\n        }\n    };\n    OrderBy.prototype.canonicalId = function () {\n        // TODO(b/29183165): Make this collision robust.\n        return this.field.canonicalString() + this.dir.toString();\n    };\n    OrderBy.prototype.toString = function () {\n        return this.field.canonicalString() + \" (\" + this.dir + \")\";\n    };\n    OrderBy.prototype.isEqual = function (other) {\n        return this.dir === other.dir && this.field.isEqual(other.field);\n    };\n    return OrderBy;\n}());\nexport { OrderBy };\nvar KEY_ORDERING_ASC = new OrderBy(FieldPath.keyField(), Direction.ASCENDING);\nvar KEY_ORDERING_DESC = new OrderBy(FieldPath.keyField(), Direction.DESCENDING);\n\n//# sourceMappingURL=query.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/core/query.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { fail } from '../util/assert';\nimport { Code } from '../util/error';\nimport * as log from '../util/log';\n/**\n * Error Codes describing the different ways GRPC can fail. These are copied\n * directly from GRPC's sources here:\n *\n * https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\n *\n * Important! The names of these identifiers matter because the string forms\n * are used for reverse lookups from the webchannel stream. Do NOT change the\n * names of these identifiers.\n */\nvar RpcCode;\n(function (RpcCode) {\n    RpcCode[RpcCode[\"OK\"] = 0] = \"OK\";\n    RpcCode[RpcCode[\"CANCELLED\"] = 1] = \"CANCELLED\";\n    RpcCode[RpcCode[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n    RpcCode[RpcCode[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\n    RpcCode[RpcCode[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\n    RpcCode[RpcCode[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\n    RpcCode[RpcCode[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\n    RpcCode[RpcCode[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\n    RpcCode[RpcCode[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\n    RpcCode[RpcCode[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\n    RpcCode[RpcCode[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\n    RpcCode[RpcCode[\"ABORTED\"] = 10] = \"ABORTED\";\n    RpcCode[RpcCode[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\n    RpcCode[RpcCode[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\n    RpcCode[RpcCode[\"INTERNAL\"] = 13] = \"INTERNAL\";\n    RpcCode[RpcCode[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\n    RpcCode[RpcCode[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\n})(RpcCode || (RpcCode = {}));\nexport function isPermanentError(code) {\n    switch (code) {\n        case Code.OK:\n            return fail('Treated status OK as error');\n        case Code.CANCELLED:\n        case Code.UNKNOWN:\n        case Code.DEADLINE_EXCEEDED:\n        case Code.RESOURCE_EXHAUSTED:\n        case Code.INTERNAL:\n        case Code.UNAVAILABLE:\n        // Unauthenticated means something went wrong with our token and we need\n        // to retry with new credentials which will happen automatically.\n        // TODO(b/37325376): Give up after second unauthenticated error.\n        case Code.UNAUTHENTICATED:\n            return false;\n        case Code.INVALID_ARGUMENT:\n        case Code.NOT_FOUND:\n        case Code.ALREADY_EXISTS:\n        case Code.PERMISSION_DENIED:\n        case Code.FAILED_PRECONDITION:\n        // Aborted might be retried in some scenarios, but that is dependant on\n        // the context and should handled individually by the calling code.\n        // See https://cloud.google.com/apis/design/errors.\n        case Code.ABORTED:\n        case Code.OUT_OF_RANGE:\n        case Code.UNIMPLEMENTED:\n        case Code.DATA_LOSS:\n            return true;\n        default:\n            return fail('Unknown status code: ' + code);\n    }\n}\n/**\n * Maps an error Code from a GRPC status identifier like 'NOT_FOUND'.\n *\n * @returns The Code equivalent to the given status string or undefined if\n *     there is no match.\n */\nexport function mapCodeFromRpcStatus(status) {\n    // tslint:disable-next-line:no-any lookup by string\n    var code = RpcCode[status];\n    if (code === undefined) {\n        return undefined;\n    }\n    return mapCodeFromRpcCode(code);\n}\n/**\n * Maps an error Code from GRPC status code number, like 0, 1, or 14. These\n * are not the same as HTTP status codes.\n *\n * @returns The Code equivalent to the given GRPC status code. Fails if there\n *     is no match.\n */\nexport function mapCodeFromRpcCode(code) {\n    if (code === undefined) {\n        // This shouldn't normally happen, but in certain error cases (like trying\n        // to send invalid proto messages) we may get an error with no GRPC code.\n        log.error('GRPC error has no .code');\n        return Code.UNKNOWN;\n    }\n    switch (code) {\n        case RpcCode.OK:\n            return Code.OK;\n        case RpcCode.CANCELLED:\n            return Code.CANCELLED;\n        case RpcCode.UNKNOWN:\n            return Code.UNKNOWN;\n        case RpcCode.DEADLINE_EXCEEDED:\n            return Code.DEADLINE_EXCEEDED;\n        case RpcCode.RESOURCE_EXHAUSTED:\n            return Code.RESOURCE_EXHAUSTED;\n        case RpcCode.INTERNAL:\n            return Code.INTERNAL;\n        case RpcCode.UNAVAILABLE:\n            return Code.UNAVAILABLE;\n        case RpcCode.UNAUTHENTICATED:\n            return Code.UNAUTHENTICATED;\n        case RpcCode.INVALID_ARGUMENT:\n            return Code.INVALID_ARGUMENT;\n        case RpcCode.NOT_FOUND:\n            return Code.NOT_FOUND;\n        case RpcCode.ALREADY_EXISTS:\n            return Code.ALREADY_EXISTS;\n        case RpcCode.PERMISSION_DENIED:\n            return Code.PERMISSION_DENIED;\n        case RpcCode.FAILED_PRECONDITION:\n            return Code.FAILED_PRECONDITION;\n        case RpcCode.ABORTED:\n            return Code.ABORTED;\n        case RpcCode.OUT_OF_RANGE:\n            return Code.OUT_OF_RANGE;\n        case RpcCode.UNIMPLEMENTED:\n            return Code.UNIMPLEMENTED;\n        case RpcCode.DATA_LOSS:\n            return Code.DATA_LOSS;\n        default:\n            return fail('Unknown status code: ' + code);\n    }\n}\n/**\n * Maps an RPC code from a Code. This is the reverse operation from\n * mapCodeFromRpcCode and should really only be used in tests.\n */\nexport function mapRpcCodeFromCode(code) {\n    if (code === undefined) {\n        return RpcCode.OK;\n    }\n    switch (code) {\n        case Code.OK:\n            return RpcCode.OK;\n        case Code.CANCELLED:\n            return RpcCode.CANCELLED;\n        case Code.UNKNOWN:\n            return RpcCode.UNKNOWN;\n        case Code.DEADLINE_EXCEEDED:\n            return RpcCode.DEADLINE_EXCEEDED;\n        case Code.RESOURCE_EXHAUSTED:\n            return RpcCode.RESOURCE_EXHAUSTED;\n        case Code.INTERNAL:\n            return RpcCode.INTERNAL;\n        case Code.UNAVAILABLE:\n            return RpcCode.UNAVAILABLE;\n        case Code.UNAUTHENTICATED:\n            return RpcCode.UNAUTHENTICATED;\n        case Code.INVALID_ARGUMENT:\n            return RpcCode.INVALID_ARGUMENT;\n        case Code.NOT_FOUND:\n            return RpcCode.NOT_FOUND;\n        case Code.ALREADY_EXISTS:\n            return RpcCode.ALREADY_EXISTS;\n        case Code.PERMISSION_DENIED:\n            return RpcCode.PERMISSION_DENIED;\n        case Code.FAILED_PRECONDITION:\n            return RpcCode.FAILED_PRECONDITION;\n        case Code.ABORTED:\n            return RpcCode.ABORTED;\n        case Code.OUT_OF_RANGE:\n            return RpcCode.OUT_OF_RANGE;\n        case Code.UNIMPLEMENTED:\n            return RpcCode.UNIMPLEMENTED;\n        case Code.DATA_LOSS:\n            return RpcCode.DATA_LOSS;\n        default:\n            return fail('Unknown status code: ' + code);\n    }\n}\n/**\n * Converts an HTTP Status Code to the equivalent error code.\n *\n * @param status An HTTP Status Code, like 200, 404, 503, etc.\n * @returns The equivalent Code. Unknown status codes are mapped to\n *     Code.UNKNOWN.\n */\nexport function mapCodeFromHttpStatus(status) {\n    // The canonical error codes for Google APIs [1] specify mapping onto HTTP\n    // status codes but the mapping is not bijective. In each case of ambiguity\n    // this function chooses a primary error.\n    //\n    // [1]\n    // https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto\n    switch (status) {\n        case 200:// OK\n            return Code.OK;\n        case 400:// Bad Request\n            return Code.INVALID_ARGUMENT;\n        // Other possibilities based on the forward mapping\n        // return Code.FAILED_PRECONDITION;\n        // return Code.OUT_OF_RANGE;\n        case 401:// Unauthorized\n            return Code.UNAUTHENTICATED;\n        case 403:// Forbidden\n            return Code.PERMISSION_DENIED;\n        case 404:// Not Found\n            return Code.NOT_FOUND;\n        case 409:// Conflict\n            return Code.ABORTED;\n        // Other possibilities:\n        // return Code.ALREADY_EXISTS;\n        case 416:// Range Not Satisfiable\n            return Code.OUT_OF_RANGE;\n        case 429:// Too Many Requests\n            return Code.RESOURCE_EXHAUSTED;\n        case 499:// Client Closed Request\n            return Code.CANCELLED;\n        case 500:// Internal Server Error\n            return Code.UNKNOWN;\n        // Other possibilities:\n        // return Code.INTERNAL;\n        // return Code.DATA_LOSS;\n        case 501:// Unimplemented\n            return Code.UNIMPLEMENTED;\n        case 503:// Service Unavailable\n            return Code.UNAVAILABLE;\n        case 504:// Gateway Timeout\n            return Code.DEADLINE_EXCEEDED;\n        default:\n            if (status >= 200 && status < 300)\n                return Code.OK;\n            if (status >= 400 && status < 500)\n                return Code.FAILED_PRECONDITION;\n            if (status >= 500 && status < 600)\n                return Code.INTERNAL;\n            return Code.UNKNOWN;\n    }\n}\n\n//# sourceMappingURL=rpc_error.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/remote/rpc_error.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SortedMap } from '../util/sorted_map';\nimport { SortedSet } from '../util/sorted_set';\nimport { DocumentKey } from './document_key';\nvar EMPTY_MAYBE_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);\nexport function maybeDocumentMap() {\n    return EMPTY_MAYBE_DOCUMENT_MAP;\n}\nvar EMPTY_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);\nexport function documentMap() {\n    return EMPTY_DOCUMENT_MAP;\n}\nvar EMPTY_DOCUMENT_VERSION_MAP = new SortedMap(DocumentKey.comparator);\nexport function documentVersionMap() {\n    return EMPTY_DOCUMENT_VERSION_MAP;\n}\nvar EMPTY_DOCUMENT_KEY_SET = new SortedSet(DocumentKey.comparator);\nexport function documentKeySet() {\n    return EMPTY_DOCUMENT_KEY_SET;\n}\n\n//# sourceMappingURL=collections.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/model/collections.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { maybeDocumentMap } from '../model/collections';\nimport { emptyByteString } from '../platform/platform';\nimport { assert, fail } from '../util/assert';\nimport * as objUtils from '../util/obj';\nimport { CurrentStatusUpdate, RemoteEvent, ResetMapping, UpdateMapping } from './remote_event';\n/**\n * Represents a changed document and a list of target ids to which this change\n * applies.\n *\n * If document has been deleted NoDocument will be provided.\n */\nvar DocumentWatchChange = /** @class */ (function () {\n    function DocumentWatchChange(\n    /** The new document applies to all of these targets. */\n    updatedTargetIds, \n    /** The new document is removed from all of these targets. */\n    removedTargetIds, \n    /** The key of the document for this change. */\n    key, \n    /**\n     * The new document or NoDocument if it was deleted. Is null if the\n     * document went out of view without the server sending a new document.\n     */\n    newDoc) {\n        this.updatedTargetIds = updatedTargetIds;\n        this.removedTargetIds = removedTargetIds;\n        this.key = key;\n        this.newDoc = newDoc;\n    }\n    return DocumentWatchChange;\n}());\nexport { DocumentWatchChange };\nvar ExistenceFilterChange = /** @class */ (function () {\n    function ExistenceFilterChange(targetId, existenceFilter) {\n        this.targetId = targetId;\n        this.existenceFilter = existenceFilter;\n    }\n    return ExistenceFilterChange;\n}());\nexport { ExistenceFilterChange };\nexport var WatchTargetChangeState;\n(function (WatchTargetChangeState) {\n    WatchTargetChangeState[WatchTargetChangeState[\"NoChange\"] = 0] = \"NoChange\";\n    WatchTargetChangeState[WatchTargetChangeState[\"Added\"] = 1] = \"Added\";\n    WatchTargetChangeState[WatchTargetChangeState[\"Removed\"] = 2] = \"Removed\";\n    WatchTargetChangeState[WatchTargetChangeState[\"Current\"] = 3] = \"Current\";\n    WatchTargetChangeState[WatchTargetChangeState[\"Reset\"] = 4] = \"Reset\";\n})(WatchTargetChangeState || (WatchTargetChangeState = {}));\nvar WatchTargetChange = /** @class */ (function () {\n    function WatchTargetChange(\n    /** What kind of change occurred to the watch target. */\n    state, \n    /** The target IDs that were added/removed/set. */\n    targetIds, \n    /**\n     * An opaque, server-assigned token that allows watching a query to be\n     * resumed after disconnecting without retransmitting all the data that\n     * matches the query. The resume token essentially identifies a point in\n     * time from which the server should resume sending results.\n     */\n    resumeToken, \n    /** An RPC error indicating why the watch failed. */\n    cause) {\n        if (resumeToken === void 0) { resumeToken = emptyByteString(); }\n        if (cause === void 0) { cause = null; }\n        this.state = state;\n        this.targetIds = targetIds;\n        this.resumeToken = resumeToken;\n        this.cause = cause;\n    }\n    return WatchTargetChange;\n}());\nexport { WatchTargetChange };\n/**\n * A helper class to accumulate watch changes into a RemoteEvent and other\n * target information.\n */\nvar WatchChangeAggregator = /** @class */ (function () {\n    function WatchChangeAggregator(snapshotVersion, listenTargets, pendingTargetResponses) {\n        this.snapshotVersion = snapshotVersion;\n        this.listenTargets = listenTargets;\n        /** The existence filter - if any - for the given target IDs. */\n        this.existenceFilters = {};\n        /** Keeps track of the current target mappings */\n        this.targetChanges = {};\n        /** Keeps track of document to update */\n        this.documentUpdates = maybeDocumentMap();\n        /** Whether this aggregator was frozen and can no longer be modified */\n        this.frozen = false;\n        this.pendingTargetResponses = objUtils.shallowCopy(pendingTargetResponses);\n    }\n    /** Aggregates a watch change into the current state */\n    WatchChangeAggregator.prototype.add = function (watchChange) {\n        assert(!this.frozen, 'Trying to modify frozen WatchChangeAggregator.');\n        if (watchChange instanceof DocumentWatchChange) {\n            this.addDocumentChange(watchChange);\n        }\n        else if (watchChange instanceof WatchTargetChange) {\n            this.addTargetChange(watchChange);\n        }\n        else if (watchChange instanceof ExistenceFilterChange) {\n            this.addExistenceFilterChange(watchChange);\n        }\n        else {\n            fail('Unknown watch change: ' + watchChange);\n        }\n    };\n    /** Aggregates all provided watch changes to the current state in order */\n    WatchChangeAggregator.prototype.addChanges = function (watchChanges) {\n        var _this = this;\n        assert(!this.frozen, 'Trying to modify frozen WatchChangeAggregator.');\n        watchChanges.forEach(function (change) { return _this.add(change); });\n    };\n    /**\n     * Converts the current state into a remote event with the snapshot version\n     * provided via the constructor.\n     */\n    WatchChangeAggregator.prototype.createRemoteEvent = function () {\n        var _this = this;\n        var targetChanges = this.targetChanges;\n        // Remove all the non-active targets from the remote event.\n        objUtils.forEachNumber(this.targetChanges, function (targetId) {\n            if (!_this.isActiveTarget(targetId)) {\n                delete targetChanges[targetId];\n            }\n        });\n        // Mark this aggregator as frozen so no further modifications are made\n        this.frozen = true;\n        return new RemoteEvent(this.snapshotVersion, targetChanges, this.documentUpdates);\n    };\n    WatchChangeAggregator.prototype.ensureTargetChange = function (targetId) {\n        var change = this.targetChanges[targetId];\n        if (!change) {\n            // Create an UpdateMapping by default, since resets are always explicit.\n            change = {\n                currentStatusUpdate: CurrentStatusUpdate.None,\n                snapshotVersion: this.snapshotVersion,\n                mapping: new UpdateMapping(),\n                resumeToken: emptyByteString()\n            };\n            this.targetChanges[targetId] = change;\n        }\n        return change;\n    };\n    /**\n     * We need to wait for watch to ack targets before we process those events,\n     * so to know if a target is active, there must be no pending acks we're\n     * waiting for and it must be in the current list of targets that the client\n     * cares about.\n     *\n     * This method is visible for testing.\n     */\n    WatchChangeAggregator.prototype.isActiveTarget = function (targetId) {\n        return (!objUtils.contains(this.pendingTargetResponses, targetId) &&\n            objUtils.contains(this.listenTargets, targetId));\n    };\n    WatchChangeAggregator.prototype.addDocumentChange = function (docChange) {\n        var relevant = false;\n        for (var _i = 0, _a = docChange.updatedTargetIds; _i < _a.length; _i++) {\n            var targetId = _a[_i];\n            if (this.isActiveTarget(targetId)) {\n                var change = this.ensureTargetChange(targetId);\n                change.mapping.add(docChange.key);\n                relevant = true;\n            }\n        }\n        for (var _b = 0, _c = docChange.removedTargetIds; _b < _c.length; _b++) {\n            var targetId = _c[_b];\n            if (this.isActiveTarget(targetId)) {\n                var change = this.ensureTargetChange(targetId);\n                change.mapping.delete(docChange.key);\n                relevant = true;\n            }\n        }\n        // Only update the document if there is a new document to replace to an\n        // active target that is being listened to, this might be just a target\n        // update instead.\n        if (docChange.newDoc && relevant) {\n            this.documentUpdates = this.documentUpdates.insert(docChange.key, docChange.newDoc);\n        }\n    };\n    WatchChangeAggregator.prototype.addTargetChange = function (targetChange) {\n        var _this = this;\n        targetChange.targetIds.forEach(function (targetId) {\n            var change = _this.ensureTargetChange(targetId);\n            switch (targetChange.state) {\n                case WatchTargetChangeState.NoChange:\n                    if (_this.isActiveTarget(targetId)) {\n                        // Creating the change above satisfies the semantics of no-change.\n                        applyResumeToken(change, targetChange.resumeToken);\n                    }\n                    break;\n                case WatchTargetChangeState.Added:\n                    // We need to decrement the number of pending acks needed from watch\n                    // for this targetId.\n                    _this.recordTargetResponse(targetId);\n                    if (!objUtils.contains(_this.pendingTargetResponses, targetId)) {\n                        // We have a freshly added target, so we need to reset any state\n                        // that we had previously This can happen e.g. when remove and add\n                        // back a target for existence filter mismatches.\n                        change.mapping = new UpdateMapping();\n                        change.currentStatusUpdate = CurrentStatusUpdate.None;\n                        delete _this.existenceFilters[targetId];\n                    }\n                    applyResumeToken(change, targetChange.resumeToken);\n                    break;\n                case WatchTargetChangeState.Removed:\n                    // We need to keep track of removed targets to we can\n                    // post-filter and remove any target changes.\n                    // We need to decrement the number of pending acks needed from watch\n                    // for this targetId.\n                    _this.recordTargetResponse(targetId);\n                    assert(!targetChange.cause, 'WatchChangeAggregator does not handle errored targets');\n                    break;\n                case WatchTargetChangeState.Current:\n                    if (_this.isActiveTarget(targetId)) {\n                        change.currentStatusUpdate = CurrentStatusUpdate.MarkCurrent;\n                        applyResumeToken(change, targetChange.resumeToken);\n                    }\n                    break;\n                case WatchTargetChangeState.Reset:\n                    if (_this.isActiveTarget(targetId)) {\n                        // Overwrite any existing target mapping with a reset\n                        // mapping. Every subsequent update will modify the reset\n                        // mapping, not an update mapping.\n                        change.mapping = new ResetMapping();\n                        applyResumeToken(change, targetChange.resumeToken);\n                    }\n                    break;\n                default:\n                    fail('Unknown target watch change state: ' + targetChange.state);\n            }\n        });\n    };\n    /**\n     * Record that we get a watch target add/remove by decrementing the number of\n     * pending target responses that we have.\n     */\n    WatchChangeAggregator.prototype.recordTargetResponse = function (targetId) {\n        var newCount = (this.pendingTargetResponses[targetId] || 0) - 1;\n        if (newCount === 0) {\n            delete this.pendingTargetResponses[targetId];\n        }\n        else {\n            this.pendingTargetResponses[targetId] = newCount;\n        }\n    };\n    WatchChangeAggregator.prototype.addExistenceFilterChange = function (change) {\n        if (this.isActiveTarget(change.targetId)) {\n            this.existenceFilters[change.targetId] = change.existenceFilter;\n        }\n    };\n    return WatchChangeAggregator;\n}());\nexport { WatchChangeAggregator };\n/**\n * Applies the resume token to the TargetChange, but only when it has a new\n * value. null and empty resumeTokens are discarded.\n */\nfunction applyResumeToken(change, resumeToken) {\n    if (resumeToken.length > 0) {\n        change.resumeToken = resumeToken;\n    }\n}\n\n//# sourceMappingURL=watch_change.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/remote/watch_change.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Blob } from '../api/blob';\nimport { GeoPoint } from '../api/geo_point';\nimport { DatabaseId } from '../core/database_info';\nimport { Bound, Direction, NanFilter, NullFilter, OrderBy, Query, RelationFilter, RelationOp } from '../core/query';\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../core/timestamp';\nimport { QueryPurpose } from '../local/query_data';\nimport { Document, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport * as fieldValue from '../model/field_value';\nimport { DeleteMutation, FieldMask, FieldTransform, MutationResult, PatchMutation, Precondition, ServerTimestampTransform, SetMutation, TransformMutation } from '../model/mutation';\nimport { FieldPath, ResourcePath } from '../model/path';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport * as obj from '../util/obj';\nimport * as typeUtils from '../util/types';\nimport { ExistenceFilter } from './existence_filter';\nimport { mapCodeFromRpcCode, mapRpcCodeFromCode } from './rpc_error';\nimport { DocumentWatchChange, ExistenceFilterChange, WatchTargetChange, WatchTargetChangeState } from './watch_change';\nvar DIRECTIONS = (function () {\n    var dirs = {};\n    dirs[Direction.ASCENDING.name] = 'ASCENDING';\n    dirs[Direction.DESCENDING.name] = 'DESCENDING';\n    return dirs;\n})();\nvar OPERATORS = (function () {\n    var ops = {};\n    ops[RelationOp.LESS_THAN.name] = 'LESS_THAN';\n    ops[RelationOp.LESS_THAN_OR_EQUAL.name] = 'LESS_THAN_OR_EQUAL';\n    ops[RelationOp.GREATER_THAN.name] = 'GREATER_THAN';\n    ops[RelationOp.GREATER_THAN_OR_EQUAL.name] = 'GREATER_THAN_OR_EQUAL';\n    ops[RelationOp.EQUAL.name] = 'EQUAL';\n    return ops;\n})();\nfunction assertPresent(value, description) {\n    assert(!typeUtils.isNullOrUndefined(value), description + ' is missing');\n}\nfunction parseInt64(value) {\n    // TODO(bjornick): Handle int64 greater than 53 bits.\n    if (typeof value === 'number') {\n        return value;\n    }\n    else if (typeof value === 'string') {\n        return Number(value);\n    }\n    else {\n        return fail(\"can't parse \" + value);\n    }\n}\n/**\n * Generates JsonObject values for the Datastore API suitable for sending to\n * either GRPC stub methods or via the JSON/HTTP REST API.\n * TODO(klimt): We can remove the databaseId argument if we keep the full\n * resource name in documents.\n */\nvar JsonProtoSerializer = /** @class */ (function () {\n    function JsonProtoSerializer(databaseId, options) {\n        this.databaseId = databaseId;\n        this.options = options;\n    }\n    JsonProtoSerializer.prototype.emptyByteString = function () {\n        if (this.options.useProto3Json) {\n            return '';\n        }\n        else {\n            return new Uint8Array(0);\n        }\n    };\n    JsonProtoSerializer.prototype.unsafeCastProtoByteString = function (byteString) {\n        // byteStrings can be either string or UInt8Array, but the typings say\n        // it's always a string. Cast as string to avoid type check failing\n        return byteString;\n    };\n    JsonProtoSerializer.prototype.fromRpcStatus = function (status) {\n        var code = status.code === undefined\n            ? Code.UNKNOWN\n            : mapCodeFromRpcCode(status.code);\n        return new FirestoreError(code, status.message || '');\n    };\n    /**\n     * Returns a value for a number (or undefined) that's appropriate to put into\n     * a google.protobuf.Int32Value proto.\n     * DO NOT USE THIS FOR ANYTHING ELSE.\n     * This method cheats. It's typed as returning \"number\" because that's what\n     * our generated proto interfaces say Int32Value must be. But GRPC actually\n     * expects a { value: <number> } struct.\n     */\n    JsonProtoSerializer.prototype.toInt32Value = function (val) {\n        if (!typeUtils.isNullOrUndefined(val)) {\n            // tslint:disable-next-line:no-any We need to match generated Proto types.\n            return { value: val };\n        }\n        else {\n            return undefined;\n        }\n    };\n    /**\n     * Returns a number (or null) from a google.protobuf.Int32Value proto.\n     * DO NOT USE THIS FOR ANYTHING ELSE.\n     * This method cheats. It's typed as accepting \"number\" because that's what\n     * our generated proto interfaces say Int32Value must be, but it actually\n     * accepts { value: number } to match our serialization in toInt32Value().\n     */\n    JsonProtoSerializer.prototype.fromInt32Value = function (val) {\n        var result;\n        if (typeof val === 'object') {\n            // tslint:disable-next-line:no-any We need to match generated Proto types.\n            result = val.value;\n        }\n        else {\n            // We accept raw numbers (without the {value: ... } wrapper) for\n            // compatibility with legacy persisted data.\n            result = val;\n        }\n        return typeUtils.isNullOrUndefined(result) ? null : result;\n    };\n    /**\n     * Returns a value for a Date that's appropriate to put into a proto.\n     * DO NOT USE THIS FOR ANYTHING ELSE.\n     * This method cheats. It's typed as returning \"string\" because that's what\n     * our generated proto interfaces say dates must be. But it's easier and safer\n     * to actually return a Timestamp proto.\n     */\n    JsonProtoSerializer.prototype.toTimestamp = function (timestamp) {\n        return {\n            seconds: timestamp.seconds,\n            nanos: timestamp.nanos\n            // tslint:disable-next-line:no-any\n        };\n    };\n    JsonProtoSerializer.prototype.fromTimestamp = function (date) {\n        // The json interface (for the browser) will return an iso timestamp string,\n        // while the proto js library (for node) will return a\n        // google.protobuf.Timestamp instance.\n        if (typeof date === 'string') {\n            // TODO(b/37282237): Use strings for Proto3 timestamps\n            // assert(this.options.useProto3Json,\n            //   'The timestamp string format requires Proto3.');\n            return Timestamp.fromISOString(date);\n        }\n        else {\n            assert(!!date, 'Cannot deserialize null or undefined timestamp.');\n            // TODO(b/37282237): Use strings for Proto3 timestamps\n            // assert(!this.options.useProto3Json,\n            //   'The timestamp instance format requires Proto JS.');\n            var seconds = parseInt64(date.seconds || '0');\n            var nanos = date.nanos || 0;\n            return new Timestamp(seconds, nanos);\n        }\n    };\n    /**\n     * Returns a value for bytes that's appropriate to put in a proto.\n     * DO NOT USE THIS FOR ANYTHING ELSE.\n     * This method cheats. It's typed as returning \"string\" because that's what\n     * our generated proto interfaces say bytes must be. But it should return\n     * an Uint8Array in Node.\n     */\n    JsonProtoSerializer.prototype.toBytes = function (bytes) {\n        if (this.options.useProto3Json) {\n            return bytes.toBase64();\n        }\n        else {\n            // The typings say it's a string, but it needs to be a Uint8Array in Node.\n            return this.unsafeCastProtoByteString(bytes.toUint8Array());\n        }\n    };\n    /**\n     * Parse the blob from the protos into the internal Blob class. Note that the\n     * typings assume all blobs are strings, but they are actually Uint8Arrays\n     * on Node.\n     */\n    JsonProtoSerializer.prototype.fromBlob = function (blob) {\n        if (typeof blob === 'string') {\n            assert(this.options.useProto3Json, 'Expected bytes to be passed in as Uint8Array, but got a string instead.');\n            return Blob.fromBase64String(blob);\n        }\n        else {\n            assert(!this.options.useProto3Json, 'Expected bytes to be passed in as string, but got something else instead.');\n            return Blob.fromUint8Array(blob);\n        }\n    };\n    JsonProtoSerializer.prototype.toVersion = function (version) {\n        return this.toTimestamp(version.toTimestamp());\n    };\n    JsonProtoSerializer.prototype.fromVersion = function (version) {\n        assert(!!version, \"Trying to deserialize version that isn't set\");\n        return SnapshotVersion.fromTimestamp(this.fromTimestamp(version));\n    };\n    JsonProtoSerializer.prototype.toResourceName = function (databaseId, path) {\n        return this.fullyQualifiedPrefixPath(databaseId)\n            .child('documents')\n            .child(path)\n            .canonicalString();\n    };\n    JsonProtoSerializer.prototype.fromResourceName = function (name) {\n        var resource = ResourcePath.fromString(name);\n        assert(this.isValidResourceName(resource), 'Tried to deserialize invalid key ' + resource.toString());\n        return resource;\n    };\n    JsonProtoSerializer.prototype.toName = function (key) {\n        return this.toResourceName(this.databaseId, key.path);\n    };\n    JsonProtoSerializer.prototype.fromName = function (name) {\n        var resource = this.fromResourceName(name);\n        assert(resource.get(1) === this.databaseId.projectId, 'Tried to deserialize key from different project: ' +\n            resource.get(1) +\n            ' vs ' +\n            this.databaseId.projectId);\n        assert((!resource.get(3) && !this.databaseId.database) ||\n            resource.get(3) === this.databaseId.database, 'Tried to deserialize key from different database: ' +\n            resource.get(3) +\n            ' vs ' +\n            this.databaseId.database);\n        return new DocumentKey(this.extractLocalPathFromResourceName(resource));\n    };\n    JsonProtoSerializer.prototype.toQueryPath = function (path) {\n        if (path.length === 0) {\n            // If the path is empty, the backend requires we leave off the /documents\n            // at the end.\n            return this.encodedDatabaseId;\n        }\n        return this.toResourceName(this.databaseId, path);\n    };\n    JsonProtoSerializer.prototype.fromQueryPath = function (name) {\n        var resourceName = this.fromResourceName(name);\n        if (resourceName.length === 4) {\n            return ResourcePath.EMPTY_PATH;\n        }\n        return this.extractLocalPathFromResourceName(resourceName);\n    };\n    Object.defineProperty(JsonProtoSerializer.prototype, \"encodedDatabaseId\", {\n        get: function () {\n            var path = new ResourcePath([\n                'projects',\n                this.databaseId.projectId,\n                'databases',\n                this.databaseId.database\n            ]);\n            return path.canonicalString();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    JsonProtoSerializer.prototype.fullyQualifiedPrefixPath = function (databaseId) {\n        return new ResourcePath([\n            'projects',\n            databaseId.projectId,\n            'databases',\n            databaseId.database\n        ]);\n    };\n    JsonProtoSerializer.prototype.extractLocalPathFromResourceName = function (resourceName) {\n        assert(resourceName.length > 4 && resourceName.get(4) === 'documents', 'tried to deserialize invalid key ' + resourceName.toString());\n        return resourceName.popFirst(5);\n    };\n    JsonProtoSerializer.prototype.isValidResourceName = function (path) {\n        // Resource names have at least 4 components (project ID, database ID)\n        return (path.length >= 4 &&\n            path.get(0) === 'projects' &&\n            path.get(2) === 'databases');\n    };\n    JsonProtoSerializer.prototype.toValue = function (val) {\n        if (val instanceof fieldValue.NullValue) {\n            return { nullValue: 'NULL_VALUE' };\n        }\n        else if (val instanceof fieldValue.BooleanValue) {\n            return { booleanValue: val.value() };\n        }\n        else if (val instanceof fieldValue.IntegerValue) {\n            return { integerValue: '' + val.value() };\n        }\n        else if (val instanceof fieldValue.DoubleValue) {\n            var doubleValue = val.value();\n            if (this.options.useProto3Json) {\n                // Proto 3 let's us encode NaN and Infinity as string values as\n                // expected by the backend. This is currently not checked by our unit\n                // tests because they rely on protobuf.js.\n                if (isNaN(doubleValue)) {\n                    return { doubleValue: 'NaN' };\n                }\n                else if (doubleValue === Infinity) {\n                    return { doubleValue: 'Infinity' };\n                }\n                else if (doubleValue === -Infinity) {\n                    return { doubleValue: '-Infinity' };\n                }\n            }\n            return { doubleValue: val.value() };\n        }\n        else if (val instanceof fieldValue.StringValue) {\n            return { stringValue: val.value() };\n        }\n        else if (val instanceof fieldValue.ObjectValue) {\n            return { mapValue: this.toMapValue(val) };\n        }\n        else if (val instanceof fieldValue.ArrayValue) {\n            return { arrayValue: this.toArrayValue(val) };\n        }\n        else if (val instanceof fieldValue.TimestampValue) {\n            return {\n                timestampValue: this.toTimestamp(val.internalValue)\n            };\n        }\n        else if (val instanceof fieldValue.GeoPointValue) {\n            return {\n                geoPointValue: {\n                    latitude: val.value().latitude,\n                    longitude: val.value().longitude\n                }\n            };\n        }\n        else if (val instanceof fieldValue.BlobValue) {\n            return {\n                bytesValue: this.toBytes(val.value())\n            };\n        }\n        else if (val instanceof fieldValue.RefValue) {\n            return {\n                referenceValue: this.toResourceName(val.databaseId, val.key.path)\n            };\n        }\n        else {\n            return fail('Unknown FieldValue ' + JSON.stringify(val));\n        }\n    };\n    JsonProtoSerializer.prototype.fromValue = function (obj) {\n        var _this = this;\n        // tslint:disable-next-line:no-any\n        var type = obj['value_type'];\n        if (hasTag(obj, type, 'nullValue')) {\n            return fieldValue.NullValue.INSTANCE;\n        }\n        else if (hasTag(obj, type, 'booleanValue')) {\n            return fieldValue.BooleanValue.of(obj.booleanValue);\n        }\n        else if (hasTag(obj, type, 'integerValue')) {\n            return new fieldValue.IntegerValue(parseInt64(obj.integerValue));\n        }\n        else if (hasTag(obj, type, 'doubleValue')) {\n            if (this.options.useProto3Json) {\n                // Proto 3 uses the string values 'NaN' and 'Infinity'.\n                if (obj.doubleValue === 'NaN') {\n                    return fieldValue.DoubleValue.NAN;\n                }\n                else if (obj.doubleValue === 'Infinity') {\n                    return fieldValue.DoubleValue.POSITIVE_INFINITY;\n                }\n                else if (obj.doubleValue === '-Infinity') {\n                    return fieldValue.DoubleValue.NEGATIVE_INFINITY;\n                }\n            }\n            return new fieldValue.DoubleValue(obj.doubleValue);\n        }\n        else if (hasTag(obj, type, 'stringValue')) {\n            return new fieldValue.StringValue(obj.stringValue);\n        }\n        else if (hasTag(obj, type, 'mapValue')) {\n            return this.fromFields(obj.mapValue.fields || {});\n        }\n        else if (hasTag(obj, type, 'arrayValue')) {\n            // \"values\" is not present if the array is empty\n            assertPresent(obj.arrayValue, 'arrayValue');\n            var values = obj.arrayValue.values || [];\n            return new fieldValue.ArrayValue(values.map(function (v) { return _this.fromValue(v); }));\n        }\n        else if (hasTag(obj, type, 'timestampValue')) {\n            assertPresent(obj.timestampValue, 'timestampValue');\n            return new fieldValue.TimestampValue(this.fromTimestamp(obj.timestampValue));\n        }\n        else if (hasTag(obj, type, 'geoPointValue')) {\n            assertPresent(obj.geoPointValue, 'geoPointValue');\n            var latitude = obj.geoPointValue.latitude || 0;\n            var longitude = obj.geoPointValue.longitude || 0;\n            return new fieldValue.GeoPointValue(new GeoPoint(latitude, longitude));\n        }\n        else if (hasTag(obj, type, 'bytesValue')) {\n            assertPresent(obj.bytesValue, 'bytesValue');\n            var blob = this.fromBlob(obj.bytesValue);\n            return new fieldValue.BlobValue(blob);\n        }\n        else if (hasTag(obj, type, 'referenceValue')) {\n            assertPresent(obj.referenceValue, 'referenceValue');\n            var resourceName = this.fromResourceName(obj.referenceValue);\n            var dbId = new DatabaseId(resourceName.get(1), resourceName.get(3));\n            var key = new DocumentKey(this.extractLocalPathFromResourceName(resourceName));\n            return new fieldValue.RefValue(dbId, key);\n        }\n        else {\n            return fail('Unknown Value proto ' + JSON.stringify(obj));\n        }\n    };\n    /** Creates an api.Document from key and fields (but no create/update time) */\n    JsonProtoSerializer.prototype.toMutationDocument = function (key, fields) {\n        return {\n            name: this.toName(key),\n            fields: this.toFields(fields)\n        };\n    };\n    JsonProtoSerializer.prototype.toDocument = function (document) {\n        assert(!document.hasLocalMutations, \"Can't serialize documents with mutations.\");\n        return {\n            name: this.toName(document.key),\n            fields: this.toFields(document.data),\n            updateTime: this.toTimestamp(document.version.toTimestamp())\n        };\n    };\n    JsonProtoSerializer.prototype.fromDocument = function (document) {\n        return new Document(this.fromName(document.name), this.fromVersion(document.updateTime), this.fromFields(document.fields || {}), { hasLocalMutations: false });\n    };\n    JsonProtoSerializer.prototype.toFields = function (fields) {\n        var _this = this;\n        var result = {};\n        fields.forEach(function (key, value) {\n            result[key] = _this.toValue(value);\n        });\n        return result;\n    };\n    JsonProtoSerializer.prototype.fromFields = function (object) {\n        var _this = this;\n        // Proto map<string, Value> gets mapped to Object, so cast it.\n        var map = object;\n        var result = fieldValue.ObjectValue.EMPTY;\n        obj.forEach(map, function (key, value) {\n            result = result.set(new FieldPath([key]), _this.fromValue(value));\n        });\n        return result;\n    };\n    JsonProtoSerializer.prototype.toMapValue = function (map) {\n        return {\n            fields: this.toFields(map)\n        };\n    };\n    JsonProtoSerializer.prototype.toArrayValue = function (array) {\n        var _this = this;\n        var result = [];\n        array.forEach(function (value) {\n            result.push(_this.toValue(value));\n        });\n        return { values: result };\n    };\n    JsonProtoSerializer.prototype.fromFound = function (doc) {\n        assert(!!doc.found, 'Tried to deserialize a found document from a missing document.');\n        assertPresent(doc.found.name, 'doc.found.name');\n        assertPresent(doc.found.updateTime, 'doc.found.updateTime');\n        var key = this.fromName(doc.found.name);\n        var version = this.fromVersion(doc.found.updateTime);\n        var fields = this.fromFields(doc.found.fields || {});\n        return new Document(key, version, fields, { hasLocalMutations: false });\n    };\n    JsonProtoSerializer.prototype.fromMissing = function (result) {\n        assert(!!result.missing, 'Tried to deserialize a missing document from a found document.');\n        assert(!!result.readTime, 'Tried to deserialize a missing document without a read time.');\n        var key = this.fromName(result.missing);\n        var version = this.fromVersion(result.readTime);\n        return new NoDocument(key, version);\n    };\n    JsonProtoSerializer.prototype.fromMaybeDocument = function (result) {\n        // tslint:disable-next-line:no-any\n        var type = result['result'];\n        if (hasTag(result, type, 'found')) {\n            return this.fromFound(result);\n        }\n        else if (hasTag(result, type, 'missing')) {\n            return this.fromMissing(result);\n        }\n        return fail('invalid batch get response: ' + JSON.stringify(result));\n    };\n    JsonProtoSerializer.prototype.toWatchTargetChangeState = function (state) {\n        switch (state) {\n            case WatchTargetChangeState.Added:\n                return 'ADD';\n            case WatchTargetChangeState.Current:\n                return 'CURRENT';\n            case WatchTargetChangeState.NoChange:\n                return 'NO_CHANGE';\n            case WatchTargetChangeState.Removed:\n                return 'REMOVE';\n            case WatchTargetChangeState.Reset:\n                return 'RESET';\n            default:\n                return fail('Unknown WatchTargetChangeState: ' + state);\n        }\n    };\n    JsonProtoSerializer.prototype.toTestWatchChange = function (watchChange) {\n        if (watchChange instanceof ExistenceFilterChange) {\n            return {\n                filter: {\n                    count: watchChange.existenceFilter.count,\n                    targetId: watchChange.targetId\n                }\n            };\n        }\n        if (watchChange instanceof DocumentWatchChange) {\n            if (watchChange.newDoc instanceof Document) {\n                var doc = watchChange.newDoc;\n                return {\n                    documentChange: {\n                        document: {\n                            name: this.toName(doc.key),\n                            fields: this.toFields(doc.data),\n                            updateTime: this.toVersion(doc.version)\n                        },\n                        targetIds: watchChange.updatedTargetIds,\n                        removedTargetIds: watchChange.removedTargetIds\n                    }\n                };\n            }\n            else if (watchChange.newDoc instanceof NoDocument) {\n                var doc = watchChange.newDoc;\n                return {\n                    documentDelete: {\n                        document: this.toName(doc.key),\n                        readTime: this.toVersion(doc.version),\n                        removedTargetIds: watchChange.removedTargetIds\n                    }\n                };\n            }\n            else if (watchChange.newDoc === null) {\n                return {\n                    documentRemove: {\n                        document: this.toName(watchChange.key),\n                        removedTargetIds: watchChange.removedTargetIds\n                    }\n                };\n            }\n        }\n        if (watchChange instanceof WatchTargetChange) {\n            var cause = undefined;\n            if (watchChange.cause) {\n                cause = {\n                    code: mapRpcCodeFromCode(watchChange.cause.code),\n                    message: watchChange.cause.message\n                };\n            }\n            return {\n                targetChange: {\n                    targetChangeType: this.toWatchTargetChangeState(watchChange.state),\n                    targetIds: watchChange.targetIds,\n                    resumeToken: this.unsafeCastProtoByteString(watchChange.resumeToken),\n                    cause: cause\n                }\n            };\n        }\n        return fail('Unrecognized watch change: ' + JSON.stringify(watchChange));\n    };\n    JsonProtoSerializer.prototype.fromWatchChange = function (change) {\n        // tslint:disable-next-line:no-any\n        var type = change['response_type'];\n        var watchChange;\n        if (hasTag(change, type, 'targetChange')) {\n            assertPresent(change.targetChange, 'targetChange');\n            // proto3 default value is unset in JSON (undefined), so use 'NO_CHANGE'\n            // if unset\n            var state = this.fromWatchTargetChangeState(change.targetChange.targetChangeType || 'NO_CHANGE');\n            var targetIds = change.targetChange.targetIds || [];\n            var resumeToken = change.targetChange.resumeToken || this.emptyByteString();\n            var causeProto = change.targetChange.cause;\n            var cause = causeProto && this.fromRpcStatus(causeProto);\n            watchChange = new WatchTargetChange(state, targetIds, resumeToken, cause || null);\n        }\n        else if (hasTag(change, type, 'documentChange')) {\n            assertPresent(change.documentChange, 'documentChange');\n            assertPresent(change.documentChange.document, 'documentChange.name');\n            assertPresent(change.documentChange.document.name, 'documentChange.document.name');\n            assertPresent(change.documentChange.document.updateTime, 'documentChange.document.updateTime');\n            var entityChange = change.documentChange;\n            var key = this.fromName(entityChange.document.name);\n            var version = this.fromVersion(entityChange.document.updateTime);\n            var fields = this.fromFields(entityChange.document.fields || {});\n            var doc = new Document(key, version, fields, {\n                hasLocalMutations: false\n            });\n            var updatedTargetIds = entityChange.targetIds || [];\n            var removedTargetIds = entityChange.removedTargetIds || [];\n            watchChange = new DocumentWatchChange(updatedTargetIds, removedTargetIds, doc.key, doc);\n        }\n        else if (hasTag(change, type, 'documentDelete')) {\n            assertPresent(change.documentDelete, 'documentDelete');\n            assertPresent(change.documentDelete.document, 'documentDelete.document');\n            var docDelete = change.documentDelete;\n            var key = this.fromName(docDelete.document);\n            var version = docDelete.readTime\n                ? this.fromVersion(docDelete.readTime)\n                : SnapshotVersion.forDeletedDoc();\n            var doc = new NoDocument(key, version);\n            var removedTargetIds = docDelete.removedTargetIds || [];\n            watchChange = new DocumentWatchChange([], removedTargetIds, doc.key, doc);\n        }\n        else if (hasTag(change, type, 'documentRemove')) {\n            assertPresent(change.documentRemove, 'documentRemove');\n            assertPresent(change.documentRemove.document, 'documentRemove');\n            var docRemove = change.documentRemove;\n            var key = this.fromName(docRemove.document);\n            var removedTargetIds = docRemove.removedTargetIds || [];\n            watchChange = new DocumentWatchChange([], removedTargetIds, key, null);\n        }\n        else if (hasTag(change, type, 'filter')) {\n            // TODO(dimond): implement existence filter parsing with strategy.\n            assertPresent(change.filter, 'filter');\n            assertPresent(change.filter.targetId, 'filter.targetId');\n            var filter = change.filter;\n            var count = filter.count || 0;\n            var existenceFilter = new ExistenceFilter(count);\n            var targetId = filter.targetId;\n            watchChange = new ExistenceFilterChange(targetId, existenceFilter);\n        }\n        else {\n            return fail('Unknown change type ' + JSON.stringify(change));\n        }\n        return watchChange;\n    };\n    JsonProtoSerializer.prototype.fromWatchTargetChangeState = function (state) {\n        if (state === 'NO_CHANGE') {\n            return WatchTargetChangeState.NoChange;\n        }\n        else if (state === 'ADD') {\n            return WatchTargetChangeState.Added;\n        }\n        else if (state === 'REMOVE') {\n            return WatchTargetChangeState.Removed;\n        }\n        else if (state === 'CURRENT') {\n            return WatchTargetChangeState.Current;\n        }\n        else if (state === 'RESET') {\n            return WatchTargetChangeState.Reset;\n        }\n        else {\n            return fail('Got unexpected TargetChange.state: ' + state);\n        }\n    };\n    JsonProtoSerializer.prototype.versionFromListenResponse = function (change) {\n        // We have only reached a consistent snapshot for the entire stream if there\n        // is a read_time set and it applies to all targets (i.e. the list of\n        // targets is empty). The backend is guaranteed to send such responses.\n        // tslint:disable-next-line:no-any\n        var type = change['response_type'];\n        if (!hasTag(change, type, 'targetChange')) {\n            return SnapshotVersion.MIN;\n        }\n        var targetChange = change.targetChange;\n        if (targetChange.targetIds && targetChange.targetIds.length) {\n            return SnapshotVersion.MIN;\n        }\n        if (!targetChange.readTime) {\n            return SnapshotVersion.MIN;\n        }\n        return this.fromVersion(targetChange.readTime);\n    };\n    JsonProtoSerializer.prototype.toMutation = function (mutation) {\n        var _this = this;\n        var result;\n        if (mutation instanceof SetMutation) {\n            result = {\n                update: this.toMutationDocument(mutation.key, mutation.value)\n            };\n        }\n        else if (mutation instanceof DeleteMutation) {\n            result = { delete: this.toName(mutation.key) };\n        }\n        else if (mutation instanceof PatchMutation) {\n            result = {\n                update: this.toMutationDocument(mutation.key, mutation.data),\n                updateMask: this.toDocumentMask(mutation.fieldMask)\n            };\n        }\n        else if (mutation instanceof TransformMutation) {\n            result = {\n                transform: {\n                    document: this.toName(mutation.key),\n                    fieldTransforms: mutation.fieldTransforms.map(function (transform) {\n                        return _this.toFieldTransform(transform);\n                    })\n                }\n            };\n        }\n        else {\n            return fail('Unknown mutation type ' + mutation.type);\n        }\n        if (!mutation.precondition.isNone) {\n            result.currentDocument = this.toPrecondition(mutation.precondition);\n        }\n        return result;\n    };\n    JsonProtoSerializer.prototype.fromMutation = function (proto) {\n        var _this = this;\n        var precondition = proto.currentDocument\n            ? this.fromPrecondition(proto.currentDocument)\n            : Precondition.NONE;\n        if (proto.update) {\n            assertPresent(proto.update.name, 'name');\n            var key = this.fromName(proto.update.name);\n            var value = this.fromFields(proto.update.fields || {});\n            if (proto.updateMask) {\n                var fieldMask = this.fromDocumentMask(proto.updateMask);\n                return new PatchMutation(key, value, fieldMask, precondition);\n            }\n            else {\n                return new SetMutation(key, value, precondition);\n            }\n        }\n        else if (proto.delete) {\n            var key = this.fromName(proto.delete);\n            return new DeleteMutation(key, precondition);\n        }\n        else if (proto.transform) {\n            var key = this.fromName(proto.transform.document);\n            var fieldTransforms = proto.transform.fieldTransforms.map(function (transform) {\n                return _this.fromFieldTransform(transform);\n            });\n            assert(precondition.exists === true, 'Transforms only support precondition \"exists == true\"');\n            return new TransformMutation(key, fieldTransforms);\n        }\n        else {\n            return fail('unknown mutation proto: ' + JSON.stringify(proto));\n        }\n    };\n    JsonProtoSerializer.prototype.toPrecondition = function (precondition) {\n        assert(!precondition.isNone, \"Can't serialize an empty precondition\");\n        if (precondition.updateTime !== undefined) {\n            return {\n                updateTime: this.toVersion(precondition.updateTime)\n            };\n        }\n        else if (precondition.exists !== undefined) {\n            return { exists: precondition.exists };\n        }\n        else {\n            return fail('Unknown precondition');\n        }\n    };\n    JsonProtoSerializer.prototype.fromPrecondition = function (precondition) {\n        if (precondition.updateTime !== undefined) {\n            return Precondition.updateTime(this.fromVersion(precondition.updateTime));\n        }\n        else if (precondition.exists !== undefined) {\n            return Precondition.exists(precondition.exists);\n        }\n        else {\n            return Precondition.NONE;\n        }\n    };\n    JsonProtoSerializer.prototype.fromWriteResult = function (proto) {\n        var _this = this;\n        // NOTE: Deletes don't have an updateTime.\n        var version = proto.updateTime\n            ? this.fromVersion(proto.updateTime)\n            : null;\n        var transformResults = null;\n        if (proto.transformResults && proto.transformResults.length > 0) {\n            transformResults = proto.transformResults.map(function (result) {\n                return _this.fromValue(result);\n            });\n        }\n        return new MutationResult(version, transformResults);\n    };\n    JsonProtoSerializer.prototype.fromWriteResults = function (protos) {\n        var _this = this;\n        return (protos || []).map(function (proto) { return _this.fromWriteResult(proto); });\n    };\n    JsonProtoSerializer.prototype.toFieldTransform = function (fieldTransform) {\n        assert(fieldTransform.transform instanceof ServerTimestampTransform, 'Unknown transform: ' + fieldTransform.transform);\n        return {\n            fieldPath: fieldTransform.field.canonicalString(),\n            setToServerValue: 'REQUEST_TIME'\n        };\n    };\n    JsonProtoSerializer.prototype.fromFieldTransform = function (proto) {\n        assert(proto.setToServerValue === 'REQUEST_TIME', 'Unknown transform proto: ' + JSON.stringify(proto));\n        var fieldPath = FieldPath.fromServerFormat(proto.fieldPath);\n        return new FieldTransform(fieldPath, ServerTimestampTransform.instance);\n    };\n    JsonProtoSerializer.prototype.toDocumentsTarget = function (query) {\n        return { documents: [this.toQueryPath(query.path)] };\n    };\n    JsonProtoSerializer.prototype.fromDocumentsTarget = function (documentsTarget) {\n        var count = documentsTarget.documents.length;\n        assert(count === 1, 'DocumentsTarget contained other than 1 document: ' + count);\n        var name = documentsTarget.documents[0];\n        return Query.atPath(this.fromQueryPath(name));\n    };\n    JsonProtoSerializer.prototype.toQueryTarget = function (query) {\n        // Dissect the path into parent, collectionId, and optional key filter.\n        var result = { structuredQuery: {} };\n        if (query.path.isEmpty()) {\n            result.parent = this.toQueryPath(ResourcePath.EMPTY_PATH);\n        }\n        else {\n            var path = query.path;\n            assert(path.length % 2 !== 0, 'Document queries with filters are not supported.');\n            result.parent = this.toQueryPath(path.popLast());\n            result.structuredQuery.from = [{ collectionId: path.lastSegment() }];\n        }\n        var where = this.toFilter(query.filters);\n        if (where) {\n            result.structuredQuery.where = where;\n        }\n        var orderBy = this.toOrder(query.orderBy);\n        if (orderBy) {\n            result.structuredQuery.orderBy = orderBy;\n        }\n        var limit = this.toInt32Value(query.limit);\n        if (limit !== undefined) {\n            result.structuredQuery.limit = limit;\n        }\n        if (query.startAt) {\n            result.structuredQuery.startAt = this.toCursor(query.startAt);\n        }\n        if (query.endAt) {\n            result.structuredQuery.endAt = this.toCursor(query.endAt);\n        }\n        return result;\n    };\n    JsonProtoSerializer.prototype.fromQueryTarget = function (target) {\n        var path = this.fromQueryPath(target.parent);\n        var query = target.structuredQuery;\n        var fromCount = query.from ? query.from.length : 0;\n        if (fromCount > 0) {\n            assert(fromCount === 1, 'StructuredQuery.from with more than one collection is not supported.');\n            var from = query.from[0];\n            path = path.child(from.collectionId);\n        }\n        var filterBy = [];\n        if (query.where) {\n            filterBy = this.fromFilter(query.where);\n        }\n        var orderBy = [];\n        if (query.orderBy) {\n            orderBy = this.fromOrder(query.orderBy);\n        }\n        var limit = null;\n        if (query.limit) {\n            limit = this.fromInt32Value(query.limit);\n        }\n        var startAt = null;\n        if (query.startAt) {\n            startAt = this.fromCursor(query.startAt);\n        }\n        var endAt = null;\n        if (query.endAt) {\n            endAt = this.fromCursor(query.endAt);\n        }\n        return new Query(path, orderBy, filterBy, limit, startAt, endAt);\n    };\n    JsonProtoSerializer.prototype.toListenRequestLabels = function (queryData) {\n        var value = this.toLabel(queryData.purpose);\n        if (value == null) {\n            return null;\n        }\n        else {\n            return {\n                'goog-listen-tags': value\n            };\n        }\n    };\n    JsonProtoSerializer.prototype.toLabel = function (purpose) {\n        switch (purpose) {\n            case QueryPurpose.Listen:\n                return null;\n            case QueryPurpose.ExistenceFilterMismatch:\n                return 'existence-filter-mismatch';\n            case QueryPurpose.LimboResolution:\n                return 'limbo-document';\n            default:\n                return fail('Unrecognized query purpose: ' + purpose);\n        }\n    };\n    JsonProtoSerializer.prototype.toTarget = function (queryData) {\n        var result;\n        var query = queryData.query;\n        if (query.isDocumentQuery()) {\n            result = { documents: this.toDocumentsTarget(query) };\n        }\n        else {\n            result = { query: this.toQueryTarget(query) };\n        }\n        result.targetId = queryData.targetId;\n        if (queryData.resumeToken.length > 0) {\n            result.resumeToken = this.unsafeCastProtoByteString(queryData.resumeToken);\n        }\n        return result;\n    };\n    JsonProtoSerializer.prototype.toFilter = function (filters) {\n        var _this = this;\n        if (filters.length === 0)\n            return;\n        var protos = filters.map(function (filter) {\n            return filter instanceof RelationFilter\n                ? _this.toRelationFilter(filter)\n                : _this.toUnaryFilter(filter);\n        });\n        if (protos.length === 1) {\n            return protos[0];\n        }\n        return { compositeFilter: { op: 'AND', filters: protos } };\n    };\n    JsonProtoSerializer.prototype.fromFilter = function (filter) {\n        var _this = this;\n        if (!filter) {\n            return [];\n        }\n        else if (filter.unaryFilter !== undefined) {\n            return [this.fromUnaryFilter(filter)];\n        }\n        else if (filter.fieldFilter !== undefined) {\n            return [this.fromRelationFilter(filter)];\n        }\n        else if (filter.compositeFilter !== undefined) {\n            return filter.compositeFilter.filters\n                .map(function (f) { return _this.fromFilter(f); })\n                .reduce(function (accum, current) { return accum.concat(current); });\n        }\n        else {\n            return fail('Unknown filter: ' + JSON.stringify(filter));\n        }\n    };\n    JsonProtoSerializer.prototype.toOrder = function (orderBys) {\n        var _this = this;\n        if (orderBys.length === 0)\n            return;\n        return orderBys.map(function (order) { return _this.toPropertyOrder(order); });\n    };\n    JsonProtoSerializer.prototype.fromOrder = function (orderBys) {\n        var _this = this;\n        return orderBys.map(function (order) { return _this.fromPropertyOrder(order); });\n    };\n    JsonProtoSerializer.prototype.toCursor = function (cursor) {\n        var _this = this;\n        return {\n            before: cursor.before,\n            values: cursor.position.map(function (component) { return _this.toValue(component); })\n        };\n    };\n    JsonProtoSerializer.prototype.fromCursor = function (cursor) {\n        var _this = this;\n        var before = !!cursor.before;\n        var position = cursor.values.map(function (component) { return _this.fromValue(component); });\n        return new Bound(position, before);\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.toDirection = function (dir) {\n        return DIRECTIONS[dir.name];\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.fromDirection = function (dir) {\n        switch (dir) {\n            case 'ASCENDING':\n                return Direction.ASCENDING;\n            case 'DESCENDING':\n                return Direction.DESCENDING;\n            default:\n                return undefined;\n        }\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.toOperatorName = function (op) {\n        return OPERATORS[op.name];\n    };\n    JsonProtoSerializer.prototype.fromOperatorName = function (op) {\n        switch (op) {\n            case 'EQUAL':\n                return RelationOp.EQUAL;\n            case 'GREATER_THAN':\n                return RelationOp.GREATER_THAN;\n            case 'GREATER_THAN_OR_EQUAL':\n                return RelationOp.GREATER_THAN_OR_EQUAL;\n            case 'LESS_THAN':\n                return RelationOp.LESS_THAN;\n            case 'LESS_THAN_OR_EQUAL':\n                return RelationOp.LESS_THAN_OR_EQUAL;\n            case 'OPERATOR_UNSPECIFIED':\n                return fail('Unspecified relation');\n            default:\n                return fail('Unknown relation');\n        }\n    };\n    JsonProtoSerializer.prototype.toFieldPathReference = function (path) {\n        return { fieldPath: path.canonicalString() };\n    };\n    JsonProtoSerializer.prototype.fromFieldPathReference = function (fieldReference) {\n        return FieldPath.fromServerFormat(fieldReference.fieldPath);\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.toPropertyOrder = function (orderBy) {\n        return {\n            field: this.toFieldPathReference(orderBy.field),\n            direction: this.toDirection(orderBy.dir)\n        };\n    };\n    JsonProtoSerializer.prototype.fromPropertyOrder = function (orderBy) {\n        return new OrderBy(this.fromFieldPathReference(orderBy.field), this.fromDirection(orderBy.direction));\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.toRelationFilter = function (filter) {\n        if (filter instanceof RelationFilter) {\n            return {\n                fieldFilter: {\n                    field: this.toFieldPathReference(filter.field),\n                    op: this.toOperatorName(filter.op),\n                    value: this.toValue(filter.value)\n                }\n            };\n        }\n        else {\n            return fail('Unrecognized filter: ' + JSON.stringify(filter));\n        }\n    };\n    JsonProtoSerializer.prototype.fromRelationFilter = function (filter) {\n        return new RelationFilter(this.fromFieldPathReference(filter.fieldFilter.field), this.fromOperatorName(filter.fieldFilter.op), this.fromValue(filter.fieldFilter.value));\n    };\n    // visible for testing\n    JsonProtoSerializer.prototype.toUnaryFilter = function (filter) {\n        if (filter instanceof NanFilter) {\n            return {\n                unaryFilter: {\n                    field: this.toFieldPathReference(filter.field),\n                    op: 'IS_NAN'\n                }\n            };\n        }\n        else if (filter instanceof NullFilter) {\n            return {\n                unaryFilter: {\n                    field: this.toFieldPathReference(filter.field),\n                    op: 'IS_NULL'\n                }\n            };\n        }\n        else {\n            return fail('Unrecognized filter: ' + JSON.stringify(filter));\n        }\n    };\n    JsonProtoSerializer.prototype.fromUnaryFilter = function (filter) {\n        switch (filter.unaryFilter.op) {\n            case 'IS_NAN':\n                var nanField = this.fromFieldPathReference(filter.unaryFilter.field);\n                return new NanFilter(nanField);\n            case 'IS_NULL':\n                var nullField = this.fromFieldPathReference(filter.unaryFilter.field);\n                return new NullFilter(nullField);\n            case 'OPERATOR_UNSPECIFIED':\n                return fail('Unspecified filter');\n            default:\n                return fail('Unknown filter');\n        }\n    };\n    JsonProtoSerializer.prototype.toDocumentMask = function (fieldMask) {\n        return {\n            fieldPaths: fieldMask.fields.map(function (field) { return field.canonicalString(); })\n        };\n    };\n    JsonProtoSerializer.prototype.fromDocumentMask = function (proto) {\n        var paths = proto.fieldPaths || [];\n        var fields = paths.map(function (path) { return FieldPath.fromServerFormat(path); });\n        return new FieldMask(fields);\n    };\n    return JsonProtoSerializer;\n}());\nexport { JsonProtoSerializer };\n/**\n * Checks for a specific oneof tag in a protocol buffer message.\n *\n * This intentionally accommodates two distinct cases:\n *\n * 1) Messages containing a type tag: these are the format produced by GRPC in\n * return values. These may contain default-value mappings for all tags in the\n * oneof but the type tag specifies which one was actually set.\n *\n * 2) Messages that don't contain a type tag: these are the format required by\n * GRPC as inputs. If we emitted objects with type tags, ProtoBuf.js would\n * choke claiming that the tags aren't fields in the Message.\n *\n * Allowing both formats here makes the serializer able to consume the outputs\n * it produces: for all messages it supports, fromX(toX(value)) == value.\n *\n * Note that case 2 suffers from ambiguity: if multiple tags are present\n * without a type tag then the callers are structured in such a way that the\n * first invocation will win. Since we only parse in this mode when parsing\n * the output of a serialize method this works, but it's not a general\n * solution.\n *\n * Unfortunately there is no general solution here because proto3 makes it\n * impossible to distinguish unset from explicitly set fields: both have the\n * default value for the type. Without the type tag but multiple value tags\n * it's possible to have default values for each tag in the oneof and not be\n * able to know which was actually in effect.\n */\nfunction hasTag(obj, type, tag) {\n    return type === tag || (!type && tag in obj);\n}\n\n//# sourceMappingURL=serializer.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/remote/serializer.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { FieldPath as InternalFieldPath } from '../model/path';\nimport { Code, FirestoreError } from '../util/error';\nimport { invalidClassError, validateArgType, validateNamedArrayAtLeastNumberOfElements } from '../util/input_validation';\n// The objects that are a part of this API are exposed to third-parties as\n// compiled javascript so we want to flag our private members with a leading\n// underscore to discourage their use.\n// tslint:disable:strip-private-property-underscore\n/**\n * A FieldPath refers to a field in a document. The path may consist of a single\n * field name (referring to a top-level field in the document), or a list of\n * field names (referring to a nested field in the document).\n */\nvar FieldPath = /** @class */ (function () {\n    /**\n     * Creates a FieldPath from the provided field names. If more than one field\n     * name is provided, the path will point to a nested field in a document.\n     *\n     * @param fieldNames A list of field names.\n     */\n    function FieldPath() {\n        var fieldNames = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            fieldNames[_i] = arguments[_i];\n        }\n        validateNamedArrayAtLeastNumberOfElements('FieldPath', fieldNames, 'fieldNames', 1);\n        for (var i = 0; i < fieldNames.length; ++i) {\n            validateArgType('FieldPath', 'string', i, fieldNames[i]);\n            if (fieldNames[i].length === 0) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid field name at argument $(i + 1). \" +\n                    'Field names must not be empty.');\n            }\n        }\n        this._internalPath = new InternalFieldPath(fieldNames);\n    }\n    FieldPath.documentId = function () {\n        return FieldPath._DOCUMENT_ID;\n    };\n    FieldPath.prototype.isEqual = function (other) {\n        if (!(other instanceof FieldPath)) {\n            throw invalidClassError('isEqual', 'FieldPath', 1, other);\n        }\n        return this._internalPath.isEqual(other._internalPath);\n    };\n    /**\n     * Internal Note: The backend doesn't technically support querying by\n     * document ID. Instead it queries by the entire document name (full path\n     * included), but in the cases we currently support documentId(), the net\n     * effect is the same.\n     */\n    FieldPath._DOCUMENT_ID = new FieldPath(InternalFieldPath.keyField().canonicalString());\n    return FieldPath;\n}());\nexport { FieldPath };\n/**\n * Matches any characters in a field path string that are reserved.\n */\nvar RESERVED = new RegExp('[~\\\\*/\\\\[\\\\]]');\n/**\n * Parses a field path string into a FieldPath, treating dots as separators.\n */\nexport function fromDotSeparatedString(path) {\n    var found = path.search(RESERVED);\n    if (found >= 0) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid field path (\" + path + \"). Paths must not contain \" +\n            \"'~', '*', '/', '[', or ']'\");\n    }\n    try {\n        return new (FieldPath.bind.apply(FieldPath, [void 0].concat(path.split('.'))))();\n    }\n    catch (e) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid field path (\" + path + \"). Paths must not be empty, \" +\n            \"begin with '.', end with '.', or contain '..'\");\n    }\n}\n\n//# sourceMappingURL=field_path.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/api/field_path.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { documentKeySet } from '../model/collections';\nimport { Document } from '../model/document';\nimport { DocumentSet } from '../model/document_set';\nimport { CurrentStatusUpdate, ResetMapping, UpdateMapping } from '../remote/remote_event';\nimport { assert, fail } from '../util/assert';\nimport { OnlineState } from './types';\nimport { ChangeType, DocumentChangeSet, SyncState, ViewSnapshot } from './view_snapshot';\nvar AddedLimboDocument = /** @class */ (function () {\n    function AddedLimboDocument(key) {\n        this.key = key;\n    }\n    return AddedLimboDocument;\n}());\nexport { AddedLimboDocument };\nvar RemovedLimboDocument = /** @class */ (function () {\n    function RemovedLimboDocument(key) {\n        this.key = key;\n    }\n    return RemovedLimboDocument;\n}());\nexport { RemovedLimboDocument };\n/**\n * View is responsible for computing the final merged truth of what docs are in\n * a query. It gets notified of local and remote changes to docs, and applies\n * the query filters and limits to determine the most correct possible results.\n */\nvar View = /** @class */ (function () {\n    function View(query, \n    /** Documents included in the remote target */\n    syncedDocuments) {\n        this.query = query;\n        this.syncedDocuments = syncedDocuments;\n        this.syncState = null;\n        /**\n         * A flag whether the view is current with the backend. A view is considered\n         * current after it has seen the current flag from the backend and did not\n         * lose consistency within the watch stream (e.g. because of an existence\n         * filter mismatch).\n         */\n        this.current = false;\n        /** Documents in the view but not in the remote target */\n        this.limboDocuments = documentKeySet();\n        /** Document Keys that have local changes */\n        this.mutatedKeys = documentKeySet();\n        this.documentSet = new DocumentSet(query.docComparator.bind(query));\n    }\n    /**\n     * Iterates over a set of doc changes, applies the query limit, and computes\n     * what the new results should be, what the changes were, and whether we may\n     * need to go back to the local cache for more results. Does not make any\n     * changes to the view.\n     * @param docChanges The doc changes to apply to this view.\n     * @param previousChanges If this is being called with a refill, then start\n     *        with this set of docs and changes instead of the current view.\n     * @return a new set of docs, changes, and refill flag.\n     */\n    View.prototype.computeDocChanges = function (docChanges, previousChanges) {\n        var _this = this;\n        var changeSet = previousChanges\n            ? previousChanges.changeSet\n            : new DocumentChangeSet();\n        var oldDocumentSet = previousChanges\n            ? previousChanges.documentSet\n            : this.documentSet;\n        var newMutatedKeys = previousChanges\n            ? previousChanges.mutatedKeys\n            : this.mutatedKeys;\n        var newDocumentSet = oldDocumentSet;\n        var needsRefill = false;\n        // Track the last doc in a (full) limit. This is necessary, because some\n        // update (a delete, or an update moving a doc past the old limit) might\n        // mean there is some other document in the local cache that either should\n        // come (1) between the old last limit doc and the new last document, in the\n        // case of updates, or (2) after the new last document, in the case of\n        // deletes. So we keep this doc at the old limit to compare the updates to.\n        //\n        // Note that this should never get used in a refill (when previousChanges is\n        // set), because there will only be adds -- no deletes or updates.\n        var lastDocInLimit = this.query.hasLimit() && oldDocumentSet.size === this.query.limit\n            ? oldDocumentSet.last()\n            : null;\n        docChanges.inorderTraversal(function (key, newMaybeDoc) {\n            var oldDoc = oldDocumentSet.get(key);\n            var newDoc = newMaybeDoc instanceof Document ? newMaybeDoc : null;\n            if (newDoc) {\n                assert(key.isEqual(newDoc.key), 'Mismatching keys found in document changes: ' +\n                    key +\n                    ' != ' +\n                    newDoc.key);\n                newDoc = _this.query.matches(newDoc) ? newDoc : null;\n            }\n            if (newDoc) {\n                newDocumentSet = newDocumentSet.add(newDoc);\n                if (newDoc.hasLocalMutations) {\n                    newMutatedKeys = newMutatedKeys.add(key);\n                }\n                else {\n                    newMutatedKeys = newMutatedKeys.delete(key);\n                }\n            }\n            else {\n                newDocumentSet = newDocumentSet.delete(key);\n                newMutatedKeys = newMutatedKeys.delete(key);\n            }\n            // Calculate change\n            if (oldDoc && newDoc) {\n                var docsEqual = oldDoc.data.isEqual(newDoc.data);\n                if (!docsEqual ||\n                    oldDoc.hasLocalMutations !== newDoc.hasLocalMutations) {\n                    // only report a change if document actually changed\n                    if (docsEqual) {\n                        changeSet.track({ type: ChangeType.Metadata, doc: newDoc });\n                    }\n                    else {\n                        changeSet.track({ type: ChangeType.Modified, doc: newDoc });\n                    }\n                    if (lastDocInLimit &&\n                        _this.query.docComparator(newDoc, lastDocInLimit) > 0) {\n                        // This doc moved from inside the limit to after the limit.\n                        // That means there may be some doc in the local cache that's\n                        // actually less than this one.\n                        needsRefill = true;\n                    }\n                }\n            }\n            else if (!oldDoc && newDoc) {\n                changeSet.track({ type: ChangeType.Added, doc: newDoc });\n            }\n            else if (oldDoc && !newDoc) {\n                changeSet.track({ type: ChangeType.Removed, doc: oldDoc });\n                if (lastDocInLimit) {\n                    // A doc was removed from a full limit query. We'll need to\n                    // requery from the local cache to see if we know about some other\n                    // doc that should be in the results.\n                    needsRefill = true;\n                }\n            }\n        });\n        if (this.query.hasLimit()) {\n            // TODO(klimt): Make DocumentSet size be constant time.\n            while (newDocumentSet.size > this.query.limit) {\n                var oldDoc = newDocumentSet.last();\n                newDocumentSet = newDocumentSet.delete(oldDoc.key);\n                changeSet.track({ type: ChangeType.Removed, doc: oldDoc });\n            }\n        }\n        assert(!needsRefill || !previousChanges, 'View was refilled using docs that themselves needed refilling.');\n        return {\n            documentSet: newDocumentSet,\n            changeSet: changeSet,\n            needsRefill: needsRefill,\n            mutatedKeys: newMutatedKeys\n        };\n    };\n    /**\n     * Updates the view with the given ViewDocumentChanges and updates limbo docs\n     * and sync state from the given (optional) target change.\n     * @param docChanges The set of changes to make to the view's docs.\n     * @param targetChange A target change to apply for computing limbo docs and\n     *        sync state.\n     * @return A new ViewChange with the given docs, changes, and sync state.\n     */\n    View.prototype.applyChanges = function (docChanges, targetChange) {\n        var _this = this;\n        assert(!docChanges.needsRefill, 'Cannot apply changes that need a refill');\n        var oldDocs = this.documentSet;\n        this.documentSet = docChanges.documentSet;\n        this.mutatedKeys = docChanges.mutatedKeys;\n        // Sort changes based on type and query comparator\n        var changes = docChanges.changeSet.getChanges();\n        changes.sort(function (c1, c2) {\n            return (compareChangeType(c1.type, c2.type) ||\n                _this.query.docComparator(c1.doc, c2.doc));\n        });\n        this.applyTargetChange(targetChange);\n        var limboChanges = this.updateLimboDocuments();\n        var synced = this.limboDocuments.size === 0 && this.current;\n        var newSyncState = synced ? SyncState.Synced : SyncState.Local;\n        var syncStateChanged = newSyncState !== this.syncState;\n        this.syncState = newSyncState;\n        if (changes.length === 0 && !syncStateChanged) {\n            // no changes\n            return { limboChanges: limboChanges };\n        }\n        else {\n            var snap = new ViewSnapshot(this.query, docChanges.documentSet, oldDocs, changes, newSyncState === SyncState.Local, !docChanges.mutatedKeys.isEmpty(), syncStateChanged);\n            return {\n                snapshot: snap,\n                limboChanges: limboChanges\n            };\n        }\n    };\n    /**\n     * Applies an OnlineState change to the view, potentially generating a\n     * ViewChange if the view's syncState changes as a result.\n     */\n    View.prototype.applyOnlineStateChange = function (onlineState) {\n        if (this.current && onlineState === OnlineState.Offline) {\n            // If we're offline, set `current` to false and then call applyChanges()\n            // to refresh our syncState and generate a ViewChange as appropriate. We\n            // are guaranteed to get a new TargetChange that sets `current` back to\n            // true once the client is back online.\n            this.current = false;\n            return this.applyChanges({\n                documentSet: this.documentSet,\n                changeSet: new DocumentChangeSet(),\n                mutatedKeys: this.mutatedKeys,\n                needsRefill: false\n            });\n        }\n        else {\n            // No effect, just return a no-op ViewChange.\n            return { limboChanges: [] };\n        }\n    };\n    /**\n     * Returns whether the doc for the given key should be in limbo.\n     */\n    View.prototype.shouldBeInLimbo = function (key) {\n        // If the remote end says it's part of this query, it's not in limbo.\n        if (this.syncedDocuments.has(key)) {\n            return false;\n        }\n        // The local store doesn't think it's a result, so it shouldn't be in limbo.\n        if (!this.documentSet.has(key)) {\n            return false;\n        }\n        // If there are local changes to the doc, they might explain why the server\n        // doesn't know that it's part of the query. So don't put it in limbo.\n        // TODO(klimt): Ideally, we would only consider changes that might actually\n        // affect this specific query.\n        if (this.documentSet.get(key).hasLocalMutations) {\n            return false;\n        }\n        // Everything else is in limbo.\n        return true;\n    };\n    /**\n     * Updates syncedDocuments, current, and limbo docs based on the given change.\n     * Returns the list of changes to which docs are in limbo.\n     */\n    View.prototype.applyTargetChange = function (targetChange) {\n        if (targetChange) {\n            var targetMapping = targetChange.mapping;\n            if (targetMapping instanceof ResetMapping) {\n                this.syncedDocuments = targetMapping.documents;\n            }\n            else if (targetMapping instanceof UpdateMapping) {\n                this.syncedDocuments = targetMapping.applyToKeySet(this.syncedDocuments);\n            }\n            switch (targetChange.currentStatusUpdate) {\n                case CurrentStatusUpdate.MarkCurrent:\n                    this.current = true;\n                    break;\n                case CurrentStatusUpdate.MarkNotCurrent:\n                    this.current = false;\n                    break;\n                case CurrentStatusUpdate.None:\n                    break;\n                default:\n                    fail('Unknown current status update: ' + targetChange.currentStatusUpdate);\n            }\n        }\n    };\n    View.prototype.updateLimboDocuments = function () {\n        var _this = this;\n        // We can only determine limbo documents when we're in-sync with the server.\n        if (!this.current) {\n            return [];\n        }\n        // TODO(klimt): Do this incrementally so that it's not quadratic when\n        // updating many documents.\n        var oldLimboDocuments = this.limboDocuments;\n        this.limboDocuments = documentKeySet();\n        this.documentSet.forEach(function (doc) {\n            if (_this.shouldBeInLimbo(doc.key)) {\n                _this.limboDocuments = _this.limboDocuments.add(doc.key);\n            }\n        });\n        // Diff the new limbo docs with the old limbo docs.\n        var changes = [];\n        oldLimboDocuments.forEach(function (key) {\n            if (!_this.limboDocuments.has(key)) {\n                changes.push(new RemovedLimboDocument(key));\n            }\n        });\n        this.limboDocuments.forEach(function (key) {\n            if (!oldLimboDocuments.has(key)) {\n                changes.push(new AddedLimboDocument(key));\n            }\n        });\n        return changes;\n    };\n    return View;\n}());\nexport { View };\nfunction compareChangeType(c1, c2) {\n    var order = function (change) {\n        switch (change) {\n            case ChangeType.Added:\n                return 1;\n            case ChangeType.Modified:\n                return 2;\n            case ChangeType.Metadata:\n                // A metadata change is converted to a modified change at the public\n                // api layer.  Since we sort by document key and then change type,\n                // metadata and modified changes must be sorted equivalently.\n                return 2;\n            case ChangeType.Removed:\n                return 0;\n            default:\n                return fail('Unknown ChangeType: ' + change);\n        }\n    };\n    return order(c1) - order(c2);\n}\n\n//# sourceMappingURL=view.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/core/view.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ResourcePath } from '../model/path';\nimport { assert, fail } from '../util/assert';\nvar escapeChar = '\\u0001';\nvar encodedSeparatorChar = '\\u0001';\nvar encodedNul = '\\u0010';\nvar encodedEscape = '\\u0011';\n/**\n * Encodes a resource path into a IndexedDb-compatible string form.\n */\nexport function encode(path) {\n    var result = '';\n    for (var i = 0; i < path.length; i++) {\n        if (result.length > 0) {\n            result = encodeSeparator(result);\n        }\n        result = encodeSegment(path.get(i), result);\n    }\n    return encodeSeparator(result);\n}\n/** Encodes a single segment of a resource path into the given result */\nfunction encodeSegment(segment, resultBuf) {\n    var result = resultBuf;\n    var length = segment.length;\n    for (var i = 0; i < length; i++) {\n        var c = segment.charAt(i);\n        switch (c) {\n            case '\\0':\n                result += escapeChar + encodedNul;\n                break;\n            case escapeChar:\n                result += escapeChar + encodedEscape;\n                break;\n            default:\n                result += c;\n        }\n    }\n    return result;\n}\n/** Encodes a path separator into the given result */\nfunction encodeSeparator(result) {\n    return result + escapeChar + encodedSeparatorChar;\n}\n/**\n * Decodes the given IndexedDb-compatible string form of a resource path into\n * a ResourcePath instance. Note that this method is not suitable for use with\n * decoding resource names from the server; those are One Platform format\n * strings.\n */\nexport function decode(path) {\n    // Event the empty path must encode as a path of at least length 2. A path\n    // with exactly 2 must be the empty path.\n    var length = path.length;\n    assert(length >= 2, 'Invalid path ' + path);\n    if (length === 2) {\n        assert(path.charAt(0) === escapeChar && path.charAt(1) === encodedSeparatorChar, 'Non-empty path ' + path + ' had length 2');\n        return ResourcePath.EMPTY_PATH;\n    }\n    // Escape characters cannot exist past the second-to-last position in the\n    // source value.\n    var lastReasonableEscapeIndex = length - 2;\n    var segments = [];\n    var segmentBuilder = '';\n    for (var start = 0; start < length;) {\n        // The last two characters of a valid encoded path must be a separator, so\n        // there must be an end to this segment.\n        var end = path.indexOf(escapeChar, start);\n        if (end < 0 || end > lastReasonableEscapeIndex) {\n            fail('Invalid encoded resource path: \"' + path + '\"');\n        }\n        var next = path.charAt(end + 1);\n        switch (next) {\n            case encodedSeparatorChar:\n                var currentPiece = path.substring(start, end);\n                var segment = void 0;\n                if (segmentBuilder.length === 0) {\n                    // Avoid copying for the common case of a segment that excludes \\0\n                    // and \\001\n                    segment = currentPiece;\n                }\n                else {\n                    segmentBuilder += currentPiece;\n                    segment = segmentBuilder;\n                    segmentBuilder = '';\n                }\n                segments.push(segment);\n                break;\n            case encodedNul:\n                segmentBuilder += path.substring(start, end);\n                segmentBuilder += '\\0';\n                break;\n            case encodedEscape:\n                // The escape character can be used in the output to encode itself.\n                segmentBuilder += path.substring(start, end + 1);\n                break;\n            default:\n                fail('Invalid encoded resource path: \"' + path + '\"');\n        }\n        start = end + 2;\n    }\n    return new ResourcePath(segments);\n}\n/**\n * Computes the prefix successor of the given path, computed by encode above.\n * A prefix successor is the first key that cannot be prefixed by the given\n * path. It's useful for defining the end of a prefix scan such that all keys\n * in the scan have the same prefix.\n *\n * Note that this is not a general prefix successor implementation, which is\n * tricky to get right with Strings, given that they encode down to UTF-8.\n * Instead this relies on the fact that all paths encoded by this class are\n * always terminated with a separator, and so a successor can always be\n * cheaply computed by incrementing the last character of the path.\n */\nexport function prefixSuccessor(path) {\n    var c = path.charCodeAt(path.length - 1);\n    // TODO(mcg): this really should be a general thing, but not worth it right\n    // now\n    assert(c === 1, 'successor may only operate on paths generated by encode');\n    return path.substring(0, path.length - 1) + String.fromCharCode(c + 1);\n}\n\n//# sourceMappingURL=encoded_resource_path.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/encoded_resource_path.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert';\nimport { encode } from './encoded_resource_path';\nimport { PersistencePromise } from './persistence_promise';\nimport { SnapshotVersion } from '../core/snapshot_version';\n/**\n * Schema Version for the Web client:\n * 1. Initial version including Mutation Queue, Query Cache, and Remote Document\n *    Cache\n * 2. Added targetCount to targetGlobal row.\n */\nexport var SCHEMA_VERSION = 2;\n/**\n * Performs database creation and schema upgrades.\n *\n * Note that in production, this method is only ever used to upgrade the schema\n * to SCHEMA_VERSION. Different values of toVersion are only used for testing\n * and local feature development.\n */\nexport function createOrUpgradeDb(db, txn, fromVersion, toVersion) {\n    // This function currently supports migrating to schema version 1 (Mutation\n    // Queue, Query and Remote Document Cache) and schema version 2 (Query\n    // counting).\n    assert(fromVersion < toVersion && fromVersion >= 0 && toVersion <= 2, 'Unexpected schema upgrade from v${fromVersion} to v{toVersion}.');\n    if (fromVersion < 1 && toVersion >= 1) {\n        createOwnerStore(db);\n        createMutationQueue(db);\n        createQueryCache(db);\n        createRemoteDocumentCache(db);\n    }\n    var p = PersistencePromise.resolve();\n    if (fromVersion < 2 && toVersion >= 2) {\n        p = ensureTargetGlobalExists(txn).next(function (targetGlobal) {\n            return saveTargetCount(txn, targetGlobal);\n        });\n    }\n    return p;\n}\n/**\n * Wrapper class to store timestamps (seconds and nanos) in IndexedDb objects.\n */\nvar DbTimestamp = /** @class */ (function () {\n    function DbTimestamp(seconds, nanos) {\n        this.seconds = seconds;\n        this.nanos = nanos;\n    }\n    return DbTimestamp;\n}());\nexport { DbTimestamp };\n/**\n * A singleton object to be stored in the 'owner' store in IndexedDb.\n *\n * A given database can be owned by a single tab at a given time. That tab\n * must validate that it is still the owner before every write operation and\n * should regularly write an updated timestamp to prevent other tabs from\n * \"stealing\" ownership of the db.\n */\nvar DbOwner = /** @class */ (function () {\n    function DbOwner(ownerId, leaseTimestampMs) {\n        this.ownerId = ownerId;\n        this.leaseTimestampMs = leaseTimestampMs;\n    }\n    /** Name of the IndexedDb object store. */\n    DbOwner.store = 'owner';\n    return DbOwner;\n}());\nexport { DbOwner };\nfunction createOwnerStore(db) {\n    db.createObjectStore(DbOwner.store);\n}\n/**\n * An object to be stored in the 'mutationQueues' store in IndexedDb.\n *\n * Each user gets a single queue of MutationBatches to apply to the server.\n * DbMutationQueue tracks the metadata about the queue.\n */\nvar DbMutationQueue = /** @class */ (function () {\n    function DbMutationQueue(\n    /**\n     * The normalized user ID to which this queue belongs.\n     */\n    userId, \n    /**\n     * An identifier for the highest numbered batch that has been acknowledged\n     * by the server. All MutationBatches in this queue with batchIds less\n     * than or equal to this value are considered to have been acknowledged by\n     * the server.\n     */\n    lastAcknowledgedBatchId, \n    /**\n     * A stream token that was previously sent by the server.\n     *\n     * See StreamingWriteRequest in datastore.proto for more details about\n     * usage.\n     *\n     * After sending this token, earlier tokens may not be used anymore so\n     * only a single stream token is retained.\n     */\n    lastStreamToken) {\n        this.userId = userId;\n        this.lastAcknowledgedBatchId = lastAcknowledgedBatchId;\n        this.lastStreamToken = lastStreamToken;\n    }\n    /** Name of the IndexedDb object store.  */\n    DbMutationQueue.store = 'mutationQueues';\n    /** Keys are automatically assigned via the userId property. */\n    DbMutationQueue.keyPath = 'userId';\n    return DbMutationQueue;\n}());\nexport { DbMutationQueue };\n/**\n * An object to be stored in the 'mutations' store in IndexedDb.\n *\n * Represents a batch of user-level mutations intended to be sent to the server\n * in a single write. Each user-level batch gets a separate DbMutationBatch\n * with a new batchId.\n */\nvar DbMutationBatch = /** @class */ (function () {\n    function DbMutationBatch(\n    /**\n     * The normalized user ID to which this batch belongs.\n     */\n    userId, \n    /**\n     * An identifier for this batch, allocated by the mutation queue in a\n     * monotonically increasing manner.\n     */\n    batchId, \n    /**\n     * The local write time of the batch, stored as milliseconds since the\n     * epoch.\n     */\n    localWriteTimeMs, \n    /**\n     * A list of mutations to apply. All mutations will be applied atomically.\n     *\n     * Mutations are serialized via JsonProtoSerializer.toMutation().\n     */\n    mutations) {\n        this.userId = userId;\n        this.batchId = batchId;\n        this.localWriteTimeMs = localWriteTimeMs;\n        this.mutations = mutations;\n    }\n    /** Name of the IndexedDb object store.  */\n    DbMutationBatch.store = 'mutations';\n    /** Keys are automatically assigned via the userId, batchId properties. */\n    DbMutationBatch.keyPath = ['userId', 'batchId'];\n    return DbMutationBatch;\n}());\nexport { DbMutationBatch };\nfunction createMutationQueue(db) {\n    db.createObjectStore(DbMutationQueue.store, {\n        keyPath: DbMutationQueue.keyPath\n    });\n    db.createObjectStore(DbMutationBatch.store, {\n        keyPath: DbMutationBatch.keyPath\n    });\n    db.createObjectStore(DbDocumentMutation.store);\n}\n/**\n * An object to be stored in the 'documentMutations' store in IndexedDb.\n *\n * A manually maintained index of all the mutation batches that affect a given\n * document key. The rows in this table are references based on the contents of\n * DbMutationBatch.mutations.\n */\nvar DbDocumentMutation = /** @class */ (function () {\n    function DbDocumentMutation() {\n    }\n    /**\n     * Creates a [userId] key for use in the DbDocumentMutations index to iterate\n     * over all of a user's document mutations.\n     */\n    DbDocumentMutation.prefixForUser = function (userId) {\n        return [userId];\n    };\n    /**\n     * Creates a [userId, encodedPath] key for use in the DbDocumentMutations\n     * index to iterate over all at document mutations for a given path or lower.\n     */\n    DbDocumentMutation.prefixForPath = function (userId, path) {\n        return [userId, encode(path)];\n    };\n    /**\n     * Creates a full index key of [userId, encodedPath, batchId] for inserting\n     * and deleting into the DbDocumentMutations index.\n     */\n    DbDocumentMutation.key = function (userId, path, batchId) {\n        return [userId, encode(path), batchId];\n    };\n    DbDocumentMutation.store = 'documentMutations';\n    /**\n     * Because we store all the useful information for this store in the key,\n     * there is no useful information to store as the value. The raw (unencoded)\n     * path cannot be stored because IndexedDb doesn't store prototype\n     * information.\n     */\n    DbDocumentMutation.PLACEHOLDER = new DbDocumentMutation();\n    return DbDocumentMutation;\n}());\nexport { DbDocumentMutation };\nfunction createRemoteDocumentCache(db) {\n    db.createObjectStore(DbRemoteDocument.store);\n}\n/**\n * Represents the known absence of a document at a particular version.\n * Stored in IndexedDb as part of a DbRemoteDocument object.\n */\nvar DbNoDocument = /** @class */ (function () {\n    function DbNoDocument(path, readTime) {\n        this.path = path;\n        this.readTime = readTime;\n    }\n    return DbNoDocument;\n}());\nexport { DbNoDocument };\n/**\n * An object to be stored in the 'remoteDocuments' store in IndexedDb. It\n * represents either a cached document (if it exists) or a cached \"no-document\"\n * (if it is known to not exist).\n *\n * Note: This is the persisted equivalent of a MaybeDocument and could perhaps\n * be made more general if necessary.\n */\nvar DbRemoteDocument = /** @class */ (function () {\n    function DbRemoteDocument(\n    /**\n     * Set to an instance of a DbNoDocument if it is known that no document\n     * exists.\n     */\n    noDocument, \n    /**\n     * Set to an instance of a Document if there's a cached version of the\n     * document.\n     */\n    document) {\n        this.noDocument = noDocument;\n        this.document = document;\n    }\n    DbRemoteDocument.store = 'remoteDocuments';\n    return DbRemoteDocument;\n}());\nexport { DbRemoteDocument };\n/**\n * An object to be stored in the 'targets' store in IndexedDb.\n *\n * This is based on and should be kept in sync with the proto used in the iOS\n * client.\n *\n * Each query the client listens to against the server is tracked on disk so\n * that the query can be efficiently resumed on restart.\n */\nvar DbTarget = /** @class */ (function () {\n    function DbTarget(\n    /**\n     * An auto-generated sequential numeric identifier for the query.\n     *\n     * Queries are stored using their canonicalId as the key, but these\n     * canonicalIds can be quite long so we additionally assign a unique\n     * queryId which can be used by referenced data structures (e.g.\n     * indexes) to minimize the on-disk cost.\n     */\n    targetId, \n    /**\n     * The canonical string representing this query. This is not unique.\n     */\n    canonicalId, \n    /**\n     * The last readTime received from the Watch Service for this query.\n     *\n     * This is the same value as TargetChange.read_time in the protos.\n     */\n    readTime, \n    /**\n     * An opaque, server-assigned token that allows watching a query to be\n     * resumed after disconnecting without retransmitting all the data\n     * that matches the query. The resume token essentially identifies a\n     * point in time from which the server should resume sending results.\n     *\n     * This is related to the snapshotVersion in that the resumeToken\n     * effectively also encodes that value, but the resumeToken is opaque\n     * and sometimes encodes additional information.\n     *\n     * A consequence of this is that the resumeToken should be used when\n     * asking the server to reason about where this client is in the watch\n     * stream, but the client should use the snapshotVersion for its own\n     * purposes.\n     *\n     * This is the same value as TargetChange.resume_token in the protos.\n     */\n    resumeToken, \n    /**\n     * A sequence number representing the last time this query was\n     * listened to, used for garbage collection purposes.\n     *\n     * Conventionally this would be a timestamp value, but device-local\n     * clocks are unreliable and they must be able to create new listens\n     * even while disconnected. Instead this should be a monotonically\n     * increasing number that's incremented on each listen call.\n     *\n     * This is different from the queryId since the queryId is an\n     * immutable identifier assigned to the Query on first use while\n     * lastListenSequenceNumber is updated every time the query is\n     * listened to.\n     */\n    lastListenSequenceNumber, \n    /**\n     * The query for this target.\n     *\n     * Because canonical ids are not unique we must store the actual query. We\n     * use the proto to have an object we can persist without having to\n     * duplicate translation logic to and from a `Query` object.\n     */\n    query) {\n        this.targetId = targetId;\n        this.canonicalId = canonicalId;\n        this.readTime = readTime;\n        this.resumeToken = resumeToken;\n        this.lastListenSequenceNumber = lastListenSequenceNumber;\n        this.query = query;\n    }\n    DbTarget.store = 'targets';\n    /** Keys are automatically assigned via the targetId property. */\n    DbTarget.keyPath = 'targetId';\n    /** The name of the queryTargets index. */\n    DbTarget.queryTargetsIndexName = 'queryTargetsIndex';\n    /**\n     * The index of all canonicalIds to the targets that they match. This is not\n     * a unique mapping because canonicalId does not promise a unique name for all\n     * possible queries, so we append the targetId to make the mapping unique.\n     */\n    DbTarget.queryTargetsKeyPath = ['canonicalId', 'targetId'];\n    return DbTarget;\n}());\nexport { DbTarget };\n/**\n * An object representing an association between a target and a document.\n * Stored in the targetDocument object store to store the documents tracked by a\n * particular target.\n */\nvar DbTargetDocument = /** @class */ (function () {\n    function DbTargetDocument(\n    /**\n     * The targetId identifying a target.\n     */\n    targetId, \n    /**\n     * The path to the document, as encoded in the key.\n     */\n    path) {\n        this.targetId = targetId;\n        this.path = path;\n    }\n    /** Name of the IndexedDb object store.  */\n    DbTargetDocument.store = 'targetDocuments';\n    /** Keys are automatically assigned via the targetId, path properties. */\n    DbTargetDocument.keyPath = ['targetId', 'path'];\n    /** The index name for the reverse index. */\n    DbTargetDocument.documentTargetsIndex = 'documentTargetsIndex';\n    /** We also need to create the reverse index for these properties. */\n    DbTargetDocument.documentTargetsKeyPath = ['path', 'targetId'];\n    return DbTargetDocument;\n}());\nexport { DbTargetDocument };\n/**\n * A record of global state tracked across all Targets, tracked separately\n * to avoid the need for extra indexes.\n *\n * This should be kept in-sync with the proto used in the iOS client.\n */\nvar DbTargetGlobal = /** @class */ (function () {\n    function DbTargetGlobal(\n    /**\n     * The highest numbered target id across all targets.\n     *\n     * See DbTarget.targetId.\n     */\n    highestTargetId, \n    /**\n     * The highest numbered lastListenSequenceNumber across all targets.\n     *\n     * See DbTarget.lastListenSequenceNumber.\n     */\n    highestListenSequenceNumber, \n    /**\n     * A global snapshot version representing the last consistent snapshot we\n     * received from the backend. This is monotonically increasing and any\n     * snapshots received from the backend prior to this version (e.g. for\n     * targets resumed with a resumeToken) should be suppressed (buffered)\n     * until the backend has caught up to this snapshot version again. This\n     * prevents our cache from ever going backwards in time.\n     */\n    lastRemoteSnapshotVersion, \n    /**\n     * The number of targets persisted.\n     */\n    targetCount) {\n        this.highestTargetId = highestTargetId;\n        this.highestListenSequenceNumber = highestListenSequenceNumber;\n        this.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion;\n        this.targetCount = targetCount;\n    }\n    /**\n     * The key string used for the single object that exists in the\n     * DbTargetGlobal store.\n     */\n    DbTargetGlobal.key = 'targetGlobalKey';\n    DbTargetGlobal.store = 'targetGlobal';\n    return DbTargetGlobal;\n}());\nexport { DbTargetGlobal };\nfunction createQueryCache(db) {\n    var targetDocumentsStore = db.createObjectStore(DbTargetDocument.store, {\n        keyPath: DbTargetDocument.keyPath\n    });\n    targetDocumentsStore.createIndex(DbTargetDocument.documentTargetsIndex, DbTargetDocument.documentTargetsKeyPath, { unique: true });\n    var targetStore = db.createObjectStore(DbTarget.store, {\n        keyPath: DbTarget.keyPath\n    });\n    // NOTE: This is unique only because the TargetId is the suffix.\n    targetStore.createIndex(DbTarget.queryTargetsIndexName, DbTarget.queryTargetsKeyPath, { unique: true });\n    db.createObjectStore(DbTargetGlobal.store);\n}\n/**\n * Counts the number of targets persisted and adds that value to the target\n * global singleton.\n */\nfunction saveTargetCount(txn, metadata) {\n    var globalStore = txn.store(DbTargetGlobal.store);\n    var targetStore = txn.store(DbTarget.store);\n    return targetStore.count().next(function (count) {\n        metadata.targetCount = count;\n        return globalStore.put(DbTargetGlobal.key, metadata);\n    });\n}\n/**\n * Ensures that the target global singleton row exists by adding it if it's\n * missing.\n *\n * @param {IDBTransaction} txn The version upgrade transaction for indexeddb\n */\nfunction ensureTargetGlobalExists(txn) {\n    var globalStore = txn.store(DbTargetGlobal.store);\n    return globalStore.get(DbTargetGlobal.key).next(function (metadata) {\n        if (metadata != null) {\n            return PersistencePromise.resolve(metadata);\n        }\n        else {\n            metadata = new DbTargetGlobal(\n            /*highestTargetId=*/ 0, \n            /*lastListenSequenceNumber=*/ 0, SnapshotVersion.MIN.toTimestamp(), \n            /*targetCount=*/ 0);\n            return globalStore.put(DbTargetGlobal.key, metadata).next(function () { return metadata; });\n        }\n    });\n}\n/**\n * The list of all default IndexedDB stores used throughout the SDK. This is\n * used when creating transactions so that access across all stores is done\n * atomically.\n */\nexport var ALL_STORES = [\n    DbMutationQueue.store,\n    DbMutationBatch.store,\n    DbDocumentMutation.store,\n    DbRemoteDocument.store,\n    DbTarget.store,\n    DbOwner.store,\n    DbTargetGlobal.store,\n    DbTargetDocument.store\n];\n\n//# sourceMappingURL=indexeddb_schema.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/indexeddb_schema.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert';\nimport { debug } from '../util/log';\nimport { PersistencePromise } from './persistence_promise';\nimport { SCHEMA_VERSION } from './indexeddb_schema';\nvar LOG_TAG = 'SimpleDb';\n/**\n * Provides a wrapper around IndexedDb with a simplified interface that uses\n * Promise-like return values to chain operations. Real promises cannot be used\n * since .then() continuations are executed asynchronously (e.g. via\n * .setImmediate), which would cause IndexedDB to end the transaction.\n * See PersistencePromise for more details.\n */\nvar SimpleDb = /** @class */ (function () {\n    function SimpleDb(db) {\n        this.db = db;\n    }\n    /** Opens the specified database, creating or upgrading it if necessary. */\n    SimpleDb.openOrCreate = function (name, version, runUpgrade) {\n        assert(SimpleDb.isAvailable(), 'IndexedDB not supported in current environment.');\n        debug(LOG_TAG, 'Opening database:', name);\n        return new PersistencePromise(function (resolve, reject) {\n            // TODO(mikelehen): Investigate browser compatibility.\n            // https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB\n            // suggests IE9 and older WebKit browsers handle upgrade\n            // differently. They expect setVersion, as described here:\n            // https://developer.mozilla.org/en-US/docs/Web/API/IDBVersionChangeRequest/setVersion\n            var request = window.indexedDB.open(name, version);\n            request.onsuccess = function (event) {\n                var db = event.target.result;\n                resolve(new SimpleDb(db));\n            };\n            request.onerror = function (event) {\n                reject(event.target.error);\n            };\n            request.onupgradeneeded = function (event) {\n                debug(LOG_TAG, 'Database \"' + name + '\" requires upgrade from version:', event.oldVersion);\n                var db = event.target.result;\n                // We are provided a version upgrade transaction from the request, so\n                // we wrap that in a SimpleDbTransaction to allow use of our friendlier\n                // API for schema migration operations.\n                var txn = new SimpleDbTransaction(request.transaction);\n                runUpgrade(db, txn, event.oldVersion, SCHEMA_VERSION).next(function () {\n                    debug(LOG_TAG, 'Database upgrade to version ' + SCHEMA_VERSION + ' complete');\n                });\n            };\n        }).toPromise();\n    };\n    /** Deletes the specified database. */\n    SimpleDb.delete = function (name) {\n        debug(LOG_TAG, 'Removing database:', name);\n        return wrapRequest(window.indexedDB.deleteDatabase(name)).toPromise();\n    };\n    /** Returns true if IndexedDB is available in the current environment. */\n    SimpleDb.isAvailable = function () {\n        if (typeof window === 'undefined' || window.indexedDB == null) {\n            return false;\n        }\n        // We extensively use indexed array values and compound keys,\n        // which IE and Edge do not support. However, they still have indexedDB\n        // defined on the window, so we need to check for them here and make sure\n        // to return that persistence is not enabled for those browsers.\n        // For tracking support of this feature, see here:\n        // https://developer.microsoft.com/en-us/microsoft-edge/platform/status/indexeddbarraysandmultientrysupport/\n        // Check the UA string to find out the browser.\n        var ua = window.navigator.userAgent;\n        // IE 10\n        // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';\n        // IE 11\n        // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';\n        // Edge\n        // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML,\n        // like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';\n        if (ua.indexOf('MSIE ') > 0 ||\n            ua.indexOf('Trident/') > 0 ||\n            ua.indexOf('Edge/') > 0) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    };\n    SimpleDb.prototype.runTransaction = function (mode, objectStores, transactionFn) {\n        var transaction = SimpleDbTransaction.open(this.db, mode, objectStores);\n        var transactionFnResult = transactionFn(transaction)\n            .catch(function (error) {\n            // Abort the transaction if there was an\n            // error.\n            transaction.abort();\n            return PersistencePromise.reject(error);\n        })\n            .toPromise();\n        // Wait for the transaction to complete (i.e. IndexedDb's onsuccess event to\n        // fire), but still return the original transactionFnResult back to the\n        // caller.\n        return transaction.completionPromise.then(function () { return transactionFnResult; });\n    };\n    SimpleDb.prototype.close = function () {\n        this.db.close();\n    };\n    return SimpleDb;\n}());\nexport { SimpleDb };\n/**\n * A controller for iterating over a key range or index. It allows an iterate\n * callback to delete the currently-referenced object, or jump to a new key\n * within the key range or index.\n */\nvar IterationController = /** @class */ (function () {\n    function IterationController(dbCursor) {\n        this.dbCursor = dbCursor;\n        this.shouldStop = false;\n        this.nextKey = null;\n    }\n    Object.defineProperty(IterationController.prototype, \"isDone\", {\n        get: function () {\n            return this.shouldStop;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(IterationController.prototype, \"skipToKey\", {\n        get: function () {\n            return this.nextKey;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(IterationController.prototype, \"cursor\", {\n        set: function (value) {\n            this.dbCursor = value;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * This function can be called to stop iteration at any point.\n     */\n    IterationController.prototype.done = function () {\n        this.shouldStop = true;\n    };\n    /**\n     * This function can be called to skip to that next key, which could be\n     * an index or a primary key.\n     */\n    IterationController.prototype.skip = function (key) {\n        this.nextKey = key;\n    };\n    /**\n     * Delete the current cursor value from the object store.\n     *\n     * NOTE: You CANNOT do this with a keysOnly query.\n     */\n    IterationController.prototype.delete = function () {\n        return wrapRequest(this.dbCursor.delete());\n    };\n    return IterationController;\n}());\nexport { IterationController };\n/**\n * Wraps an IDBTransaction and exposes a store() method to get a handle to a\n * specific object store.\n */\nvar SimpleDbTransaction = /** @class */ (function () {\n    function SimpleDbTransaction(transaction) {\n        var _this = this;\n        this.transaction = transaction;\n        this.aborted = false;\n        this.completionPromise = new Promise(function (resolve, reject) {\n            // We consider aborting to be \"normal\" and just resolve the promise.\n            // May need to revisit if/when we actually need to abort transactions.\n            _this.transaction.onabort = _this.transaction.oncomplete = function (event) {\n                resolve();\n            };\n            _this.transaction.onerror = function (event) {\n                reject(event.target.error);\n            };\n        });\n    }\n    SimpleDbTransaction.open = function (db, mode, objectStoreNames) {\n        return new SimpleDbTransaction(db.transaction(objectStoreNames, mode));\n    };\n    SimpleDbTransaction.prototype.abort = function () {\n        if (!this.aborted) {\n            debug(LOG_TAG, 'Aborting transaction.');\n            this.aborted = true;\n            this.transaction.abort();\n        }\n    };\n    /**\n     * Returns a SimpleDbStore<KeyType, ValueType> for the specified store. All\n     * operations performed on the SimpleDbStore happen within the context of this\n     * transaction and it cannot be used anymore once the transaction is\n     * completed.\n     *\n     * Note that we can't actually enforce that the KeyType and ValueType are\n     * correct, but they allow type safety through the rest of the consuming code.\n     */\n    SimpleDbTransaction.prototype.store = function (storeName) {\n        var store = this.transaction.objectStore(storeName);\n        assert(!!store, 'Object store not part of transaction: ' + storeName);\n        return new SimpleDbStore(store);\n    };\n    return SimpleDbTransaction;\n}());\nexport { SimpleDbTransaction };\n/**\n * A wrapper around an IDBObjectStore providing an API that:\n *\n * 1) Has generic KeyType / ValueType parameters to provide strongly-typed\n * methods for acting against the object store.\n * 2) Deals with IndexedDB's onsuccess / onerror event callbacks, making every\n * method return a PersistencePromise instead.\n * 3) Provides a higher-level API to avoid needing to do excessive wrapping of\n * intermediate IndexedDB types (IDBCursorWithValue, etc.)\n */\nvar SimpleDbStore = /** @class */ (function () {\n    function SimpleDbStore(store) {\n        this.store = store;\n    }\n    SimpleDbStore.prototype.put = function (keyOrValue, value) {\n        var request;\n        if (value !== undefined) {\n            debug(LOG_TAG, 'PUT', this.store.name, keyOrValue, value);\n            request = this.store.put(value, keyOrValue);\n        }\n        else {\n            debug(LOG_TAG, 'PUT', this.store.name, '<auto-key>', keyOrValue);\n            request = this.store.put(keyOrValue);\n        }\n        return wrapRequest(request);\n    };\n    /**\n     * Gets the object with the specified key from the specified store, or null\n     * if no object exists with the specified key.\n     *\n     * @key The key of the object to get.\n     * @return The object with the specified key or null if no object exists.\n     */\n    SimpleDbStore.prototype.get = function (key) {\n        var _this = this;\n        var request = this.store.get(key);\n        // tslint:disable-next-line:no-any We're doing an unsafe cast to ValueType.\n        return wrapRequest(request).next(function (result) {\n            // Normalize nonexistence to null.\n            if (result === undefined) {\n                result = null;\n            }\n            debug(LOG_TAG, 'GET', _this.store.name, key, result);\n            return result;\n        });\n    };\n    SimpleDbStore.prototype.delete = function (key) {\n        debug(LOG_TAG, 'DELETE', this.store.name, key);\n        var request = this.store.delete(key);\n        return wrapRequest(request);\n    };\n    /**\n     * If we ever need more of the count variants, we can add overloads. For now,\n     * all we need is to count everything in a store.\n     *\n     * Returns the number of rows in the store.\n     */\n    SimpleDbStore.prototype.count = function () {\n        debug(LOG_TAG, 'COUNT', this.store.name);\n        var request = this.store.count();\n        return wrapRequest(request);\n    };\n    SimpleDbStore.prototype.loadAll = function (indexOrRange, range) {\n        var cursor = this.cursor(this.options(indexOrRange, range));\n        var results = [];\n        return this.iterateCursor(cursor, function (key, value) {\n            results.push(value);\n        }).next(function () {\n            return results;\n        });\n    };\n    SimpleDbStore.prototype.deleteAll = function (indexOrRange, range) {\n        debug(LOG_TAG, 'DELETE ALL', this.store.name);\n        var options = this.options(indexOrRange, range);\n        options.keysOnly = false;\n        var cursor = this.cursor(options);\n        return this.iterateCursor(cursor, function (key, value, control) {\n            // NOTE: Calling delete() on a cursor is documented as more efficient than\n            // calling delete() on an object store with a single key\n            // (https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/delete),\n            // however, this requires us *not* to use a keysOnly cursor\n            // (https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/delete). We\n            // may want to compare the performance of each method.\n            return control.delete();\n        });\n    };\n    SimpleDbStore.prototype.iterate = function (optionsOrCallback, callback) {\n        var options;\n        if (!callback) {\n            options = {};\n            callback = optionsOrCallback;\n        }\n        else {\n            options = optionsOrCallback;\n        }\n        var cursor = this.cursor(options);\n        return this.iterateCursor(cursor, callback);\n    };\n    SimpleDbStore.prototype.iterateCursor = function (cursorRequest, fn) {\n        var results = [];\n        return new PersistencePromise(function (resolve, reject) {\n            cursorRequest.onerror = function (event) {\n                reject(event.target.error);\n            };\n            cursorRequest.onsuccess = function (event) {\n                var cursor = event.target.result;\n                if (!cursor) {\n                    resolve();\n                    return;\n                }\n                var controller = new IterationController(cursor);\n                var userResult = fn(cursor.primaryKey, cursor.value, controller);\n                if (userResult instanceof PersistencePromise) {\n                    results.push(userResult);\n                }\n                if (controller.isDone) {\n                    resolve();\n                }\n                else if (controller.skipToKey === null) {\n                    cursor.continue();\n                }\n                else {\n                    cursor.continue(controller.skipToKey);\n                }\n            };\n        }).next(function () {\n            return PersistencePromise.waitFor(results);\n        });\n    };\n    SimpleDbStore.prototype.options = function (indexOrRange, range) {\n        var indexName = undefined;\n        if (indexOrRange !== undefined) {\n            if (typeof indexOrRange === 'string') {\n                indexName = indexOrRange;\n            }\n            else {\n                assert(range === undefined, '3rd argument must not be defined if 2nd is a range.');\n                range = indexOrRange;\n            }\n        }\n        return { index: indexName, range: range };\n    };\n    SimpleDbStore.prototype.cursor = function (options) {\n        var direction = 'next';\n        if (options.reverse) {\n            direction = 'prev';\n        }\n        if (options.index) {\n            var index = this.store.index(options.index);\n            if (options.keysOnly) {\n                return index.openKeyCursor(options.range, direction);\n            }\n            else {\n                return index.openCursor(options.range, direction);\n            }\n        }\n        else {\n            return this.store.openCursor(options.range, direction);\n        }\n    };\n    return SimpleDbStore;\n}());\nexport { SimpleDbStore };\n/**\n * Wraps an IDBRequest in a PersistencePromise, using the onsuccess / onerror\n * handlers to resolve / reject the PersistencePromise as appropriate.\n */\nfunction wrapRequest(request) {\n    return new PersistencePromise(function (resolve, reject) {\n        request.onsuccess = function (event) {\n            var result = event.target.result;\n            resolve(result);\n        };\n        request.onerror = function (event) {\n            reject(event.target.error);\n        };\n    });\n}\n\n//# sourceMappingURL=simple_db.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/simple_db.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BATCHID_UNKNOWN, MutationBatch } from '../model/mutation_batch';\nimport { assert, fail } from '../util/assert';\nimport { immediatePredecessor, primitiveComparator } from '../util/misc';\nimport { SortedSet } from '../util/sorted_set';\nimport * as EncodedResourcePath from './encoded_resource_path';\nimport { DbDocumentMutation, DbMutationBatch, DbMutationQueue } from './indexeddb_schema';\nimport { PersistencePromise } from './persistence_promise';\nimport { SimpleDbTransaction } from './simple_db';\n/** A mutation queue for a specific user, backed by IndexedDB. */\nvar IndexedDbMutationQueue = /** @class */ (function () {\n    function IndexedDbMutationQueue(\n    /**\n     * The normalized userId (e.g. null UID => \"\" userId) used to store /\n     * retrieve mutations.\n     */\n    userId, serializer) {\n        this.userId = userId;\n        this.serializer = serializer;\n        this.garbageCollector = null;\n    }\n    /**\n     * Creates a new mutation queue for the given user.\n     * @param user The user for which to create a mutation queue.\n     * @param serializer The serializer to use when persisting to IndexedDb.\n     */\n    IndexedDbMutationQueue.forUser = function (user, serializer) {\n        // TODO(mcg): Figure out what constraints there are on userIDs\n        // In particular, are there any reserved characters? are empty ids allowed?\n        // For the moment store these together in the same mutations table assuming\n        // that empty userIDs aren't allowed.\n        assert(user.uid !== '', 'UserID must not be an empty string.');\n        var userId = user.isAuthenticated() ? user.uid : '';\n        return new IndexedDbMutationQueue(userId, serializer);\n    };\n    IndexedDbMutationQueue.prototype.start = function (transaction) {\n        var _this = this;\n        return IndexedDbMutationQueue.loadNextBatchIdFromDb(transaction)\n            .next(function (nextBatchId) {\n            _this.nextBatchId = nextBatchId;\n            return mutationQueuesStore(transaction).get(_this.userId);\n        })\n            .next(function (metadata) {\n            if (!metadata) {\n                metadata = new DbMutationQueue(_this.userId, BATCHID_UNKNOWN, \n                /*lastStreamToken=*/ '');\n            }\n            _this.metadata = metadata;\n            // On restart, nextBatchId may end up lower than\n            // lastAcknowledgedBatchId since it's computed from the queue\n            // contents, and there may be no mutations in the queue. In this\n            // case, we need to reset lastAcknowledgedBatchId (which is safe\n            // since the queue must be empty).\n            if (_this.metadata.lastAcknowledgedBatchId >= _this.nextBatchId) {\n                return _this.checkEmpty(transaction).next(function (empty) {\n                    assert(empty, 'Reset nextBatchID is only possible when the queue is empty');\n                    _this.metadata.lastAcknowledgedBatchId = BATCHID_UNKNOWN;\n                    return mutationQueuesStore(transaction).put(_this.metadata);\n                });\n            }\n            else {\n                return PersistencePromise.resolve();\n            }\n        });\n    };\n    /**\n     * Returns one larger than the largest batch ID that has been stored. If there\n     * are no mutations returns 0. Note that batch IDs are global.\n     */\n    IndexedDbMutationQueue.loadNextBatchIdFromDb = function (txn) {\n        var maxBatchId = BATCHID_UNKNOWN;\n        return mutationsStore(txn)\n            .iterate({ reverse: true }, function (key, batch, control) {\n            var userId = key[0], batchId = key[1];\n            if (batchId > maxBatchId) {\n                maxBatchId = batch.batchId;\n            }\n            if (userId === '') {\n                // We can't compute a predecessor for the empty string, since it\n                // is lexographically first. That also means that no other\n                // userIds can come before this one, so we can just exit early.\n                control.done();\n            }\n            else {\n                var nextUser = immediatePredecessor(userId);\n                control.skip([nextUser]);\n            }\n        })\n            .next(function () { return maxBatchId + 1; });\n    };\n    IndexedDbMutationQueue.prototype.checkEmpty = function (transaction) {\n        var empty = true;\n        var range = IDBKeyRange.bound(this.keyForBatchId(Number.NEGATIVE_INFINITY), this.keyForBatchId(Number.POSITIVE_INFINITY));\n        return mutationsStore(transaction)\n            .iterate({ range: range }, function (key, value, control) {\n            empty = false;\n            control.done();\n        })\n            .next(function () { return empty; });\n    };\n    IndexedDbMutationQueue.prototype.getNextBatchId = function (transaction) {\n        return PersistencePromise.resolve(this.nextBatchId);\n    };\n    IndexedDbMutationQueue.prototype.getHighestAcknowledgedBatchId = function (transaction) {\n        return PersistencePromise.resolve(this.metadata.lastAcknowledgedBatchId);\n    };\n    IndexedDbMutationQueue.prototype.acknowledgeBatch = function (transaction, batch, streamToken) {\n        var batchId = batch.batchId;\n        assert(batchId > this.metadata.lastAcknowledgedBatchId, 'Mutation batchIDs must be acknowledged in order');\n        this.metadata.lastAcknowledgedBatchId = batchId;\n        this.metadata.lastStreamToken = validateStreamToken(streamToken);\n        return mutationQueuesStore(transaction).put(this.metadata);\n    };\n    IndexedDbMutationQueue.prototype.getLastStreamToken = function (transaction) {\n        return PersistencePromise.resolve(this.metadata.lastStreamToken);\n    };\n    IndexedDbMutationQueue.prototype.setLastStreamToken = function (transaction, streamToken) {\n        this.metadata.lastStreamToken = validateStreamToken(streamToken);\n        return mutationQueuesStore(transaction).put(this.metadata);\n    };\n    IndexedDbMutationQueue.prototype.addMutationBatch = function (transaction, localWriteTime, mutations) {\n        var _this = this;\n        var batchId = this.nextBatchId;\n        this.nextBatchId++;\n        var batch = new MutationBatch(batchId, localWriteTime, mutations);\n        var dbBatch = this.serializer.toDbMutationBatch(this.userId, batch);\n        return mutationsStore(transaction)\n            .put(dbBatch)\n            .next(function () {\n            var promises = [];\n            for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {\n                var mutation = mutations_1[_i];\n                var indexKey = DbDocumentMutation.key(_this.userId, mutation.key.path, batchId);\n                documentMutationsStore(transaction).put(indexKey, DbDocumentMutation.PLACEHOLDER);\n            }\n            return PersistencePromise.waitFor(promises);\n        })\n            .next(function () {\n            return batch;\n        });\n    };\n    IndexedDbMutationQueue.prototype.lookupMutationBatch = function (transaction, batchId) {\n        var _this = this;\n        return mutationsStore(transaction)\n            .get(this.keyForBatchId(batchId))\n            .next(function (dbBatch) {\n            return dbBatch ? _this.serializer.fromDbMutationBatch(dbBatch) : null;\n        });\n    };\n    IndexedDbMutationQueue.prototype.getNextMutationBatchAfterBatchId = function (transaction, batchId) {\n        var _this = this;\n        // All batches with batchId <= this.metadata.lastAcknowledgedBatchId have\n        // been acknowledged so the first unacknowledged batch after batchID will\n        // have a batchID larger than both of these values.\n        var nextBatchId = Math.max(batchId, this.metadata.lastAcknowledgedBatchId) + 1;\n        var range = IDBKeyRange.lowerBound(this.keyForBatchId(nextBatchId));\n        var foundBatch = null;\n        return mutationsStore(transaction)\n            .iterate({ range: range }, function (key, dbBatch, control) {\n            if (dbBatch.userId === _this.userId) {\n                assert(dbBatch.batchId >= nextBatchId, 'Should have found mutation after ' + nextBatchId);\n                foundBatch = _this.serializer.fromDbMutationBatch(dbBatch);\n            }\n            control.done();\n        })\n            .next(function () { return foundBatch; });\n    };\n    IndexedDbMutationQueue.prototype.getAllMutationBatches = function (transaction) {\n        var _this = this;\n        var range = IDBKeyRange.bound(this.keyForBatchId(BATCHID_UNKNOWN), this.keyForBatchId(Number.POSITIVE_INFINITY));\n        return mutationsStore(transaction)\n            .loadAll(range)\n            .next(function (dbBatches) {\n            return dbBatches.map(function (dbBatch) { return _this.serializer.fromDbMutationBatch(dbBatch); });\n        });\n    };\n    IndexedDbMutationQueue.prototype.getAllMutationBatchesThroughBatchId = function (transaction, batchId) {\n        var _this = this;\n        var range = IDBKeyRange.bound(this.keyForBatchId(BATCHID_UNKNOWN), this.keyForBatchId(batchId));\n        return mutationsStore(transaction)\n            .loadAll(range)\n            .next(function (dbBatches) {\n            return dbBatches.map(function (dbBatch) { return _this.serializer.fromDbMutationBatch(dbBatch); });\n        });\n    };\n    IndexedDbMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKey = function (transaction, documentKey) {\n        var _this = this;\n        // Scan the document-mutation index starting with a prefix starting with\n        // the given documentKey.\n        var indexPrefix = DbDocumentMutation.prefixForPath(this.userId, documentKey.path);\n        var indexStart = IDBKeyRange.lowerBound(indexPrefix);\n        var results = [];\n        return documentMutationsStore(transaction)\n            .iterate({ range: indexStart }, function (indexKey, _, control) {\n            var userID = indexKey[0], encodedPath = indexKey[1], batchID = indexKey[2];\n            // Only consider rows matching exactly the specific key of\n            // interest. Note that because we order by path first, and we\n            // order terminators before path separators, we'll encounter all\n            // the index rows for documentKey contiguously. In particular, all\n            // the rows for documentKey will occur before any rows for\n            // documents nested in a subcollection beneath documentKey so we\n            // can stop as soon as we hit any such row.\n            var path = EncodedResourcePath.decode(encodedPath);\n            if (userID !== _this.userId || !documentKey.path.isEqual(path)) {\n                control.done();\n                return;\n            }\n            var mutationKey = _this.keyForBatchId(batchID);\n            // Look up the mutation batch in the store.\n            // PORTING NOTE: because iteration is callback driven in the web,\n            // we just look up the key instead of keeping an open iterator\n            // like iOS.\n            return mutationsStore(transaction)\n                .get(mutationKey)\n                .next(function (dbBatch) {\n                if (dbBatch === null) {\n                    fail('Dangling document-mutation reference found: ' +\n                        indexKey +\n                        ' which points to ' +\n                        mutationKey);\n                }\n                results.push(_this.serializer.fromDbMutationBatch(dbBatch));\n            });\n        })\n            .next(function () { return results; });\n    };\n    IndexedDbMutationQueue.prototype.getAllMutationBatchesAffectingQuery = function (transaction, query) {\n        var _this = this;\n        assert(!query.isDocumentQuery(), \"Document queries shouldn't go down this path\");\n        var queryPath = query.path;\n        var immediateChildrenLength = queryPath.length + 1;\n        // TODO(mcg): Actually implement a single-collection query\n        //\n        // This is actually executing an ancestor query, traversing the whole\n        // subtree below the collection which can be horrifically inefficient for\n        // some structures. The right way to solve this is to implement the full\n        // value index, but that's not in the cards in the near future so this is\n        // the best we can do for the moment.\n        //\n        // Since we don't yet index the actual properties in the mutations, our\n        // current approach is to just return all mutation batches that affect\n        // documents in the collection being queried.\n        var indexPrefix = DbDocumentMutation.prefixForPath(this.userId, queryPath);\n        var indexStart = IDBKeyRange.lowerBound(indexPrefix);\n        // Collect up unique batchIDs encountered during a scan of the index. Use a\n        // SortedSet to accumulate batch IDs so they can be traversed in order in a\n        // scan of the main table.\n        var uniqueBatchIDs = new SortedSet(primitiveComparator);\n        return documentMutationsStore(transaction)\n            .iterate({ range: indexStart }, function (indexKey, _, control) {\n            var userID = indexKey[0], encodedPath = indexKey[1], batchID = indexKey[2];\n            var path = EncodedResourcePath.decode(encodedPath);\n            if (userID !== _this.userId || !queryPath.isPrefixOf(path)) {\n                control.done();\n                return;\n            }\n            // Rows with document keys more than one segment longer than the\n            // query path can't be matches. For example, a query on 'rooms'\n            // can't match the document /rooms/abc/messages/xyx.\n            // TODO(mcg): we'll need a different scanner when we implement\n            // ancestor queries.\n            if (path.length !== immediateChildrenLength) {\n                return;\n            }\n            uniqueBatchIDs = uniqueBatchIDs.add(batchID);\n        })\n            .next(function () {\n            var results = [];\n            var promises = [];\n            // TODO(rockwood): Implement this using iterate.\n            uniqueBatchIDs.forEach(function (batchID) {\n                var mutationKey = _this.keyForBatchId(batchID);\n                promises.push(mutationsStore(transaction)\n                    .get(mutationKey)\n                    .next(function (mutation) {\n                    if (mutation === null) {\n                        fail('Dangling document-mutation reference found, ' +\n                            'which points to ' +\n                            mutationKey);\n                    }\n                    results.push(_this.serializer.fromDbMutationBatch(mutation));\n                }));\n            });\n            return PersistencePromise.waitFor(promises).next(function () { return results; });\n        });\n    };\n    IndexedDbMutationQueue.prototype.removeMutationBatches = function (transaction, batches) {\n        var txn = mutationsStore(transaction);\n        var indexTxn = documentMutationsStore(transaction);\n        var promises = [];\n        var _loop_1 = function (batch) {\n            var range = IDBKeyRange.only(this_1.keyForBatchId(batch.batchId));\n            var numDeleted = 0;\n            var removePromise = txn.iterate({ range: range }, function (key, value, control) {\n                numDeleted++;\n                return control.delete();\n            });\n            promises.push(removePromise.next(function () {\n                assert(numDeleted === 1, 'Dangling document-mutation reference found: Missing batch ' +\n                    batch.batchId);\n            }));\n            for (var _i = 0, _a = batch.mutations; _i < _a.length; _i++) {\n                var mutation = _a[_i];\n                var indexKey = DbDocumentMutation.key(this_1.userId, mutation.key.path, batch.batchId);\n                promises.push(indexTxn.delete(indexKey));\n                if (this_1.garbageCollector !== null) {\n                    this_1.garbageCollector.addPotentialGarbageKey(mutation.key);\n                }\n            }\n        };\n        var this_1 = this;\n        for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {\n            var batch = batches_1[_i];\n            _loop_1(batch);\n        }\n        return PersistencePromise.waitFor(promises);\n    };\n    IndexedDbMutationQueue.prototype.performConsistencyCheck = function (txn) {\n        var _this = this;\n        return this.checkEmpty(txn).next(function (empty) {\n            if (!empty) {\n                return PersistencePromise.resolve();\n            }\n            // Verify that there are no entries in the documentMutations index if\n            // the queue is empty.\n            var startRange = IDBKeyRange.lowerBound(DbDocumentMutation.prefixForUser(_this.userId));\n            var danglingMutationReferences = [];\n            return documentMutationsStore(txn)\n                .iterate({ range: startRange }, function (key, _, control) {\n                var userID = key[0];\n                if (userID !== _this.userId) {\n                    control.done();\n                    return;\n                }\n                else {\n                    var path = EncodedResourcePath.decode(key[1]);\n                    danglingMutationReferences.push(path);\n                }\n            })\n                .next(function () {\n                assert(danglingMutationReferences.length === 0, 'Document leak -- detected dangling mutation references when queue is empty. Dangling keys: ' +\n                    danglingMutationReferences.map(function (p) { return p.canonicalString(); }));\n            });\n        });\n    };\n    IndexedDbMutationQueue.prototype.setGarbageCollector = function (gc) {\n        this.garbageCollector = gc;\n    };\n    IndexedDbMutationQueue.prototype.containsKey = function (txn, key) {\n        var _this = this;\n        var indexKey = DbDocumentMutation.prefixForPath(this.userId, key.path);\n        var encodedPath = indexKey[1];\n        var startRange = IDBKeyRange.lowerBound(indexKey);\n        var containsKey = false;\n        return documentMutationsStore(txn)\n            .iterate({ range: startRange, keysOnly: true }, function (key, value, control) {\n            var userID = key[0], keyPath = key[1], /*batchID*/ _ = key[2];\n            if (userID === _this.userId && keyPath === encodedPath) {\n                containsKey = true;\n            }\n            control.done();\n        })\n            .next(function () { return containsKey; });\n    };\n    /**\n     * Creates a [userId, batchId] key for use with the DbMutationQueue object\n     * store.\n     */\n    IndexedDbMutationQueue.prototype.keyForBatchId = function (batchId) {\n        return [this.userId, batchId];\n    };\n    return IndexedDbMutationQueue;\n}());\nexport { IndexedDbMutationQueue };\nfunction validateStreamToken(token) {\n    assert(typeof token === 'string', 'Persisting non-string stream token not supported.');\n    return token;\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutations object store.\n */\nfunction mutationsStore(txn) {\n    return getStore(txn, DbMutationBatch.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\nfunction documentMutationsStore(txn) {\n    return getStore(txn, DbDocumentMutation.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the mutationQueues object store.\n */\nfunction mutationQueuesStore(txn) {\n    return getStore(txn, DbMutationQueue.store);\n}\n/**\n * Helper to get a typed SimpleDbStore from a transaction.\n */\nfunction getStore(txn, store) {\n    if (txn instanceof SimpleDbTransaction) {\n        return txn.store(store);\n    }\n    else {\n        return fail('Invalid transaction object provided!');\n    }\n}\n\n//# sourceMappingURL=indexeddb_mutation_queue.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/indexeddb_mutation_queue.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../core/timestamp';\nimport { documentKeySet } from '../model/collections';\nimport { DocumentKey } from '../model/document_key';\nimport { assert, fail } from '../util/assert';\nimport { immediateSuccessor } from '../util/misc';\nimport * as EncodedResourcePath from './encoded_resource_path';\nimport { DbTarget, DbTargetDocument, DbTargetGlobal } from './indexeddb_schema';\nimport { PersistencePromise } from './persistence_promise';\nimport { SimpleDbTransaction } from './simple_db';\nvar IndexedDbQueryCache = /** @class */ (function () {\n    function IndexedDbQueryCache(serializer) {\n        this.serializer = serializer;\n        /**\n         * The last received snapshot version. We store this seperately from the\n         * metadata to avoid the extra conversion to/from DbTimestamp.\n         */\n        this.lastRemoteSnapshotVersion = SnapshotVersion.MIN;\n        /**\n         * A cached copy of the metadata for the query cache.\n         */\n        this.metadata = null;\n        /** The garbage collector to notify about potential garbage keys. */\n        this.garbageCollector = null;\n    }\n    IndexedDbQueryCache.prototype.start = function (transaction) {\n        var _this = this;\n        return globalTargetStore(transaction)\n            .get(DbTargetGlobal.key)\n            .next(function (metadata) {\n            assert(metadata !== null, 'Missing metadata row that should be added by schema migration.');\n            _this.metadata = metadata;\n            var lastSavedVersion = metadata.lastRemoteSnapshotVersion;\n            _this.lastRemoteSnapshotVersion = SnapshotVersion.fromTimestamp(new Timestamp(lastSavedVersion.seconds, lastSavedVersion.nanos));\n            return PersistencePromise.resolve();\n        });\n    };\n    IndexedDbQueryCache.prototype.getHighestTargetId = function () {\n        return this.metadata.highestTargetId;\n    };\n    IndexedDbQueryCache.prototype.getLastRemoteSnapshotVersion = function () {\n        return this.lastRemoteSnapshotVersion;\n    };\n    IndexedDbQueryCache.prototype.setLastRemoteSnapshotVersion = function (transaction, snapshotVersion) {\n        this.lastRemoteSnapshotVersion = snapshotVersion;\n        this.metadata.lastRemoteSnapshotVersion = snapshotVersion.toTimestamp();\n        return globalTargetStore(transaction).put(DbTargetGlobal.key, this.metadata);\n    };\n    IndexedDbQueryCache.prototype.addQueryData = function (transaction, queryData) {\n        var _this = this;\n        return this.saveQueryData(transaction, queryData).next(function () {\n            _this.metadata.targetCount += 1;\n            _this.updateMetadataFromQueryData(queryData);\n            return _this.saveMetadata(transaction);\n        });\n    };\n    IndexedDbQueryCache.prototype.updateQueryData = function (transaction, queryData) {\n        var _this = this;\n        return this.saveQueryData(transaction, queryData).next(function () {\n            if (_this.updateMetadataFromQueryData(queryData)) {\n                return _this.saveMetadata(transaction);\n            }\n            else {\n                return PersistencePromise.resolve();\n            }\n        });\n    };\n    IndexedDbQueryCache.prototype.removeQueryData = function (transaction, queryData) {\n        var _this = this;\n        assert(this.metadata.targetCount > 0, 'Removing from an empty query cache');\n        return this.removeMatchingKeysForTargetId(transaction, queryData.targetId)\n            .next(function () { return targetsStore(transaction).delete(queryData.targetId); })\n            .next(function () {\n            _this.metadata.targetCount -= 1;\n            return _this.saveMetadata(transaction);\n        });\n    };\n    IndexedDbQueryCache.prototype.saveMetadata = function (transaction) {\n        return globalTargetStore(transaction).put(DbTargetGlobal.key, this.metadata);\n    };\n    IndexedDbQueryCache.prototype.saveQueryData = function (transaction, queryData) {\n        return targetsStore(transaction).put(this.serializer.toDbTarget(queryData));\n    };\n    /**\n     * Updates the in-memory version of the metadata to account for values in the\n     * given QueryData. Saving is done separately. Returns true if there were any\n     * changes to the metadata.\n     */\n    IndexedDbQueryCache.prototype.updateMetadataFromQueryData = function (queryData) {\n        var needsUpdate = false;\n        if (queryData.targetId > this.metadata.highestTargetId) {\n            this.metadata.highestTargetId = queryData.targetId;\n            needsUpdate = true;\n        }\n        // TODO(GC): add sequence number check\n        return needsUpdate;\n    };\n    Object.defineProperty(IndexedDbQueryCache.prototype, \"count\", {\n        get: function () {\n            return this.metadata.targetCount;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    IndexedDbQueryCache.prototype.getQueryData = function (transaction, query) {\n        var _this = this;\n        // Iterating by the canonicalId may yield more than one result because\n        // canonicalId values are not required to be unique per target. This query\n        // depends on the queryTargets index to be efficent.\n        var canonicalId = query.canonicalId();\n        var range = IDBKeyRange.bound([canonicalId, Number.NEGATIVE_INFINITY], [canonicalId, Number.POSITIVE_INFINITY]);\n        var result = null;\n        return targetsStore(transaction)\n            .iterate({ range: range, index: DbTarget.queryTargetsIndexName }, function (key, value, control) {\n            var found = _this.serializer.fromDbTarget(value);\n            // After finding a potential match, check that the query is\n            // actually equal to the requested query.\n            if (query.isEqual(found.query)) {\n                result = found;\n                control.done();\n            }\n        })\n            .next(function () { return result; });\n    };\n    IndexedDbQueryCache.prototype.addMatchingKeys = function (txn, keys, targetId) {\n        // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n        // Indexeddb.\n        var promises = [];\n        var store = documentTargetStore(txn);\n        keys.forEach(function (key) {\n            var path = EncodedResourcePath.encode(key.path);\n            promises.push(store.put(new DbTargetDocument(targetId, path)));\n        });\n        return PersistencePromise.waitFor(promises);\n    };\n    IndexedDbQueryCache.prototype.removeMatchingKeys = function (txn, keys, targetId) {\n        var _this = this;\n        // PORTING NOTE: The reverse index (documentsTargets) is maintained by\n        // IndexedDb.\n        var promises = [];\n        var store = documentTargetStore(txn);\n        keys.forEach(function (key) {\n            var path = EncodedResourcePath.encode(key.path);\n            promises.push(store.delete([targetId, path]));\n            if (_this.garbageCollector !== null) {\n                _this.garbageCollector.addPotentialGarbageKey(key);\n            }\n        });\n        return PersistencePromise.waitFor(promises);\n    };\n    IndexedDbQueryCache.prototype.removeMatchingKeysForTargetId = function (txn, targetId) {\n        var store = documentTargetStore(txn);\n        var range = IDBKeyRange.bound([targetId], [targetId + 1], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        return this.notifyGCForRemovedKeys(txn, range).next(function () {\n            return store.delete(range);\n        });\n    };\n    IndexedDbQueryCache.prototype.notifyGCForRemovedKeys = function (txn, range) {\n        var _this = this;\n        var store = documentTargetStore(txn);\n        if (this.garbageCollector !== null && this.garbageCollector.isEager) {\n            // In order to generate garbage events properly, we need to read these\n            // keys before deleting.\n            return store.iterate({ range: range, keysOnly: true }, function (key, _, control) {\n                var path = EncodedResourcePath.decode(key[1]);\n                var docKey = new DocumentKey(path);\n                // Paranoid assertion in case the the collector is set to null\n                // during the iteration.\n                assert(_this.garbageCollector !== null, 'GarbageCollector for query cache set to null during key removal.');\n                _this.garbageCollector.addPotentialGarbageKey(docKey);\n            });\n        }\n        else {\n            return PersistencePromise.resolve();\n        }\n    };\n    IndexedDbQueryCache.prototype.getMatchingKeysForTargetId = function (txn, targetId) {\n        var range = IDBKeyRange.bound([targetId], [targetId + 1], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        var store = documentTargetStore(txn);\n        var result = documentKeySet();\n        return store\n            .iterate({ range: range, keysOnly: true }, function (key, _, control) {\n            var path = EncodedResourcePath.decode(key[1]);\n            var docKey = new DocumentKey(path);\n            result = result.add(docKey);\n        })\n            .next(function () { return result; });\n    };\n    IndexedDbQueryCache.prototype.setGarbageCollector = function (gc) {\n        this.garbageCollector = gc;\n    };\n    IndexedDbQueryCache.prototype.containsKey = function (txn, key) {\n        assert(txn !== null, 'Persistence Transaction cannot be null for query cache containsKey');\n        var path = EncodedResourcePath.encode(key.path);\n        var range = IDBKeyRange.bound([path], [immediateSuccessor(path)], \n        /*lowerOpen=*/ false, \n        /*upperOpen=*/ true);\n        var count = 0;\n        return documentTargetStore(txn)\n            .iterate({\n            index: DbTargetDocument.documentTargetsIndex,\n            keysOnly: true,\n            range: range\n        }, function (key, _, control) {\n            count++;\n            control.done();\n        })\n            .next(function () { return count > 0; });\n    };\n    return IndexedDbQueryCache;\n}());\nexport { IndexedDbQueryCache };\n/**\n * Helper to get a typed SimpleDbStore for the queries object store.\n */\nfunction targetsStore(txn) {\n    return getStore(txn, DbTarget.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the target globals object store.\n */\nfunction globalTargetStore(txn) {\n    return getStore(txn, DbTargetGlobal.store);\n}\n/**\n * Helper to get a typed SimpleDbStore for the document target object store.\n */\nfunction documentTargetStore(txn) {\n    return getStore(txn, DbTargetDocument.store);\n}\n/**\n * Helper to get a typed SimpleDbStore from a transaction.\n */\nfunction getStore(txn, store) {\n    if (txn instanceof SimpleDbTransaction) {\n        return txn.store(store);\n    }\n    else {\n        return fail('Invalid transaction object provided!');\n    }\n}\n\n//# sourceMappingURL=indexeddb_query_cache.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/indexeddb_query_cache.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { documentMap } from '../model/collections';\nimport { Document } from '../model/document';\nimport { fail } from '../util/assert';\nimport { DbRemoteDocument } from './indexeddb_schema';\nimport { SimpleDbTransaction } from './simple_db';\nvar IndexedDbRemoteDocumentCache = /** @class */ (function () {\n    function IndexedDbRemoteDocumentCache(serializer) {\n        this.serializer = serializer;\n    }\n    IndexedDbRemoteDocumentCache.prototype.addEntry = function (transaction, maybeDocument) {\n        return remoteDocumentsStore(transaction).put(dbKey(maybeDocument.key), this.serializer.toDbRemoteDocument(maybeDocument));\n    };\n    IndexedDbRemoteDocumentCache.prototype.removeEntry = function (transaction, documentKey) {\n        return remoteDocumentsStore(transaction).delete(dbKey(documentKey));\n    };\n    IndexedDbRemoteDocumentCache.prototype.getEntry = function (transaction, documentKey) {\n        var _this = this;\n        return remoteDocumentsStore(transaction)\n            .get(dbKey(documentKey))\n            .next(function (dbRemoteDoc) {\n            return dbRemoteDoc\n                ? _this.serializer.fromDbRemoteDocument(dbRemoteDoc)\n                : null;\n        });\n    };\n    IndexedDbRemoteDocumentCache.prototype.getDocumentsMatchingQuery = function (transaction, query) {\n        var _this = this;\n        var results = documentMap();\n        // Documents are ordered by key, so we can use a prefix scan to narrow down\n        // the documents we need to match the query against.\n        var startKey = query.path.toArray();\n        var range = IDBKeyRange.lowerBound(startKey);\n        return remoteDocumentsStore(transaction)\n            .iterate({ range: range }, function (key, dbRemoteDoc, control) {\n            var maybeDoc = _this.serializer.fromDbRemoteDocument(dbRemoteDoc);\n            if (!query.path.isPrefixOf(maybeDoc.key.path)) {\n                control.done();\n            }\n            else if (maybeDoc instanceof Document && query.matches(maybeDoc)) {\n                results = results.insert(maybeDoc.key, maybeDoc);\n            }\n        })\n            .next(function () { return results; });\n    };\n    return IndexedDbRemoteDocumentCache;\n}());\nexport { IndexedDbRemoteDocumentCache };\n/**\n * Helper to get a typed SimpleDbStore for the remoteDocuments object store.\n */\nfunction remoteDocumentsStore(txn) {\n    if (txn instanceof SimpleDbTransaction) {\n        return txn.store(DbRemoteDocument.store);\n    }\n    else {\n        return fail('Invalid transaction object provided!');\n    }\n}\nfunction dbKey(docKey) {\n    return docKey.path.toArray();\n}\n\n//# sourceMappingURL=indexeddb_remote_document_cache.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/indexeddb_remote_document_cache.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Timestamp } from '../core/timestamp';\nimport { Document, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { MutationBatch } from '../model/mutation_batch';\nimport { assert, fail } from '../util/assert';\nimport { DbMutationBatch, DbNoDocument, DbRemoteDocument, DbTarget, DbTimestamp } from './indexeddb_schema';\nimport { QueryData, QueryPurpose } from './query_data';\n/** Serializer for values stored in the LocalStore. */\nvar LocalSerializer = /** @class */ (function () {\n    function LocalSerializer(remoteSerializer) {\n        this.remoteSerializer = remoteSerializer;\n    }\n    /** Decodes a remote document from storage locally to a Document. */\n    LocalSerializer.prototype.fromDbRemoteDocument = function (remoteDoc) {\n        if (remoteDoc.document) {\n            return this.remoteSerializer.fromDocument(remoteDoc.document);\n        }\n        else if (remoteDoc.noDocument) {\n            var key = DocumentKey.fromSegments(remoteDoc.noDocument.path);\n            var readTime = remoteDoc.noDocument.readTime;\n            var timestamp = new Timestamp(readTime.seconds, readTime.nanos);\n            return new NoDocument(key, SnapshotVersion.fromTimestamp(timestamp));\n        }\n        else {\n            return fail('Unexpected DbRemoteDocument');\n        }\n    };\n    /** Encodes a document for storage locally. */\n    LocalSerializer.prototype.toDbRemoteDocument = function (maybeDoc) {\n        if (maybeDoc instanceof Document) {\n            var doc = this.remoteSerializer.toDocument(maybeDoc);\n            return new DbRemoteDocument(null, doc);\n        }\n        else {\n            var path = maybeDoc.key.path.toArray();\n            var timestamp = maybeDoc.version.toTimestamp();\n            var readTime = new DbTimestamp(timestamp.seconds, timestamp.nanos);\n            return new DbRemoteDocument(new DbNoDocument(path, readTime), null);\n        }\n    };\n    /** Encodes a batch of mutations into a DbMutationBatch for local storage. */\n    LocalSerializer.prototype.toDbMutationBatch = function (userId, batch) {\n        var _this = this;\n        var serializedMutations = batch.mutations.map(function (m) {\n            return _this.remoteSerializer.toMutation(m);\n        });\n        return new DbMutationBatch(userId, batch.batchId, batch.localWriteTime.toEpochMilliseconds(), serializedMutations);\n    };\n    /** Decodes a DbMutationBatch into a MutationBatch */\n    LocalSerializer.prototype.fromDbMutationBatch = function (dbBatch) {\n        var _this = this;\n        var mutations = dbBatch.mutations.map(function (m) {\n            return _this.remoteSerializer.fromMutation(m);\n        });\n        var timestamp = Timestamp.fromEpochMilliseconds(dbBatch.localWriteTimeMs);\n        return new MutationBatch(dbBatch.batchId, timestamp, mutations);\n    };\n    /** Decodes a DbTarget into QueryData */\n    LocalSerializer.prototype.fromDbTarget = function (dbTarget) {\n        var readTime = new Timestamp(dbTarget.readTime.seconds, dbTarget.readTime.nanos);\n        var version = SnapshotVersion.fromTimestamp(readTime);\n        var query;\n        if (isDocumentQuery(dbTarget.query)) {\n            query = this.remoteSerializer.fromDocumentsTarget(dbTarget.query);\n        }\n        else {\n            query = this.remoteSerializer.fromQueryTarget(dbTarget.query);\n        }\n        return new QueryData(query, dbTarget.targetId, QueryPurpose.Listen, version, dbTarget.resumeToken);\n    };\n    /** Encodes QueryData into a DbTarget for storage locally. */\n    LocalSerializer.prototype.toDbTarget = function (queryData) {\n        assert(QueryPurpose.Listen === queryData.purpose, 'Only queries with purpose ' +\n            QueryPurpose.Listen +\n            ' may be stored, got ' +\n            queryData.purpose);\n        var timestamp = queryData.snapshotVersion.toTimestamp();\n        var dbTimestamp = new DbTimestamp(timestamp.seconds, timestamp.nanos);\n        var queryProto;\n        if (queryData.query.isDocumentQuery()) {\n            queryProto = this.remoteSerializer.toDocumentsTarget(queryData.query);\n        }\n        else {\n            queryProto = this.remoteSerializer.toQueryTarget(queryData.query);\n        }\n        assert(typeof queryData.resumeToken === 'string', 'Persisting non-string resume token not supported.');\n        var resumeToken = queryData.resumeToken;\n        // lastListenSequenceNumber is always 0 until we do real GC.\n        return new DbTarget(queryData.targetId, queryData.query.canonicalId(), dbTimestamp, resumeToken, 0, queryProto);\n    };\n    return LocalSerializer;\n}());\nexport { LocalSerializer };\n/**\n * A helper function for figuring out what kind of query has been stored.\n */\nfunction isDocumentQuery(dbQuery) {\n    return dbQuery.documents !== undefined;\n}\n\n//# sourceMappingURL=local_serializer.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/local_serializer.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { User } from '../auth/user';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nvar OAuthToken = /** @class */ (function () {\n    function OAuthToken(value, user) {\n        this.user = user;\n        this.type = 'OAuth';\n        this.authHeaders = { Authorization: \"Bearer \" + value };\n    }\n    return OAuthToken;\n}());\nexport { OAuthToken };\n/** A CredentialsProvider that always yields an empty token. */\nvar EmptyCredentialsProvider = /** @class */ (function () {\n    function EmptyCredentialsProvider() {\n        /**\n         * Stores the User listener registered with setUserChangeListener()\n         * This isn't actually necessary since the UID never changes, but we use this\n         * to verify the listen contract is adhered to in tests.\n         */\n        this.userListener = null;\n    }\n    EmptyCredentialsProvider.prototype.getToken = function (forceRefresh) {\n        return Promise.resolve(null);\n    };\n    EmptyCredentialsProvider.prototype.setUserChangeListener = function (listener) {\n        assert(!this.userListener, 'Can only call setUserChangeListener() once.');\n        this.userListener = listener;\n        // Fire with initial user.\n        listener(User.UNAUTHENTICATED);\n    };\n    EmptyCredentialsProvider.prototype.removeUserChangeListener = function () {\n        assert(this.userListener !== null, 'removeUserChangeListener() when no listener registered');\n        this.userListener = null;\n    };\n    return EmptyCredentialsProvider;\n}());\nexport { EmptyCredentialsProvider };\nvar FirebaseCredentialsProvider = /** @class */ (function () {\n    function FirebaseCredentialsProvider(app) {\n        var _this = this;\n        this.app = app;\n        /**\n         * The auth token listener registered with FirebaseApp, retained here so we\n         * can unregister it.\n         */\n        this.tokenListener = null;\n        /**\n         * Counter used to detect if the user changed while a getToken request was\n         * outstanding.\n         */\n        this.userCounter = 0;\n        /** The User listener registered with setUserChangeListener(). */\n        this.userListener = null;\n        // We listen for token changes but all we really care about is knowing when\n        // the uid may have changed.\n        this.tokenListener = function () {\n            var newUser = _this.getUser();\n            if (!_this.currentUser || !newUser.isEqual(_this.currentUser)) {\n                _this.currentUser = newUser;\n                _this.userCounter++;\n                if (_this.userListener) {\n                    _this.userListener(_this.currentUser);\n                }\n            }\n        };\n        this.userCounter = 0;\n        // Will fire at least once where we set this.currentUser\n        this.app.INTERNAL.addAuthTokenListener(this.tokenListener);\n    }\n    FirebaseCredentialsProvider.prototype.getToken = function (forceRefresh) {\n        var _this = this;\n        assert(this.tokenListener != null, 'getToken cannot be called after listener removed.');\n        // Take note of the current value of the userCounter so that this method can\n        // fail (with an ABORTED error) if there is a user change while the request\n        // is outstanding.\n        var initialUserCounter = this.userCounter;\n        return this.app.INTERNAL.getToken(forceRefresh).then(function (tokenData) {\n            // Cancel the request since the user changed while the request was\n            // outstanding so the response is likely for a previous user (which\n            // user, we can't be sure).\n            if (_this.userCounter !== initialUserCounter) {\n                throw new FirestoreError(Code.ABORTED, 'getToken aborted due to uid change.');\n            }\n            else {\n                if (tokenData) {\n                    assert(typeof tokenData.accessToken === 'string', 'Invalid tokenData returned from getToken():' + tokenData);\n                    return new OAuthToken(tokenData.accessToken, _this.currentUser);\n                }\n                else {\n                    return null;\n                }\n            }\n        });\n    };\n    FirebaseCredentialsProvider.prototype.setUserChangeListener = function (listener) {\n        assert(!this.userListener, 'Can only call setUserChangeListener() once.');\n        this.userListener = listener;\n        // Fire the initial event, but only if we received the initial user\n        if (this.currentUser) {\n            listener(this.currentUser);\n        }\n    };\n    FirebaseCredentialsProvider.prototype.removeUserChangeListener = function () {\n        assert(this.tokenListener != null, 'removeUserChangeListener() called twice');\n        assert(this.userListener !== null, 'removeUserChangeListener() called when no listener registered');\n        this.app.INTERNAL.removeAuthTokenListener(this.tokenListener);\n        this.tokenListener = null;\n        this.userListener = null;\n    };\n    FirebaseCredentialsProvider.prototype.getUser = function () {\n        // TODO(mikelehen): Remove this check once we're shipping with firebase.js.\n        if (typeof this.app.INTERNAL.getUid !== 'function') {\n            fail('This version of the Firestore SDK requires at least version' +\n                ' 3.7.0 of firebase.js.');\n        }\n        var currentUid = this.app.INTERNAL.getUid();\n        assert(currentUid === null || typeof currentUid === 'string', 'Received invalid UID: ' + currentUid);\n        return new User(currentUid);\n    };\n    return FirebaseCredentialsProvider;\n}());\nexport { FirebaseCredentialsProvider };\n/*\n * FirstPartyToken provides a fresh token each time its value\n * is requested, because if the token is too old, requests will be rejected.\n * TODO(b/33147818) this implementation violates the current assumption that\n * tokens are immutable.  We need to either revisit this assumption or come\n * up with some way for FPA to use the listen/unlisten interface.\n */\nvar FirstPartyToken = /** @class */ (function () {\n    function FirstPartyToken(gapi, sessionIndex) {\n        this.gapi = gapi;\n        this.sessionIndex = sessionIndex;\n        this.type = 'FirstParty';\n        this.user = User.FIRST_PARTY;\n        assert(this.gapi &&\n            this.gapi['auth'] &&\n            this.gapi['auth']['getAuthHeaderValueForFirstParty'], 'unexpected gapi interface');\n    }\n    Object.defineProperty(FirstPartyToken.prototype, \"authHeaders\", {\n        get: function () {\n            return {\n                Authorization: this.gapi['auth']['getAuthHeaderValueForFirstParty']([]),\n                'X-Goog-AuthUser': this.sessionIndex\n            };\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return FirstPartyToken;\n}());\nexport { FirstPartyToken };\n/*\n * Provides user credentials required for the Firestore JavaScript SDK\n * to authenticate the user, using technique that is only available\n * to applications hosted by Google.\n */\nvar FirstPartyCredentialsProvider = /** @class */ (function () {\n    function FirstPartyCredentialsProvider(gapi, sessionIndex) {\n        this.gapi = gapi;\n        this.sessionIndex = sessionIndex;\n        assert(this.gapi &&\n            this.gapi['auth'] &&\n            this.gapi['auth']['getAuthHeaderValueForFirstParty'], 'unexpected gapi interface');\n    }\n    FirstPartyCredentialsProvider.prototype.getToken = function (forceRefresh) {\n        return Promise.resolve(new FirstPartyToken(this.gapi, this.sessionIndex));\n    };\n    // TODO(33108925): can someone switch users w/o a page refresh?\n    // TODO(33110621): need to understand token/session lifecycle\n    FirstPartyCredentialsProvider.prototype.setUserChangeListener = function (listener) {\n        // Fire with initial uid.\n        listener(User.FIRST_PARTY);\n    };\n    FirstPartyCredentialsProvider.prototype.removeUserChangeListener = function () { };\n    return FirstPartyCredentialsProvider;\n}());\nexport { FirstPartyCredentialsProvider };\n/**\n * Builds a CredentialsProvider depending on the type of\n * the credentials passed in.\n */\nexport function makeCredentialsProvider(credentials) {\n    if (!credentials) {\n        return new EmptyCredentialsProvider();\n    }\n    switch (credentials.type) {\n        case 'gapi':\n            return new FirstPartyCredentialsProvider(credentials.client, credentials.sessionIndex || '0');\n        case 'provider':\n            return credentials.client;\n        default:\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'makeCredentialsProvider failed due to invalid credential type');\n    }\n}\n\n//# sourceMappingURL=credentials.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/api/credentials.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport function isPartialObserver(obj) {\n    return implementsAnyMethods(obj, ['next', 'error', 'complete']);\n}\n/**\n * Returns true if obj is an object and contains at least one of the specified\n * methods.\n */\nfunction implementsAnyMethods(obj, methods) {\n    if (typeof obj !== 'object' || obj === null) {\n        return false;\n    }\n    var object = obj;\n    for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {\n        var method = methods_1[_i];\n        if (method in object && typeof object[method] === 'function') {\n            return true;\n        }\n    }\n    return false;\n}\n\n//# sourceMappingURL=observer.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/api/observer.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Timestamp } from '../core/timestamp';\nimport { ObjectValue } from '../model/field_value';\nimport { ArrayValue, BlobValue, BooleanValue, DoubleValue, GeoPointValue, IntegerValue, NullValue, RefValue, StringValue, TimestampValue } from '../model/field_value';\nimport { FieldMask, FieldTransform, PatchMutation, ServerTimestampTransform, SetMutation, TransformMutation } from '../model/mutation';\nimport { FieldPath } from '../model/path';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport { isPlainObject, valueDescription } from '../util/input_validation';\nimport { primitiveComparator } from '../util/misc';\nimport * as objUtils from '../util/obj';\nimport { SortedMap } from '../util/sorted_map';\nimport * as typeUtils from '../util/types';\nimport { Blob } from './blob';\nimport { FieldPath as ExternalFieldPath, fromDotSeparatedString } from './field_path';\nimport { DeleteFieldValueImpl, FieldValueImpl, ServerTimestampFieldValueImpl } from './field_value';\nimport { GeoPoint } from './geo_point';\nvar RESERVED_FIELD_REGEX = /^__.*__$/;\n/** The result of parsing document data (e.g. for a setData call). */\nvar ParsedSetData = /** @class */ (function () {\n    function ParsedSetData(data, fieldMask, fieldTransforms) {\n        this.data = data;\n        this.fieldMask = fieldMask;\n        this.fieldTransforms = fieldTransforms;\n    }\n    ParsedSetData.prototype.toMutations = function (key, precondition) {\n        var mutations = [];\n        if (this.fieldMask !== null) {\n            mutations.push(new PatchMutation(key, this.data, this.fieldMask, precondition));\n        }\n        else {\n            mutations.push(new SetMutation(key, this.data, precondition));\n        }\n        if (this.fieldTransforms.length > 0) {\n            mutations.push(new TransformMutation(key, this.fieldTransforms));\n        }\n        return mutations;\n    };\n    return ParsedSetData;\n}());\nexport { ParsedSetData };\n/** The result of parsing \"update\" data (i.e. for an updateData call). */\nvar ParsedUpdateData = /** @class */ (function () {\n    function ParsedUpdateData(data, fieldMask, fieldTransforms) {\n        this.data = data;\n        this.fieldMask = fieldMask;\n        this.fieldTransforms = fieldTransforms;\n    }\n    ParsedUpdateData.prototype.toMutations = function (key, precondition) {\n        var mutations = [\n            new PatchMutation(key, this.data, this.fieldMask, precondition)\n        ];\n        if (this.fieldTransforms.length > 0) {\n            mutations.push(new TransformMutation(key, this.fieldTransforms));\n        }\n        return mutations;\n    };\n    return ParsedUpdateData;\n}());\nexport { ParsedUpdateData };\n/*\n * Represents what type of API method provided the data being parsed; useful\n * for determining which error conditions apply during parsing and providing\n * better error messages.\n */\nvar UserDataSource;\n(function (UserDataSource) {\n    UserDataSource[UserDataSource[\"Set\"] = 0] = \"Set\";\n    UserDataSource[UserDataSource[\"Update\"] = 1] = \"Update\";\n    UserDataSource[UserDataSource[\"MergeSet\"] = 2] = \"MergeSet\";\n    UserDataSource[UserDataSource[\"QueryValue\"] = 3] = \"QueryValue\"; // from a where clause or cursor bound\n})(UserDataSource || (UserDataSource = {}));\nfunction isWrite(dataSource) {\n    switch (dataSource) {\n        case UserDataSource.Set: // fall through\n        case UserDataSource.MergeSet: // fall through\n        case UserDataSource.Update:\n            return true;\n        case UserDataSource.QueryValue:\n            return false;\n        default:\n            throw fail(\"Unexpected case for UserDataSource: \" + dataSource);\n    }\n}\n/** A \"context\" object passed around while parsing user data. */\nvar ParseContext = /** @class */ (function () {\n    /**\n     * Initializes a ParseContext with the given source and path.\n     *\n     * @param dataSource Indicates what kind of API method this data came from.\n     * @param methodName The name of the method the user called to create this\n     *     ParseContext.\n     * @param path A path within the object being parsed. This could be an empty\n     *     path (in which case the context represents the root of the data being\n     *     parsed), or a nonempty path (indicating the context represents a nested\n     *     location within the data).\n     * @param arrayElement Whether or not this context corresponds to an element\n     *     of an array.\n     * @param fieldTransforms A mutable list of field transforms encountered while\n     *     parsing the data.\n     * @param fieldMask A mutable list of field paths encountered while parsing\n     *     the data.\n     *\n     * TODO(b/34871131): We don't support array paths right now, so path can be\n     * null to indicate the context represents any location within an array (in\n     * which case certain features will not work and errors will be somewhat\n     * compromised).\n     */\n    function ParseContext(dataSource, methodName, path, arrayElement, fieldTransforms, fieldMask) {\n        this.dataSource = dataSource;\n        this.methodName = methodName;\n        this.path = path;\n        this.arrayElement = arrayElement;\n        // Minor hack: If fieldTransforms is undefined, we assume this is an\n        // external call and we need to validate the entire path.\n        if (fieldTransforms === undefined) {\n            this.validatePath();\n        }\n        this.arrayElement = arrayElement !== undefined ? arrayElement : false;\n        this.fieldTransforms = fieldTransforms || [];\n        this.fieldMask = fieldMask || [];\n    }\n    ParseContext.prototype.childContextForField = function (field) {\n        var childPath = this.path == null ? null : this.path.child(field);\n        var context = new ParseContext(this.dataSource, this.methodName, childPath, \n        /*arrayElement=*/ false, this.fieldTransforms, this.fieldMask);\n        context.validatePathSegment(field);\n        return context;\n    };\n    ParseContext.prototype.childContextForFieldPath = function (field) {\n        var childPath = this.path == null ? null : this.path.child(field);\n        var context = new ParseContext(this.dataSource, this.methodName, childPath, \n        /*arrayElement=*/ false, this.fieldTransforms, this.fieldMask);\n        context.validatePath();\n        return context;\n    };\n    ParseContext.prototype.childContextForArray = function (index) {\n        // TODO(b/34871131): We don't support array paths right now; so make path\n        // null.\n        return new ParseContext(this.dataSource, this.methodName, \n        /*path=*/ null, \n        /*arrayElement=*/ true, this.fieldTransforms, this.fieldMask);\n    };\n    ParseContext.prototype.createError = function (reason) {\n        var fieldDescription = this.path === null || this.path.isEmpty()\n            ? ''\n            : \" (found in field \" + this.path.toString() + \")\";\n        return new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + this.methodName + \"() called with invalid data. \" +\n            reason +\n            fieldDescription);\n    };\n    ParseContext.prototype.validatePath = function () {\n        // TODO(b/34871131): Remove null check once we have proper paths for fields\n        // within arrays.\n        if (this.path === null) {\n            return;\n        }\n        for (var i = 0; i < this.path.length; i++) {\n            this.validatePathSegment(this.path.get(i));\n        }\n    };\n    ParseContext.prototype.validatePathSegment = function (segment) {\n        if (isWrite(this.dataSource) && RESERVED_FIELD_REGEX.test(segment)) {\n            throw this.createError('Document fields cannot begin and end with __');\n        }\n    };\n    return ParseContext;\n}());\n/**\n * A placeholder object for DocumentReferences in this file, in order to\n * avoid a circular dependency. See the comments for `DataPreConverter` for\n * the full context.\n */\nvar DocumentKeyReference = /** @class */ (function () {\n    function DocumentKeyReference(databaseId, key) {\n        this.databaseId = databaseId;\n        this.key = key;\n    }\n    return DocumentKeyReference;\n}());\nexport { DocumentKeyReference };\n/**\n * Helper for parsing raw user input (provided via the API) into internal model\n * classes.\n */\nvar UserDataConverter = /** @class */ (function () {\n    function UserDataConverter(preConverter) {\n        this.preConverter = preConverter;\n    }\n    /** Parse document data from a non-merge set() call. */\n    UserDataConverter.prototype.parseSetData = function (methodName, input) {\n        var context = new ParseContext(UserDataSource.Set, methodName, FieldPath.EMPTY_PATH);\n        validatePlainObject('Data must be an object, but it was:', context, input);\n        var updateData = this.parseData(input, context);\n        return new ParsedSetData(updateData, \n        /* fieldMask= */ null, context.fieldTransforms);\n    };\n    /** Parse document data from a set() call with '{merge:true}'. */\n    UserDataConverter.prototype.parseMergeData = function (methodName, input) {\n        var context = new ParseContext(UserDataSource.MergeSet, methodName, FieldPath.EMPTY_PATH);\n        validatePlainObject('Data must be an object, but it was:', context, input);\n        var updateData = this.parseData(input, context);\n        var fieldMask = new FieldMask(context.fieldMask);\n        return new ParsedSetData(updateData, fieldMask, context.fieldTransforms);\n    };\n    /** Parse update data from an update() call. */\n    UserDataConverter.prototype.parseUpdateData = function (methodName, input) {\n        var _this = this;\n        var context = new ParseContext(UserDataSource.Update, methodName, FieldPath.EMPTY_PATH);\n        validatePlainObject('Data must be an object, but it was:', context, input);\n        var fieldMaskPaths = [];\n        var updateData = ObjectValue.EMPTY;\n        objUtils.forEach(input, function (key, value) {\n            var path = fieldPathFromDotSeparatedString(methodName, key);\n            var childContext = context.childContextForFieldPath(path);\n            value = _this.runPreConverter(value, childContext);\n            if (value instanceof DeleteFieldValueImpl) {\n                // Add it to the field mask, but don't add anything to updateData.\n                fieldMaskPaths.push(path);\n            }\n            else {\n                var parsedValue = _this.parseData(value, childContext);\n                if (parsedValue != null) {\n                    fieldMaskPaths.push(path);\n                    updateData = updateData.set(path, parsedValue);\n                }\n            }\n        });\n        var mask = new FieldMask(fieldMaskPaths);\n        return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\n    };\n    /** Parse update data from a list of field/value arguments. */\n    UserDataConverter.prototype.parseUpdateVarargs = function (methodName, field, value, moreFieldsAndValues) {\n        var context = new ParseContext(UserDataSource.Update, methodName, FieldPath.EMPTY_PATH);\n        var keys = [fieldPathFromArgument(methodName, field)];\n        var values = [value];\n        if (moreFieldsAndValues.length % 2 !== 0) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + methodName + \"() needs to be called with an even number \" +\n                'of arguments that alternate between field names and values.');\n        }\n        for (var i = 0; i < moreFieldsAndValues.length; i += 2) {\n            keys.push(fieldPathFromArgument(methodName, moreFieldsAndValues[i]));\n            values.push(moreFieldsAndValues[i + 1]);\n        }\n        var fieldMaskPaths = [];\n        var updateData = ObjectValue.EMPTY;\n        for (var i = 0; i < keys.length; ++i) {\n            var path = keys[i];\n            var childContext = context.childContextForFieldPath(path);\n            var value_1 = this.runPreConverter(values[i], childContext);\n            if (value_1 instanceof DeleteFieldValueImpl) {\n                // Add it to the field mask, but don't add anything to updateData.\n                fieldMaskPaths.push(path);\n            }\n            else {\n                var parsedValue = this.parseData(value_1, childContext);\n                if (parsedValue != null) {\n                    fieldMaskPaths.push(path);\n                    updateData = updateData.set(path, parsedValue);\n                }\n            }\n        }\n        var mask = new FieldMask(fieldMaskPaths);\n        return new ParsedUpdateData(updateData, mask, context.fieldTransforms);\n    };\n    /**\n     * Parse a \"query value\" (e.g. value in a where filter or a value in a cursor\n     * bound).\n     */\n    UserDataConverter.prototype.parseQueryValue = function (methodName, input) {\n        var context = new ParseContext(UserDataSource.QueryValue, methodName, FieldPath.EMPTY_PATH);\n        var parsed = this.parseData(input, context);\n        assert(parsed != null, 'Parsed data should not be null.');\n        assert(context.fieldTransforms.length === 0, 'Field transforms should have been disallowed.');\n        return parsed;\n    };\n    /** Sends data through this.preConverter, handling any thrown errors. */\n    UserDataConverter.prototype.runPreConverter = function (input, context) {\n        try {\n            return this.preConverter(input);\n        }\n        catch (e) {\n            var message = errorMessage(e);\n            throw context.createError(message);\n        }\n    };\n    /**\n     * Internal helper for parsing user data.\n     *\n     * @param input Data to be parsed.\n     * @param context A context object representing the current path being parsed,\n     * the source of the data being parsed, etc.\n     * @return The parsed value, or null if the value was a FieldValue sentinel\n     * that should not be included in the resulting parsed data.\n     */\n    UserDataConverter.prototype.parseData = function (input, context) {\n        input = this.runPreConverter(input, context);\n        if (input instanceof Array) {\n            // TODO(b/34871131): Include the path containing the array in the error\n            // message.\n            if (context.arrayElement) {\n                throw context.createError('Nested arrays are not supported');\n            }\n            // If context.path is null we are already inside an array and we don't\n            // support field mask paths more granular than the top-level array.\n            if (context.path) {\n                context.fieldMask.push(context.path);\n            }\n            return this.parseArray(input, context);\n        }\n        else if (looksLikeJsonObject(input)) {\n            validatePlainObject('Unsupported field value:', context, input);\n            return this.parseObject(input, context);\n        }\n        else {\n            // If context.path is null, we are inside an array and we should have\n            // already added the root of the array to the field mask.\n            if (context.path) {\n                context.fieldMask.push(context.path);\n            }\n            return this.parseScalarValue(input, context);\n        }\n    };\n    UserDataConverter.prototype.parseArray = function (array, context) {\n        var result = [];\n        var entryIndex = 0;\n        for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\n            var entry = array_1[_i];\n            var parsedEntry = this.parseData(entry, context.childContextForArray(entryIndex));\n            if (parsedEntry == null) {\n                // Just include nulls in the array for fields being replaced with a\n                // sentinel.\n                parsedEntry = NullValue.INSTANCE;\n            }\n            result.push(parsedEntry);\n            entryIndex++;\n        }\n        return new ArrayValue(result);\n    };\n    UserDataConverter.prototype.parseObject = function (obj, context) {\n        var _this = this;\n        var result = new SortedMap(primitiveComparator);\n        objUtils.forEach(obj, function (key, val) {\n            var parsedValue = _this.parseData(val, context.childContextForField(key));\n            if (parsedValue != null) {\n                result = result.insert(key, parsedValue);\n            }\n        });\n        return new ObjectValue(result);\n    };\n    /**\n     * Helper to parse a scalar value (i.e. not an Object or Array)\n     *\n     * @return The parsed value, or null if the value was a FieldValue sentinel\n     * that should not be included in the resulting parsed data.\n     */\n    UserDataConverter.prototype.parseScalarValue = function (value, context) {\n        if (value === null) {\n            return NullValue.INSTANCE;\n        }\n        else if (typeof value === 'number') {\n            if (typeUtils.isSafeInteger(value)) {\n                return new IntegerValue(value);\n            }\n            else {\n                return new DoubleValue(value);\n            }\n        }\n        else if (typeof value === 'boolean') {\n            return BooleanValue.of(value);\n        }\n        else if (typeof value === 'string') {\n            return new StringValue(value);\n        }\n        else if (value instanceof Date) {\n            return new TimestampValue(Timestamp.fromDate(value));\n        }\n        else if (value instanceof GeoPoint) {\n            return new GeoPointValue(value);\n        }\n        else if (value instanceof Blob) {\n            return new BlobValue(value);\n        }\n        else if (value instanceof DocumentKeyReference) {\n            return new RefValue(value.databaseId, value.key);\n        }\n        else if (value instanceof FieldValueImpl) {\n            if (value instanceof DeleteFieldValueImpl) {\n                if (context.dataSource === UserDataSource.MergeSet) {\n                    return null;\n                }\n                else if (context.dataSource === UserDataSource.Update) {\n                    assert(context.path == null || context.path.length > 0, 'FieldValue.delete() at the top level should have already' +\n                        ' been handled.');\n                    throw context.createError('FieldValue.delete() can only appear at the top level ' +\n                        'of your update data');\n                }\n                else {\n                    // We shouldn't encounter delete sentinels for queries or non-merge set() calls.\n                    throw context.createError('FieldValue.delete() can only be used with update() and set() with {merge:true}');\n                }\n            }\n            else if (value instanceof ServerTimestampFieldValueImpl) {\n                if (!isWrite(context.dataSource)) {\n                    throw context.createError('FieldValue.serverTimestamp() can only be used with set()' +\n                        ' and update()');\n                }\n                if (context.path === null) {\n                    throw context.createError('FieldValue.serverTimestamp() is not currently' +\n                        ' supported inside arrays');\n                }\n                context.fieldTransforms.push(new FieldTransform(context.path, ServerTimestampTransform.instance));\n                // Return null so this value is omitted from the parsed result.\n                return null;\n            }\n            else {\n                return fail('Unknown FieldValue type: ' + value);\n            }\n        }\n        else {\n            throw context.createError(\"Unsupported field value: \" + valueDescription(value));\n        }\n    };\n    return UserDataConverter;\n}());\nexport { UserDataConverter };\n/**\n * Checks whether an object looks like a JSON object that should be converted\n * into a struct. Normal class/prototype instances are considered to look like\n * JSON objects since they should be converted to a struct value. Arrays, Dates,\n * GeoPoints, etc. are not considered to look like JSON objects since they map\n * to specific FieldValue types other than ObjectValue.\n */\nfunction looksLikeJsonObject(input) {\n    return (typeof input === 'object' &&\n        input !== null &&\n        !(input instanceof Array) &&\n        !(input instanceof Date) &&\n        !(input instanceof GeoPoint) &&\n        !(input instanceof Blob) &&\n        !(input instanceof DocumentKeyReference) &&\n        !(input instanceof FieldValueImpl));\n}\nfunction validatePlainObject(message, context, input) {\n    if (!looksLikeJsonObject(input) || !isPlainObject(input)) {\n        var description = valueDescription(input);\n        if (description === 'an object') {\n            // Massage the error if it was an object.\n            throw context.createError(message + ' a custom object');\n        }\n        else {\n            throw context.createError(message + ' ' + description);\n        }\n    }\n}\n/**\n * Helper that calls fromDotSeparatedString() but wraps any error thrown.\n */\nexport function fieldPathFromArgument(methodName, path) {\n    if (path instanceof ExternalFieldPath) {\n        return path._internalPath;\n    }\n    else if (typeof path === 'string') {\n        return fieldPathFromDotSeparatedString(methodName, path);\n    }\n    else {\n        var message = 'Field path arguments must be of type string or FieldPath.';\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + methodName + \"() called with invalid data. \" + message);\n    }\n}\n/**\n * Wraps fromDotSeparatedString with an error message about the method that\n * was thrown.\n * @param methodName The publicly visible method name\n * @param path The dot-separated string form of a field path which will be split\n * on dots.\n */\nfunction fieldPathFromDotSeparatedString(methodName, path) {\n    try {\n        return fromDotSeparatedString(path)._internalPath;\n    }\n    catch (e) {\n        var message = errorMessage(e);\n        throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function \" + methodName + \"() called with invalid data. \" + message);\n    }\n}\n/**\n * Extracts the message from a caught exception, which should be an Error object\n * though JS doesn't guarantee that.\n */\nfunction errorMessage(error) {\n    return error instanceof Error ? error.message : error.toString();\n}\n\n//# sourceMappingURL=user_data_converter.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/api/user_data_converter.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { FieldPath as ExternalFieldPath } from './field_path';\nimport { DatabaseId, DatabaseInfo } from '../core/database_info';\nimport { FirestoreClient } from '../core/firestore_client';\nimport { Bound, Direction, fieldFilter, OrderBy, Query as InternalQuery, RelationFilter, RelationOp } from '../core/query';\nimport { ChangeType } from '../core/view_snapshot';\nimport { NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { ArrayValue, FieldValueOptions, ObjectValue, RefValue } from '../model/field_value';\nimport { DeleteMutation, Precondition } from '../model/mutation';\nimport { ResourcePath } from '../model/path';\nimport { PlatformSupport } from '../platform/platform';\nimport { makeConstructorPrivate } from '../util/api';\nimport { assert, fail } from '../util/assert';\nimport { AsyncObserver } from '../util/async_observer';\nimport { AsyncQueue } from '../util/async_queue';\nimport { Code, FirestoreError } from '../util/error';\nimport { invalidClassError, validateArgType, validateAtLeastNumberOfArgs, validateBetweenNumberOfArgs, validateDefined, validateExactNumberOfArgs, validateNamedOptionalType, validateNamedOptionalPropertyEquals, validateNamedType, validateOptionalArgType, validateOptionNames, valueDescription } from '../util/input_validation';\nimport * as log from '../util/log';\nimport { LogLevel } from '../util/log';\nimport { AutoId } from '../util/misc';\nimport * as objUtils from '../util/obj';\nimport { EmptyCredentialsProvider, FirebaseCredentialsProvider, makeCredentialsProvider } from './credentials';\nimport { isPartialObserver } from './observer';\nimport { DocumentKeyReference, fieldPathFromArgument, UserDataConverter } from './user_data_converter';\n// The objects that are a part of this API are exposed to third-parties as\n// compiled javascript so we want to flag our private members with a leading\n// underscore to discourage their use.\n// tslint:disable:strip-private-property-underscore\nvar DEFAULT_HOST = 'firestore.googleapis.com';\nvar DEFAULT_SSL = true;\n/**\n * A concrete type describing all the values that can be applied via a\n * user-supplied firestore.Settings object. This is a separate type so that\n * defaults can be supplied and the value can be checked for equality.\n */\nvar FirestoreSettings = /** @class */ (function () {\n    function FirestoreSettings(settings) {\n        if (settings.host === undefined) {\n            if (settings.ssl !== undefined) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Can't provide ssl option if host option is not set\");\n            }\n            this.host = DEFAULT_HOST;\n            this.ssl = DEFAULT_SSL;\n        }\n        else {\n            validateNamedType('settings', 'string', 'host', settings.host);\n            this.host = settings.host;\n            validateNamedOptionalType('settings', 'boolean', 'ssl', settings.ssl);\n            this.ssl = objUtils.defaulted(settings.ssl, DEFAULT_SSL);\n        }\n        validateOptionNames('settings', settings, ['host', 'ssl', 'credentials']);\n        validateNamedOptionalType('settings', 'object', 'credentials', settings.credentials);\n        this.credentials = settings.credentials;\n    }\n    FirestoreSettings.prototype.isEqual = function (other) {\n        return (this.host === other.host &&\n            this.ssl === other.ssl &&\n            this.credentials === other.credentials);\n    };\n    return FirestoreSettings;\n}());\nvar FirestoreConfig = /** @class */ (function () {\n    function FirestoreConfig() {\n    }\n    return FirestoreConfig;\n}());\n/**\n * The root reference to the database.\n */\nvar Firestore = /** @class */ (function () {\n    function Firestore(databaseIdOrApp) {\n        var _this = this;\n        // Public for use in tests.\n        // TODO(mikelehen): Use modularized initialization instead.\n        this._queue = new AsyncQueue();\n        this.INTERNAL = {\n            delete: function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n                return tslib_1.__generator(this, function (_a) {\n                    if (this._firestoreClient) {\n                        return [2 /*return*/, this._firestoreClient.shutdown()];\n                    }\n                    return [2 /*return*/];\n                });\n            }); }\n        };\n        var config = new FirestoreConfig();\n        if (typeof databaseIdOrApp.options === 'object') {\n            // This is very likely a Firebase app object\n            // TODO(b/34177605): Can we somehow use instanceof?\n            var app = databaseIdOrApp;\n            config.firebaseApp = app;\n            config.databaseId = Firestore.databaseIdFromApp(app);\n            config.persistenceKey = config.firebaseApp.name;\n            config.credentials = new FirebaseCredentialsProvider(app);\n        }\n        else {\n            var external_1 = databaseIdOrApp;\n            if (!external_1.projectId) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide projectId');\n            }\n            config.databaseId = new DatabaseId(external_1.projectId, external_1.database);\n            // Use a default persistenceKey that lines up with FirebaseApp.\n            config.persistenceKey = '[DEFAULT]';\n            config.credentials = new EmptyCredentialsProvider();\n        }\n        config.settings = new FirestoreSettings({});\n        this._config = config;\n        this._databaseId = config.databaseId;\n    }\n    Firestore.prototype.settings = function (settingsLiteral) {\n        validateExactNumberOfArgs('Firestore.settings', arguments, 1);\n        validateArgType('Firestore.settings', 'object', 1, settingsLiteral);\n        if (objUtils.contains(settingsLiteral, 'persistence')) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, '\"persistence\" is now specified with a separate call to ' +\n                'firestore.enablePersistence().');\n        }\n        var newSettings = new FirestoreSettings(settingsLiteral);\n        if (this._firestoreClient && !this._config.settings.isEqual(newSettings)) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and its settings can no longer ' +\n                'be changed. You can only call settings() before calling any other ' +\n                'methods on a Firestore object.');\n        }\n        this._config.settings = newSettings;\n        if (newSettings.credentials !== undefined) {\n            this._config.credentials = makeCredentialsProvider(newSettings.credentials);\n        }\n    };\n    Firestore.prototype.enableNetwork = function () {\n        this.ensureClientConfigured();\n        return this._firestoreClient.enableNetwork();\n    };\n    Firestore.prototype.disableNetwork = function () {\n        this.ensureClientConfigured();\n        return this._firestoreClient.disableNetwork();\n    };\n    Firestore.prototype.enablePersistence = function () {\n        if (this._firestoreClient) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and persistence can no longer ' +\n                'be enabled. You can only call enablePersistence() before calling ' +\n                'any other methods on a Firestore object.');\n        }\n        return this.configureClient(/* persistence= */ true);\n    };\n    Firestore.prototype.ensureClientConfigured = function () {\n        if (!this._firestoreClient) {\n            this.configureClient(/* persistence= */ false);\n        }\n        return this._firestoreClient;\n    };\n    Firestore.prototype.configureClient = function (persistence) {\n        var _this = this;\n        assert(!!this._config.settings.host, 'FirestoreSettings.host cannot be falsey');\n        assert(!this._firestoreClient, 'configureClient() called multiple times');\n        var databaseInfo = new DatabaseInfo(this._config.databaseId, this._config.persistenceKey, this._config.settings.host, this._config.settings.ssl);\n        var preConverter = function (value) {\n            if (value instanceof DocumentReference) {\n                var thisDb = _this._config.databaseId;\n                var otherDb = value.firestore._config.databaseId;\n                if (!otherDb.isEqual(thisDb)) {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Document reference is for database ' +\n                        (otherDb.projectId + \"/\" + otherDb.database + \" but should be \") +\n                        (\"for database \" + thisDb.projectId + \"/\" + thisDb.database));\n                }\n                return new DocumentKeyReference(_this._config.databaseId, value._key);\n            }\n            else {\n                return value;\n            }\n        };\n        this._dataConverter = new UserDataConverter(preConverter);\n        this._firestoreClient = new FirestoreClient(PlatformSupport.getPlatform(), databaseInfo, this._config.credentials, this._queue);\n        return this._firestoreClient.start(persistence);\n    };\n    Firestore.databaseIdFromApp = function (app) {\n        var options = app.options;\n        if (!objUtils.contains(options, 'projectId')) {\n            // TODO(b/62673263): We can safely remove the special handling of\n            // 'firestoreId' once alpha testers have upgraded.\n            if (objUtils.contains(options, 'firestoreId')) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, '\"firestoreId\" is now specified as \"projectId\" in ' +\n                    'firebase.initializeApp.');\n            }\n            throw new FirestoreError(Code.INVALID_ARGUMENT, '\"projectId\" not provided in firebase.initializeApp.');\n        }\n        if (objUtils.contains(options, 'firestoreOptions')) {\n            // TODO(b/62673263): We can safely remove the special handling of\n            // 'firestoreOptions' once alpha testers have upgraded.\n            throw new FirestoreError(Code.INVALID_ARGUMENT, '\"firestoreOptions\" values are now specified with ' +\n                'Firestore.settings()');\n        }\n        var projectId = options['projectId'];\n        if (!projectId || typeof projectId !== 'string') {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'projectId must be a string in FirebaseApp.options');\n        }\n        return new DatabaseId(projectId);\n    };\n    Object.defineProperty(Firestore.prototype, \"app\", {\n        get: function () {\n            if (!this._config.firebaseApp) {\n                throw new FirestoreError(Code.FAILED_PRECONDITION, \"Firestore was not initialized using the Firebase SDK. 'app' is \" +\n                    'not available');\n            }\n            return this._config.firebaseApp;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Firestore.prototype.collection = function (pathString) {\n        validateExactNumberOfArgs('Firestore.collection', arguments, 1);\n        validateArgType('Firestore.collection', 'string', 1, pathString);\n        if (!pathString) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty collection path to collection()');\n        }\n        this.ensureClientConfigured();\n        return new CollectionReference(ResourcePath.fromString(pathString), this);\n    };\n    Firestore.prototype.doc = function (pathString) {\n        validateExactNumberOfArgs('Firestore.doc', arguments, 1);\n        validateArgType('Firestore.doc', 'string', 1, pathString);\n        if (!pathString) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty document path to doc()');\n        }\n        this.ensureClientConfigured();\n        return DocumentReference.forPath(ResourcePath.fromString(pathString), this);\n    };\n    Firestore.prototype.runTransaction = function (updateFunction) {\n        var _this = this;\n        validateExactNumberOfArgs('Firestore.runTransaction', arguments, 1);\n        validateArgType('Firestore.runTransaction', 'function', 1, updateFunction);\n        return this.ensureClientConfigured().transaction(function (transaction) {\n            return updateFunction(new Transaction(_this, transaction));\n        });\n    };\n    Firestore.prototype.batch = function () {\n        this.ensureClientConfigured();\n        return new WriteBatch(this);\n    };\n    Object.defineProperty(Firestore, \"logLevel\", {\n        get: function () {\n            switch (log.getLogLevel()) {\n                case LogLevel.DEBUG:\n                    return 'debug';\n                case LogLevel.ERROR:\n                    return 'error';\n                case LogLevel.SILENT:\n                    return 'silent';\n                default:\n                    return fail('Unknown log level: ' + log.getLogLevel());\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Firestore.setLogLevel = function (level) {\n        validateExactNumberOfArgs('Firestore.setLogLevel', arguments, 1);\n        validateArgType('Firestore.setLogLevel', 'string', 1, level);\n        switch (level) {\n            case 'debug':\n                log.setLogLevel(log.LogLevel.DEBUG);\n                break;\n            case 'error':\n                log.setLogLevel(log.LogLevel.ERROR);\n                break;\n            case 'silent':\n                log.setLogLevel(log.LogLevel.SILENT);\n                break;\n            default:\n                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid log level: ' + level);\n        }\n    };\n    return Firestore;\n}());\nexport { Firestore };\n/**\n * A reference to a transaction.\n */\nvar Transaction = /** @class */ (function () {\n    function Transaction(_firestore, _transaction) {\n        this._firestore = _firestore;\n        this._transaction = _transaction;\n    }\n    Transaction.prototype.get = function (documentRef) {\n        var _this = this;\n        validateExactNumberOfArgs('Transaction.get', arguments, 1);\n        var ref = validateReference('Transaction.get', documentRef, this._firestore);\n        return this._transaction\n            .lookup([ref._key])\n            .then(function (docs) {\n            if (!docs || docs.length !== 1) {\n                return fail('Mismatch in docs returned from document lookup.');\n            }\n            var doc = docs[0];\n            if (doc instanceof NoDocument) {\n                return new DocumentSnapshot(_this._firestore, ref._key, null, false);\n            }\n            return new DocumentSnapshot(_this._firestore, ref._key, doc, false);\n        });\n    };\n    Transaction.prototype.set = function (documentRef, value, options) {\n        validateBetweenNumberOfArgs('Transaction.set', arguments, 2, 3);\n        var ref = validateReference('Transaction.set', documentRef, this._firestore);\n        options = validateSetOptions('Transaction.set', options);\n        var parsed = options.merge\n            ? this._firestore._dataConverter.parseMergeData('Transaction.set', value)\n            : this._firestore._dataConverter.parseSetData('Transaction.set', value);\n        this._transaction.set(ref._key, parsed);\n        return this;\n    };\n    Transaction.prototype.update = function (documentRef, fieldOrUpdateData, value) {\n        var moreFieldsAndValues = [];\n        for (var _i = 3; _i < arguments.length; _i++) {\n            moreFieldsAndValues[_i - 3] = arguments[_i];\n        }\n        var ref;\n        var parsed;\n        if (typeof fieldOrUpdateData === 'string' ||\n            fieldOrUpdateData instanceof ExternalFieldPath) {\n            validateAtLeastNumberOfArgs('Transaction.update', arguments, 3);\n            ref = validateReference('Transaction.update', documentRef, this._firestore);\n            parsed = this._firestore._dataConverter.parseUpdateVarargs('Transaction.update', fieldOrUpdateData, value, moreFieldsAndValues);\n        }\n        else {\n            validateExactNumberOfArgs('Transaction.update', arguments, 2);\n            ref = validateReference('Transaction.update', documentRef, this._firestore);\n            parsed = this._firestore._dataConverter.parseUpdateData('Transaction.update', fieldOrUpdateData);\n        }\n        this._transaction.update(ref._key, parsed);\n        return this;\n    };\n    Transaction.prototype.delete = function (documentRef) {\n        validateExactNumberOfArgs('Transaction.delete', arguments, 1);\n        var ref = validateReference('Transaction.delete', documentRef, this._firestore);\n        this._transaction.delete(ref._key);\n        return this;\n    };\n    return Transaction;\n}());\nexport { Transaction };\nvar WriteBatch = /** @class */ (function () {\n    function WriteBatch(_firestore) {\n        this._firestore = _firestore;\n        this._mutations = [];\n        this._committed = false;\n    }\n    WriteBatch.prototype.set = function (documentRef, value, options) {\n        validateBetweenNumberOfArgs('WriteBatch.set', arguments, 2, 3);\n        this.verifyNotCommitted();\n        var ref = validateReference('WriteBatch.set', documentRef, this._firestore);\n        options = validateSetOptions('WriteBatch.set', options);\n        var parsed = options.merge\n            ? this._firestore._dataConverter.parseMergeData('WriteBatch.set', value)\n            : this._firestore._dataConverter.parseSetData('WriteBatch.set', value);\n        this._mutations = this._mutations.concat(parsed.toMutations(ref._key, Precondition.NONE));\n        return this;\n    };\n    WriteBatch.prototype.update = function (documentRef, fieldOrUpdateData, value) {\n        var moreFieldsAndValues = [];\n        for (var _i = 3; _i < arguments.length; _i++) {\n            moreFieldsAndValues[_i - 3] = arguments[_i];\n        }\n        this.verifyNotCommitted();\n        var ref;\n        var parsed;\n        if (typeof fieldOrUpdateData === 'string' ||\n            fieldOrUpdateData instanceof ExternalFieldPath) {\n            validateAtLeastNumberOfArgs('WriteBatch.update', arguments, 3);\n            ref = validateReference('WriteBatch.update', documentRef, this._firestore);\n            parsed = this._firestore._dataConverter.parseUpdateVarargs('WriteBatch.update', fieldOrUpdateData, value, moreFieldsAndValues);\n        }\n        else {\n            validateExactNumberOfArgs('WriteBatch.update', arguments, 2);\n            ref = validateReference('WriteBatch.update', documentRef, this._firestore);\n            parsed = this._firestore._dataConverter.parseUpdateData('WriteBatch.update', fieldOrUpdateData);\n        }\n        this._mutations = this._mutations.concat(parsed.toMutations(ref._key, Precondition.exists(true)));\n        return this;\n    };\n    WriteBatch.prototype.delete = function (documentRef) {\n        validateExactNumberOfArgs('WriteBatch.delete', arguments, 1);\n        this.verifyNotCommitted();\n        var ref = validateReference('WriteBatch.delete', documentRef, this._firestore);\n        this._mutations = this._mutations.concat(new DeleteMutation(ref._key, Precondition.NONE));\n        return this;\n    };\n    WriteBatch.prototype.commit = function () {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            return tslib_1.__generator(this, function (_a) {\n                this.verifyNotCommitted();\n                this._committed = true;\n                if (this._mutations.length > 0) {\n                    return [2 /*return*/, this._firestore.ensureClientConfigured().write(this._mutations)];\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    WriteBatch.prototype.verifyNotCommitted = function () {\n        if (this._committed) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'A write batch can no longer be used after commit() ' +\n                'has been called.');\n        }\n    };\n    return WriteBatch;\n}());\nexport { WriteBatch };\n/**\n * A reference to a particular document in a collection in the database.\n */\nvar DocumentReference = /** @class */ (function () {\n    function DocumentReference(_key, firestore) {\n        this._key = _key;\n        this.firestore = firestore;\n        this._firestoreClient = this.firestore.ensureClientConfigured();\n    }\n    DocumentReference.forPath = function (path, firestore) {\n        if (path.length % 2 !== 0) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid document reference. Document ' +\n                'references must have an even number of segments, but ' +\n                (path.canonicalString() + \" has \" + path.length));\n        }\n        return new DocumentReference(new DocumentKey(path), firestore);\n    };\n    Object.defineProperty(DocumentReference.prototype, \"id\", {\n        get: function () {\n            return this._key.path.lastSegment();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentReference.prototype, \"parent\", {\n        get: function () {\n            return new CollectionReference(this._key.path.popLast(), this.firestore);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentReference.prototype, \"path\", {\n        get: function () {\n            return this._key.path.canonicalString();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DocumentReference.prototype.collection = function (pathString) {\n        validateExactNumberOfArgs('DocumentReference.collection', arguments, 1);\n        validateArgType('DocumentReference.collection', 'string', 1, pathString);\n        if (!pathString) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty collection name to collection()');\n        }\n        var path = ResourcePath.fromString(pathString);\n        return new CollectionReference(this._key.path.child(path), this.firestore);\n    };\n    DocumentReference.prototype.isEqual = function (other) {\n        if (!(other instanceof DocumentReference)) {\n            throw invalidClassError('isEqual', 'DocumentReference', 1, other);\n        }\n        return this.firestore === other.firestore && this._key.isEqual(other._key);\n    };\n    DocumentReference.prototype.set = function (value, options) {\n        validateBetweenNumberOfArgs('DocumentReference.set', arguments, 1, 2);\n        options = validateSetOptions('DocumentReference.set', options);\n        var parsed = options.merge\n            ? this.firestore._dataConverter.parseMergeData('DocumentReference.set', value)\n            : this.firestore._dataConverter.parseSetData('DocumentReference.set', value);\n        return this._firestoreClient.write(parsed.toMutations(this._key, Precondition.NONE));\n    };\n    DocumentReference.prototype.update = function (fieldOrUpdateData, value) {\n        var moreFieldsAndValues = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            moreFieldsAndValues[_i - 2] = arguments[_i];\n        }\n        var parsed;\n        if (typeof fieldOrUpdateData === 'string' ||\n            fieldOrUpdateData instanceof ExternalFieldPath) {\n            validateAtLeastNumberOfArgs('DocumentReference.update', arguments, 2);\n            parsed = this.firestore._dataConverter.parseUpdateVarargs('DocumentReference.update', fieldOrUpdateData, value, moreFieldsAndValues);\n        }\n        else {\n            validateExactNumberOfArgs('DocumentReference.update', arguments, 1);\n            parsed = this.firestore._dataConverter.parseUpdateData('DocumentReference.update', fieldOrUpdateData);\n        }\n        return this._firestoreClient.write(parsed.toMutations(this._key, Precondition.exists(true)));\n    };\n    DocumentReference.prototype.delete = function () {\n        validateExactNumberOfArgs('DocumentReference.delete', arguments, 0);\n        return this._firestoreClient.write([\n            new DeleteMutation(this._key, Precondition.NONE)\n        ]);\n    };\n    DocumentReference.prototype.onSnapshot = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        validateBetweenNumberOfArgs('DocumentReference.onSnapshot', arguments, 1, 4);\n        var options = {\n            includeMetadataChanges: false\n        };\n        var observer;\n        var currArg = 0;\n        if (typeof args[currArg] === 'object' &&\n            !isPartialObserver(args[currArg])) {\n            options = args[currArg];\n            validateOptionNames('DocumentReference.onSnapshot', options, [\n                'includeMetadataChanges'\n            ]);\n            validateNamedOptionalType('DocumentReference.onSnapshot', 'boolean', 'includeMetadataChanges', options.includeMetadataChanges);\n            currArg++;\n        }\n        var internalOptions = {\n            includeDocumentMetadataChanges: options.includeMetadataChanges,\n            includeQueryMetadataChanges: options.includeMetadataChanges\n        };\n        if (isPartialObserver(args[currArg])) {\n            observer = args[currArg];\n        }\n        else {\n            validateArgType('DocumentReference.onSnapshot', 'function', currArg, args[currArg]);\n            validateOptionalArgType('DocumentReference.onSnapshot', 'function', currArg + 1, args[currArg + 1]);\n            validateOptionalArgType('DocumentReference.onSnapshot', 'function', currArg + 2, args[currArg + 2]);\n            observer = {\n                next: args[currArg],\n                error: args[currArg + 1],\n                complete: args[currArg + 2]\n            };\n        }\n        return this.onSnapshotInternal(internalOptions, observer);\n    };\n    DocumentReference.prototype.onSnapshotInternal = function (options, observer) {\n        var _this = this;\n        var errHandler = function (err) {\n            console.error('Uncaught Error in onSnapshot:', err);\n        };\n        if (observer.error) {\n            errHandler = observer.error.bind(observer);\n        }\n        var asyncObserver = new AsyncObserver({\n            next: function (snapshot) {\n                if (observer.next) {\n                    assert(snapshot.docs.size <= 1, 'Too many documents returned on a document query');\n                    var doc = snapshot.docs.get(_this._key);\n                    observer.next(new DocumentSnapshot(_this.firestore, _this._key, doc, snapshot.fromCache));\n                }\n            },\n            error: errHandler\n        });\n        var internalListener = this._firestoreClient.listen(InternalQuery.atPath(this._key.path), asyncObserver, options);\n        return function () {\n            asyncObserver.mute();\n            _this._firestoreClient.unlisten(internalListener);\n        };\n    };\n    DocumentReference.prototype.get = function () {\n        var _this = this;\n        validateExactNumberOfArgs('DocumentReference.get', arguments, 0);\n        return new Promise(function (resolve, reject) {\n            var unlisten = _this.onSnapshotInternal({\n                includeQueryMetadataChanges: true,\n                includeDocumentMetadataChanges: true,\n                waitForSyncWhenOnline: true\n            }, {\n                next: function (snap) {\n                    // Remove query first before passing event to user to avoid\n                    // user actions affecting the now stale query.\n                    unlisten();\n                    if (!snap.exists && snap.metadata.fromCache) {\n                        // TODO(dimond): If we're online and the document doesn't\n                        // exist then we resolve with a doc.exists set to false. If\n                        // we're offline however, we reject the Promise in this\n                        // case. Two options: 1) Cache the negative response from\n                        // the server so we can deliver that even when you're\n                        // offline 2) Actually reject the Promise in the online case\n                        // if the document doesn't exist.\n                        reject(new FirestoreError(Code.ABORTED, 'Failed to get document because the client is ' + 'offline.'));\n                    }\n                    else {\n                        resolve(snap);\n                    }\n                },\n                error: reject\n            });\n        });\n    };\n    return DocumentReference;\n}());\nexport { DocumentReference };\nvar SnapshotMetadata = /** @class */ (function () {\n    function SnapshotMetadata(hasPendingWrites, fromCache) {\n        this.hasPendingWrites = hasPendingWrites;\n        this.fromCache = fromCache;\n    }\n    SnapshotMetadata.prototype.isEqual = function (other) {\n        return (this.hasPendingWrites === other.hasPendingWrites &&\n            this.fromCache === other.fromCache);\n    };\n    return SnapshotMetadata;\n}());\nvar DocumentSnapshot = /** @class */ (function () {\n    function DocumentSnapshot(_firestore, _key, _document, _fromCache) {\n        this._firestore = _firestore;\n        this._key = _key;\n        this._document = _document;\n        this._fromCache = _fromCache;\n    }\n    DocumentSnapshot.prototype.data = function (options) {\n        validateBetweenNumberOfArgs('DocumentSnapshot.data', arguments, 0, 1);\n        options = validateSnapshotOptions('DocumentSnapshot.data', options);\n        return !this._document\n            ? undefined\n            : this.convertObject(this._document.data, FieldValueOptions.fromSnapshotOptions(options));\n    };\n    DocumentSnapshot.prototype.get = function (fieldPath, options) {\n        validateBetweenNumberOfArgs('DocumentSnapshot.get', arguments, 1, 2);\n        options = validateSnapshotOptions('DocumentSnapshot.get', options);\n        if (this._document) {\n            var value = this._document.data.field(fieldPathFromArgument('DocumentSnapshot.get', fieldPath));\n            if (value !== undefined) {\n                return this.convertValue(value, FieldValueOptions.fromSnapshotOptions(options));\n            }\n        }\n        return undefined;\n    };\n    Object.defineProperty(DocumentSnapshot.prototype, \"id\", {\n        get: function () {\n            return this._key.path.lastSegment();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentSnapshot.prototype, \"ref\", {\n        get: function () {\n            return new DocumentReference(this._key, this._firestore);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentSnapshot.prototype, \"exists\", {\n        get: function () {\n            return this._document !== null;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DocumentSnapshot.prototype, \"metadata\", {\n        get: function () {\n            return new SnapshotMetadata(this._document !== null && this._document.hasLocalMutations, this._fromCache);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DocumentSnapshot.prototype.isEqual = function (other) {\n        if (!(other instanceof DocumentSnapshot)) {\n            throw invalidClassError('isEqual', 'DocumentSnapshot', 1, other);\n        }\n        return (this._firestore === other._firestore &&\n            this._fromCache === other._fromCache &&\n            this._key.isEqual(other._key) &&\n            (this._document === null\n                ? other._document === null\n                : this._document.isEqual(other._document)));\n    };\n    DocumentSnapshot.prototype.convertObject = function (data, options) {\n        var _this = this;\n        var result = {};\n        data.forEach(function (key, value) {\n            result[key] = _this.convertValue(value, options);\n        });\n        return result;\n    };\n    DocumentSnapshot.prototype.convertValue = function (value, options) {\n        if (value instanceof ObjectValue) {\n            return this.convertObject(value, options);\n        }\n        else if (value instanceof ArrayValue) {\n            return this.convertArray(value, options);\n        }\n        else if (value instanceof RefValue) {\n            var key = value.value(options);\n            var database = this._firestore.ensureClientConfigured().databaseId();\n            if (!value.databaseId.isEqual(database)) {\n                // TODO(b/64130202): Somehow support foreign references.\n                log.error(\"Document \" + this._key.path + \" contains a document \" +\n                    \"reference within a different database (\" +\n                    (value.databaseId.projectId + \"/\" + value.databaseId.database + \") which is not \") +\n                    \"supported. It will be treated as a reference in the current \" +\n                    (\"database (\" + database.projectId + \"/\" + database.database + \") \") +\n                    \"instead.\");\n            }\n            return new DocumentReference(key, this._firestore);\n        }\n        else {\n            return value.value(options);\n        }\n    };\n    DocumentSnapshot.prototype.convertArray = function (data, options) {\n        var _this = this;\n        return data.internalValue.map(function (value) {\n            return _this.convertValue(value, options);\n        });\n    };\n    return DocumentSnapshot;\n}());\nexport { DocumentSnapshot };\nvar QueryDocumentSnapshot = /** @class */ (function (_super) {\n    tslib_1.__extends(QueryDocumentSnapshot, _super);\n    function QueryDocumentSnapshot(firestore, key, document, fromCache) {\n        return _super.call(this, firestore, key, document, fromCache) || this;\n    }\n    QueryDocumentSnapshot.prototype.data = function (options) {\n        var data = _super.prototype.data.call(this, options);\n        assert(typeof data === 'object', 'Document in a QueryDocumentSnapshot should exist');\n        return data;\n    };\n    return QueryDocumentSnapshot;\n}(DocumentSnapshot));\nexport { QueryDocumentSnapshot };\nvar Query = /** @class */ (function () {\n    function Query(_query, firestore) {\n        this._query = _query;\n        this.firestore = firestore;\n    }\n    Query.prototype.where = function (field, opStr, value) {\n        validateExactNumberOfArgs('Query.where', arguments, 3);\n        validateArgType('Query.where', 'string', 2, opStr);\n        validateDefined('Query.where', 3, value);\n        var fieldValue;\n        var fieldPath = fieldPathFromArgument('Query.where', field);\n        if (fieldPath.isKeyField()) {\n            if (typeof value === 'string') {\n                if (value.indexOf('/') !== -1) {\n                    // TODO(dimond): Allow slashes once ancestor queries are supported\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Function Query.where() requires its third parameter to be a ' +\n                        'valid document ID if the first parameter is ' +\n                        'FieldPath.documentId(), but it contains a slash.');\n                }\n                if (value === '') {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Function Query.where() requires its third parameter to be a ' +\n                        'valid document ID if the first parameter is ' +\n                        'FieldPath.documentId(), but it was an empty string.');\n                }\n                var path = this._query.path.child(new ResourcePath([value]));\n                assert(path.length % 2 === 0, 'Path should be a document key');\n                fieldValue = new RefValue(this.firestore._databaseId, new DocumentKey(path));\n            }\n            else if (value instanceof DocumentReference) {\n                var ref = value;\n                fieldValue = new RefValue(this.firestore._databaseId, ref._key);\n            }\n            else {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function Query.where() requires its third parameter to be a \" +\n                    \"string or a DocumentReference if the first parameter is \" +\n                    \"FieldPath.documentId(), but it was: \" +\n                    (valueDescription(value) + \".\"));\n            }\n        }\n        else {\n            fieldValue = this.firestore._dataConverter.parseQueryValue('Query.where', value);\n        }\n        var filter = fieldFilter(fieldPath, RelationOp.fromString(opStr), fieldValue);\n        this.validateNewFilter(filter);\n        return new Query(this._query.addFilter(filter), this.firestore);\n    };\n    Query.prototype.orderBy = function (field, directionStr) {\n        validateBetweenNumberOfArgs('Query.orderBy', arguments, 1, 2);\n        validateOptionalArgType('Query.orderBy', 'string', 2, directionStr);\n        var direction;\n        if (directionStr === undefined || directionStr === 'asc') {\n            direction = Direction.ASCENDING;\n        }\n        else if (directionStr === 'desc') {\n            direction = Direction.DESCENDING;\n        }\n        else {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Function Query.orderBy() has unknown direction '\" + directionStr + \"', \" +\n                \"expected 'asc' or 'desc'.\");\n        }\n        if (this._query.startAt !== null) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call Query.startAt() or ' +\n                'Query.startAfter() before calling Query.orderBy().');\n        }\n        if (this._query.endAt !== null) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call Query.endAt() or ' +\n                'Query.endBefore() before calling Query.orderBy().');\n        }\n        var fieldPath = fieldPathFromArgument('Query.orderBy', field);\n        var orderBy = new OrderBy(fieldPath, direction);\n        this.validateNewOrderBy(orderBy);\n        return new Query(this._query.addOrderBy(orderBy), this.firestore);\n    };\n    Query.prototype.limit = function (n) {\n        validateExactNumberOfArgs('Query.limit', arguments, 1);\n        validateArgType('Query.limit', 'number', 1, n);\n        if (n <= 0) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid Query. Query limit (\" + n + \") is invalid. Limit must be \" +\n                'positive.');\n        }\n        return new Query(this._query.withLimit(n), this.firestore);\n    };\n    Query.prototype.startAt = function (docOrField) {\n        var fields = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            fields[_i - 1] = arguments[_i];\n        }\n        validateAtLeastNumberOfArgs('Query.startAt', arguments, 1);\n        var bound = this.boundFromDocOrFields('Query.startAt', docOrField, fields, \n        /*before=*/ true);\n        return new Query(this._query.withStartAt(bound), this.firestore);\n    };\n    Query.prototype.startAfter = function (docOrField) {\n        var fields = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            fields[_i - 1] = arguments[_i];\n        }\n        validateAtLeastNumberOfArgs('Query.startAfter', arguments, 1);\n        var bound = this.boundFromDocOrFields('Query.startAfter', docOrField, fields, \n        /*before=*/ false);\n        return new Query(this._query.withStartAt(bound), this.firestore);\n    };\n    Query.prototype.endBefore = function (docOrField) {\n        var fields = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            fields[_i - 1] = arguments[_i];\n        }\n        validateAtLeastNumberOfArgs('Query.endBefore', arguments, 1);\n        var bound = this.boundFromDocOrFields('Query.endBefore', docOrField, fields, \n        /*before=*/ true);\n        return new Query(this._query.withEndAt(bound), this.firestore);\n    };\n    Query.prototype.endAt = function (docOrField) {\n        var fields = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            fields[_i - 1] = arguments[_i];\n        }\n        validateAtLeastNumberOfArgs('Query.endAt', arguments, 1);\n        var bound = this.boundFromDocOrFields('Query.endAt', docOrField, fields, \n        /*before=*/ false);\n        return new Query(this._query.withEndAt(bound), this.firestore);\n    };\n    Query.prototype.isEqual = function (other) {\n        if (!(other instanceof Query)) {\n            throw invalidClassError('isEqual', 'Query', 1, other);\n        }\n        return (this.firestore === other.firestore && this._query.isEqual(other._query));\n    };\n    /** Helper function to create a bound from a document or fields */\n    Query.prototype.boundFromDocOrFields = function (methodName, docOrField, fields, before) {\n        validateDefined(methodName, 1, docOrField);\n        if (docOrField instanceof DocumentSnapshot) {\n            if (fields.length > 0) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Too many arguments provided to \" + methodName + \"().\");\n            }\n            var snap = docOrField;\n            if (!snap.exists) {\n                throw new FirestoreError(Code.NOT_FOUND, \"Can't use a DocumentSnapshot that doesn't exist for \" +\n                    (methodName + \"().\"));\n            }\n            return this.boundFromDocument(methodName, snap._document, before);\n        }\n        else {\n            var allFields = [docOrField].concat(fields);\n            return this.boundFromFields(methodName, allFields, before);\n        }\n    };\n    /**\n     * Create a Bound from a query and a document.\n     *\n     * Note that the Bound will always include the key of the document\n     * and so only the provided document will compare equal to the returned\n     * position.\n     *\n     * Will throw if the document does not contain all fields of the order by\n     * of the query.\n     */\n    Query.prototype.boundFromDocument = function (methodName, doc, before) {\n        var components = [];\n        // Because people expect to continue/end a query at the exact document\n        // provided, we need to use the implicit sort order rather than the explicit\n        // sort order, because it's guaranteed to contain the document key. That way\n        // the position becomes unambiguous and the query continues/ends exactly at\n        // the provided document. Without the key (by using the explicit sort\n        // orders), multiple documents could match the position, yielding duplicate\n        // results.\n        for (var _i = 0, _a = this._query.orderBy; _i < _a.length; _i++) {\n            var orderBy = _a[_i];\n            if (orderBy.field.isKeyField()) {\n                components.push(new RefValue(this.firestore._databaseId, doc.key));\n            }\n            else {\n                var value = doc.field(orderBy.field);\n                if (value !== undefined) {\n                    components.push(value);\n                }\n                else {\n                    var field = orderBy.field.canonicalString();\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. You are trying to start or end a query using a \" +\n                        (\"document for which the field '\" + field + \"' (used as the \") +\n                        \"orderBy) does not exist.\");\n                }\n            }\n        }\n        return new Bound(components, before);\n    };\n    /**\n     * Converts a list of field values to a Bound for the given query.\n     */\n    Query.prototype.boundFromFields = function (methodName, values, before) {\n        // Use explicit order by's because it has to match the query the user made\n        var orderBy = this._query.explicitOrderBy;\n        if (values.length > orderBy.length) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Too many arguments provided to \" + methodName + \"(). \" +\n                \"The number of arguments must be less than or equal to the \" +\n                \"number of Query.orderBy() clauses\");\n        }\n        var components = [];\n        for (var i = 0; i < values.length; i++) {\n            var rawValue = values[i];\n            var orderByComponent = orderBy[i];\n            if (orderByComponent.field.isKeyField()) {\n                if (typeof rawValue !== 'string') {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. Expected a string for document ID in \" +\n                        (methodName + \"(), but got a \" + typeof rawValue));\n                }\n                if (rawValue.indexOf('/') !== -1) {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. Document ID '\" + rawValue + \"' contains a slash in \" +\n                        (methodName + \"()\"));\n                }\n                var key = new DocumentKey(this._query.path.child(rawValue));\n                components.push(new RefValue(this.firestore._databaseId, key));\n            }\n            else {\n                var wrapped = this.firestore._dataConverter.parseQueryValue(methodName, rawValue);\n                components.push(wrapped);\n            }\n        }\n        return new Bound(components, before);\n    };\n    Query.prototype.onSnapshot = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        validateBetweenNumberOfArgs('Query.onSnapshot', arguments, 1, 4);\n        var options = {};\n        var observer;\n        var currArg = 0;\n        if (typeof args[currArg] === 'object' &&\n            !isPartialObserver(args[currArg])) {\n            options = args[currArg];\n            validateOptionNames('Query.onSnapshot', options, [\n                'includeQueryMetadataChanges',\n                'includeDocumentMetadataChanges'\n            ]);\n            validateNamedOptionalType('Query.onSnapshot', 'boolean', 'includeDocumentMetadataChanges', options.includeDocumentMetadataChanges);\n            validateNamedOptionalType('Query.onSnapshot', 'boolean', 'includeQueryMetadataChanges', options.includeQueryMetadataChanges);\n            currArg++;\n        }\n        if (isPartialObserver(args[currArg])) {\n            observer = args[currArg];\n        }\n        else {\n            validateArgType('Query.onSnapshot', 'function', currArg, args[currArg]);\n            validateOptionalArgType('Query.onSnapshot', 'function', currArg + 1, args[currArg + 1]);\n            validateOptionalArgType('Query.onSnapshot', 'function', currArg + 2, args[currArg + 2]);\n            observer = {\n                next: args[currArg],\n                error: args[currArg + 1],\n                complete: args[currArg + 2]\n            };\n        }\n        return this.onSnapshotInternal(options, observer);\n    };\n    Query.prototype.onSnapshotInternal = function (options, observer) {\n        var _this = this;\n        var errHandler = function (err) {\n            console.error('Uncaught Error in onSnapshot:', err);\n        };\n        if (observer.error) {\n            errHandler = observer.error.bind(observer);\n        }\n        var asyncObserver = new AsyncObserver({\n            next: function (result) {\n                if (observer.next) {\n                    observer.next(new QuerySnapshot(_this.firestore, _this._query, result));\n                }\n            },\n            error: errHandler\n        });\n        var firestoreClient = this.firestore.ensureClientConfigured();\n        var internalListener = firestoreClient.listen(this._query, asyncObserver, options);\n        return function () {\n            asyncObserver.mute();\n            firestoreClient.unlisten(internalListener);\n        };\n    };\n    Query.prototype.get = function () {\n        var _this = this;\n        validateExactNumberOfArgs('Query.get', arguments, 0);\n        return new Promise(function (resolve, reject) {\n            var unlisten = _this.onSnapshotInternal({\n                includeDocumentMetadataChanges: false,\n                includeQueryMetadataChanges: true,\n                waitForSyncWhenOnline: true\n            }, {\n                next: function (result) {\n                    // Remove query first before passing event to user to avoid\n                    // user actions affecting the now stale query.\n                    unlisten();\n                    resolve(result);\n                },\n                error: reject\n            });\n        });\n    };\n    Query.prototype.validateNewFilter = function (filter) {\n        if (filter instanceof RelationFilter && filter.isInequality()) {\n            var existingField = this._query.getInequalityFilterField();\n            if (existingField !== null && !existingField.isEqual(filter.field)) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. All where filters with an inequality' +\n                    ' (<, <=, >, or >=) must be on the same field. But you have' +\n                    (\" inequality filters on '\" + existingField.toString() + \"'\") +\n                    (\" and '\" + filter.field.toString() + \"'\"));\n            }\n            var firstOrderByField = this._query.getFirstOrderByField();\n            if (firstOrderByField !== null) {\n                this.validateOrderByAndInequalityMatch(filter.field, firstOrderByField);\n            }\n        }\n    };\n    Query.prototype.validateNewOrderBy = function (orderBy) {\n        if (this._query.getFirstOrderByField() === null) {\n            // This is the first order by. It must match any inequality.\n            var inequalityField = this._query.getInequalityFilterField();\n            if (inequalityField !== null) {\n                this.validateOrderByAndInequalityMatch(inequalityField, orderBy.field);\n            }\n        }\n    };\n    Query.prototype.validateOrderByAndInequalityMatch = function (inequality, orderBy) {\n        if (!orderBy.isEqual(inequality)) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid query. You have a where filter with an inequality \" +\n                (\"(<, <=, >, or >=) on field '\" + inequality.toString() + \"' \") +\n                (\"and so you must also use '\" + inequality.toString() + \"' \") +\n                \"as your first Query.orderBy(), but your first Query.orderBy() \" +\n                (\"is on field '\" + orderBy.toString() + \"' instead.\"));\n        }\n    };\n    return Query;\n}());\nexport { Query };\nvar QuerySnapshot = /** @class */ (function () {\n    function QuerySnapshot(_firestore, _originalQuery, _snapshot) {\n        this._firestore = _firestore;\n        this._originalQuery = _originalQuery;\n        this._snapshot = _snapshot;\n        this._cachedChanges = null;\n        this.metadata = new SnapshotMetadata(_snapshot.hasPendingWrites, _snapshot.fromCache);\n    }\n    Object.defineProperty(QuerySnapshot.prototype, \"docs\", {\n        get: function () {\n            var result = [];\n            this.forEach(function (doc) { return result.push(doc); });\n            return result;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(QuerySnapshot.prototype, \"empty\", {\n        get: function () {\n            return this._snapshot.docs.isEmpty();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(QuerySnapshot.prototype, \"size\", {\n        get: function () {\n            return this._snapshot.docs.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    QuerySnapshot.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        validateBetweenNumberOfArgs('QuerySnapshot.forEach', arguments, 1, 2);\n        validateArgType('QuerySnapshot.forEach', 'function', 1, callback);\n        this._snapshot.docs.forEach(function (doc) {\n            callback.call(thisArg, _this.convertToDocumentImpl(doc));\n        });\n    };\n    Object.defineProperty(QuerySnapshot.prototype, \"query\", {\n        get: function () {\n            return new Query(this._originalQuery, this._firestore);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(QuerySnapshot.prototype, \"docChanges\", {\n        get: function () {\n            if (!this._cachedChanges) {\n                this._cachedChanges = changesFromSnapshot(this._firestore, this._snapshot);\n            }\n            return this._cachedChanges;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Check the equality. The call can be very expensive. */\n    QuerySnapshot.prototype.isEqual = function (other) {\n        if (!(other instanceof QuerySnapshot)) {\n            throw invalidClassError('isEqual', 'QuerySnapshot', 1, other);\n        }\n        return (this._firestore === other._firestore &&\n            this._originalQuery.isEqual(other._originalQuery) &&\n            this._snapshot.isEqual(other._snapshot));\n    };\n    QuerySnapshot.prototype.convertToDocumentImpl = function (doc) {\n        return new QueryDocumentSnapshot(this._firestore, doc.key, doc, this.metadata.fromCache);\n    };\n    return QuerySnapshot;\n}());\nexport { QuerySnapshot };\nvar CollectionReference = /** @class */ (function (_super) {\n    tslib_1.__extends(CollectionReference, _super);\n    function CollectionReference(path, firestore) {\n        var _this = _super.call(this, InternalQuery.atPath(path), firestore) || this;\n        if (path.length % 2 !== 1) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid collection reference. Collection ' +\n                'references must have an odd number of segments, but ' +\n                (path.canonicalString() + \" has \" + path.length));\n        }\n        return _this;\n    }\n    Object.defineProperty(CollectionReference.prototype, \"id\", {\n        get: function () {\n            return this._query.path.lastSegment();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CollectionReference.prototype, \"parent\", {\n        get: function () {\n            var parentPath = this._query.path.popLast();\n            if (parentPath.isEmpty()) {\n                return null;\n            }\n            else {\n                return new DocumentReference(new DocumentKey(parentPath), this.firestore);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CollectionReference.prototype, \"path\", {\n        get: function () {\n            return this._query.path.canonicalString();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    CollectionReference.prototype.doc = function (pathString) {\n        validateBetweenNumberOfArgs('CollectionReference.doc', arguments, 0, 1);\n        // We allow omission of 'pathString' but explicitly prohibit passing in both\n        // 'undefined' and 'null'.\n        if (arguments.length === 0) {\n            pathString = AutoId.newId();\n        }\n        validateArgType('CollectionReference.doc', 'string', 1, pathString);\n        if (pathString === '') {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Document path must be a non-empty string');\n        }\n        var path = ResourcePath.fromString(pathString);\n        return DocumentReference.forPath(this._query.path.child(path), this.firestore);\n    };\n    CollectionReference.prototype.add = function (value) {\n        validateExactNumberOfArgs('CollectionReference.add', arguments, 1);\n        validateArgType('CollectionReference.add', 'object', 1, value);\n        var docRef = this.doc();\n        return docRef.set(value).then(function () { return docRef; });\n    };\n    return CollectionReference;\n}(Query));\nexport { CollectionReference };\nfunction validateSetOptions(methodName, options) {\n    if (options === undefined) {\n        return {\n            merge: false\n        };\n    }\n    validateOptionNames(methodName, options, ['merge']);\n    validateNamedOptionalType(methodName, 'boolean', 'merge', options.merge);\n    return options;\n}\nfunction validateSnapshotOptions(methodName, options) {\n    if (options === undefined) {\n        return {};\n    }\n    validateOptionNames(methodName, options, ['serverTimestamps']);\n    validateNamedOptionalPropertyEquals(methodName, 'options', 'serverTimestamps', options.serverTimestamps, ['estimate', 'previous', 'none']);\n    return options;\n}\nfunction validateReference(methodName, documentRef, firestore) {\n    if (!(documentRef instanceof DocumentReference)) {\n        throw invalidClassError(methodName, 'DocumentReference', 1, documentRef);\n    }\n    else if (documentRef.firestore !== firestore) {\n        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Provided document reference is from a different Firestore instance.');\n    }\n    else {\n        return documentRef;\n    }\n}\n/**\n * Calculates the array of firestore.DocumentChange's for a given ViewSnapshot.\n *\n * Exported for testing.\n */\nexport function changesFromSnapshot(firestore, snapshot) {\n    if (snapshot.oldDocs.isEmpty()) {\n        // Special case the first snapshot because index calculation is easy and\n        // fast\n        var lastDoc_1;\n        var index_1 = 0;\n        return snapshot.docChanges.map(function (change) {\n            var doc = new QueryDocumentSnapshot(firestore, change.doc.key, change.doc, snapshot.fromCache);\n            assert(change.type === ChangeType.Added, 'Invalid event type for first snapshot');\n            assert(!lastDoc_1 || snapshot.query.docComparator(lastDoc_1, change.doc) < 0, 'Got added events in wrong order');\n            lastDoc_1 = change.doc;\n            return {\n                type: 'added',\n                doc: doc,\n                oldIndex: -1,\n                newIndex: index_1++\n            };\n        });\n    }\n    else {\n        // A DocumentSet that is updated incrementally as changes are applied to use\n        // to lookup the index of a document.\n        var indexTracker_1 = snapshot.oldDocs;\n        return snapshot.docChanges.map(function (change) {\n            var doc = new QueryDocumentSnapshot(firestore, change.doc.key, change.doc, snapshot.fromCache);\n            var oldIndex = -1;\n            var newIndex = -1;\n            if (change.type !== ChangeType.Added) {\n                oldIndex = indexTracker_1.indexOf(change.doc.key);\n                assert(oldIndex >= 0, 'Index for document not found');\n                indexTracker_1 = indexTracker_1.delete(change.doc.key);\n            }\n            if (change.type !== ChangeType.Removed) {\n                indexTracker_1 = indexTracker_1.add(change.doc);\n                newIndex = indexTracker_1.indexOf(change.doc.key);\n            }\n            return { type: resultChangeType(change.type), doc: doc, oldIndex: oldIndex, newIndex: newIndex };\n        });\n    }\n}\nfunction resultChangeType(type) {\n    switch (type) {\n        case ChangeType.Added:\n            return 'added';\n        case ChangeType.Modified:\n        case ChangeType.Metadata:\n            return 'modified';\n        case ChangeType.Removed:\n            return 'removed';\n        default:\n            return fail('Unknown change type: ' + type);\n    }\n}\n// Export the classes with a private constructor (it will fail if invoked\n// at runtime). Note that this still allows instanceof checks.\n// We're treating the variables as class names, so disable checking for lower\n// case variable names.\n// tslint:disable:variable-name\nexport var PublicFirestore = makeConstructorPrivate(Firestore, 'Use firebase.firestore() instead.');\nexport var PublicTransaction = makeConstructorPrivate(Transaction, 'Use firebase.firestore().runTransaction() instead.');\nexport var PublicWriteBatch = makeConstructorPrivate(WriteBatch, 'Use firebase.firestore().batch() instead.');\nexport var PublicDocumentReference = makeConstructorPrivate(DocumentReference, 'Use firebase.firestore().doc() instead.');\nexport var PublicDocumentSnapshot = makeConstructorPrivate(DocumentSnapshot);\nexport var PublicQueryDocumentSnapshot = makeConstructorPrivate(QueryDocumentSnapshot);\nexport var PublicQuery = makeConstructorPrivate(Query);\nexport var PublicQuerySnapshot = makeConstructorPrivate(QuerySnapshot);\nexport var PublicCollectionReference = makeConstructorPrivate(CollectionReference, 'Use firebase.firestore().collection() instead.');\n// tslint:enable:variable-name\n\n//# sourceMappingURL=database.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/api/database.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { PublicBlob } from '../api/blob';\nimport { Firestore, PublicCollectionReference, PublicDocumentReference, PublicDocumentSnapshot, PublicFirestore, PublicQuery, PublicQueryDocumentSnapshot, PublicQuerySnapshot, PublicTransaction, PublicWriteBatch } from '../api/database';\nimport { FieldPath } from '../api/field_path';\nimport { PublicFieldValue } from '../api/field_value';\nimport { GeoPoint } from '../api/geo_point';\nimport { shallowCopy } from '../util/obj';\nvar firestoreNamespace = {\n    Firestore: PublicFirestore,\n    GeoPoint: GeoPoint,\n    Blob: PublicBlob,\n    Transaction: PublicTransaction,\n    WriteBatch: PublicWriteBatch,\n    DocumentReference: PublicDocumentReference,\n    DocumentSnapshot: PublicDocumentSnapshot,\n    Query: PublicQuery,\n    QueryDocumentSnapshot: PublicQueryDocumentSnapshot,\n    QuerySnapshot: PublicQuerySnapshot,\n    CollectionReference: PublicCollectionReference,\n    FieldPath: FieldPath,\n    FieldValue: PublicFieldValue,\n    setLogLevel: Firestore.setLogLevel\n};\n/**\n * Configures Firestore as part of the Firebase SDK by calling registerService.\n */\nexport function configureForFirebase(firebase) {\n    firebase.INTERNAL.registerService('firestore', function (app) { return new Firestore(app); }, shallowCopy(firestoreNamespace));\n}\n/**\n * Exports the Firestore namespace into the provided `exportObject` object under\n * the key 'firestore'. This is used for wrapped binary that exposes Firestore\n * as a goog module.\n */\nexport function configureForStandalone(exportObject) {\n    var copiedNamespace = shallowCopy(firestoreNamespace);\n    // Unlike the use with Firebase, the standalone allows the use of the\n    // constructor, so export it's internal class\n    copiedNamespace['Firestore'] = Firestore;\n    exportObject['firestore'] = copiedNamespace;\n}\n\n//# sourceMappingURL=config.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/platform/config.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport firebase from '@firebase/app';\nimport './src/platform_browser/browser_init';\nimport { configureForFirebase } from './src/platform/config';\nexport function registerFirestore(instance) {\n    configureForFirebase(instance);\n}\nregisterFirestore(firebase);\n\n//# sourceMappingURL=index.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/index.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport firebase from '@firebase/app';\n/** The semver (www.semver.org) version of the SDK. */\nexport var SDK_VERSION = firebase.SDK_VERSION;\n\n//# sourceMappingURL=version.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/core/version.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\n// TODO(mcg): Change to a string enum once we've upgraded to typescript 2.4.\n//  tslint:disable-next-line:variable-name Intended to look like a TS 2.4 enum\nexport var Code = {\n    // Causes are copied from:\n    // https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\n    /** Not an error; returned on success. */\n    OK: 'ok',\n    /** The operation was cancelled (typically by the caller). */\n    CANCELLED: 'cancelled',\n    /** Unknown error or an error from a different error domain. */\n    UNKNOWN: 'unknown',\n    /**\n     * Client specified an invalid argument. Note that this differs from\n     * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are\n     * problematic regardless of the state of the system (e.g., a malformed file\n     * name).\n     */\n    INVALID_ARGUMENT: 'invalid-argument',\n    /**\n     * Deadline expired before operation could complete. For operations that\n     * change the state of the system, this error may be returned even if the\n     * operation has completed successfully. For example, a successful response\n     * from a server could have been delayed long enough for the deadline to\n     * expire.\n     */\n    DEADLINE_EXCEEDED: 'deadline-exceeded',\n    /** Some requested entity (e.g., file or directory) was not found. */\n    NOT_FOUND: 'not-found',\n    /**\n     * Some entity that we attempted to create (e.g., file or directory) already\n     * exists.\n     */\n    ALREADY_EXISTS: 'already-exists',\n    /**\n     * The caller does not have permission to execute the specified operation.\n     * PERMISSION_DENIED must not be used for rejections caused by exhausting\n     * some resource (use RESOURCE_EXHAUSTED instead for those errors).\n     * PERMISSION_DENIED must not be used if the caller can not be identified\n     * (use UNAUTHENTICATED instead for those errors).\n     */\n    PERMISSION_DENIED: 'permission-denied',\n    /**\n     * The request does not have valid authentication credentials for the\n     * operation.\n     */\n    UNAUTHENTICATED: 'unauthenticated',\n    /**\n     * Some resource has been exhausted, perhaps a per-user quota, or perhaps the\n     * entire file system is out of space.\n     */\n    RESOURCE_EXHAUSTED: 'resource-exhausted',\n    /**\n     * Operation was rejected because the system is not in a state required for\n     * the operation's execution. For example, directory to be deleted may be\n     * non-empty, an rmdir operation is applied to a non-directory, etc.\n     *\n     * A litmus test that may help a service implementor in deciding\n     * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:\n     *  (a) Use UNAVAILABLE if the client can retry just the failing call.\n     *  (b) Use ABORTED if the client should retry at a higher-level\n     *      (e.g., restarting a read-modify-write sequence).\n     *  (c) Use FAILED_PRECONDITION if the client should not retry until\n     *      the system state has been explicitly fixed. E.g., if an \"rmdir\"\n     *      fails because the directory is non-empty, FAILED_PRECONDITION\n     *      should be returned since the client should not retry unless\n     *      they have first fixed up the directory by deleting files from it.\n     *  (d) Use FAILED_PRECONDITION if the client performs conditional\n     *      REST Get/Update/Delete on a resource and the resource on the\n     *      server does not match the condition. E.g., conflicting\n     *      read-modify-write on the same resource.\n     */\n    FAILED_PRECONDITION: 'failed-precondition',\n    /**\n     * The operation was aborted, typically due to a concurrency issue like\n     * sequencer check failures, transaction aborts, etc.\n     *\n     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n     * and UNAVAILABLE.\n     */\n    ABORTED: 'aborted',\n    /**\n     * Operation was attempted past the valid range. E.g., seeking or reading\n     * past end of file.\n     *\n     * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed\n     * if the system state changes. For example, a 32-bit file system will\n     * generate INVALID_ARGUMENT if asked to read at an offset that is not in the\n     * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from\n     * an offset past the current file size.\n     *\n     * There is a fair bit of overlap between FAILED_PRECONDITION and\n     * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)\n     * when it applies so that callers who are iterating through a space can\n     * easily look for an OUT_OF_RANGE error to detect when they are done.\n     */\n    OUT_OF_RANGE: 'out-of-range',\n    /** Operation is not implemented or not supported/enabled in this service. */\n    UNIMPLEMENTED: 'unimplemented',\n    /**\n     * Internal errors. Means some invariants expected by underlying System has\n     * been broken. If you see one of these errors, Something is very broken.\n     */\n    INTERNAL: 'internal',\n    /**\n     * The service is currently unavailable. This is a most likely a transient\n     * condition and may be corrected by retrying with a backoff.\n     *\n     * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n     * and UNAVAILABLE.\n     */\n    UNAVAILABLE: 'unavailable',\n    /** Unrecoverable data loss or corruption. */\n    DATA_LOSS: 'data-loss'\n};\n/**\n * An error class used for Firestore-generated errors. Ideally we should be\n * using FirebaseError, but integrating with it is overly arduous at the moment,\n * so we define our own compatible error class (with a `name` of 'FirebaseError'\n * and compatible `code` and `message` fields.)\n */\nvar FirestoreError = /** @class */ (function (_super) {\n    tslib_1.__extends(FirestoreError, _super);\n    function FirestoreError(code, message) {\n        var _this = _super.call(this, message) || this;\n        _this.code = code;\n        _this.message = message;\n        _this.name = 'FirebaseError';\n        // HACK: We write a toString property directly because Error is not a real\n        // class and so inheritance does not work correctly. We could alternatively\n        // do the same \"back-door inheritance\" trick that FirebaseError does.\n        _this.toString = function () { return _this.name + \": [code=\" + _this.code + \"]: \" + _this.message; };\n        return _this;\n    }\n    return FirestoreError;\n}(Error));\nexport { FirestoreError };\n\n//# sourceMappingURL=error.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/error.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Code, FirestoreError } from '../util/error';\nimport { validateArgType, validateExactNumberOfArgs } from '../util/input_validation';\nimport { primitiveComparator } from '../util/misc';\n/**\n * Immutable class representing a geo point as latitude-longitude pair.\n * This class is directly exposed in the public API, including its constructor.\n */\nvar GeoPoint = /** @class */ (function () {\n    function GeoPoint(latitude, longitude) {\n        validateExactNumberOfArgs('GeoPoint', arguments, 2);\n        validateArgType('GeoPoint', 'number', 1, latitude);\n        validateArgType('GeoPoint', 'number', 2, longitude);\n        if (!isFinite(latitude) || latitude < -90 || latitude > 90) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Latitude must be a number between -90 and 90, but was: ' + latitude);\n        }\n        if (!isFinite(longitude) || longitude < -180 || longitude > 180) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Longitude must be a number between -180 and 180, but was: ' + longitude);\n        }\n        this._lat = latitude;\n        this._long = longitude;\n    }\n    Object.defineProperty(GeoPoint.prototype, \"latitude\", {\n        /**\n         * Returns the latitude of this geo point, a number between -90 and 90.\n         */\n        get: function () {\n            return this._lat;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GeoPoint.prototype, \"longitude\", {\n        /**\n         * Returns the longitude of this geo point, a number between -180 and 180.\n         */\n        get: function () {\n            return this._long;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    GeoPoint.prototype.isEqual = function (other) {\n        return this._lat === other._lat && this._long === other._long;\n    };\n    /**\n     * Actually private to JS consumers of our API, so this function is prefixed\n     * with an underscore.\n     */\n    GeoPoint.prototype._compareTo = function (other) {\n        return (primitiveComparator(this._lat, other._lat) ||\n            primitiveComparator(this._long, other._long));\n    };\n    return GeoPoint;\n}());\nexport { GeoPoint };\n\n//# sourceMappingURL=geo_point.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/api/geo_point.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { primitiveComparator } from '../util/misc';\nvar DatabaseInfo = /** @class */ (function () {\n    /**\n     * Constructs a DatabaseInfo using the provided host, databaseId and\n     * persistenceKey.\n     *\n     * @param databaseId The database to use.\n     * @param persistenceKey A unique identifier for this Firestore's local\n     * storage (used in conjunction with the databaseId).\n     * @param host The Firestore backend host to connect to.\n     * @param ssl Whether to use SSL when connecting.\n     */\n    function DatabaseInfo(databaseId, persistenceKey, host, ssl) {\n        this.databaseId = databaseId;\n        this.persistenceKey = persistenceKey;\n        this.host = host;\n        this.ssl = ssl;\n    }\n    return DatabaseInfo;\n}());\nexport { DatabaseInfo };\n/** The default database name for a project. */\nvar DEFAULT_DATABASE_NAME = '(default)';\n/** Represents the database ID a Firestore client is associated with. */\nvar DatabaseId = /** @class */ (function () {\n    function DatabaseId(projectId, database) {\n        this.projectId = projectId;\n        this.database = database ? database : DEFAULT_DATABASE_NAME;\n    }\n    Object.defineProperty(DatabaseId.prototype, \"isDefaultDatabase\", {\n        get: function () {\n            return this.database === DEFAULT_DATABASE_NAME;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    DatabaseId.prototype.isEqual = function (other) {\n        return (other instanceof DatabaseId &&\n            other.projectId === this.projectId &&\n            other.database === this.database);\n    };\n    DatabaseId.prototype.compareTo = function (other) {\n        return (primitiveComparator(this.projectId, other.projectId) ||\n            primitiveComparator(this.database, other.database));\n    };\n    return DatabaseId;\n}());\nexport { DatabaseId };\n\n//# sourceMappingURL=database_info.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/core/database_info.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nexport var DOCUMENT_KEY_NAME = '__name__';\n/**\n * Path represents an ordered sequence of string segments.\n */\nvar Path = /** @class */ (function () {\n    function Path(segments, offset, length) {\n        this.init(segments, offset, length);\n    }\n    /**\n     * An initialization method that can be called from outside the constructor.\n     * We need this so that we can have a non-static construct method that returns\n     * the polymorphic `this` type.\n     */\n    Path.prototype.init = function (segments, offset, length) {\n        if (offset === undefined) {\n            offset = 0;\n        }\n        else if (offset > segments.length) {\n            fail('offset ' + offset + ' out of range ' + segments.length);\n        }\n        if (length === undefined) {\n            length = segments.length - offset;\n        }\n        else if (length > segments.length - offset) {\n            fail('length ' + length + ' out of range ' + (segments.length - offset));\n        }\n        this.segments = segments;\n        this.offset = offset;\n        this.len = length;\n    };\n    /**\n     * Constructs a new instance of Path using the same concrete type as `this`.\n     * We need this instead of using the normal constructor, because polymorphic\n     * `this` doesn't work on static methods.\n     */\n    Path.prototype.construct = function (segments, offset, length) {\n        var path = Object.create(Object.getPrototypeOf(this));\n        path.init(segments, offset, length);\n        return path;\n    };\n    Object.defineProperty(Path.prototype, \"length\", {\n        get: function () {\n            return this.len;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Path.prototype.isEqual = function (other) {\n        return Path.comparator(this, other) === 0;\n    };\n    Path.prototype.child = function (nameOrPath) {\n        var segments = this.segments.slice(this.offset, this.limit());\n        if (nameOrPath instanceof Path) {\n            nameOrPath.forEach(function (segment) {\n                segments.push(segment);\n            });\n        }\n        else if (typeof nameOrPath === 'string') {\n            segments.push(nameOrPath);\n        }\n        else {\n            fail('Unknown parameter type for Path.child(): ' + nameOrPath);\n        }\n        return this.construct(segments);\n    };\n    /** The index of one past the last segment of the path. */\n    Path.prototype.limit = function () {\n        return this.offset + this.length;\n    };\n    Path.prototype.popFirst = function (size) {\n        size = size === undefined ? 1 : size;\n        assert(this.length >= size, \"Can't call popFirst() with less segments\");\n        return this.construct(this.segments, this.offset + size, this.length - size);\n    };\n    Path.prototype.popLast = function () {\n        assert(!this.isEmpty(), \"Can't call popLast() on empty path\");\n        return this.construct(this.segments, this.offset, this.length - 1);\n    };\n    Path.prototype.firstSegment = function () {\n        assert(!this.isEmpty(), \"Can't call firstSegment() on empty path\");\n        return this.segments[this.offset];\n    };\n    Path.prototype.lastSegment = function () {\n        assert(!this.isEmpty(), \"Can't call lastSegment() on empty path\");\n        return this.segments[this.limit() - 1];\n    };\n    Path.prototype.get = function (index) {\n        assert(index < this.length, 'Index out of range');\n        return this.segments[this.offset + index];\n    };\n    Path.prototype.isEmpty = function () {\n        return this.length === 0;\n    };\n    Path.prototype.isPrefixOf = function (other) {\n        if (other.length < this.length) {\n            return false;\n        }\n        for (var i = 0; i < this.length; i++) {\n            if (this.get(i) !== other.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    Path.prototype.forEach = function (fn) {\n        for (var i = this.offset, end = this.limit(); i < end; i++) {\n            fn(this.segments[i]);\n        }\n    };\n    Path.prototype.toArray = function () {\n        return this.segments.slice(this.offset, this.limit());\n    };\n    Path.comparator = function (p1, p2) {\n        var len = Math.min(p1.length, p2.length);\n        for (var i = 0; i < len; i++) {\n            var left = p1.get(i);\n            var right = p2.get(i);\n            if (left < right)\n                return -1;\n            if (left > right)\n                return 1;\n        }\n        if (p1.length < p2.length)\n            return -1;\n        if (p1.length > p2.length)\n            return 1;\n        return 0;\n    };\n    return Path;\n}());\nexport { Path };\n/**\n * A slash-separated path for navigating resources (documents and collections)\n * within Firestore.\n */\nvar ResourcePath = /** @class */ (function (_super) {\n    tslib_1.__extends(ResourcePath, _super);\n    function ResourcePath() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ResourcePath.prototype.canonicalString = function () {\n        // NOTE: The client is ignorant of any path segments containing escape\n        // sequences (e.g. __id123__) and just passes them through raw (they exist\n        // for legacy reasons and should not be used frequently).\n        return this.toArray().join('/');\n    };\n    ResourcePath.prototype.toString = function () {\n        return this.canonicalString();\n    };\n    /**\n     * Creates a resource path from the given slash-delimited string.\n     */\n    ResourcePath.fromString = function (path) {\n        // NOTE: The client is ignorant of any path segments containing escape\n        // sequences (e.g. __id123__) and just passes them through raw (they exist\n        // for legacy reasons and should not be used frequently).\n        if (path.indexOf('//') >= 0) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid path (\" + path + \"). Paths must not contain // in them.\");\n        }\n        // We may still have an empty segment at the beginning or end if they had a\n        // leading or trailing slash (which we allow).\n        var segments = path.split('/').filter(function (segment) { return segment.length > 0; });\n        return new ResourcePath(segments);\n    };\n    ResourcePath.EMPTY_PATH = new ResourcePath([]);\n    return ResourcePath;\n}(Path));\nexport { ResourcePath };\nvar identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;\n/** A dot-separated path for navigating sub-objects within a document. */\nvar FieldPath = /** @class */ (function (_super) {\n    tslib_1.__extends(FieldPath, _super);\n    function FieldPath() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Returns true if the string could be used as a segment in a field path\n     * without escaping.\n     */\n    FieldPath.isValidIdentifier = function (segment) {\n        return identifierRegExp.test(segment);\n    };\n    FieldPath.prototype.canonicalString = function () {\n        return this.toArray()\n            .map(function (str) {\n            str = str.replace('\\\\', '\\\\\\\\').replace('`', '\\\\`');\n            if (!FieldPath.isValidIdentifier(str)) {\n                str = '`' + str + '`';\n            }\n            return str;\n        })\n            .join('.');\n    };\n    FieldPath.prototype.toString = function () {\n        return this.canonicalString();\n    };\n    /**\n     * Returns true if this field references the key of a document.\n     */\n    FieldPath.prototype.isKeyField = function () {\n        return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;\n    };\n    /**\n     * The field designating the key of a document.\n     */\n    FieldPath.keyField = function () {\n        return new FieldPath([DOCUMENT_KEY_NAME]);\n    };\n    /**\n     * Parses a field string from the given server-formatted string.\n     *\n     * - Splitting the empty string is not allowed (for now at least).\n     * - Empty segments within the string (e.g. if there are two consecutive\n     *   separators) are not allowed.\n     *\n     * TODO(b/37244157): we should make this more strict. Right now, it allows\n     * non-identifier path components, even if they aren't escaped.\n     */\n    FieldPath.fromServerFormat = function (path) {\n        var segments = [];\n        var current = '';\n        var i = 0;\n        var addCurrentSegment = function () {\n            if (current.length === 0) {\n                throw new FirestoreError(Code.INVALID_ARGUMENT, \"Invalid field path (\" + path + \"). Paths must not be empty, begin \" +\n                    \"with '.', end with '.', or contain '..'\");\n            }\n            segments.push(current);\n            current = '';\n        };\n        var inBackticks = false;\n        while (i < path.length) {\n            var c = path[i];\n            if (c === '\\\\') {\n                if (i + 1 === path.length) {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has trailing escape character: ' + path);\n                }\n                var next = path[i + 1];\n                if (!(next === '\\\\' || next === '.' || next === '`')) {\n                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has invalid escape sequence: ' + path);\n                }\n                current += next;\n                i += 2;\n            }\n            else if (c === '`') {\n                inBackticks = !inBackticks;\n                i++;\n            }\n            else if (c === '.' && !inBackticks) {\n                addCurrentSegment();\n                i++;\n            }\n            else {\n                current += c;\n                i++;\n            }\n        }\n        addCurrentSegment();\n        if (inBackticks) {\n            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Unterminated ` in path: ' + path);\n        }\n        return new FieldPath(segments);\n    };\n    FieldPath.EMPTY_PATH = new FieldPath([]);\n    return FieldPath;\n}(Path));\nexport { FieldPath };\n\n//# sourceMappingURL=path.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/model/path.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert';\nimport { ResourcePath } from './path';\nvar DocumentKey = /** @class */ (function () {\n    function DocumentKey(path) {\n        this.path = path;\n        assert(DocumentKey.isDocumentKey(path), 'Invalid DocumentKey with an odd number of segments: ' +\n            path.toArray().join('/'));\n    }\n    DocumentKey.prototype.isEqual = function (other) {\n        return (other !== null && ResourcePath.comparator(this.path, other.path) === 0);\n    };\n    DocumentKey.prototype.toString = function () {\n        return this.path.toString();\n    };\n    DocumentKey.comparator = function (k1, k2) {\n        return ResourcePath.comparator(k1.path, k2.path);\n    };\n    DocumentKey.isDocumentKey = function (path) {\n        return path.length % 2 === 0;\n    };\n    /**\n     * Creates and returns a new document key with the given segments.\n     *\n     * @param path The segments of the path to the document\n     * @return A new instance of DocumentKey\n     */\n    DocumentKey.fromSegments = function (segments) {\n        return new DocumentKey(new ResourcePath(segments.slice()));\n    };\n    /**\n     * Creates and returns a new document key using '/' to split the string into\n     * segments.\n     *\n     * @param path The slash-separated path string to the document\n     * @return A new instance of DocumentKey\n     */\n    DocumentKey.fromPathString = function (path) {\n        return new DocumentKey(ResourcePath.fromString(path));\n    };\n    DocumentKey.EMPTY = new DocumentKey(new ResourcePath([]));\n    return DocumentKey;\n}());\nexport { DocumentKey };\n\n//# sourceMappingURL=document_key.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/model/document_key.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { fail } from '../util/assert';\nimport { DocumentKey } from './document_key';\nvar Document = /** @class */ (function () {\n    function Document(key, version, data, options) {\n        this.key = key;\n        this.version = version;\n        this.data = data;\n        this.hasLocalMutations = options.hasLocalMutations;\n    }\n    Document.prototype.field = function (path) {\n        return this.data.field(path);\n    };\n    Document.prototype.fieldValue = function (path) {\n        var field = this.field(path);\n        return field ? field.value() : undefined;\n    };\n    Document.prototype.value = function () {\n        return this.data.value();\n    };\n    Document.prototype.isEqual = function (other) {\n        return (other instanceof Document &&\n            this.key.isEqual(other.key) &&\n            this.version.isEqual(other.version) &&\n            this.data.isEqual(other.data) &&\n            this.hasLocalMutations === other.hasLocalMutations);\n    };\n    Document.prototype.toString = function () {\n        return (\"Document(\" + this.key + \", \" + this.version + \", \" + this.data.toString() + \", \" +\n            (\"{hasLocalMutations: \" + this.hasLocalMutations + \"})\"));\n    };\n    Document.compareByKey = function (d1, d2) {\n        return DocumentKey.comparator(d1.key, d2.key);\n    };\n    Document.compareByField = function (field, d1, d2) {\n        var v1 = d1.field(field);\n        var v2 = d2.field(field);\n        if (v1 !== undefined && v2 !== undefined) {\n            return v1.compareTo(v2);\n        }\n        else {\n            return fail(\"Trying to compare documents on fields that don't exist\");\n        }\n    };\n    return Document;\n}());\nexport { Document };\n/**\n * A class representing a deleted document.\n * Version is set to 0 if we don't point to any specific time, otherwise it\n * denotes time we know it didn't exist at.\n */\nvar NoDocument = /** @class */ (function () {\n    function NoDocument(key, version) {\n        this.key = key;\n        this.version = version;\n    }\n    NoDocument.prototype.toString = function () {\n        return \"NoDocument(\" + this.key + \", \" + this.version + \")\";\n    };\n    NoDocument.prototype.isEqual = function (other) {\n        return (other &&\n            other.version.isEqual(this.version) &&\n            other.key.isEqual(this.key));\n    };\n    NoDocument.compareByKey = function (d1, d2) {\n        return DocumentKey.comparator(d1.key, d2.key);\n    };\n    return NoDocument;\n}());\nexport { NoDocument };\n\n//# sourceMappingURL=document.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/model/document.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert, fail } from './assert';\n// An immutable sorted map implementation, based on a Left-leaning Red-Black\n// tree.\nvar SortedMap = /** @class */ (function () {\n    function SortedMap(comparator, root) {\n        this.comparator = comparator;\n        this.root = root ? root : LLRBNode.EMPTY;\n    }\n    // Returns a copy of the map, with the specified key/value added or replaced.\n    SortedMap.prototype.insert = function (key, value) {\n        return new SortedMap(this.comparator, this.root\n            .insert(key, value, this.comparator)\n            .copy(null, null, LLRBNode.BLACK, null, null));\n    };\n    // Returns a copy of the map, with the specified key removed.\n    SortedMap.prototype.remove = function (key) {\n        return new SortedMap(this.comparator, this.root\n            .remove(key, this.comparator)\n            .copy(null, null, LLRBNode.BLACK, null, null));\n    };\n    // Returns the value of the node with the given key, or null.\n    SortedMap.prototype.get = function (key) {\n        var node = this.root;\n        while (!node.isEmpty()) {\n            var cmp = this.comparator(key, node.key);\n            if (cmp === 0) {\n                return node.value;\n            }\n            else if (cmp < 0) {\n                node = node.left;\n            }\n            else if (cmp > 0) {\n                node = node.right;\n            }\n        }\n        return null;\n    };\n    // Returns the index of the element in this sorted map, or -1 if it doesn't\n    // exist.\n    SortedMap.prototype.indexOf = function (key) {\n        // Number of nodes that were pruned when descending right\n        var prunedNodes = 0;\n        var node = this.root;\n        while (!node.isEmpty()) {\n            var cmp = this.comparator(key, node.key);\n            if (cmp === 0) {\n                return prunedNodes + node.left.size;\n            }\n            else if (cmp < 0) {\n                node = node.left;\n            }\n            else {\n                // Count all nodes left of the node plus the node itself\n                prunedNodes += node.left.size + 1;\n                node = node.right;\n            }\n        }\n        // Node not found\n        return -1;\n    };\n    SortedMap.prototype.isEmpty = function () {\n        return this.root.isEmpty();\n    };\n    Object.defineProperty(SortedMap.prototype, \"size\", {\n        // Returns the total number of nodes in the map.\n        get: function () {\n            return this.root.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // Returns the minimum key in the map.\n    SortedMap.prototype.minKey = function () {\n        return this.root.minKey();\n    };\n    // Returns the maximum key in the map.\n    SortedMap.prototype.maxKey = function () {\n        return this.root.maxKey();\n    };\n    // Traverses the map in key order and calls the specified action function\n    // for each key/value pair. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    SortedMap.prototype.inorderTraversal = function (action) {\n        return this.root.inorderTraversal(action);\n    };\n    SortedMap.prototype.forEach = function (fn) {\n        this.inorderTraversal(function (k, v) {\n            fn(k, v);\n            return false;\n        });\n    };\n    // Traverses the map in reverse key order and calls the specified action\n    // function for each key/value pair. If action returns true, traversal is\n    // aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    SortedMap.prototype.reverseTraversal = function (action) {\n        return this.root.reverseTraversal(action);\n    };\n    // Returns an iterator over the SortedMap.\n    SortedMap.prototype.getIterator = function () {\n        return new SortedMapIterator(this.root, null, this.comparator, false);\n    };\n    SortedMap.prototype.getIteratorFrom = function (key) {\n        return new SortedMapIterator(this.root, key, this.comparator, false);\n    };\n    SortedMap.prototype.getReverseIterator = function () {\n        return new SortedMapIterator(this.root, null, this.comparator, true);\n    };\n    SortedMap.prototype.getReverseIteratorFrom = function (key) {\n        return new SortedMapIterator(this.root, key, this.comparator, true);\n    };\n    return SortedMap;\n}()); // end SortedMap\nexport { SortedMap };\n// An iterator over an LLRBNode.\nvar SortedMapIterator = /** @class */ (function () {\n    function SortedMapIterator(node, startKey, comparator, isReverse) {\n        this.isReverse = isReverse;\n        this.nodeStack = [];\n        var cmp = 1;\n        while (!node.isEmpty()) {\n            cmp = startKey ? comparator(node.key, startKey) : 1;\n            // flip the comparison if we're going in reverse\n            if (isReverse)\n                cmp *= -1;\n            if (cmp < 0) {\n                // This node is less than our start key. ignore it\n                if (this.isReverse) {\n                    node = node.left;\n                }\n                else {\n                    node = node.right;\n                }\n            }\n            else if (cmp === 0) {\n                // This node is exactly equal to our start key. Push it on the stack,\n                // but stop iterating;\n                this.nodeStack.push(node);\n                break;\n            }\n            else {\n                // This node is greater than our start key, add it to the stack and move\n                // to the next one\n                this.nodeStack.push(node);\n                if (this.isReverse) {\n                    node = node.right;\n                }\n                else {\n                    node = node.left;\n                }\n            }\n        }\n    }\n    SortedMapIterator.prototype.getNext = function () {\n        assert(this.nodeStack.length > 0, 'getNext() called on iterator when hasNext() is false.');\n        var node = this.nodeStack.pop();\n        var result = { key: node.key, value: node.value };\n        if (this.isReverse) {\n            node = node.left;\n            while (!node.isEmpty()) {\n                this.nodeStack.push(node);\n                node = node.right;\n            }\n        }\n        else {\n            node = node.right;\n            while (!node.isEmpty()) {\n                this.nodeStack.push(node);\n                node = node.left;\n            }\n        }\n        return result;\n    };\n    SortedMapIterator.prototype.hasNext = function () {\n        return this.nodeStack.length > 0;\n    };\n    SortedMapIterator.prototype.peek = function () {\n        if (this.nodeStack.length === 0)\n            return null;\n        var node = this.nodeStack[this.nodeStack.length - 1];\n        return { key: node.key, value: node.value };\n    };\n    return SortedMapIterator;\n}()); // end SortedMapIterator\nexport { SortedMapIterator };\n// Represents a node in a Left-leaning Red-Black tree.\nvar LLRBNode = /** @class */ (function () {\n    function LLRBNode(key, value, color, left, right) {\n        this.key = key;\n        this.value = value;\n        this.color = color != null ? color : LLRBNode.RED;\n        this.left = left != null ? left : LLRBNode.EMPTY;\n        this.right = right != null ? right : LLRBNode.EMPTY;\n        this.size = this.left.size + 1 + this.right.size;\n    }\n    // Returns a copy of the current node, optionally replacing pieces of it.\n    LLRBNode.prototype.copy = function (key, value, color, left, right) {\n        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);\n    };\n    LLRBNode.prototype.isEmpty = function () {\n        return false;\n    };\n    // Traverses the tree in key order and calls the specified action function\n    // for each node. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    LLRBNode.prototype.inorderTraversal = function (action) {\n        return (this.left.inorderTraversal(action) ||\n            action(this.key, this.value) ||\n            this.right.inorderTraversal(action));\n    };\n    // Traverses the tree in reverse key order and calls the specified action\n    // function for each node. If action returns true, traversal is aborted.\n    // Returns the first truthy value returned by action, or the last falsey\n    // value returned by action.\n    LLRBNode.prototype.reverseTraversal = function (action) {\n        return (this.right.reverseTraversal(action) ||\n            action(this.key, this.value) ||\n            this.left.reverseTraversal(action));\n    };\n    // Returns the minimum node in the tree.\n    LLRBNode.prototype.min = function () {\n        if (this.left.isEmpty()) {\n            return this;\n        }\n        else {\n            return this.left.min();\n        }\n    };\n    // Returns the maximum key in the tree.\n    LLRBNode.prototype.minKey = function () {\n        return this.min().key;\n    };\n    // Returns the maximum key in the tree.\n    LLRBNode.prototype.maxKey = function () {\n        if (this.right.isEmpty()) {\n            return this.key;\n        }\n        else {\n            return this.right.maxKey();\n        }\n    };\n    // Returns new tree, with the key/value added.\n    LLRBNode.prototype.insert = function (key, value, comparator) {\n        var n = this;\n        var cmp = comparator(key, n.key);\n        if (cmp < 0) {\n            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);\n        }\n        else if (cmp === 0) {\n            n = n.copy(null, value, null, null, null);\n        }\n        else {\n            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));\n        }\n        return n.fixUp();\n    };\n    LLRBNode.prototype.removeMin = function () {\n        if (this.left.isEmpty()) {\n            return LLRBNode.EMPTY;\n        }\n        var n = this;\n        if (!n.left.isRed() && !n.left.left.isRed())\n            n = n.moveRedLeft();\n        n = n.copy(null, null, null, n.left.removeMin(), null);\n        return n.fixUp();\n    };\n    // Returns new tree, with the specified item removed.\n    LLRBNode.prototype.remove = function (key, comparator) {\n        var smallest;\n        var n = this;\n        if (comparator(key, n.key) < 0) {\n            if (!n.left.isEmpty() && !n.left.isRed() && !n.left.left.isRed()) {\n                n = n.moveRedLeft();\n            }\n            n = n.copy(null, null, null, n.left.remove(key, comparator), null);\n        }\n        else {\n            if (n.left.isRed())\n                n = n.rotateRight();\n            if (!n.right.isEmpty() && !n.right.isRed() && !n.right.left.isRed()) {\n                n = n.moveRedRight();\n            }\n            if (comparator(key, n.key) === 0) {\n                if (n.right.isEmpty()) {\n                    return LLRBNode.EMPTY;\n                }\n                else {\n                    smallest = n.right.min();\n                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin());\n                }\n            }\n            n = n.copy(null, null, null, null, n.right.remove(key, comparator));\n        }\n        return n.fixUp();\n    };\n    LLRBNode.prototype.isRed = function () {\n        return this.color;\n    };\n    // Returns new tree after performing any needed rotations.\n    LLRBNode.prototype.fixUp = function () {\n        var n = this;\n        if (n.right.isRed() && !n.left.isRed())\n            n = n.rotateLeft();\n        if (n.left.isRed() && n.left.left.isRed())\n            n = n.rotateRight();\n        if (n.left.isRed() && n.right.isRed())\n            n = n.colorFlip();\n        return n;\n    };\n    LLRBNode.prototype.moveRedLeft = function () {\n        var n = this.colorFlip();\n        if (n.right.left.isRed()) {\n            n = n.copy(null, null, null, null, n.right.rotateRight());\n            n = n.rotateLeft();\n            n = n.colorFlip();\n        }\n        return n;\n    };\n    LLRBNode.prototype.moveRedRight = function () {\n        var n = this.colorFlip();\n        if (n.left.left.isRed()) {\n            n = n.rotateRight();\n            n = n.colorFlip();\n        }\n        return n;\n    };\n    LLRBNode.prototype.rotateLeft = function () {\n        var nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);\n        return this.right.copy(null, null, this.color, nl, null);\n    };\n    LLRBNode.prototype.rotateRight = function () {\n        var nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);\n        return this.left.copy(null, null, this.color, null, nr);\n    };\n    LLRBNode.prototype.colorFlip = function () {\n        var left = this.left.copy(null, null, !this.left.color, null, null);\n        var right = this.right.copy(null, null, !this.right.color, null, null);\n        return this.copy(null, null, !this.color, left, right);\n    };\n    // For testing.\n    LLRBNode.prototype.checkMaxDepth = function () {\n        var blackDepth = this.check();\n        if (Math.pow(2.0, blackDepth) <= this.size + 1) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    // In a balanced RB tree, the black-depth (number of black nodes) from root to\n    // leaves is equal on both sides.  This function verifies that or asserts.\n    LLRBNode.prototype.check = function () {\n        if (this.isRed() && this.left.isRed()) {\n            throw fail('Red node has red child(' + this.key + ',' + this.value + ')');\n        }\n        if (this.right.isRed()) {\n            throw fail('Right child of (' + this.key + ',' + this.value + ') is red');\n        }\n        var blackDepth = this.left.check();\n        if (blackDepth !== this.right.check()) {\n            throw fail('Black depths differ');\n        }\n        else {\n            return blackDepth + (this.isRed() ? 0 : 1);\n        }\n    };\n    // tslint:disable-next-line:no-any Empty node is shared between all LLRB trees.\n    LLRBNode.EMPTY = null;\n    LLRBNode.RED = true;\n    LLRBNode.BLACK = false;\n    return LLRBNode;\n}()); // end LLRBNode\nexport { LLRBNode };\n// Represents an empty node (a leaf node in the Red-Black Tree).\nvar LLRBEmptyNode = /** @class */ (function () {\n    function LLRBEmptyNode() {\n        this.size = 0;\n    }\n    // Returns a copy of the current node.\n    LLRBEmptyNode.prototype.copy = function (key, value, color, left, right) {\n        return this;\n    };\n    // Returns a copy of the tree, with the specified key/value added.\n    LLRBEmptyNode.prototype.insert = function (key, value, comparator) {\n        return new LLRBNode(key, value);\n    };\n    // Returns a copy of the tree, with the specified key removed.\n    LLRBEmptyNode.prototype.remove = function (key, comparator) {\n        return this;\n    };\n    LLRBEmptyNode.prototype.isEmpty = function () {\n        return true;\n    };\n    LLRBEmptyNode.prototype.inorderTraversal = function (action) {\n        return false;\n    };\n    LLRBEmptyNode.prototype.reverseTraversal = function (action) {\n        return false;\n    };\n    LLRBEmptyNode.prototype.minKey = function () {\n        return null;\n    };\n    LLRBEmptyNode.prototype.maxKey = function () {\n        return null;\n    };\n    LLRBEmptyNode.prototype.isRed = function () {\n        return false;\n    };\n    // For testing.\n    LLRBEmptyNode.prototype.checkMaxDepth = function () {\n        return true;\n    };\n    LLRBEmptyNode.prototype.check = function () {\n        return 0;\n    };\n    return LLRBEmptyNode;\n}()); // end LLRBEmptyNode\nexport { LLRBEmptyNode };\nLLRBNode.EMPTY = new LLRBEmptyNode();\n\n//# sourceMappingURL=sorted_map.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/sorted_map.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { emptyByteString } from '../platform/platform';\n/** An enumeration of the different purposes we have for queries. */\nexport var QueryPurpose;\n(function (QueryPurpose) {\n    /** A regular, normal query. */\n    QueryPurpose[QueryPurpose[\"Listen\"] = 0] = \"Listen\";\n    /**\n     * The query was used to refill a query after an existence filter mismatch.\n     */\n    QueryPurpose[QueryPurpose[\"ExistenceFilterMismatch\"] = 1] = \"ExistenceFilterMismatch\";\n    /** The query was used to resolve a limbo document. */\n    QueryPurpose[QueryPurpose[\"LimboResolution\"] = 2] = \"LimboResolution\";\n})(QueryPurpose || (QueryPurpose = {}));\n/**\n * An immutable set of metadata that the local store tracks for each query.\n */\nvar QueryData = /** @class */ (function () {\n    function QueryData(\n    /** The query being listened to. */\n    query, \n    /**\n     * The target ID to which the query corresponds; Assigned by the\n     * LocalStore for user listens and by the SyncEngine for limbo watches.\n     */\n    targetId, \n    /** The purpose of the query. */\n    purpose, \n    /** The latest snapshot version seen for this target. */\n    snapshotVersion, \n    /**\n     * An opaque, server-assigned token that allows watching a query to be\n     * resumed after disconnecting without retransmitting all the data that\n     * matches the query. The resume token essentially identifies a point in\n     * time from which the server should resume sending results.\n     */\n    resumeToken) {\n        if (snapshotVersion === void 0) { snapshotVersion = SnapshotVersion.MIN; }\n        if (resumeToken === void 0) { resumeToken = emptyByteString(); }\n        this.query = query;\n        this.targetId = targetId;\n        this.purpose = purpose;\n        this.snapshotVersion = snapshotVersion;\n        this.resumeToken = resumeToken;\n    }\n    /**\n     * Creates a new query data instance with an updated snapshot version and\n     * resume token.\n     */\n    QueryData.prototype.update = function (updated) {\n        return new QueryData(this.query, this.targetId, this.purpose, updated.snapshotVersion, updated.resumeToken);\n    };\n    QueryData.prototype.isEqual = function (other) {\n        return (this.targetId === other.targetId &&\n            this.purpose === other.purpose &&\n            this.snapshotVersion.isEqual(other.snapshotVersion) &&\n            this.resumeToken === other.resumeToken &&\n            this.query.isEqual(other.query));\n    };\n    return QueryData;\n}());\nexport { QueryData };\n\n//# sourceMappingURL=query_data.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/query_data.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert';\nimport { primitiveComparator } from '../util/misc';\n// A RegExp matching ISO 8601 UTC timestamps with optional fraction.\nvar isoRegExp = new RegExp(/^\\d{4}-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(?:\\.(\\d+))?Z$/);\nvar Timestamp = /** @class */ (function () {\n    function Timestamp(seconds, nanos) {\n        this.seconds = seconds;\n        this.nanos = nanos;\n        assert(nanos >= 0, 'timestamp nanoseconds out of range: ' + nanos);\n        assert(nanos < 1e9, 'timestamp nanoseconds out of range' + nanos);\n        // Midnight at the beginning of 1/1/1 is the earliest Firestore supports.\n        assert(seconds >= -62135596800, 'timestamp seconds out of range: ' + seconds);\n        // This will break in the year 10,000.\n        assert(seconds < 253402300800, 'timestamp seconds out of range' + seconds);\n    }\n    Timestamp.now = function () {\n        return Timestamp.fromEpochMilliseconds(Date.now());\n    };\n    Timestamp.fromDate = function (date) {\n        return Timestamp.fromEpochMilliseconds(date.getTime());\n    };\n    Timestamp.fromEpochMilliseconds = function (milliseconds) {\n        var seconds = Math.floor(milliseconds / 1000);\n        var nanos = (milliseconds - seconds * 1000) * 1e6;\n        return new Timestamp(seconds, nanos);\n    };\n    Timestamp.fromISOString = function (utc) {\n        // The date string can have higher precision (nanos) than the Date class\n        // (millis), so we do some custom parsing here.\n        // Parse the nanos right out of the string.\n        var nanos = 0;\n        var fraction = isoRegExp.exec(utc);\n        assert(!!fraction, 'invalid timestamp: ' + utc);\n        if (fraction[1]) {\n            // Pad the fraction out to 9 digits (nanos).\n            var nanoStr = fraction[1];\n            nanoStr = (nanoStr + '000000000').substr(0, 9);\n            nanos = Number(nanoStr);\n        }\n        // Parse the date to get the seconds.\n        var date = new Date(utc);\n        var seconds = Math.floor(date.getTime() / 1000);\n        return new Timestamp(seconds, nanos);\n    };\n    Timestamp.prototype.toDate = function () {\n        return new Date(this.toEpochMilliseconds());\n    };\n    Timestamp.prototype.toEpochMilliseconds = function () {\n        return this.seconds * 1000 + this.nanos / 1e6;\n    };\n    Timestamp.prototype.compareTo = function (other) {\n        if (this.seconds === other.seconds) {\n            return primitiveComparator(this.nanos, other.nanos);\n        }\n        return primitiveComparator(this.seconds, other.seconds);\n    };\n    Timestamp.prototype.isEqual = function (other) {\n        return other.seconds === this.seconds && other.nanos === this.nanos;\n    };\n    Timestamp.prototype.toString = function () {\n        return 'Timestamp(seconds=' + this.seconds + ', nanos=' + this.nanos + ')';\n    };\n    return Timestamp;\n}());\nexport { Timestamp };\n\n//# sourceMappingURL=timestamp.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/core/timestamp.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Timestamp } from './timestamp';\n/**\n * A version of a document in Firestore. This corresponds to the version\n * timestamp, such as update_time or read_time.\n */\nvar SnapshotVersion = /** @class */ (function () {\n    function SnapshotVersion(timestamp) {\n        this.timestamp = timestamp;\n    }\n    // TODO(b/34176344): Once we no longer need to use the old alpha protos,\n    // delete this constructor and use a timestamp-backed version everywhere.\n    SnapshotVersion.fromMicroseconds = function (value) {\n        var seconds = Math.floor(value / 1e6);\n        var nanos = (value % 1e6) * 1e3;\n        return new SnapshotVersion(new Timestamp(seconds, nanos));\n    };\n    SnapshotVersion.fromTimestamp = function (value) {\n        return new SnapshotVersion(value);\n    };\n    SnapshotVersion.forDeletedDoc = function () {\n        return SnapshotVersion.MIN;\n    };\n    SnapshotVersion.prototype.compareTo = function (other) {\n        return this.timestamp.compareTo(other.timestamp);\n    };\n    SnapshotVersion.prototype.isEqual = function (other) {\n        return this.timestamp.isEqual(other.timestamp);\n    };\n    /** Returns a number representation of the version for use in spec tests. */\n    SnapshotVersion.prototype.toMicroseconds = function () {\n        // Convert to microseconds.\n        return this.timestamp.seconds * 1e6 + this.timestamp.nanos / 1000;\n    };\n    SnapshotVersion.prototype.toString = function () {\n        return 'SnapshotVersion(' + this.timestamp.toString() + ')';\n    };\n    SnapshotVersion.prototype.toTimestamp = function () {\n        return this.timestamp;\n    };\n    SnapshotVersion.MIN = new SnapshotVersion(new Timestamp(0, 0));\n    return SnapshotVersion;\n}());\nexport { SnapshotVersion };\n\n//# sourceMappingURL=snapshot_version.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/core/snapshot_version.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { assert, fail } from '../util/assert';\nimport * as misc from '../util/misc';\nimport { Document, NoDocument } from './document';\nimport { ObjectValue, ServerTimestampValue } from './field_value';\n/**\n * Provides a set of fields that can be used to partially patch a document.\n * FieldMask is used in conjunction with ObjectValue.\n * Examples:\n *   foo - Overwrites foo entirely with the provided value. If foo is not\n *         present in the companion ObjectValue, the field is deleted.\n *   foo.bar - Overwrites only the field bar of the object foo.\n *             If foo is not an object, foo is replaced with an object\n *             containing foo\n */\nvar FieldMask = /** @class */ (function () {\n    function FieldMask(fields) {\n        this.fields = fields;\n        // TODO(dimond): validation of FieldMask\n    }\n    FieldMask.prototype.isEqual = function (other) {\n        return misc.arrayEquals(this.fields, other.fields);\n    };\n    return FieldMask;\n}());\nexport { FieldMask };\n/** Transforms a value into a server-generated timestamp. */\nvar ServerTimestampTransform = /** @class */ (function () {\n    function ServerTimestampTransform() {\n    }\n    ServerTimestampTransform.prototype.isEqual = function (other) {\n        return other instanceof ServerTimestampTransform;\n    };\n    ServerTimestampTransform.instance = new ServerTimestampTransform();\n    return ServerTimestampTransform;\n}());\nexport { ServerTimestampTransform };\n/** A field path and the TransformOperation to perform upon it. */\nvar FieldTransform = /** @class */ (function () {\n    function FieldTransform(field, transform) {\n        this.field = field;\n        this.transform = transform;\n    }\n    FieldTransform.prototype.isEqual = function (other) {\n        return (this.field.isEqual(other.field) && this.transform.isEqual(other.transform));\n    };\n    return FieldTransform;\n}());\nexport { FieldTransform };\n/** The result of successfully applying a mutation to the backend. */\nvar MutationResult = /** @class */ (function () {\n    function MutationResult(\n    /**\n     * The version at which the mutation was committed or null for a delete.\n     */\n    version, \n    /**\n     * The resulting fields returned from the backend after a\n     * TransformMutation has been committed. Contains one FieldValue for each\n     * FieldTransform that was in the mutation.\n     *\n     * Will be null if the mutation was not a TransformMutation.\n     */\n    transformResults) {\n        this.version = version;\n        this.transformResults = transformResults;\n    }\n    return MutationResult;\n}());\nexport { MutationResult };\nexport var MutationType;\n(function (MutationType) {\n    MutationType[MutationType[\"Set\"] = 0] = \"Set\";\n    MutationType[MutationType[\"Patch\"] = 1] = \"Patch\";\n    MutationType[MutationType[\"Transform\"] = 2] = \"Transform\";\n    MutationType[MutationType[\"Delete\"] = 3] = \"Delete\";\n})(MutationType || (MutationType = {}));\n/**\n * Encodes a precondition for a mutation. This follows the model that the\n * backend accepts with the special case of an explicit \"empty\" precondition\n * (meaning no precondition).\n */\nvar Precondition = /** @class */ (function () {\n    function Precondition(updateTime, exists) {\n        this.updateTime = updateTime;\n        this.exists = exists;\n        assert(updateTime === undefined || exists === undefined, 'Precondition can specify \"exists\" or \"updateTime\" but not both');\n    }\n    /** Creates a new Precondition with an exists flag. */\n    Precondition.exists = function (exists) {\n        return new Precondition(undefined, exists);\n    };\n    /** Creates a new Precondition based on a version a document exists at. */\n    Precondition.updateTime = function (version) {\n        return new Precondition(version);\n    };\n    Object.defineProperty(Precondition.prototype, \"isNone\", {\n        /** Returns whether this Precondition is empty. */\n        get: function () {\n            return this.updateTime === undefined && this.exists === undefined;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Returns true if the preconditions is valid for the given document\n     * (or null if no document is available).\n     */\n    Precondition.prototype.isValidFor = function (maybeDoc) {\n        if (this.updateTime !== undefined) {\n            return (maybeDoc instanceof Document &&\n                maybeDoc.version.isEqual(this.updateTime));\n        }\n        else if (this.exists !== undefined) {\n            if (this.exists) {\n                return maybeDoc instanceof Document;\n            }\n            else {\n                return maybeDoc === null || maybeDoc instanceof NoDocument;\n            }\n        }\n        else {\n            assert(this.isNone, 'Precondition should be empty');\n            return true;\n        }\n    };\n    Precondition.prototype.isEqual = function (other) {\n        return (misc.equals(this.updateTime, other.updateTime) &&\n            this.exists === other.exists);\n    };\n    Precondition.NONE = new Precondition();\n    return Precondition;\n}());\nexport { Precondition };\n/**\n * A mutation describes a self-contained change to a document. Mutations can\n * create, replace, delete, and update subsets of documents.\n *\n * Mutations not only act on the value of the document but also it version.\n * In the case of Set, Patch, and Transform mutations we preserve the existing\n * version. In the case of Delete mutations, we reset the version to 0.\n *\n * Here's the expected transition table.\n *\n * MUTATION           APPLIED TO            RESULTS IN\n *\n * SetMutation        Document(v3)          Document(v3)\n * SetMutation        NoDocument(v3)        Document(v0)\n * SetMutation        null                  Document(v0)\n * PatchMutation      Document(v3)          Document(v3)\n * PatchMutation      NoDocument(v3)        NoDocument(v3)\n * PatchMutation      null                  null\n * TransformMutation  Document(v3)          Document(v3)\n * TransformMutation  NoDocument(v3)        NoDocument(v3)\n * TransformMutation  null                  null\n * DeleteMutation     Document(v3)          NoDocument(v0)\n * DeleteMutation     NoDocument(v3)        NoDocument(v0)\n * DeleteMutation     null                  NoDocument(v0)\n *\n * Note that TransformMutations don't create Documents (in the case of being\n * applied to a NoDocument), even though they would on the backend. This is\n * because the client always combines the TransformMutation with a SetMutation\n * or PatchMutation and we only want to apply the transform if the prior\n * mutation resulted in a Document (always true for a SetMutation, but not\n * necessarily for a PatchMutation).\n *\n * ## Subclassing Notes\n *\n * Subclasses of Mutation need to implement applyToRemoteDocument() and\n * applyToLocalView() to implement the actual behavior of applying the mutation\n * to some source document.\n */\nvar Mutation = /** @class */ (function () {\n    function Mutation() {\n    }\n    Mutation.prototype.verifyKeyMatches = function (maybeDoc) {\n        if (maybeDoc != null) {\n            assert(maybeDoc.key.isEqual(this.key), 'Can only apply a mutation to a document with the same key');\n        }\n    };\n    /**\n     * Returns the version from the given document for use as the result of a\n     * mutation. Mutations are defined to return the version of the base document\n     * only if it is an existing document. Deleted and unknown documents have a\n     * post-mutation version of SnapshotVersion.MIN.\n     */\n    Mutation.getPostMutationVersion = function (maybeDoc) {\n        if (maybeDoc instanceof Document) {\n            return maybeDoc.version;\n        }\n        else {\n            return SnapshotVersion.MIN;\n        }\n    };\n    return Mutation;\n}());\nexport { Mutation };\n/**\n * A mutation that creates or replaces the document at the given key with the\n * object value contents.\n */\nvar SetMutation = /** @class */ (function (_super) {\n    tslib_1.__extends(SetMutation, _super);\n    function SetMutation(key, value, precondition) {\n        var _this = _super.call(this) || this;\n        _this.key = key;\n        _this.value = value;\n        _this.precondition = precondition;\n        _this.type = MutationType.Set;\n        return _this;\n    }\n    SetMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {\n        this.verifyKeyMatches(maybeDoc);\n        assert(mutationResult.transformResults == null, 'Transform results received by SetMutation.');\n        // Unlike applyToLocalView, if we're applying a mutation to a remote\n        // document the server has accepted the mutation so the precondition must\n        // have held.\n        var version = Mutation.getPostMutationVersion(maybeDoc);\n        return new Document(this.key, version, this.value, {\n            hasLocalMutations: false\n        });\n    };\n    SetMutation.prototype.applyToLocalView = function (maybeDoc, baseDoc, localWriteTime) {\n        this.verifyKeyMatches(maybeDoc);\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        var version = Mutation.getPostMutationVersion(maybeDoc);\n        return new Document(this.key, version, this.value, {\n            hasLocalMutations: true\n        });\n    };\n    SetMutation.prototype.isEqual = function (other) {\n        return (other instanceof SetMutation &&\n            this.key.isEqual(other.key) &&\n            this.value.isEqual(other.value) &&\n            this.precondition.isEqual(other.precondition));\n    };\n    return SetMutation;\n}(Mutation));\nexport { SetMutation };\n/**\n * A mutation that modifies fields of the document at the given key with the\n * given values. The values are applied through a field mask:\n *\n *  * When a field is in both the mask and the values, the corresponding field\n *    is updated.\n *  * When a field is in neither the mask nor the values, the corresponding\n *    field is unmodified.\n *  * When a field is in the mask but not in the values, the corresponding field\n *    is deleted.\n *  * When a field is not in the mask but is in the values, the values map is\n *    ignored.\n */\nvar PatchMutation = /** @class */ (function (_super) {\n    tslib_1.__extends(PatchMutation, _super);\n    function PatchMutation(key, data, fieldMask, precondition) {\n        var _this = _super.call(this) || this;\n        _this.key = key;\n        _this.data = data;\n        _this.fieldMask = fieldMask;\n        _this.precondition = precondition;\n        _this.type = MutationType.Patch;\n        return _this;\n    }\n    PatchMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {\n        this.verifyKeyMatches(maybeDoc);\n        assert(mutationResult.transformResults == null, 'Transform results received by PatchMutation.');\n        // TODO(mcg): Relax enforcement of this precondition\n        //\n        // We shouldn't actually enforce the precondition since it already passed on\n        // the backend, but we may not have a local version of the document to\n        // patch, so we use the precondition to prevent incorrectly putting a\n        // partial document into our cache.\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        var version = Mutation.getPostMutationVersion(maybeDoc);\n        var newData = this.patchDocument(maybeDoc);\n        return new Document(this.key, version, newData, {\n            hasLocalMutations: false\n        });\n    };\n    PatchMutation.prototype.applyToLocalView = function (maybeDoc, baseDoc, localWriteTime) {\n        this.verifyKeyMatches(maybeDoc);\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        var version = Mutation.getPostMutationVersion(maybeDoc);\n        var newData = this.patchDocument(maybeDoc);\n        return new Document(this.key, version, newData, {\n            hasLocalMutations: true\n        });\n    };\n    PatchMutation.prototype.isEqual = function (other) {\n        return (other instanceof PatchMutation &&\n            this.key.isEqual(other.key) &&\n            this.fieldMask.isEqual(other.fieldMask) &&\n            this.precondition.isEqual(other.precondition));\n    };\n    /**\n     * Patches the data of document if available or creates a new document. Note\n     * that this does not check whether or not the precondition of this patch\n     * holds.\n     */\n    PatchMutation.prototype.patchDocument = function (maybeDoc) {\n        var data;\n        if (maybeDoc instanceof Document) {\n            data = maybeDoc.data;\n        }\n        else {\n            data = ObjectValue.EMPTY;\n        }\n        return this.patchObject(data);\n    };\n    PatchMutation.prototype.patchObject = function (data) {\n        for (var _i = 0, _a = this.fieldMask.fields; _i < _a.length; _i++) {\n            var fieldPath = _a[_i];\n            var newValue = this.data.field(fieldPath);\n            if (newValue !== undefined) {\n                data = data.set(fieldPath, newValue);\n            }\n            else {\n                data = data.delete(fieldPath);\n            }\n        }\n        return data;\n    };\n    return PatchMutation;\n}(Mutation));\nexport { PatchMutation };\n/**\n * A mutation that modifies specific fields of the document with transform\n * operations. Currently the only supported transform is a server timestamp, but\n * IP Address, increment(n), etc. could be supported in the future.\n *\n * It is somewhat similar to a PatchMutation in that it patches specific fields\n * and has no effect when applied to a null or NoDocument (see comment on\n * Mutation for rationale).\n */\nvar TransformMutation = /** @class */ (function (_super) {\n    tslib_1.__extends(TransformMutation, _super);\n    function TransformMutation(key, fieldTransforms) {\n        var _this = _super.call(this) || this;\n        _this.key = key;\n        _this.fieldTransforms = fieldTransforms;\n        _this.type = MutationType.Transform;\n        // NOTE: We set a precondition of exists: true as a safety-check, since we\n        // always combine TransformMutations with a SetMutation or PatchMutation which\n        // (if successful) should end up with an existing document.\n        _this.precondition = Precondition.exists(true);\n        return _this;\n    }\n    TransformMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {\n        this.verifyKeyMatches(maybeDoc);\n        assert(mutationResult.transformResults != null, 'Transform results missing for TransformMutation.');\n        var transformResults = mutationResult.transformResults;\n        // TODO(mcg): Relax enforcement of this precondition\n        //\n        // We shouldn't actually enforce the precondition since it already passed on\n        // the backend, but we may not have a local version of the document to\n        // patch, so we use the precondition to prevent incorrectly putting a\n        // partial document into our cache.\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        var doc = this.requireDocument(maybeDoc);\n        var newData = this.transformObject(doc.data, transformResults);\n        return new Document(this.key, doc.version, newData, {\n            hasLocalMutations: false\n        });\n    };\n    TransformMutation.prototype.applyToLocalView = function (maybeDoc, baseDoc, localWriteTime) {\n        this.verifyKeyMatches(maybeDoc);\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        var doc = this.requireDocument(maybeDoc);\n        var transformResults = this.localTransformResults(localWriteTime, baseDoc);\n        var newData = this.transformObject(doc.data, transformResults);\n        return new Document(this.key, doc.version, newData, {\n            hasLocalMutations: true\n        });\n    };\n    TransformMutation.prototype.isEqual = function (other) {\n        return (other instanceof TransformMutation &&\n            this.key.isEqual(other.key) &&\n            misc.arrayEquals(this.fieldTransforms, other.fieldTransforms) &&\n            this.precondition.isEqual(other.precondition));\n    };\n    /**\n     * Asserts that the given MaybeDocument is actually a Document and verifies\n     * that it matches the key for this mutation. Since we only support\n     * transformations with precondition exists this method is guaranteed to be\n     * safe.\n     */\n    TransformMutation.prototype.requireDocument = function (maybeDoc) {\n        assert(maybeDoc instanceof Document, 'Unknown MaybeDocument type ' + maybeDoc);\n        var doc = maybeDoc;\n        assert(doc.key.isEqual(this.key), 'Can only transform a document with the same key');\n        return doc;\n    };\n    /**\n     * Creates a list of \"transform results\" (a transform result is a field value\n     * representing the result of applying a transform) for use when applying a\n     * TransformMutation locally.\n     *\n     * @param localWriteTime The local time of the transform mutation (used to\n     *     generate ServerTimestampValues).\n     * @param baseDoc The document prior to applying this mutation batch.\n     * @return The transform results list.\n     */\n    TransformMutation.prototype.localTransformResults = function (localWriteTime, baseDoc) {\n        var transformResults = [];\n        for (var _i = 0, _a = this.fieldTransforms; _i < _a.length; _i++) {\n            var fieldTransform = _a[_i];\n            var transform = fieldTransform.transform;\n            if (transform instanceof ServerTimestampTransform) {\n                var previousValue = null;\n                if (baseDoc instanceof Document) {\n                    previousValue = baseDoc.field(fieldTransform.field) || null;\n                }\n                transformResults.push(new ServerTimestampValue(localWriteTime, previousValue));\n            }\n            else {\n                return fail('Encountered unknown transform: ' + transform);\n            }\n        }\n        return transformResults;\n    };\n    TransformMutation.prototype.transformObject = function (data, transformResults) {\n        assert(transformResults.length === this.fieldTransforms.length, 'TransformResults length mismatch.');\n        for (var i = 0; i < this.fieldTransforms.length; i++) {\n            var fieldTransform = this.fieldTransforms[i];\n            var transform = fieldTransform.transform;\n            var fieldPath = fieldTransform.field;\n            if (transform instanceof ServerTimestampTransform) {\n                data = data.set(fieldPath, transformResults[i]);\n            }\n            else {\n                return fail('Encountered unknown transform: ' + transform);\n            }\n        }\n        return data;\n    };\n    return TransformMutation;\n}(Mutation));\nexport { TransformMutation };\n/** A mutation that deletes the document at the given key. */\nvar DeleteMutation = /** @class */ (function (_super) {\n    tslib_1.__extends(DeleteMutation, _super);\n    function DeleteMutation(key, precondition) {\n        var _this = _super.call(this) || this;\n        _this.key = key;\n        _this.precondition = precondition;\n        _this.type = MutationType.Delete;\n        return _this;\n    }\n    DeleteMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {\n        this.verifyKeyMatches(maybeDoc);\n        assert(mutationResult.transformResults == null, 'Transform results received by DeleteMutation.');\n        // Unlike applyToLocalView, if we're applying a mutation to a remote\n        // document the server has accepted the mutation so the precondition must\n        // have held.\n        return new NoDocument(this.key, SnapshotVersion.MIN);\n    };\n    DeleteMutation.prototype.applyToLocalView = function (maybeDoc, baseDoc, localWriteTime) {\n        this.verifyKeyMatches(maybeDoc);\n        if (!this.precondition.isValidFor(maybeDoc)) {\n            return maybeDoc;\n        }\n        if (maybeDoc) {\n            assert(maybeDoc.key.isEqual(this.key), 'Can only apply mutation to document with same key');\n        }\n        return new NoDocument(this.key, SnapshotVersion.forDeletedDoc());\n    };\n    DeleteMutation.prototype.isEqual = function (other) {\n        return (other instanceof DeleteMutation &&\n            this.key.isEqual(other.key) &&\n            this.precondition.isEqual(other.precondition));\n    };\n    return DeleteMutation;\n}(Mutation));\nexport { DeleteMutation };\n\n//# sourceMappingURL=mutation.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/model/mutation.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar ExistenceFilter = /** @class */ (function () {\n    // TODO(b/33078163): just use simplest form of existence filter for now\n    function ExistenceFilter(count) {\n        this.count = count;\n    }\n    ExistenceFilter.prototype.isEqual = function (other) {\n        return other && other.count === this.count;\n    };\n    return ExistenceFilter;\n}());\nexport { ExistenceFilter };\n\n//# sourceMappingURL=existence_filter.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/remote/existence_filter.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SortedMap } from './sorted_map';\n/**\n * SortedSet is an immutable (copy-on-write) collection that holds elements\n * in order specified by the provided comparator.\n *\n * NOTE: if provided comparator returns 0 for two elements, we consider them to\n * be equal!\n */\nvar SortedSet = /** @class */ (function () {\n    function SortedSet(comparator) {\n        this.comparator = comparator;\n        this.data = new SortedMap(this.comparator);\n    }\n    /**\n     * Creates a SortedSet from the keys of the map.\n     * This is currently implemented as an O(n) copy.\n     */\n    SortedSet.fromMapKeys = function (map) {\n        var keys = new SortedSet(map.comparator);\n        map.forEach(function (key) {\n            keys = keys.add(key);\n        });\n        return keys;\n    };\n    SortedSet.prototype.has = function (elem) {\n        return this.data.get(elem) !== null;\n    };\n    SortedSet.prototype.first = function () {\n        return this.data.minKey();\n    };\n    SortedSet.prototype.last = function () {\n        return this.data.maxKey();\n    };\n    Object.defineProperty(SortedSet.prototype, \"size\", {\n        get: function () {\n            return this.data.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SortedSet.prototype.indexOf = function (elem) {\n        return this.data.indexOf(elem);\n    };\n    /** Iterates elements in order defined by \"comparator\" */\n    SortedSet.prototype.forEach = function (cb) {\n        this.data.inorderTraversal(function (k, v) {\n            cb(k);\n            return false;\n        });\n    };\n    /** Iterates over `elem`s such that: range[0] <= elem < range[1]. */\n    SortedSet.prototype.forEachInRange = function (range, cb) {\n        var iter = this.data.getIteratorFrom(range[0]);\n        while (iter.hasNext()) {\n            var elem = iter.getNext();\n            if (this.comparator(elem.key, range[1]) >= 0)\n                return;\n            cb(elem.key);\n        }\n    };\n    /**\n     * Iterates over `elem`s such that: start <= elem until false is returned.\n     */\n    SortedSet.prototype.forEachWhile = function (cb, start) {\n        var iter;\n        if (start !== undefined) {\n            iter = this.data.getIteratorFrom(start);\n        }\n        else {\n            iter = this.data.getIterator();\n        }\n        while (iter.hasNext()) {\n            var elem = iter.getNext();\n            var result = cb(elem.key);\n            if (!result)\n                return;\n        }\n    };\n    /** Finds the least element greater than or equal to `elem`. */\n    SortedSet.prototype.firstAfterOrEqual = function (elem) {\n        var iter = this.data.getIteratorFrom(elem);\n        return iter.hasNext() ? iter.getNext().key : null;\n    };\n    /** Inserts or updates an element */\n    SortedSet.prototype.add = function (elem) {\n        return this.copy(this.data.remove(elem).insert(elem, true));\n    };\n    /** Deletes an element */\n    SortedSet.prototype.delete = function (elem) {\n        if (!this.has(elem))\n            return this;\n        return this.copy(this.data.remove(elem));\n    };\n    SortedSet.prototype.isEmpty = function () {\n        return this.data.isEmpty();\n    };\n    SortedSet.prototype.unionWith = function (other) {\n        var result = this;\n        other.forEach(function (elem) {\n            result = result.add(elem);\n        });\n        return result;\n    };\n    SortedSet.prototype.isEqual = function (other) {\n        if (!(other instanceof SortedSet))\n            return false;\n        if (this.size !== other.size)\n            return false;\n        var thisIt = this.data.getIterator();\n        var otherIt = other.data.getIterator();\n        while (thisIt.hasNext()) {\n            var thisElem = thisIt.getNext().key;\n            var otherElem = otherIt.getNext().key;\n            if (this.comparator(thisElem, otherElem) !== 0)\n                return false;\n        }\n        return true;\n    };\n    SortedSet.prototype.toString = function () {\n        var result = [];\n        this.forEach(function (elem) { return result.push(elem); });\n        return 'SortedSet(' + result.toString() + ')';\n    };\n    SortedSet.prototype.copy = function (data) {\n        var result = new SortedSet(this.comparator);\n        result.data = data;\n        return result;\n    };\n    return SortedSet;\n}());\nexport { SortedSet };\n\n//# sourceMappingURL=sorted_set.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/sorted_set.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { documentKeySet } from '../model/collections';\nimport { emptyByteString } from '../platform/platform';\n/**\n * An event from the RemoteStore. It is split into targetChanges (changes to the\n * state or the set of documents in our watched targets) and documentUpdates\n * (changes to the actual documents).\n */\nvar RemoteEvent = /** @class */ (function () {\n    function RemoteEvent(\n    /**\n     * The snapshot version this event brings us up to, or MIN if not set.\n     */\n    snapshotVersion, \n    /**\n     * A map from target to changes to the target. See TargetChange.\n     */\n    targetChanges, \n    /**\n     * A set of which documents have changed or been deleted, along with the\n     * doc's new values (if not deleted).\n     */\n    documentUpdates) {\n        this.snapshotVersion = snapshotVersion;\n        this.targetChanges = targetChanges;\n        this.documentUpdates = documentUpdates;\n    }\n    RemoteEvent.prototype.addDocumentUpdate = function (doc) {\n        this.documentUpdates = this.documentUpdates.insert(doc.key, doc);\n    };\n    RemoteEvent.prototype.handleExistenceFilterMismatch = function (targetId) {\n        /*\n         * An existence filter mismatch will reset the query and we need to reset\n         * the mapping to contain no documents and an empty resume token.\n         *\n         * Note:\n         *   * The reset mapping is empty, specifically forcing the consumer of the\n         *     change to forget all keys for this targetID;\n         *   * The resume snapshot for this target must be reset\n         *   * The target must be unacked because unwatching and rewatching\n         *     introduces a race for changes.\n         */\n        this.targetChanges[targetId] = {\n            mapping: new ResetMapping(),\n            snapshotVersion: SnapshotVersion.MIN,\n            currentStatusUpdate: CurrentStatusUpdate.MarkNotCurrent,\n            resumeToken: emptyByteString()\n        };\n    };\n    return RemoteEvent;\n}());\nexport { RemoteEvent };\n/**\n * Represents an update to the current status of a target, either explicitly\n * having no new state, or the new value to set. Note \"current\" has special\n * meaning for in the RPC protocol that implies that a target is both up-to-date\n * and consistent with the rest of the watch stream.\n */\nexport var CurrentStatusUpdate;\n(function (CurrentStatusUpdate) {\n    /** The current status is not affected and should not be modified. */\n    CurrentStatusUpdate[CurrentStatusUpdate[\"None\"] = 0] = \"None\";\n    /** The target must be marked as no longer \"current\". */\n    CurrentStatusUpdate[CurrentStatusUpdate[\"MarkNotCurrent\"] = 1] = \"MarkNotCurrent\";\n    /** The target must be marked as \"current\". */\n    CurrentStatusUpdate[CurrentStatusUpdate[\"MarkCurrent\"] = 2] = \"MarkCurrent\";\n})(CurrentStatusUpdate || (CurrentStatusUpdate = {}));\nvar EMPTY_KEY_SET = documentKeySet();\nvar ResetMapping = /** @class */ (function () {\n    function ResetMapping() {\n        this.docs = EMPTY_KEY_SET;\n    }\n    Object.defineProperty(ResetMapping.prototype, \"documents\", {\n        get: function () {\n            return this.docs;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ResetMapping.prototype.add = function (key) {\n        this.docs = this.docs.add(key);\n    };\n    ResetMapping.prototype.delete = function (key) {\n        this.docs = this.docs.delete(key);\n    };\n    ResetMapping.prototype.isEqual = function (other) {\n        return other !== null && this.docs.isEqual(other.docs);\n    };\n    return ResetMapping;\n}());\nexport { ResetMapping };\nvar UpdateMapping = /** @class */ (function () {\n    function UpdateMapping() {\n        this.addedDocuments = EMPTY_KEY_SET;\n        this.removedDocuments = EMPTY_KEY_SET;\n    }\n    UpdateMapping.prototype.applyToKeySet = function (keys) {\n        var result = keys;\n        this.addedDocuments.forEach(function (key) { return (result = result.add(key)); });\n        this.removedDocuments.forEach(function (key) { return (result = result.delete(key)); });\n        return result;\n    };\n    UpdateMapping.prototype.add = function (key) {\n        this.addedDocuments = this.addedDocuments.add(key);\n        this.removedDocuments = this.removedDocuments.delete(key);\n    };\n    UpdateMapping.prototype.delete = function (key) {\n        this.addedDocuments = this.addedDocuments.delete(key);\n        this.removedDocuments = this.removedDocuments.add(key);\n    };\n    UpdateMapping.prototype.isEqual = function (other) {\n        return (other !== null &&\n            this.addedDocuments.isEqual(other.addedDocuments) &&\n            this.removedDocuments.isEqual(other.removedDocuments));\n    };\n    return UpdateMapping;\n}());\nexport { UpdateMapping };\n\n//# sourceMappingURL=remote_event.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/remote/remote_event.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert';\n/**\n * Provides a simple helper class that implements the Stream interface to\n * bridge to other implementations that are streams but do not implement the\n * interface. The stream callbacks are invoked with the callOn... methods.\n */\nvar StreamBridge = /** @class */ (function () {\n    function StreamBridge(args) {\n        this.sendFn = args.sendFn;\n        this.closeFn = args.closeFn;\n    }\n    StreamBridge.prototype.onOpen = function (callback) {\n        assert(!this.wrappedOnOpen, 'Called onOpen on stream twice!');\n        this.wrappedOnOpen = callback;\n    };\n    StreamBridge.prototype.onClose = function (callback) {\n        assert(!this.wrappedOnClose, 'Called onClose on stream twice!');\n        this.wrappedOnClose = callback;\n    };\n    StreamBridge.prototype.onMessage = function (callback) {\n        assert(!this.wrappedOnMessage, 'Called onMessage on stream twice!');\n        this.wrappedOnMessage = callback;\n    };\n    StreamBridge.prototype.close = function () {\n        this.closeFn();\n    };\n    StreamBridge.prototype.send = function (msg) {\n        this.sendFn(msg);\n    };\n    StreamBridge.prototype.callOnOpen = function () {\n        assert(this.wrappedOnOpen !== undefined, 'Cannot call onOpen because no callback was set');\n        this.wrappedOnOpen();\n    };\n    StreamBridge.prototype.callOnClose = function (err) {\n        assert(this.wrappedOnClose !== undefined, 'Cannot call onClose because no callback was set');\n        this.wrappedOnClose(err);\n    };\n    StreamBridge.prototype.callOnMessage = function (msg) {\n        assert(this.wrappedOnMessage !== undefined, 'Cannot call onMessage because no callback was set');\n        this.wrappedOnMessage(msg);\n    };\n    return StreamBridge;\n}());\nexport { StreamBridge };\n\n//# sourceMappingURL=stream_bridge.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/remote/stream_bridge.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ErrorCode, EventType, WebChannel, XhrIoPool, createWebChannelTransport } from '@firebase/webchannel-wrapper';\nimport { SDK_VERSION } from '../core/version';\nimport { mapCodeFromHttpStatus, mapCodeFromRpcStatus } from '../remote/rpc_error';\nimport { StreamBridge } from '../remote/stream_bridge';\nimport { assert, fail } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport * as log from '../util/log';\nvar LOG_TAG = 'Connection';\nvar RPC_STREAM_SERVICE = 'google.firestore.v1beta1.Firestore';\nvar RPC_URL_VERSION = 'v1beta1';\n/** Maps RPC names to the corresponding REST endpoint name. */\nvar RPC_NAME_REST_MAPPING = {\n    BatchGetDocuments: 'batchGet',\n    Commit: 'commit'\n};\n// TODO(b/38203344): The SDK_VERSION is set independently from Firebase because\n// we are doing out-of-band releases. Once we release as part of Firebase, we\n// should use the Firebase version instead.\nvar X_GOOG_API_CLIENT_VALUE = 'gl-js/ fire/' + SDK_VERSION;\nvar XHR_TIMEOUT_SECS = 15;\nvar WebChannelConnection = /** @class */ (function () {\n    function WebChannelConnection(info) {\n        this.databaseId = info.databaseId;\n        this.pool = new XhrIoPool();\n        var proto = info.ssl ? 'https' : 'http';\n        this.baseUrl = proto + '://' + info.host;\n    }\n    /**\n     * Modifies the headers for a request, adding any authorization token if\n     * present and any additional headers for the request.\n     */\n    WebChannelConnection.prototype.modifyHeadersForRequest = function (headers, token) {\n        if (token) {\n            for (var header in token.authHeaders) {\n                if (token.authHeaders.hasOwnProperty(header)) {\n                    headers[header] = token.authHeaders[header];\n                }\n            }\n        }\n        headers['X-Goog-Api-Client'] = X_GOOG_API_CLIENT_VALUE;\n    };\n    WebChannelConnection.prototype.invokeRPC = function (rpcName, request, token) {\n        var _this = this;\n        var url = this.makeUrl(rpcName);\n        return new Promise(function (resolve, reject) {\n            // tslint:disable-next-line:no-any XhrIoPool doesn't have TS typings.\n            _this.pool.getObject(function (xhr) {\n                xhr.listenOnce(EventType.COMPLETE, function () {\n                    try {\n                        switch (xhr.getLastErrorCode()) {\n                            case ErrorCode.NO_ERROR:\n                                var json = xhr.getResponseJson();\n                                log.debug(LOG_TAG, 'XHR received:', JSON.stringify(json));\n                                resolve(json);\n                                break;\n                            case ErrorCode.TIMEOUT:\n                                log.debug(LOG_TAG, 'RPC \"' + rpcName + '\" timed out');\n                                reject(new FirestoreError(Code.DEADLINE_EXCEEDED, 'Request time out'));\n                                break;\n                            case ErrorCode.HTTP_ERROR:\n                                var status_1 = xhr.getStatus();\n                                log.debug(LOG_TAG, 'RPC \"' + rpcName + '\" failed with status:', status_1, 'response text:', xhr.getResponseText());\n                                if (status_1 > 0) {\n                                    reject(new FirestoreError(mapCodeFromHttpStatus(status_1), 'Server responded with status ' + xhr.getStatusText()));\n                                }\n                                else {\n                                    // If we received an HTTP_ERROR but there's no status code,\n                                    // it's most probably a connection issue\n                                    log.debug(LOG_TAG, 'RPC \"' + rpcName + '\" failed');\n                                    reject(new FirestoreError(Code.UNAVAILABLE, 'Connection failed.'));\n                                }\n                                break;\n                            default:\n                                fail('RPC \"' +\n                                    rpcName +\n                                    '\" failed with unanticipated ' +\n                                    'webchannel error ' +\n                                    xhr.getLastErrorCode() +\n                                    ': ' +\n                                    xhr.getLastError() +\n                                    ', giving up.');\n                        }\n                    }\n                    finally {\n                        log.debug(LOG_TAG, 'RPC \"' + rpcName + '\" completed.');\n                        _this.pool.releaseObject(xhr);\n                    }\n                });\n                var requestString = JSON.stringify(request);\n                log.debug(LOG_TAG, 'XHR sending: ', url + ' ' + requestString);\n                // Content-Type: text/plain will avoid preflight requests which might\n                // mess with CORS and redirects by proxies. If we add custom headers\n                // we will need to change this code to potentially use the\n                // $httpOverwrite parameter supported by ESF to avoid\n                // triggering preflight requests.\n                var headers = { 'Content-Type': 'text/plain' };\n                _this.modifyHeadersForRequest(headers, token);\n                xhr.send(url, 'POST', requestString, headers, XHR_TIMEOUT_SECS);\n            });\n        });\n    };\n    WebChannelConnection.prototype.invokeStreamingRPC = function (rpcName, request, token) {\n        // The REST API automatically aggregates all of the streamed results, so we\n        // can just use the normal invoke() method.\n        return this.invokeRPC(rpcName, request, token);\n    };\n    WebChannelConnection.prototype.openStream = function (rpcName, token) {\n        var urlParts = [\n            this.baseUrl,\n            '/',\n            RPC_STREAM_SERVICE,\n            '/',\n            rpcName,\n            '/channel'\n        ];\n        var webchannelTransport = createWebChannelTransport();\n        var request = {\n            // Background channel test avoids the initial two test calls and decreases\n            // initial cold start time.\n            // TODO(dimond): wenboz@ mentioned this might affect use with proxies and\n            // we should monitor closely for any reports.\n            backgroundChannelTest: true,\n            // Required for backend stickiness, routing behavior is based on this\n            // parameter.\n            httpSessionIdParam: 'gsessionid',\n            initMessageHeaders: {},\n            // Send our custom headers as a '$httpHeaders=' url param to avoid CORS\n            // preflight round-trip. This is formally defined here:\n            // https://github.com/google/closure-library/blob/b0e1815b13fb92a46d7c9b3c30de5d6a396a3245/closure/goog/net/rpc/httpcors.js#L40\n            httpHeadersOverwriteParam: '$httpHeaders',\n            messageUrlParams: {\n                // This param is used to improve routing and project isolation by the\n                // backend and must be included in every request.\n                database: \"projects/\" + this.databaseId.projectId + \"/databases/\" + this.databaseId.database\n            },\n            sendRawJson: true,\n            supportsCrossDomainXhr: true\n        };\n        this.modifyHeadersForRequest(request.initMessageHeaders, token);\n        var url = urlParts.join('');\n        log.debug(LOG_TAG, 'Creating WebChannel: ' + url + ' ' + request);\n        // tslint:disable-next-line:no-any Because listen isn't defined on it.\n        var channel = webchannelTransport.createWebChannel(url, request);\n        // WebChannel supports sending the first message with the handshake - saving\n        // a network round trip. However, it will have to call send in the same\n        // JS event loop as open. In order to enforce this, we delay actually\n        // opening the WebChannel until send is called. Whether we have called\n        // open is tracked with this variable.\n        var opened = false;\n        // A flag to determine whether the stream was closed (by us or through an\n        // error/close event) to avoid delivering multiple close events or sending\n        // on a closed stream\n        var closed = false;\n        var streamBridge = new StreamBridge({\n            sendFn: function (msg) {\n                if (!closed) {\n                    if (!opened) {\n                        log.debug(LOG_TAG, 'Opening WebChannel transport.');\n                        channel.open();\n                        opened = true;\n                    }\n                    log.debug(LOG_TAG, 'WebChannel sending:', msg);\n                    channel.send(msg);\n                }\n                else {\n                    log.debug(LOG_TAG, 'Not sending because WebChannel is closed:', msg);\n                }\n            },\n            closeFn: function () { return channel.close(); }\n        });\n        // Closure events are guarded and exceptions are swallowed, so catch any\n        // exception and rethrow using a setTimeout so they become visible again.\n        // Note that eventually this function could go away if we are confident\n        // enough the code is exception free.\n        var unguardedEventListen = function (type, fn) {\n            // TODO(dimond): closure typing seems broken because WebChannel does\n            // not implement goog.events.Listenable\n            channel.listen(type, function (param) {\n                try {\n                    fn(param);\n                }\n                catch (e) {\n                    setTimeout(function () {\n                        throw e;\n                    }, 0);\n                }\n            });\n        };\n        unguardedEventListen(WebChannel.EventType.OPEN, function () {\n            if (!closed) {\n                log.debug(LOG_TAG, 'WebChannel transport opened.');\n            }\n        });\n        unguardedEventListen(WebChannel.EventType.CLOSE, function () {\n            if (!closed) {\n                closed = true;\n                log.debug(LOG_TAG, 'WebChannel transport closed');\n                streamBridge.callOnClose();\n            }\n        });\n        unguardedEventListen(WebChannel.EventType.ERROR, function (err) {\n            if (!closed) {\n                closed = true;\n                log.debug(LOG_TAG, 'WebChannel transport errored:', err);\n                streamBridge.callOnClose(new FirestoreError(Code.UNAVAILABLE, 'The operation could not be completed'));\n            }\n        });\n        unguardedEventListen(WebChannel.EventType.MESSAGE, function (msg) {\n            if (!closed) {\n                var msgData = msg.data[0];\n                assert(!!msgData, 'Got a webchannel message without data.');\n                // TODO(b/35143891): There is a bug in One Platform that caused errors\n                // (and only errors) to be wrapped in an extra array. To be forward\n                // compatible with the bug we need to check either condition. The latter\n                // can be removed once the fix has been rolled out.\n                var error = \n                // tslint:disable-next-line:no-any msgData.error is not typed.\n                msgData.error || (msgData[0] && msgData[0].error);\n                if (error) {\n                    log.debug(LOG_TAG, 'WebChannel received error:', error);\n                    // error.status will be a string like 'OK' or 'NOT_FOUND'.\n                    var status_2 = error.status;\n                    var code = mapCodeFromRpcStatus(status_2);\n                    var message = error.message;\n                    if (code === undefined) {\n                        code = Code.INTERNAL;\n                        message =\n                            'Unknown error status: ' +\n                                status_2 +\n                                ' with message ' +\n                                error.message;\n                    }\n                    // Mark closed so no further events are propagated\n                    closed = true;\n                    streamBridge.callOnClose(new FirestoreError(code, message));\n                    channel.close();\n                }\n                else {\n                    log.debug(LOG_TAG, 'WebChannel received:', msgData);\n                    streamBridge.callOnMessage(msgData);\n                }\n            }\n        });\n        setTimeout(function () {\n            // Technically we could/should wait for the WebChannel opened event,\n            // but because we want to send the first message with the WebChannel\n            // handshake we pretend the channel opened here (asynchronously), and\n            // then delay the actual open until the first message is sent.\n            streamBridge.callOnOpen();\n        }, 0);\n        return streamBridge;\n    };\n    // visible for testing\n    WebChannelConnection.prototype.makeUrl = function (rpcName) {\n        var urlRpcName = RPC_NAME_REST_MAPPING[rpcName];\n        assert(urlRpcName !== undefined, 'Unknown REST mapping for: ' + rpcName);\n        var url = [this.baseUrl, '/', RPC_URL_VERSION];\n        url.push('/projects/');\n        url.push(this.databaseId.projectId);\n        url.push('/databases/');\n        url.push(this.databaseId.database);\n        url.push('/documents');\n        url.push(':');\n        url.push(urlRpcName);\n        return url.join('');\n    };\n    return WebChannelConnection;\n}());\nexport { WebChannelConnection };\n\n//# sourceMappingURL=webchannel_connection.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/platform_browser/webchannel_connection.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { JsonProtoSerializer } from '../remote/serializer';\nimport { WebChannelConnection } from './webchannel_connection';\nvar BrowserPlatform = /** @class */ (function () {\n    function BrowserPlatform() {\n        this.emptyByteString = '';\n        this.base64Available = typeof atob !== 'undefined';\n    }\n    BrowserPlatform.prototype.loadConnection = function (databaseInfo) {\n        return Promise.resolve(new WebChannelConnection(databaseInfo));\n    };\n    BrowserPlatform.prototype.newSerializer = function (databaseId) {\n        return new JsonProtoSerializer(databaseId, { useProto3Json: true });\n    };\n    BrowserPlatform.prototype.formatJSON = function (value) {\n        return JSON.stringify(value);\n    };\n    BrowserPlatform.prototype.atob = function (encoded) {\n        return atob(encoded);\n    };\n    BrowserPlatform.prototype.btoa = function (raw) {\n        return btoa(raw);\n    };\n    return BrowserPlatform;\n}());\nexport { BrowserPlatform };\n\n//# sourceMappingURL=browser_platform.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/platform_browser/browser_platform.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { PlatformSupport } from '../platform/platform';\nimport { BrowserPlatform } from './browser_platform';\n/**\n * This code needs to run before Firestore is used. This can be achieved in\n * several ways:\n *   1) Through the JSCompiler compiling this code and then (automatically)\n *      executing it before exporting the Firestore symbols.\n *   2) Through importing this module first in a Firestore main module\n */\nPlatformSupport.setPlatform(new BrowserPlatform());\n\n//# sourceMappingURL=browser_init.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/platform_browser/browser_init.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Describes the online state of the Firestore client. Note that this does not\n * indicate whether or not the remote store is trying to connect or not. This is\n * primarily used by the View / EventManager code to change their behavior while\n * offline (e.g. get() calls shouldn't wait for data from the server and\n * snapshot events should set metadata.isFromCache=true).\n */\nexport var OnlineState;\n(function (OnlineState) {\n    /**\n     * The Firestore client is in an unknown online state. This means the client\n     * is either not actively trying to establish a connection or it is currently\n     * trying to establish a connection, but it has not succeeded or failed yet.\n     * Higher-level components should not operate in offline mode.\n     */\n    OnlineState[OnlineState[\"Unknown\"] = 0] = \"Unknown\";\n    /**\n     * The client is connected and the connections are healthy. This state is\n     * reached after a successful connection and there has been at least one\n     * successful message received from the backends.\n     */\n    OnlineState[OnlineState[\"Online\"] = 1] = \"Online\";\n    /**\n     * The client is either trying to establish a connection but failing, or it\n     * has been explicitly marked offline via a call to disableNetwork().\n     * Higher-level components should operate in offline mode.\n     */\n    OnlineState[OnlineState[\"Offline\"] = 2] = \"Offline\";\n})(OnlineState || (OnlineState = {}));\n\n//# sourceMappingURL=types.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/core/types.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { DocumentKey } from '../model/document_key';\nimport { fail } from '../util/assert';\nimport { SortedMap } from '../util/sorted_map';\nexport var ChangeType;\n(function (ChangeType) {\n    ChangeType[ChangeType[\"Added\"] = 0] = \"Added\";\n    ChangeType[ChangeType[\"Removed\"] = 1] = \"Removed\";\n    ChangeType[ChangeType[\"Modified\"] = 2] = \"Modified\";\n    ChangeType[ChangeType[\"Metadata\"] = 3] = \"Metadata\";\n})(ChangeType || (ChangeType = {}));\nexport var SyncState;\n(function (SyncState) {\n    SyncState[SyncState[\"Local\"] = 0] = \"Local\";\n    SyncState[SyncState[\"Synced\"] = 1] = \"Synced\";\n})(SyncState || (SyncState = {}));\n/**\n * DocumentChangeSet keeps track of a set of changes to docs in a query, merging\n * duplicate events for the same doc.\n */\nvar DocumentChangeSet = /** @class */ (function () {\n    function DocumentChangeSet() {\n        this.changeMap = new SortedMap(DocumentKey.comparator);\n    }\n    DocumentChangeSet.prototype.track = function (change) {\n        var key = change.doc.key;\n        var oldChange = this.changeMap.get(key);\n        if (!oldChange) {\n            this.changeMap = this.changeMap.insert(key, change);\n            return;\n        }\n        // Merge the new change with the existing change.\n        if (change.type !== ChangeType.Added &&\n            oldChange.type === ChangeType.Metadata) {\n            this.changeMap = this.changeMap.insert(key, change);\n        }\n        else if (change.type === ChangeType.Metadata &&\n            oldChange.type !== ChangeType.Removed) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: oldChange.type,\n                doc: change.doc\n            });\n        }\n        else if (change.type === ChangeType.Modified &&\n            oldChange.type === ChangeType.Modified) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: ChangeType.Modified,\n                doc: change.doc\n            });\n        }\n        else if (change.type === ChangeType.Modified &&\n            oldChange.type === ChangeType.Added) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: ChangeType.Added,\n                doc: change.doc\n            });\n        }\n        else if (change.type === ChangeType.Removed &&\n            oldChange.type === ChangeType.Added) {\n            this.changeMap = this.changeMap.remove(key);\n        }\n        else if (change.type === ChangeType.Removed &&\n            oldChange.type === ChangeType.Modified) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: ChangeType.Removed,\n                doc: oldChange.doc\n            });\n        }\n        else if (change.type === ChangeType.Added &&\n            oldChange.type === ChangeType.Removed) {\n            this.changeMap = this.changeMap.insert(key, {\n                type: ChangeType.Modified,\n                doc: change.doc\n            });\n        }\n        else {\n            // This includes these cases, which don't make sense:\n            // Added->Added\n            // Removed->Removed\n            // Modified->Added\n            // Removed->Modified\n            // Metadata->Added\n            // Removed->Metadata\n            fail('unsupported combination of changes: ' +\n                JSON.stringify(change) +\n                ' after ' +\n                JSON.stringify(oldChange));\n        }\n    };\n    DocumentChangeSet.prototype.getChanges = function () {\n        var changes = [];\n        this.changeMap.inorderTraversal(function (key, change) {\n            changes.push(change);\n        });\n        return changes;\n    };\n    return DocumentChangeSet;\n}());\nexport { DocumentChangeSet };\nvar ViewSnapshot = /** @class */ (function () {\n    function ViewSnapshot(query, docs, oldDocs, docChanges, fromCache, hasPendingWrites, syncStateChanged) {\n        this.query = query;\n        this.docs = docs;\n        this.oldDocs = oldDocs;\n        this.docChanges = docChanges;\n        this.fromCache = fromCache;\n        this.hasPendingWrites = hasPendingWrites;\n        this.syncStateChanged = syncStateChanged;\n    }\n    ViewSnapshot.prototype.isEqual = function (other) {\n        if (this.fromCache !== other.fromCache ||\n            this.hasPendingWrites !== other.hasPendingWrites ||\n            this.syncStateChanged !== other.syncStateChanged ||\n            !this.query.isEqual(other.query) ||\n            !this.docs.isEqual(other.docs) ||\n            !this.oldDocs.isEqual(other.oldDocs)) {\n            return false;\n        }\n        var changes = this.docChanges;\n        var otherChanges = other.docChanges;\n        if (changes.length !== otherChanges.length) {\n            return false;\n        }\n        for (var i = 0; i < changes.length; i++) {\n            if (changes[i].type !== otherChanges[i].type ||\n                !changes[i].doc.isEqual(otherChanges[i].doc)) {\n                return false;\n            }\n        }\n        return true;\n    };\n    return ViewSnapshot;\n}());\nexport { ViewSnapshot };\n\n//# sourceMappingURL=view_snapshot.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/core/view_snapshot.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar RESERVED_BITS = 1;\nvar GeneratorIds;\n(function (GeneratorIds) {\n    GeneratorIds[GeneratorIds[\"LocalStore\"] = 0] = \"LocalStore\";\n    GeneratorIds[GeneratorIds[\"SyncEngine\"] = 1] = \"SyncEngine\";\n})(GeneratorIds || (GeneratorIds = {}));\n/**\n * TargetIdGenerator generates monotonically increasing integer IDs. There are\n * separate generators for different scopes. While these generators will operate\n * independently of each other, they are scoped, such that no two generators\n * will ever produce the same ID. This is useful, because sometimes the backend\n * may group IDs from separate parts of the client into the same ID space.\n */\nvar TargetIdGenerator = /** @class */ (function () {\n    function TargetIdGenerator(generatorId, initAfter) {\n        if (initAfter === void 0) { initAfter = 0; }\n        this.generatorId = generatorId;\n        // Replace the generator part of initAfter with this generator's ID.\n        var afterWithoutGenerator = (initAfter >> RESERVED_BITS) << RESERVED_BITS;\n        var afterGenerator = initAfter - afterWithoutGenerator;\n        if (afterGenerator >= generatorId) {\n            // For example, if:\n            //   this.generatorId = 0b0000\n            //   after = 0b1011\n            //   afterGenerator = 0b0001\n            // Then:\n            //   previous = 0b1010\n            //   next = 0b1100\n            this.previousId = afterWithoutGenerator | this.generatorId;\n        }\n        else {\n            // For example, if:\n            //   this.generatorId = 0b0001\n            //   after = 0b1010\n            //   afterGenerator = 0b0000\n            // Then:\n            //   previous = 0b1001\n            //   next = 0b1011\n            this.previousId =\n                (afterWithoutGenerator | this.generatorId) - (1 << RESERVED_BITS);\n        }\n    }\n    TargetIdGenerator.prototype.next = function () {\n        this.previousId += 1 << RESERVED_BITS;\n        return this.previousId;\n    };\n    TargetIdGenerator.forLocalStore = function (initAfter) {\n        if (initAfter === void 0) { initAfter = 0; }\n        return new TargetIdGenerator(GeneratorIds.LocalStore, initAfter);\n    };\n    TargetIdGenerator.forSyncEngine = function () {\n        return new TargetIdGenerator(GeneratorIds.SyncEngine);\n    };\n    return TargetIdGenerator;\n}());\nexport { TargetIdGenerator };\n\n//# sourceMappingURL=target_id_generator.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/core/target_id_generator.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SortedMap } from '../util/sorted_map';\nimport { documentMap } from './collections';\nimport { DocumentKey } from './document_key';\n/**\n * DocumentSet is an immutable (copy-on-write) collection that holds documents\n * in order specified by the provided comparator. We always add a document key\n * comparator on top of what is provided to guarantee document equality based on\n * the key.\n */\nvar DocumentSet = /** @class */ (function () {\n    /** The default ordering is by key if the comparator is omitted */\n    function DocumentSet(comp) {\n        // We are adding document key comparator to the end as it's the only\n        // guaranteed unique property of a document.\n        if (comp) {\n            this.comparator = function (d1, d2) {\n                return comp(d1, d2) || DocumentKey.comparator(d1.key, d2.key);\n            };\n        }\n        else {\n            this.comparator = function (d1, d2) {\n                return DocumentKey.comparator(d1.key, d2.key);\n            };\n        }\n        this.keyedMap = documentMap();\n        this.sortedSet = new SortedMap(this.comparator);\n    }\n    /**\n     * Returns an empty copy of the existing DocumentSet, using the same\n     * comparator.\n     */\n    DocumentSet.emptySet = function (oldSet) {\n        return new DocumentSet(oldSet.comparator);\n    };\n    DocumentSet.prototype.has = function (key) {\n        return this.keyedMap.get(key) != null;\n    };\n    DocumentSet.prototype.get = function (key) {\n        return this.keyedMap.get(key);\n    };\n    DocumentSet.prototype.first = function () {\n        return this.sortedSet.minKey();\n    };\n    DocumentSet.prototype.last = function () {\n        return this.sortedSet.maxKey();\n    };\n    DocumentSet.prototype.isEmpty = function () {\n        return this.sortedSet.isEmpty();\n    };\n    /**\n     * Returns the index of the provided key in the document set, or -1 if the\n     * document key is not present in the set;\n     */\n    DocumentSet.prototype.indexOf = function (key) {\n        var doc = this.keyedMap.get(key);\n        return doc ? this.sortedSet.indexOf(doc) : -1;\n    };\n    Object.defineProperty(DocumentSet.prototype, \"size\", {\n        get: function () {\n            return this.sortedSet.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Iterates documents in order defined by \"comparator\" */\n    DocumentSet.prototype.forEach = function (cb) {\n        this.sortedSet.inorderTraversal(function (k, v) {\n            cb(k);\n            return false;\n        });\n    };\n    /** Inserts or updates a document with the same key */\n    DocumentSet.prototype.add = function (doc) {\n        // First remove the element if we have it.\n        var set = this.delete(doc.key);\n        return set.copy(set.keyedMap.insert(doc.key, doc), set.sortedSet.insert(doc, null));\n    };\n    /** Deletes a document with a given key */\n    DocumentSet.prototype.delete = function (key) {\n        var doc = this.get(key);\n        if (!doc) {\n            return this;\n        }\n        return this.copy(this.keyedMap.remove(key), this.sortedSet.remove(doc));\n    };\n    DocumentSet.prototype.isEqual = function (other) {\n        if (!(other instanceof DocumentSet))\n            return false;\n        if (this.size !== other.size)\n            return false;\n        var thisIt = this.sortedSet.getIterator();\n        var otherIt = other.sortedSet.getIterator();\n        while (thisIt.hasNext()) {\n            var thisDoc = thisIt.getNext().key;\n            var otherDoc = otherIt.getNext().key;\n            if (!thisDoc.isEqual(otherDoc))\n                return false;\n        }\n        return true;\n    };\n    DocumentSet.prototype.toString = function () {\n        var docStrings = [];\n        this.forEach(function (doc) {\n            docStrings.push(doc.toString());\n        });\n        if (docStrings.length === 0) {\n            return 'DocumentSet ()';\n        }\n        else {\n            return 'DocumentSet (\\n  ' + docStrings.join('  \\n') + '\\n)';\n        }\n    };\n    DocumentSet.prototype.copy = function (keyedMap, sortedSet) {\n        var newSet = new DocumentSet();\n        newSet.comparator = this.comparator;\n        newSet.keyedMap = keyedMap;\n        newSet.sortedSet = sortedSet;\n        return newSet;\n    };\n    return DocumentSet;\n}());\nexport { DocumentSet };\n\n//# sourceMappingURL=document_set.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/model/document_set.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as objUtil from './obj';\n/**\n * A map implementation that uses objects as keys. Objects must implement the\n * Equatable interface and must be immutable. Entries in the map are stored\n * together with the key being produced from the mapKeyFn. This map\n * automatically handles collisions of keys.\n */\nvar ObjectMap = /** @class */ (function () {\n    function ObjectMap(mapKeyFn) {\n        this.mapKeyFn = mapKeyFn;\n        /**\n         * The inner map for a key -> value pair. Due to the possibility of\n         * collisions we keep a list of entries that we do a linear search through\n         * to find an actual match. Note that collisions should be rare, so we still\n         * expect near constant time lookups in practice.\n         */\n        this.inner = {};\n    }\n    /** Get a value for this key, or undefined if it does not exist. */\n    ObjectMap.prototype.get = function (key) {\n        var id = this.mapKeyFn(key);\n        var matches = this.inner[id];\n        if (matches === undefined) {\n            return undefined;\n        }\n        for (var _i = 0, matches_1 = matches; _i < matches_1.length; _i++) {\n            var _a = matches_1[_i], otherKey = _a[0], value = _a[1];\n            if (otherKey.isEqual(key)) {\n                return value;\n            }\n        }\n        return undefined;\n    };\n    ObjectMap.prototype.has = function (key) {\n        return this.get(key) !== undefined;\n    };\n    /** Put this key and value in the map. */\n    ObjectMap.prototype.set = function (key, value) {\n        var id = this.mapKeyFn(key);\n        var matches = this.inner[id];\n        if (matches === undefined) {\n            this.inner[id] = [[key, value]];\n            return;\n        }\n        for (var i = 0; i < matches.length; i++) {\n            if (matches[i][0].isEqual(key)) {\n                matches[i] = [key, value];\n                return;\n            }\n        }\n        matches.push([key, value]);\n    };\n    /**\n     * Remove this key from the map. Returns a boolean if anything was deleted.\n     */\n    ObjectMap.prototype.delete = function (key) {\n        var id = this.mapKeyFn(key);\n        var matches = this.inner[id];\n        if (matches === undefined) {\n            return false;\n        }\n        for (var i = 0; i < matches.length; i++) {\n            if (matches[i][0].isEqual(key)) {\n                if (matches.length === 1) {\n                    delete this.inner[id];\n                }\n                else {\n                    matches.splice(i, 1);\n                }\n                return true;\n            }\n        }\n        return false;\n    };\n    ObjectMap.prototype.forEach = function (fn) {\n        objUtil.forEach(this.inner, function (_, entries) {\n            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n                var _a = entries_1[_i], k = _a[0], v = _a[1];\n                fn(k, v);\n            }\n        });\n    };\n    ObjectMap.prototype.isEmpty = function () {\n        return objUtil.isEmpty(this.inner);\n    };\n    return ObjectMap;\n}());\nexport { ObjectMap };\n\n//# sourceMappingURL=obj_map.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/obj_map.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { OnlineState } from './types';\nimport { ChangeType, ViewSnapshot } from './view_snapshot';\nimport { DocumentSet } from '../model/document_set';\nimport { assert } from '../util/assert';\nimport { ObjectMap } from '../util/obj_map';\n/**\n * Holds the listeners and the last received ViewSnapshot for a query being\n * tracked by EventManager.\n */\nvar QueryListenersInfo = /** @class */ (function () {\n    function QueryListenersInfo() {\n        this.listeners = [];\n    }\n    return QueryListenersInfo;\n}());\n/**\n * EventManager is responsible for mapping queries to query event emitters.\n * It handles \"fan-out\". -- Identical queries will re-use the same watch on the\n * backend.\n */\nvar EventManager = /** @class */ (function () {\n    function EventManager(syncEngine) {\n        this.syncEngine = syncEngine;\n        this.queries = new ObjectMap(function (q) {\n            return q.canonicalId();\n        });\n        this.onlineState = OnlineState.Unknown;\n        this.syncEngine.subscribe(this.onChange.bind(this), this.onError.bind(this));\n    }\n    EventManager.prototype.listen = function (listener) {\n        var query = listener.query;\n        var firstListen = false;\n        var queryInfo = this.queries.get(query);\n        if (!queryInfo) {\n            firstListen = true;\n            queryInfo = new QueryListenersInfo();\n            this.queries.set(query, queryInfo);\n        }\n        queryInfo.listeners.push(listener);\n        listener.applyOnlineStateChange(this.onlineState);\n        if (queryInfo.viewSnap)\n            listener.onViewSnapshot(queryInfo.viewSnap);\n        if (firstListen) {\n            return this.syncEngine.listen(query).then(function (targetId) {\n                queryInfo.targetId = targetId;\n                return targetId;\n            });\n        }\n        else {\n            return Promise.resolve(queryInfo.targetId);\n        }\n    };\n    EventManager.prototype.unlisten = function (listener) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var query, lastListen, queryInfo, i;\n            return tslib_1.__generator(this, function (_a) {\n                query = listener.query;\n                lastListen = false;\n                queryInfo = this.queries.get(query);\n                if (queryInfo) {\n                    i = queryInfo.listeners.indexOf(listener);\n                    if (i >= 0) {\n                        queryInfo.listeners.splice(i, 1);\n                        lastListen = queryInfo.listeners.length === 0;\n                    }\n                }\n                if (lastListen) {\n                    this.queries.delete(query);\n                    return [2 /*return*/, this.syncEngine.unlisten(query)];\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    EventManager.prototype.onChange = function (viewSnaps) {\n        for (var _i = 0, viewSnaps_1 = viewSnaps; _i < viewSnaps_1.length; _i++) {\n            var viewSnap = viewSnaps_1[_i];\n            var query = viewSnap.query;\n            var queryInfo = this.queries.get(query);\n            if (queryInfo) {\n                for (var _a = 0, _b = queryInfo.listeners; _a < _b.length; _a++) {\n                    var listener = _b[_a];\n                    listener.onViewSnapshot(viewSnap);\n                }\n                queryInfo.viewSnap = viewSnap;\n            }\n        }\n    };\n    EventManager.prototype.onError = function (query, error) {\n        var queryInfo = this.queries.get(query);\n        if (queryInfo) {\n            for (var _i = 0, _a = queryInfo.listeners; _i < _a.length; _i++) {\n                var listener = _a[_i];\n                listener.onError(error);\n            }\n        }\n        // Remove all listeners. NOTE: We don't need to call syncEngine.unlisten()\n        // after an error.\n        this.queries.delete(query);\n    };\n    EventManager.prototype.applyOnlineStateChange = function (onlineState) {\n        this.onlineState = onlineState;\n        this.queries.forEach(function (_, queryInfo) {\n            for (var _i = 0, _a = queryInfo.listeners; _i < _a.length; _i++) {\n                var listener = _a[_i];\n                listener.applyOnlineStateChange(onlineState);\n            }\n        });\n    };\n    return EventManager;\n}());\nexport { EventManager };\n/**\n * QueryListener takes a series of internal view snapshots and determines\n * when to raise the event.\n *\n * It uses an Observer to dispatch events.\n */\nvar QueryListener = /** @class */ (function () {\n    function QueryListener(query, queryObserver, options) {\n        this.query = query;\n        this.queryObserver = queryObserver;\n        /**\n         * Initial snapshots (e.g. from cache) may not be propagated to the wrapped\n         * observer. This flag is set to true once we've actually raised an event.\n         */\n        this.raisedInitialEvent = false;\n        this.onlineState = OnlineState.Unknown;\n        this.options = options || {};\n    }\n    QueryListener.prototype.onViewSnapshot = function (snap) {\n        assert(snap.docChanges.length > 0 || snap.syncStateChanged, 'We got a new snapshot with no changes?');\n        if (!this.options.includeDocumentMetadataChanges) {\n            // Remove the metadata only changes.\n            var docChanges = [];\n            for (var _i = 0, _a = snap.docChanges; _i < _a.length; _i++) {\n                var docChange = _a[_i];\n                if (docChange.type !== ChangeType.Metadata) {\n                    docChanges.push(docChange);\n                }\n            }\n            snap = new ViewSnapshot(snap.query, snap.docs, snap.oldDocs, docChanges, snap.fromCache, snap.hasPendingWrites, snap.syncStateChanged);\n        }\n        if (!this.raisedInitialEvent) {\n            if (this.shouldRaiseInitialEvent(snap, this.onlineState)) {\n                this.raiseInitialEvent(snap);\n            }\n        }\n        else if (this.shouldRaiseEvent(snap)) {\n            this.queryObserver.next(snap);\n        }\n        this.snap = snap;\n    };\n    QueryListener.prototype.onError = function (error) {\n        this.queryObserver.error(error);\n    };\n    QueryListener.prototype.applyOnlineStateChange = function (onlineState) {\n        this.onlineState = onlineState;\n        if (this.snap &&\n            !this.raisedInitialEvent &&\n            this.shouldRaiseInitialEvent(this.snap, onlineState)) {\n            this.raiseInitialEvent(this.snap);\n        }\n    };\n    QueryListener.prototype.shouldRaiseInitialEvent = function (snap, onlineState) {\n        assert(!this.raisedInitialEvent, 'Determining whether to raise first event but already had first event');\n        // Always raise the first event when we're synced\n        if (!snap.fromCache) {\n            return true;\n        }\n        // NOTE: We consider OnlineState.Unknown as online (it should become Offline\n        // or Online if we wait long enough).\n        var maybeOnline = onlineState !== OnlineState.Offline;\n        // Don't raise the event if we're online, aren't synced yet (checked\n        // above) and are waiting for a sync.\n        if (this.options.waitForSyncWhenOnline && maybeOnline) {\n            assert(snap.fromCache, 'Waiting for sync, but snapshot is not from cache');\n            return false;\n        }\n        // Raise data from cache if we have any documents or we are offline\n        return !snap.docs.isEmpty() || onlineState === OnlineState.Offline;\n    };\n    QueryListener.prototype.shouldRaiseEvent = function (snap) {\n        // We don't need to handle includeDocumentMetadataChanges here because\n        // the Metadata only changes have already been stripped out if needed.\n        // At this point the only changes we will see are the ones we should\n        // propagate.\n        if (snap.docChanges.length > 0) {\n            return true;\n        }\n        var hasPendingWritesChanged = this.snap && this.snap.hasPendingWrites !== snap.hasPendingWrites;\n        if (snap.syncStateChanged || hasPendingWritesChanged) {\n            return this.options.includeQueryMetadataChanges === true;\n        }\n        // Generally we should have hit one of the cases above, but it's possible\n        // to get here if there were only metadata docChanges and they got\n        // stripped out.\n        return false;\n    };\n    QueryListener.prototype.raiseInitialEvent = function (snap) {\n        assert(!this.raisedInitialEvent, 'Trying to raise initial events for second time');\n        snap = new ViewSnapshot(snap.query, snap.docs, DocumentSet.emptySet(snap.docs), QueryListener.getInitialViewChanges(snap), snap.fromCache, snap.hasPendingWrites, true);\n        this.raisedInitialEvent = true;\n        this.queryObserver.next(snap);\n    };\n    /** Returns changes as if all documents in the snap were added. */\n    QueryListener.getInitialViewChanges = function (snap) {\n        var result = [];\n        snap.docs.forEach(function (doc) {\n            result.push({ type: ChangeType.Added, doc: doc });\n        });\n        return result;\n    };\n    return QueryListener;\n}());\nexport { QueryListener };\n\n//# sourceMappingURL=event_manager.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/core/event_manager.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { fail } from '../util/assert';\n/**\n * PersistencePromise<> is essentially a re-implementation of Promise<> except\n * it has a .next() method instead of .then() and .next() and .catch() callbacks\n * are executed synchronously when a PersistencePromise resolves rather than\n * asynchronously (Promise<> implementations use setImmediate() or similar).\n *\n * This is necessary to interoperate with IndexedDB which will automatically\n * commit transactions if control is returned to the event loop without\n * synchronously initiating another operation on the transaction.\n *\n * NOTE: .then() and .catch() only allow a single consumer, unlike normal\n * Promises.\n */\nvar PersistencePromise = /** @class */ (function () {\n    function PersistencePromise(callback) {\n        var _this = this;\n        // NOTE: next/catchCallback will always point to our own wrapper functions,\n        // not the user's raw next() or catch() callbacks.\n        // tslint:disable-next-line:no-any Accept any result type for the next call in the Promise chain.\n        this.nextCallback = null;\n        // tslint:disable-next-line:no-any Accept any result type for the error handler.\n        this.catchCallback = null;\n        // When the operation resolves, we'll set result or error and mark isDone.\n        this.result = undefined;\n        this.error = undefined;\n        this.isDone = false;\n        // Set to true when .then() or .catch() are called and prevents additional\n        // chaining.\n        this.callbackAttached = false;\n        callback(function (value) {\n            _this.isDone = true;\n            _this.result = value;\n            if (_this.nextCallback) {\n                // value should be defined unless T is Void, but we can't express\n                // that in the type system.\n                _this.nextCallback(value);\n            }\n        }, function (error) {\n            _this.isDone = true;\n            _this.error = error;\n            if (_this.catchCallback) {\n                _this.catchCallback(error);\n            }\n        });\n    }\n    PersistencePromise.prototype.catch = function (fn) {\n        return this.next(undefined, fn);\n    };\n    PersistencePromise.prototype.next = function (nextFn, catchFn) {\n        var _this = this;\n        if (this.callbackAttached) {\n            fail('Called next() or catch() twice for PersistencePromise');\n        }\n        this.callbackAttached = true;\n        if (this.isDone) {\n            if (!this.error) {\n                return this.wrapSuccess(nextFn, this.result);\n            }\n            else {\n                return this.wrapFailure(catchFn, this.error);\n            }\n        }\n        else {\n            return new PersistencePromise(function (resolve, reject) {\n                _this.nextCallback = function (value) {\n                    _this.wrapSuccess(nextFn, value).next(resolve, reject);\n                };\n                _this.catchCallback = function (error) {\n                    _this.wrapFailure(catchFn, error).next(resolve, reject);\n                };\n            });\n        }\n    };\n    PersistencePromise.prototype.toPromise = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            _this.next(resolve, reject);\n        });\n    };\n    PersistencePromise.prototype.wrapUserFunction = function (fn) {\n        try {\n            var result = fn();\n            if (result instanceof PersistencePromise) {\n                return result;\n            }\n            else {\n                return PersistencePromise.resolve(result);\n            }\n        }\n        catch (e) {\n            return PersistencePromise.reject(e);\n        }\n    };\n    PersistencePromise.prototype.wrapSuccess = function (nextFn, value) {\n        if (nextFn) {\n            return this.wrapUserFunction(function () { return nextFn(value); });\n        }\n        else {\n            // If there's no nextFn, then R must be the same as T but we\n            // can't express that in the type system.\n            // tslint:disable-next-line:no-any\n            return PersistencePromise.resolve(value);\n        }\n    };\n    PersistencePromise.prototype.wrapFailure = function (catchFn, error) {\n        if (catchFn) {\n            return this.wrapUserFunction(function () { return catchFn(error); });\n        }\n        else {\n            return PersistencePromise.reject(error);\n        }\n    };\n    PersistencePromise.resolve = function (result) {\n        return new PersistencePromise(function (resolve, reject) {\n            resolve(result);\n        });\n    };\n    PersistencePromise.reject = function (error) {\n        return new PersistencePromise(function (resolve, reject) {\n            reject(error);\n        });\n    };\n    PersistencePromise.waitFor = function (\n    // tslint:disable-next-line:no-any Accept all Promise types in waitFor().\n    all) {\n        return all.reduce(function (promise, nextPromise, idx) {\n            return promise.next(function () {\n                return nextPromise;\n            });\n        }, PersistencePromise.resolve());\n    };\n    PersistencePromise.map = function (all) {\n        var results = [];\n        var first = true;\n        // initial is ignored, so we can cheat on the type.\n        // tslint:disable-next-line:no-any\n        var initial = PersistencePromise.resolve(null);\n        return all\n            .reduce(function (promise, nextPromise) {\n            return promise.next(function (result) {\n                if (!first) {\n                    results.push(result);\n                }\n                first = false;\n                return nextPromise;\n            });\n        }, initial)\n            .next(function (result) {\n            results.push(result);\n            return results;\n        });\n    };\n    return PersistencePromise;\n}());\nexport { PersistencePromise };\n\n//# sourceMappingURL=persistence_promise.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/persistence_promise.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { documentKeySet } from '../model/collections';\nimport { PersistencePromise } from './persistence_promise';\n/**\n * A garbage collector implementation that eagerly collects documents as soon as\n * they're no longer referenced in any of its registered GarbageSources.\n *\n * This implementation keeps track of a set of keys that are potentially garbage\n * without keeping an exact reference count. During collectGarbage, the\n * collector verifies that all potential garbage keys actually have no\n * references by consulting its list of garbage sources.\n */\nvar EagerGarbageCollector = /** @class */ (function () {\n    function EagerGarbageCollector() {\n        this.isEager = true;\n        /**\n         * The garbage collectible sources to double-check during garbage collection.\n         */\n        this.sources = [];\n        /**\n         * A set of potentially garbage keys.\n         * PORTING NOTE: This would be a mutable set if Javascript had one.\n         */\n        this.potentialGarbage = documentKeySet();\n    }\n    EagerGarbageCollector.prototype.addGarbageSource = function (garbageSource) {\n        this.sources.push(garbageSource);\n        garbageSource.setGarbageCollector(this);\n    };\n    EagerGarbageCollector.prototype.removeGarbageSource = function (garbageSource) {\n        this.sources.splice(this.sources.indexOf(garbageSource), 1);\n        garbageSource.setGarbageCollector(null);\n    };\n    EagerGarbageCollector.prototype.addPotentialGarbageKey = function (key) {\n        this.potentialGarbage = this.potentialGarbage.add(key);\n    };\n    EagerGarbageCollector.prototype.collectGarbage = function (txn) {\n        var _this = this;\n        var promises = [];\n        var garbageKeys = documentKeySet();\n        this.potentialGarbage.forEach(function (key) {\n            var hasRefsPromise = _this.documentHasAnyReferences(txn, key);\n            promises.push(hasRefsPromise.next(function (hasRefs) {\n                // If there are no references, get the key.\n                if (!hasRefs) {\n                    garbageKeys = garbageKeys.add(key);\n                }\n                return PersistencePromise.resolve();\n            }));\n        });\n        // Clear locally retained potential keys and returned confirmed garbage.\n        this.potentialGarbage = documentKeySet();\n        return PersistencePromise.waitFor(promises).next(function () { return garbageKeys; });\n    };\n    EagerGarbageCollector.prototype.documentHasAnyReferences = function (txn, key) {\n        var initial = PersistencePromise.resolve(false);\n        return this.sources\n            .map(function (source) { return function () { return source.containsKey(txn, key); }; })\n            .reduce(function (promise, nextPromise) {\n            return promise.next(function (result) {\n                if (result) {\n                    return PersistencePromise.resolve(true);\n                }\n                else {\n                    return nextPromise();\n                }\n            });\n        }, initial);\n    };\n    return EagerGarbageCollector;\n}());\nexport { EagerGarbageCollector };\n\n//# sourceMappingURL=eager_garbage_collector.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/eager_garbage_collector.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ChangeType } from '../core/view_snapshot';\nimport { documentKeySet } from '../model/collections';\n/**\n * A set of changes to what documents are currently in view and out of view for\n * a given query. These changes are sent to the LocalStore by the View (via\n * the SyncEngine) and are used to pin / unpin documents as appropriate.\n */\nvar LocalViewChanges = /** @class */ (function () {\n    function LocalViewChanges(query, addedKeys, removedKeys) {\n        this.query = query;\n        this.addedKeys = addedKeys;\n        this.removedKeys = removedKeys;\n    }\n    LocalViewChanges.fromSnapshot = function (viewSnapshot) {\n        var addedKeys = documentKeySet();\n        var removedKeys = documentKeySet();\n        for (var _i = 0, _a = viewSnapshot.docChanges; _i < _a.length; _i++) {\n            var docChange = _a[_i];\n            switch (docChange.type) {\n                case ChangeType.Added:\n                    addedKeys = addedKeys.add(docChange.doc.key);\n                    break;\n                case ChangeType.Removed:\n                    removedKeys = removedKeys.add(docChange.doc.key);\n                    break;\n                default:\n            }\n        }\n        return new LocalViewChanges(viewSnapshot.query, addedKeys, removedKeys);\n    };\n    return LocalViewChanges;\n}());\nexport { LocalViewChanges };\n\n//# sourceMappingURL=local_view_changes.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/local_view_changes.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { documentKeySet } from '../model/collections';\nimport { DocumentKey } from '../model/document_key';\nimport { primitiveComparator } from '../util/misc';\nimport { SortedSet } from '../util/sorted_set';\nimport { PersistencePromise } from './persistence_promise';\n/**\n * A collection of references to a document from some kind of numbered entity\n * (either a target ID or batch ID). As references are added to or removed from\n * the set corresponding events are emitted to a registered garbage collector.\n *\n * Each reference is represented by a DocumentReference object. Each of them\n * contains enough information to uniquely identify the reference. They are all\n * stored primarily in a set sorted by key. A document is considered garbage if\n * there's no references in that set (this can be efficiently checked thanks to\n * sorting by key).\n *\n * ReferenceSet also keeps a secondary set that contains references sorted by\n * IDs. This one is used to efficiently implement removal of all references by\n * some target ID.\n */\nvar ReferenceSet = /** @class */ (function () {\n    function ReferenceSet() {\n        // A set of outstanding references to a document sorted by key.\n        this.refsByKey = new SortedSet(DocReference.compareByKey);\n        // A set of outstanding references to a document sorted by target id.\n        this.refsByTarget = new SortedSet(DocReference.compareByTargetId);\n        /** Keeps track of keys that have references */\n        this.garbageCollector = null;\n    }\n    /** Returns true if the reference set contains no references. */\n    ReferenceSet.prototype.isEmpty = function () {\n        return this.refsByKey.isEmpty();\n    };\n    /** Adds a reference to the given document key for the given ID. */\n    ReferenceSet.prototype.addReference = function (key, id) {\n        var ref = new DocReference(key, id);\n        this.refsByKey = this.refsByKey.add(ref);\n        this.refsByTarget = this.refsByTarget.add(ref);\n    };\n    /** Add references to the given document keys for the given ID. */\n    ReferenceSet.prototype.addReferences = function (keys, id) {\n        var _this = this;\n        keys.forEach(function (key) { return _this.addReference(key, id); });\n    };\n    /**\n     * Removes a reference to the given document key for the given\n     * ID.\n     */\n    ReferenceSet.prototype.removeReference = function (key, id) {\n        this.removeRef(new DocReference(key, id));\n    };\n    ReferenceSet.prototype.removeReferences = function (keys, id) {\n        var _this = this;\n        keys.forEach(function (key) { return _this.removeReference(key, id); });\n    };\n    /**\n     * Clears all references with a given ID. Calls removeRef() for each key\n     * removed.\n     */\n    ReferenceSet.prototype.removeReferencesForId = function (id) {\n        var _this = this;\n        var emptyKey = DocumentKey.EMPTY;\n        var startRef = new DocReference(emptyKey, id);\n        var endRef = new DocReference(emptyKey, id + 1);\n        this.refsByTarget.forEachInRange([startRef, endRef], function (ref) {\n            _this.removeRef(ref);\n        });\n    };\n    ReferenceSet.prototype.removeAllReferences = function () {\n        var _this = this;\n        this.refsByKey.forEach(function (ref) { return _this.removeRef(ref); });\n    };\n    ReferenceSet.prototype.removeRef = function (ref) {\n        this.refsByKey = this.refsByKey.delete(ref);\n        this.refsByTarget = this.refsByTarget.delete(ref);\n        if (this.garbageCollector !== null) {\n            this.garbageCollector.addPotentialGarbageKey(ref.key);\n        }\n    };\n    ReferenceSet.prototype.referencesForId = function (id) {\n        var emptyKey = DocumentKey.EMPTY;\n        var startRef = new DocReference(emptyKey, id);\n        var endRef = new DocReference(emptyKey, id + 1);\n        var keys = documentKeySet();\n        this.refsByTarget.forEachInRange([startRef, endRef], function (ref) {\n            keys = keys.add(ref.key);\n        });\n        return keys;\n    };\n    ReferenceSet.prototype.setGarbageCollector = function (garbageCollector) {\n        this.garbageCollector = garbageCollector;\n    };\n    ReferenceSet.prototype.containsKey = function (txn, key) {\n        var ref = new DocReference(key, 0);\n        var firstRef = this.refsByKey.firstAfterOrEqual(ref);\n        return PersistencePromise.resolve(firstRef !== null && key.isEqual(firstRef.key));\n    };\n    return ReferenceSet;\n}());\nexport { ReferenceSet };\nvar DocReference = /** @class */ (function () {\n    function DocReference(key, targetOrBatchId) {\n        this.key = key;\n        this.targetOrBatchId = targetOrBatchId;\n    }\n    /** Compare by key then by ID */\n    DocReference.compareByKey = function (left, right) {\n        return (DocumentKey.comparator(left.key, right.key) ||\n            primitiveComparator(left.targetOrBatchId, right.targetOrBatchId));\n    };\n    /** Compare by ID then by key */\n    DocReference.compareByTargetId = function (left, right) {\n        return (primitiveComparator(left.targetOrBatchId, right.targetOrBatchId) ||\n            DocumentKey.comparator(left.key, right.key));\n    };\n    return DocReference;\n}());\nexport { DocReference };\n\n//# sourceMappingURL=reference_set.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/reference_set.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert, fail } from './assert';\nimport * as log from './log';\nimport { Deferred } from './promise';\nimport { Code, FirestoreError } from './error';\n/**\n * Wellknown \"timer\" IDs used when scheduling delayed operations on the\n * AsyncQueue. These IDs can then be used from tests to check for the presence\n * of operations or to run them early.\n *\n * The string values are used when encoding these timer IDs in JSON spec tests.\n */\nexport var TimerId;\n(function (TimerId) {\n    /** All can be used with runDelayedOperationsEarly() to run all timers. */\n    TimerId[\"All\"] = \"all\";\n    /**\n     * The following 4 timers are used in persistent_stream.ts for the listen and\n     * write streams. The \"Idle\" timer is used to close the stream due to\n     * inactivity. The \"ConnectionBackoff\" timer is used to restart a stream once\n     * the appropriate backoff delay has elapsed.\n     */\n    TimerId[\"ListenStreamIdle\"] = \"listen_stream_idle\";\n    TimerId[\"ListenStreamConnectionBackoff\"] = \"listen_stream_connection_backoff\";\n    TimerId[\"WriteStreamIdle\"] = \"write_stream_idle\";\n    TimerId[\"WriteStreamConnectionBackoff\"] = \"write_stream_connection_backoff\";\n    /**\n     * A timer used in online_state_tracker.ts to transition from\n     * OnlineState.Unknown to Offline after a set timeout, rather than waiting\n     * indefinitely for success or failure.\n     */\n    TimerId[\"OnlineStateTimeout\"] = \"online_state_timeout\";\n})(TimerId || (TimerId = {}));\n/**\n * Represents an operation scheduled to be run in the future on an AsyncQueue.\n *\n * It is created via DelayedOperation.createAndSchedule().\n *\n * Supports cancellation (via cancel()) and early execution (via skipDelay()).\n */\nvar DelayedOperation = /** @class */ (function () {\n    function DelayedOperation(asyncQueue, timerId, targetTimeMs, op, removalCallback) {\n        this.asyncQueue = asyncQueue;\n        this.timerId = timerId;\n        this.targetTimeMs = targetTimeMs;\n        this.op = op;\n        this.removalCallback = removalCallback;\n        this.deferred = new Deferred();\n        this.then = this.deferred.promise.then.bind(this.deferred.promise);\n        this.catch = this.deferred.promise.catch.bind(this.deferred.promise);\n        // It's normal for the deferred promise to be canceled (due to cancellation)\n        // and so we attach a dummy catch callback to avoid\n        // 'UnhandledPromiseRejectionWarning' log spam.\n        this.deferred.promise.catch(function (err) { });\n    }\n    /**\n     * Creates and returns a DelayedOperation that has been scheduled to be\n     * executed on the provided asyncQueue after the provided delayMs.\n     *\n     * @param asyncQueue The queue to schedule the operation on.\n     * @param id A Timer ID identifying the type of operation this is.\n     * @param delayMs The delay (ms) before the operation should be scheduled.\n     * @param op The operation to run.\n     * @param removalCallback A callback to be called synchronously once the\n     *   operation is executed or canceled, notifying the AsyncQueue to remove it\n     *   from its delayedOperations list.\n     *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and\n     *   the DelayedOperation class public.\n     */\n    DelayedOperation.createAndSchedule = function (asyncQueue, timerId, delayMs, op, removalCallback) {\n        var targetTime = Date.now() + delayMs;\n        var delayedOp = new DelayedOperation(asyncQueue, timerId, targetTime, op, removalCallback);\n        delayedOp.start(delayMs);\n        return delayedOp;\n    };\n    /**\n     * Starts the timer. This is called immediately after construction by\n     * createAndSchedule().\n     */\n    DelayedOperation.prototype.start = function (delayMs) {\n        var _this = this;\n        this.timerHandle = setTimeout(function () { return _this.handleDelayElapsed(); }, delayMs);\n    };\n    /**\n     * Queues the operation to run immediately (if it hasn't already been run or\n     * canceled).\n     */\n    DelayedOperation.prototype.skipDelay = function () {\n        return this.handleDelayElapsed();\n    };\n    /**\n     * Cancels the operation if it hasn't already been executed or canceled. The\n     * promise will be rejected.\n     *\n     * As long as the operation has not yet been run, calling cancel() provides a\n     * guarantee that the operation will not be run.\n     */\n    DelayedOperation.prototype.cancel = function (reason) {\n        if (this.timerHandle !== null) {\n            this.clearTimeout();\n            this.deferred.reject(new FirestoreError(Code.CANCELLED, 'Operation cancelled' + (reason ? ': ' + reason : '')));\n        }\n    };\n    DelayedOperation.prototype.handleDelayElapsed = function () {\n        var _this = this;\n        this.asyncQueue.enqueue(function () {\n            if (_this.timerHandle !== null) {\n                _this.clearTimeout();\n                return _this.op().then(function (result) {\n                    return _this.deferred.resolve(result);\n                });\n            }\n            else {\n                return Promise.resolve();\n            }\n        });\n    };\n    DelayedOperation.prototype.clearTimeout = function () {\n        if (this.timerHandle !== null) {\n            this.removalCallback(this);\n            clearTimeout(this.timerHandle);\n            this.timerHandle = null;\n        }\n    };\n    return DelayedOperation;\n}());\nvar AsyncQueue = /** @class */ (function () {\n    function AsyncQueue() {\n        // The last promise in the queue.\n        this.tail = Promise.resolve();\n        // Operations scheduled to be queued in the future. Operations are\n        // automatically removed after they are run or canceled.\n        this.delayedOperations = [];\n        // Flag set while there's an outstanding AsyncQueue operation, used for\n        // assertion sanity-checks.\n        this.operationInProgress = false;\n    }\n    /**\n     * Adds a new operation to the queue. Returns a promise that will be resolved\n     * when the promise returned by the new operation is (with its value).\n     */\n    AsyncQueue.prototype.enqueue = function (op) {\n        var _this = this;\n        this.verifyNotFailed();\n        var newTail = this.tail.then(function () {\n            _this.operationInProgress = true;\n            return op()\n                .catch(function (error) {\n                _this.failure = error;\n                _this.operationInProgress = false;\n                var message = error.stack || error.message || '';\n                log.error('INTERNAL UNHANDLED ERROR: ', message);\n                // Escape the promise chain and throw the error globally so that\n                // e.g. any global crash reporting library detects and reports it.\n                // (but not for simulated errors in our tests since this breaks mocha)\n                if (message.indexOf('Firestore Test Simulated Error') < 0) {\n                    setTimeout(function () {\n                        throw error;\n                    }, 0);\n                }\n                // Re-throw the error so that this.tail becomes a rejected Promise and\n                // all further attempts to chain (via .then) will just short-circuit\n                // and return the rejected Promise.\n                throw error;\n            })\n                .then(function (result) {\n                _this.operationInProgress = false;\n                return result;\n            });\n        });\n        this.tail = newTail;\n        return newTail;\n    };\n    /**\n     * Schedules an operation to be queued on the AsyncQueue once the specified\n     * `delayMs` has elapsed. The returned CancelablePromise can be used to cancel\n     * the operation prior to its running.\n     */\n    AsyncQueue.prototype.enqueueAfterDelay = function (timerId, delayMs, op) {\n        var _this = this;\n        this.verifyNotFailed();\n        // While not necessarily harmful, we currently don't expect to have multiple\n        // ops with the same timer id in the queue, so defensively reject them.\n        assert(!this.containsDelayedOperation(timerId), \"Attempted to schedule multiple operations with timer id \" + timerId + \".\");\n        var delayedOp = DelayedOperation.createAndSchedule(this, timerId, delayMs, op, function (op) { return _this.removeDelayedOperation(op); });\n        this.delayedOperations.push(delayedOp);\n        return delayedOp;\n    };\n    AsyncQueue.prototype.verifyNotFailed = function () {\n        if (this.failure) {\n            fail('AsyncQueue is already failed: ' +\n                (this.failure.stack || this.failure.message));\n        }\n    };\n    /**\n     * Verifies there's an operation currently in-progress on the AsyncQueue.\n     * Unfortunately we can't verify that the running code is in the promise chain\n     * of that operation, so this isn't a foolproof check, but it should be enough\n     * to catch some bugs.\n     */\n    AsyncQueue.prototype.verifyOperationInProgress = function () {\n        assert(this.operationInProgress, 'verifyOpInProgress() called when no op in progress on this queue.');\n    };\n    /**\n     * Waits until all currently queued tasks are finished executing. Delayed\n     * operations are not run.\n     */\n    AsyncQueue.prototype.drain = function () {\n        return this.enqueue(function () { return Promise.resolve(); });\n    };\n    /**\n     * For Tests: Determine if a delayed operation with a particular TimerId\n     * exists.\n     */\n    AsyncQueue.prototype.containsDelayedOperation = function (timerId) {\n        return this.delayedOperations.findIndex(function (op) { return op.timerId === timerId; }) >= 0;\n    };\n    /**\n     * For Tests: Runs some or all delayed operations early.\n     *\n     * @param lastTimerId Delayed operations up to and including this TimerId will\n     *  be drained. Throws if no such operation exists. Pass TimerId.All to run\n     *  all delayed operations.\n     * @returns a Promise that resolves once all operations have been run.\n     */\n    AsyncQueue.prototype.runDelayedOperationsEarly = function (lastTimerId) {\n        var _this = this;\n        // Note that draining may generate more delayed ops, so we do that first.\n        return this.drain().then(function () {\n            assert(lastTimerId === TimerId.All ||\n                _this.containsDelayedOperation(lastTimerId), \"Attempted to drain to missing operation \" + lastTimerId);\n            // Run ops in the same order they'd run if they ran naturally.\n            _this.delayedOperations.sort(function (a, b) { return a.targetTimeMs - b.targetTimeMs; });\n            for (var _i = 0, _a = _this.delayedOperations; _i < _a.length; _i++) {\n                var op = _a[_i];\n                op.skipDelay();\n                if (lastTimerId !== TimerId.All && op.timerId === lastTimerId) {\n                    break;\n                }\n            }\n            return _this.drain();\n        });\n    };\n    /** Called once a DelayedOperation is run or canceled. */\n    AsyncQueue.prototype.removeDelayedOperation = function (op) {\n        // NOTE: indexOf / slice are O(n), but delayedOperations is expected to be small.\n        var index = this.delayedOperations.indexOf(op);\n        assert(index >= 0, 'Delayed operation not found.');\n        this.delayedOperations.splice(index, 1);\n    };\n    return AsyncQueue;\n}());\nexport { AsyncQueue };\n\n//# sourceMappingURL=async_queue.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/async_queue.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EagerGarbageCollector } from '../local/eager_garbage_collector';\nimport { LocalViewChanges } from '../local/local_view_changes';\nimport { QueryData, QueryPurpose } from '../local/query_data';\nimport { ReferenceSet } from '../local/reference_set';\nimport { NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { CurrentStatusUpdate, RemoteEvent } from '../remote/remote_event';\nimport { assert, fail } from '../util/assert';\nimport * as log from '../util/log';\nimport { primitiveComparator } from '../util/misc';\nimport * as objUtils from '../util/obj';\nimport { ObjectMap } from '../util/obj_map';\nimport { SortedMap } from '../util/sorted_map';\nimport { isNullOrUndefined } from '../util/types';\nimport { Query } from './query';\nimport { SnapshotVersion } from './snapshot_version';\nimport { TargetIdGenerator } from './target_id_generator';\nimport { AddedLimboDocument, RemovedLimboDocument, View } from './view';\nvar LOG_TAG = 'SyncEngine';\n/**\n * QueryView contains all of the data that SyncEngine needs to keep track of for\n * a particular query.\n */\nvar QueryView = /** @class */ (function () {\n    function QueryView(\n    /**\n     * The query itself.\n     */\n    query, \n    /**\n     * The target number created by the client that is used in the watch\n     * stream to identify this query.\n     */\n    targetId, \n    /**\n     * An identifier from the datastore backend that indicates the last state\n     * of the results that was received. This can be used to indicate where\n     * to continue receiving new doc changes for the query.\n     */\n    resumeToken, \n    /**\n     * The view is responsible for computing the final merged truth of what\n     * docs are in the query. It gets notified of local and remote changes,\n     * and applies the query filters and limits to determine the most correct\n     * possible results.\n     */\n    view) {\n        this.query = query;\n        this.targetId = targetId;\n        this.resumeToken = resumeToken;\n        this.view = view;\n    }\n    return QueryView;\n}());\n/**\n * SyncEngine is the central controller in the client SDK architecture. It is\n * the glue code between the EventManager, LocalStore, and RemoteStore. Some of\n * SyncEngine's responsibilities include:\n * 1. Coordinating client requests and remote events between the EventManager\n *    and the local and remote data stores.\n * 2. Managing a View object for each query, providing the unified view between\n *    the local and remote data stores.\n * 3. Notifying the RemoteStore when the LocalStore has new mutations in its\n *    queue that need sending to the backend.\n *\n * The SyncEngines methods should only ever be called by methods running in the\n * global async queue.\n */\nvar SyncEngine = /** @class */ (function () {\n    function SyncEngine(localStore, remoteStore, currentUser) {\n        this.localStore = localStore;\n        this.remoteStore = remoteStore;\n        this.currentUser = currentUser;\n        this.viewHandler = null;\n        this.errorHandler = null;\n        this.queryViewsByQuery = new ObjectMap(function (q) {\n            return q.canonicalId();\n        });\n        this.queryViewsByTarget = {};\n        this.limboTargetsByKey = new SortedMap(DocumentKey.comparator);\n        this.limboKeysByTarget = {};\n        this.limboDocumentRefs = new ReferenceSet();\n        this.limboCollector = new EagerGarbageCollector();\n        /** Stores user completion handlers, indexed by User and BatchId. */\n        this.mutationUserCallbacks = {};\n        this.targetIdGenerator = TargetIdGenerator.forSyncEngine();\n    }\n    /** Subscribes view and error handler. Can be called only once. */\n    SyncEngine.prototype.subscribe = function (viewHandler, errorHandler) {\n        assert(viewHandler !== null && errorHandler !== null, 'View and error handlers cannot be null');\n        assert(this.viewHandler === null && this.errorHandler === null, 'SyncEngine already has a subscriber.');\n        this.viewHandler = viewHandler;\n        this.errorHandler = errorHandler;\n        this.limboCollector.addGarbageSource(this.limboDocumentRefs);\n    };\n    /**\n     * Initiates the new listen, resolves promise when listen enqueued to the\n     * server. All the subsequent view snapshots or errors are sent to the\n     * subscribed handlers. Returns the targetId of the query.\n     */\n    SyncEngine.prototype.listen = function (query) {\n        var _this = this;\n        this.assertSubscribed('listen()');\n        assert(!this.queryViewsByQuery.has(query), 'We already listen to the query: ' + query);\n        return this.localStore.allocateQuery(query).then(function (queryData) {\n            return _this.localStore\n                .executeQuery(query)\n                .then(function (docs) {\n                return _this.localStore\n                    .remoteDocumentKeys(queryData.targetId)\n                    .then(function (remoteKeys) {\n                    var view = new View(query, remoteKeys);\n                    var viewDocChanges = view.computeDocChanges(docs);\n                    var viewChange = view.applyChanges(viewDocChanges);\n                    assert(viewChange.limboChanges.length === 0, 'View returned limbo docs before target ack from the server.');\n                    assert(!!viewChange.snapshot, 'applyChanges for new view should always return a snapshot');\n                    var data = new QueryView(query, queryData.targetId, queryData.resumeToken, view);\n                    _this.queryViewsByQuery.set(query, data);\n                    _this.queryViewsByTarget[queryData.targetId] = data;\n                    _this.viewHandler([viewChange.snapshot]);\n                    _this.remoteStore.listen(queryData);\n                });\n            })\n                .then(function () {\n                return queryData.targetId;\n            });\n        });\n    };\n    /** Stops listening to the query. */\n    SyncEngine.prototype.unlisten = function (query) {\n        var _this = this;\n        this.assertSubscribed('unlisten()');\n        var queryView = this.queryViewsByQuery.get(query);\n        assert(!!queryView, 'Trying to unlisten on query not found:' + query);\n        return this.localStore.releaseQuery(query).then(function () {\n            _this.remoteStore.unlisten(queryView.targetId);\n            return _this.removeAndCleanupQuery(queryView).then(function () {\n                return _this.localStore.collectGarbage();\n            });\n        });\n    };\n    /**\n     * Initiates the write of local mutation batch which involves adding the\n     * writes to the mutation queue, notifying the remote store about new\n     * mutations and raising events for any changes this write caused.\n     *\n     * The promise returned by this call is resolved when the above steps\n     * have completed, *not* when the write was acked by the backend. The\n     * userCallback is resolved once the write was acked/rejected by the\n     * backend (or failed locally for any other reason).\n     */\n    SyncEngine.prototype.write = function (batch, userCallback) {\n        var _this = this;\n        this.assertSubscribed('write()');\n        return this.localStore\n            .localWrite(batch)\n            .then(function (result) {\n            _this.addMutationCallback(result.batchId, userCallback);\n            return _this.emitNewSnapsAndNotifyLocalStore(result.changes);\n        })\n            .then(function () {\n            return _this.remoteStore.fillWritePipeline();\n        });\n    };\n    // TODO(klimt): Wrap the given error in a standard Firestore error object.\n    SyncEngine.prototype.wrapUpdateFunctionError = function (error) {\n        return error;\n    };\n    /**\n     * Takes an updateFunction in which a set of reads and writes can be performed\n     * atomically. In the updateFunction, the client can read and write values\n     * using the supplied transaction object. After the updateFunction, all\n     * changes will be committed. If some other client has changed any of the data\n     * referenced, then the updateFunction will be called again. If the\n     * updateFunction still fails after the given number of retries, then the\n     * transaction will be rejection.\n     *\n     * The transaction object passed to the updateFunction contains methods for\n     * accessing documents and collections. Unlike other datastore access, data\n     * accessed with the transaction will not reflect local changes that have not\n     * been committed. For this reason, it is required that all reads are\n     * performed before any writes. Transactions must be performed while online.\n     *\n     * The promise returned is resolved when the transaction is fully committed.\n     */\n    SyncEngine.prototype.runTransaction = function (updateFunction, retries) {\n        var _this = this;\n        if (retries === void 0) { retries = 5; }\n        assert(retries >= 0, 'Got negative number of retries for transaction.');\n        var transaction = this.remoteStore.createTransaction();\n        var wrappedUpdateFunction = function () {\n            try {\n                var userPromise = updateFunction(transaction);\n                if (isNullOrUndefined(userPromise) ||\n                    !userPromise.catch ||\n                    !userPromise.then) {\n                    return Promise.reject(Error('Transaction callback must return a Promise'));\n                }\n                return userPromise.catch(function (e) {\n                    return Promise.reject(_this.wrapUpdateFunctionError(e));\n                });\n            }\n            catch (e) {\n                return Promise.reject(_this.wrapUpdateFunctionError(e));\n            }\n        };\n        return wrappedUpdateFunction().then(function (result) {\n            return transaction\n                .commit()\n                .then(function () {\n                return result;\n            })\n                .catch(function (error) {\n                if (retries === 0) {\n                    return Promise.reject(error);\n                }\n                // TODO(klimt): Put in a retry delay?\n                return _this.runTransaction(updateFunction, retries - 1);\n            });\n        });\n    };\n    SyncEngine.prototype.applyRemoteEvent = function (remoteEvent) {\n        var _this = this;\n        this.assertSubscribed('applyRemoteEvent()');\n        // Make sure limbo documents are deleted if there were no results\n        objUtils.forEachNumber(remoteEvent.targetChanges, function (targetId, targetChange) {\n            var limboKey = _this.limboKeysByTarget[targetId];\n            if (limboKey &&\n                targetChange.currentStatusUpdate ===\n                    CurrentStatusUpdate.MarkCurrent &&\n                !remoteEvent.documentUpdates.get(limboKey)) {\n                // When listening to a query the server responds with a snapshot\n                // containing documents matching the query and a current marker\n                // telling us we're now in sync. It's possible for these to arrive\n                // as separate remote events or as a single remote event.\n                // For a document query, there will be no documents sent in the\n                // response if the document doesn't exist.\n                //\n                // If the snapshot arrives separately from the current marker,\n                // we handle it normally and updateTrackedLimbos will resolve the\n                // limbo status of the document, removing it from limboDocumentRefs.\n                // This works because clients only initiate limbo resolution when\n                // a target is current and because all current targets are\n                // always at a consistent snapshot.\n                //\n                // However, if the document doesn't exist and the current marker\n                // arrives, the document is not present in the snapshot and our\n                // normal view handling would consider the document to remain in\n                // limbo indefinitely because there are no updates to the document.\n                // To avoid this, we specially handle this just this case here:\n                // synthesizing a delete.\n                //\n                // TODO(dimond): Ideally we would have an explicit lookup query\n                // instead resulting in an explicit delete message and we could\n                // remove this special logic.\n                remoteEvent.addDocumentUpdate(new NoDocument(limboKey, remoteEvent.snapshotVersion));\n            }\n        });\n        return this.localStore.applyRemoteEvent(remoteEvent).then(function (changes) {\n            return _this.emitNewSnapsAndNotifyLocalStore(changes, remoteEvent);\n        });\n    };\n    /**\n     * Applies an OnlineState change to the sync engine and notifies any views of\n     * the change.\n     */\n    SyncEngine.prototype.applyOnlineStateChange = function (onlineState) {\n        var newViewSnapshots = [];\n        this.queryViewsByQuery.forEach(function (query, queryView) {\n            var viewChange = queryView.view.applyOnlineStateChange(onlineState);\n            assert(viewChange.limboChanges.length === 0, 'OnlineState should not affect limbo documents.');\n            if (viewChange.snapshot) {\n                newViewSnapshots.push(viewChange.snapshot);\n            }\n        });\n        this.viewHandler(newViewSnapshots);\n    };\n    SyncEngine.prototype.rejectListen = function (targetId, err) {\n        var _this = this;\n        this.assertSubscribed('rejectListens()');\n        var limboKey = this.limboKeysByTarget[targetId];\n        if (limboKey) {\n            // Since this query failed, we won't want to manually unlisten to it.\n            // So go ahead and remove it from bookkeeping.\n            this.limboTargetsByKey = this.limboTargetsByKey.remove(limboKey);\n            delete this.limboKeysByTarget[targetId];\n            // TODO(klimt): We really only should do the following on permission\n            // denied errors, but we don't have the cause code here.\n            // It's a limbo doc. Create a synthetic event saying it was deleted.\n            // This is kind of a hack. Ideally, we would have a method in the local\n            // store to purge a document. However, it would be tricky to keep all of\n            // the local store's invariants with another method.\n            var docMap = new SortedMap(DocumentKey.comparator);\n            docMap = docMap.insert(limboKey, new NoDocument(limboKey, SnapshotVersion.forDeletedDoc()));\n            var event_1 = new RemoteEvent(SnapshotVersion.MIN, {}, docMap);\n            return this.applyRemoteEvent(event_1);\n        }\n        else {\n            var queryView_1 = this.queryViewsByTarget[targetId];\n            assert(!!queryView_1, 'Unknown targetId: ' + targetId);\n            return this.localStore.releaseQuery(queryView_1.query).then(function () {\n                return _this.removeAndCleanupQuery(queryView_1).then(function () {\n                    _this.errorHandler(queryView_1.query, err);\n                });\n            });\n        }\n    };\n    SyncEngine.prototype.applySuccessfulWrite = function (mutationBatchResult) {\n        var _this = this;\n        this.assertSubscribed('applySuccessfulWrite()');\n        // The local store may or may not be able to apply the write result and\n        // raise events immediately (depending on whether the watcher is caught\n        // up), so we raise user callbacks first so that they consistently happen\n        // before listen events.\n        this.processUserCallback(mutationBatchResult.batch.batchId, \n        /*error=*/ null);\n        return this.localStore\n            .acknowledgeBatch(mutationBatchResult)\n            .then(function (changes) {\n            return _this.emitNewSnapsAndNotifyLocalStore(changes);\n        });\n    };\n    SyncEngine.prototype.rejectFailedWrite = function (batchId, error) {\n        var _this = this;\n        this.assertSubscribed('rejectFailedWrite()');\n        // The local store may or may not be able to apply the write result and\n        // raise events immediately (depending on whether the watcher is caught up),\n        // so we raise user callbacks first so that they consistently happen before\n        // listen events.\n        this.processUserCallback(batchId, error);\n        return this.localStore.rejectBatch(batchId).then(function (changes) {\n            return _this.emitNewSnapsAndNotifyLocalStore(changes);\n        });\n    };\n    SyncEngine.prototype.addMutationCallback = function (batchId, callback) {\n        var newCallbacks = this.mutationUserCallbacks[this.currentUser.toKey()];\n        if (!newCallbacks) {\n            newCallbacks = new SortedMap(primitiveComparator);\n        }\n        newCallbacks = newCallbacks.insert(batchId, callback);\n        this.mutationUserCallbacks[this.currentUser.toKey()] = newCallbacks;\n    };\n    /**\n     * Resolves or rejects the user callback for the given batch and then discards\n     * it.\n     */\n    SyncEngine.prototype.processUserCallback = function (batchId, error) {\n        var newCallbacks = this.mutationUserCallbacks[this.currentUser.toKey()];\n        // NOTE: Mutations restored from persistence won't have callbacks, so it's\n        // okay for there to be no callback for this ID.\n        if (newCallbacks) {\n            var callback = newCallbacks.get(batchId);\n            if (callback) {\n                assert(batchId === newCallbacks.minKey(), 'Mutation callbacks processed out-of-order?');\n                if (error) {\n                    callback.reject(error);\n                }\n                else {\n                    callback.resolve();\n                }\n                newCallbacks = newCallbacks.remove(batchId);\n            }\n            this.mutationUserCallbacks[this.currentUser.toKey()] = newCallbacks;\n        }\n    };\n    SyncEngine.prototype.removeAndCleanupQuery = function (queryView) {\n        this.queryViewsByQuery.delete(queryView.query);\n        delete this.queryViewsByTarget[queryView.targetId];\n        this.limboDocumentRefs.removeReferencesForId(queryView.targetId);\n        return this.gcLimboDocuments();\n    };\n    SyncEngine.prototype.updateTrackedLimbos = function (targetId, limboChanges) {\n        for (var _i = 0, limboChanges_1 = limboChanges; _i < limboChanges_1.length; _i++) {\n            var limboChange = limboChanges_1[_i];\n            if (limboChange instanceof AddedLimboDocument) {\n                this.limboDocumentRefs.addReference(limboChange.key, targetId);\n                this.trackLimboChange(limboChange);\n            }\n            else if (limboChange instanceof RemovedLimboDocument) {\n                log.debug(LOG_TAG, 'Document no longer in limbo: ' + limboChange.key);\n                this.limboDocumentRefs.removeReference(limboChange.key, targetId);\n            }\n            else {\n                fail('Unknown limbo change: ' + JSON.stringify(limboChange));\n            }\n        }\n        return this.gcLimboDocuments();\n    };\n    SyncEngine.prototype.trackLimboChange = function (limboChange) {\n        var key = limboChange.key;\n        if (!this.limboTargetsByKey.get(key)) {\n            log.debug(LOG_TAG, 'New document in limbo: ' + key);\n            var limboTargetId = this.targetIdGenerator.next();\n            var query = Query.atPath(key.path);\n            this.limboKeysByTarget[limboTargetId] = key;\n            this.remoteStore.listen(new QueryData(query, limboTargetId, QueryPurpose.Listen));\n            this.limboTargetsByKey = this.limboTargetsByKey.insert(key, limboTargetId);\n        }\n    };\n    SyncEngine.prototype.gcLimboDocuments = function () {\n        var _this = this;\n        // HACK: We can use a null transaction here, because we know that the\n        // reference set is entirely within memory and doesn't need a store engine.\n        return this.limboCollector\n            .collectGarbage(null)\n            .next(function (keys) {\n            keys.forEach(function (key) {\n                var limboTargetId = _this.limboTargetsByKey.get(key);\n                if (limboTargetId === null) {\n                    // This target already got removed, because the query failed.\n                    return;\n                }\n                _this.remoteStore.unlisten(limboTargetId);\n                _this.limboTargetsByKey = _this.limboTargetsByKey.remove(key);\n                delete _this.limboKeysByTarget[limboTargetId];\n            });\n        })\n            .toPromise();\n    };\n    // Visible for testing\n    SyncEngine.prototype.currentLimboDocs = function () {\n        return this.limboTargetsByKey;\n    };\n    SyncEngine.prototype.emitNewSnapsAndNotifyLocalStore = function (changes, remoteEvent) {\n        var _this = this;\n        var newSnaps = [];\n        var docChangesInAllViews = [];\n        var queriesProcessed = [];\n        this.queryViewsByQuery.forEach(function (_, queryView) {\n            queriesProcessed.push(Promise.resolve()\n                .then(function () {\n                var viewDocChanges = queryView.view.computeDocChanges(changes);\n                if (!viewDocChanges.needsRefill) {\n                    return viewDocChanges;\n                }\n                // The query has a limit and some docs were removed, so we need\n                // to re-run the query against the local store to make sure we\n                // didn't lose any good docs that had been past the limit.\n                return _this.localStore.executeQuery(queryView.query).then(function (docs) {\n                    return queryView.view.computeDocChanges(docs, viewDocChanges);\n                });\n            })\n                .then(function (viewDocChanges) {\n                var targetChange = remoteEvent && remoteEvent.targetChanges[queryView.targetId];\n                var viewChange = queryView.view.applyChanges(viewDocChanges, targetChange);\n                return _this.updateTrackedLimbos(queryView.targetId, viewChange.limboChanges).then(function () {\n                    if (viewChange.snapshot) {\n                        newSnaps.push(viewChange.snapshot);\n                        var docChanges = LocalViewChanges.fromSnapshot(viewChange.snapshot);\n                        docChangesInAllViews.push(docChanges);\n                    }\n                });\n            }));\n        });\n        return Promise.all(queriesProcessed)\n            .then(function () {\n            _this.viewHandler(newSnaps);\n            return _this.localStore.notifyLocalViewChanges(docChangesInAllViews);\n        })\n            .then(function () {\n            return _this.localStore.collectGarbage();\n        });\n    };\n    SyncEngine.prototype.assertSubscribed = function (fnName) {\n        assert(this.viewHandler !== null && this.errorHandler !== null, 'Trying to call ' + fnName + ' before calling subscribe().');\n    };\n    SyncEngine.prototype.handleUserChange = function (user) {\n        var _this = this;\n        this.currentUser = user;\n        return this.localStore\n            .handleUserChange(user)\n            .then(function (changes) {\n            return _this.emitNewSnapsAndNotifyLocalStore(changes);\n        })\n            .then(function () {\n            return _this.remoteStore.handleUserChange(user);\n        });\n    };\n    return SyncEngine;\n}());\nexport { SyncEngine };\n\n//# sourceMappingURL=sync_engine.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/core/sync_engine.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { documentKeySet, documentVersionMap } from './collections';\nimport { assert } from '../util/assert';\nimport * as misc from '../util/misc';\nexport var BATCHID_UNKNOWN = -1;\n/**\n * A batch of mutations that will be sent as one unit to the backend.\n */\nvar MutationBatch = /** @class */ (function () {\n    function MutationBatch(batchId, localWriteTime, mutations) {\n        this.batchId = batchId;\n        this.localWriteTime = localWriteTime;\n        this.mutations = mutations;\n    }\n    /**\n     * Applies all the mutations in this MutationBatch to the specified document\n     * to create a new remote document\n     *\n     * @param docKey The key of the document to apply mutations to.\n     * @param maybeDoc The document to apply mutations to.\n     * @param batchResult The result of applying the MutationBatch to the\n     * backend.\n     */\n    MutationBatch.prototype.applyToRemoteDocument = function (docKey, maybeDoc, batchResult) {\n        if (maybeDoc) {\n            assert(maybeDoc.key.isEqual(docKey), \"applyToRemoteDocument: key \" + docKey + \" should match maybeDoc key\\n        \" + maybeDoc.key);\n        }\n        var mutationResults = batchResult.mutationResults;\n        assert(mutationResults.length === this.mutations.length, \"Mismatch between mutations length\\n      (\" + this.mutations.length + \") and mutation results length\\n      (\" + mutationResults.length + \").\");\n        for (var i = 0; i < this.mutations.length; i++) {\n            var mutation = this.mutations[i];\n            if (mutation.key.isEqual(docKey)) {\n                var mutationResult = mutationResults[i];\n                maybeDoc = mutation.applyToRemoteDocument(maybeDoc, mutationResult);\n            }\n        }\n        return maybeDoc;\n    };\n    /**\n     * Computes the local view of a document given all the mutations in this\n     * batch.\n     *\n     * @param docKey The key of the document to apply mutations to.\n     * @param maybeDoc The document to apply mutations to.\n     */\n    MutationBatch.prototype.applyToLocalView = function (docKey, maybeDoc) {\n        if (maybeDoc) {\n            assert(maybeDoc.key.isEqual(docKey), \"applyToLocalDocument: key \" + docKey + \" should match maybeDoc key\\n        \" + maybeDoc.key);\n        }\n        var baseDoc = maybeDoc;\n        for (var i = 0; i < this.mutations.length; i++) {\n            var mutation = this.mutations[i];\n            if (mutation.key.isEqual(docKey)) {\n                maybeDoc = mutation.applyToLocalView(maybeDoc, baseDoc, this.localWriteTime);\n            }\n        }\n        return maybeDoc;\n    };\n    MutationBatch.prototype.keys = function () {\n        var keySet = documentKeySet();\n        for (var _i = 0, _a = this.mutations; _i < _a.length; _i++) {\n            var mutation = _a[_i];\n            keySet = keySet.add(mutation.key);\n        }\n        return keySet;\n    };\n    MutationBatch.prototype.isEqual = function (other) {\n        return (this.batchId === other.batchId &&\n            misc.arrayEquals(this.mutations, other.mutations));\n    };\n    /**\n     * Returns true if this mutation batch has already been removed from the\n     * mutation queue.\n     *\n     * Note that not all implementations of the MutationQueue necessarily use\n     * tombstones as part of their implementation and generally speaking no code\n     * outside the mutation queues should really care about this.\n     */\n    MutationBatch.prototype.isTombstone = function () {\n        return this.mutations.length === 0;\n    };\n    /** Converts this batch into a tombstone */\n    MutationBatch.prototype.toTombstone = function () {\n        return new MutationBatch(this.batchId, this.localWriteTime, []);\n    };\n    return MutationBatch;\n}());\nexport { MutationBatch };\n/** The result of applying a mutation batch to the backend. */\nvar MutationBatchResult = /** @class */ (function () {\n    function MutationBatchResult(batch, commitVersion, mutationResults, streamToken, \n    /**\n     * A pre-computed mapping from each mutated document to the resulting\n     * version.\n     */\n    docVersions) {\n        this.batch = batch;\n        this.commitVersion = commitVersion;\n        this.mutationResults = mutationResults;\n        this.streamToken = streamToken;\n        this.docVersions = docVersions;\n    }\n    /**\n     * Creates a new MutationBatchResult for the given batch and results. There\n     * must be one result for each mutation in the batch. This static factory\n     * caches a document=>version mapping (docVersions).\n     */\n    MutationBatchResult.from = function (batch, commitVersion, results, streamToken) {\n        assert(batch.mutations.length === results.length, 'Mutations sent ' +\n            batch.mutations.length +\n            ' must equal results received ' +\n            results.length);\n        var versionMap = documentVersionMap();\n        var mutations = batch.mutations;\n        for (var i = 0; i < mutations.length; i++) {\n            var version = results[i].version;\n            if (version === null) {\n                // deletes don't have a version, so we substitute the commitVersion\n                // of the entire batch.\n                version = commitVersion;\n            }\n            versionMap = versionMap.insert(mutations[i].key, version);\n        }\n        return new MutationBatchResult(batch, commitVersion, results, streamToken, versionMap);\n    };\n    return MutationBatchResult;\n}());\nexport { MutationBatchResult };\n\n//# sourceMappingURL=mutation_batch.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/model/mutation_batch.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert';\nimport { Code, FirestoreError } from '../util/error';\nimport * as log from '../util/log';\nimport { AutoId } from '../util/misc';\nimport { IndexedDbMutationQueue } from './indexeddb_mutation_queue';\nimport { IndexedDbQueryCache } from './indexeddb_query_cache';\nimport { IndexedDbRemoteDocumentCache } from './indexeddb_remote_document_cache';\nimport { ALL_STORES, createOrUpgradeDb, DbOwner, SCHEMA_VERSION } from './indexeddb_schema';\nimport { LocalSerializer } from './local_serializer';\nimport { PersistencePromise } from './persistence_promise';\nimport { SimpleDb } from './simple_db';\nvar LOG_TAG = 'IndexedDbPersistence';\n/** If the owner lease is older than 5 seconds, try to take ownership. */\nvar OWNER_LEASE_MAX_AGE_MS = 5000;\n/** Refresh the owner lease every 4 seconds while owner. */\nvar OWNER_LEASE_REFRESH_INTERVAL_MS = 4000;\n/** LocalStorage location to indicate a zombied ownerId (see class comment). */\nvar ZOMBIE_OWNER_LOCALSTORAGE_SUFFIX = 'zombiedOwnerId';\n/** Error when the owner lease cannot be acquired or is lost. */\nvar EXISTING_OWNER_ERROR_MSG = 'There is another tab open with offline' +\n    ' persistence enabled. Only one such tab is allowed at a time. The' +\n    ' other tab must be closed or persistence must be disabled.';\nvar UNSUPPORTED_PLATFORM_ERROR_MSG = 'This platform is either missing' +\n    ' IndexedDB or is known to have an incomplete implementation. Offline' +\n    ' persistence has been disabled.';\n/**\n * An IndexedDB-backed instance of Persistence. Data is stored persistently\n * across sessions.\n *\n * Currently the Firestore SDK only supports a single consumer of the database,\n * but browsers obviously support multiple tabs. IndexedDbPersistence ensures a\n * single consumer of the database via an \"owner lease\" stored in the database.\n *\n * On startup, IndexedDbPersistence assigns itself a random \"ownerId\" and writes\n * it to a special \"owner\" object in the database (if no entry exists already or\n * the current entry is expired). This owner lease is then verified inside every\n * transaction to ensure the lease has not been lost.\n *\n * If a tab opts not to acquire the owner lease (because there's an existing\n * non-expired owner) or loses the owner lease, IndexedDbPersistence enters a\n * failed state and all subsequent operations will automatically fail.\n *\n * The current owner regularly refreshes the owner lease with new timestamps to\n * prevent newly-opened tabs from taking over ownership.\n *\n * Additionally there is an optimization so that when a tab is closed, the owner\n * lease is released immediately (this is especially important to make sure that\n * a refreshed tab is able to immediately re-acquire the owner lease).\n * Unfortunately, IndexedDB cannot be reliably used in window.unload since it is\n * an asynchronous API. So in addition to attempting to give up the lease,\n * the owner writes its ownerId to a \"zombiedOwnerId\" entry in LocalStorage\n * which acts as an indicator that another tab should go ahead and take the\n * owner lease immediately regardless of the current lease timestamp.\n */\nvar IndexedDbPersistence = /** @class */ (function () {\n    function IndexedDbPersistence(prefix, serializer) {\n        this.ownerId = this.generateOwnerId();\n        this.dbName = prefix + IndexedDbPersistence.MAIN_DATABASE;\n        this.serializer = new LocalSerializer(serializer);\n        this.localStoragePrefix = prefix;\n    }\n    IndexedDbPersistence.prototype.start = function () {\n        var _this = this;\n        if (!IndexedDbPersistence.isAvailable()) {\n            this.persistenceError = new FirestoreError(Code.UNIMPLEMENTED, UNSUPPORTED_PLATFORM_ERROR_MSG);\n            return Promise.reject(this.persistenceError);\n        }\n        assert(!this.started, 'IndexedDbPersistence double-started!');\n        this.started = true;\n        return SimpleDb.openOrCreate(this.dbName, SCHEMA_VERSION, createOrUpgradeDb)\n            .then(function (db) {\n            _this.simpleDb = db;\n        })\n            .then(function () { return _this.tryAcquireOwnerLease(); })\n            .then(function () {\n            _this.scheduleOwnerLeaseRefreshes();\n            _this.attachWindowUnloadHook();\n        });\n    };\n    IndexedDbPersistence.prototype.shutdown = function () {\n        var _this = this;\n        assert(this.started, 'IndexedDbPersistence shutdown without start!');\n        this.started = false;\n        this.detachWindowUnloadHook();\n        this.stopOwnerLeaseRefreshes();\n        return this.releaseOwnerLease().then(function () {\n            _this.simpleDb.close();\n        });\n    };\n    IndexedDbPersistence.prototype.getMutationQueue = function (user) {\n        return IndexedDbMutationQueue.forUser(user, this.serializer);\n    };\n    IndexedDbPersistence.prototype.getQueryCache = function () {\n        return new IndexedDbQueryCache(this.serializer);\n    };\n    IndexedDbPersistence.prototype.getRemoteDocumentCache = function () {\n        return new IndexedDbRemoteDocumentCache(this.serializer);\n    };\n    IndexedDbPersistence.prototype.runTransaction = function (action, operation) {\n        var _this = this;\n        if (this.persistenceError) {\n            return Promise.reject(this.persistenceError);\n        }\n        log.debug(LOG_TAG, 'Starting transaction:', action);\n        // Do all transactions as readwrite against all object stores, since we\n        // are the only reader/writer.\n        return this.simpleDb.runTransaction('readwrite', ALL_STORES, function (txn) {\n            // Verify that we still have the owner lease as part of every transaction.\n            return _this.ensureOwnerLease(txn).next(function () { return operation(txn); });\n        });\n    };\n    IndexedDbPersistence.isAvailable = function () {\n        return SimpleDb.isAvailable();\n    };\n    /**\n     * Generates a string used as a prefix when storing data in IndexedDB and\n     * LocalStorage.\n     */\n    IndexedDbPersistence.buildStoragePrefix = function (databaseInfo) {\n        // Use two different prefix formats:\n        //\n        //   * firestore / persistenceKey / projectID . databaseID / ...\n        //   * firestore / persistenceKey / projectID / ...\n        //\n        // projectIDs are DNS-compatible names and cannot contain dots\n        // so there's no danger of collisions.\n        var database = databaseInfo.databaseId.projectId;\n        if (!databaseInfo.databaseId.isDefaultDatabase) {\n            database += '.' + databaseInfo.databaseId.database;\n        }\n        return 'firestore/' + databaseInfo.persistenceKey + '/' + database + '/';\n    };\n    /**\n     * Acquires the owner lease if there's no valid owner. Else returns a rejected\n     * promise.\n     */\n    IndexedDbPersistence.prototype.tryAcquireOwnerLease = function () {\n        var _this = this;\n        // NOTE: Don't use this.runTransaction, since it requires us to already\n        // have the lease.\n        return this.simpleDb.runTransaction('readwrite', [DbOwner.store], function (txn) {\n            var store = txn.store(DbOwner.store);\n            return store.get('owner').next(function (dbOwner) {\n                if (!_this.validOwner(dbOwner)) {\n                    var newDbOwner = new DbOwner(_this.ownerId, Date.now());\n                    log.debug(LOG_TAG, 'No valid owner. Acquiring owner lease. Current owner:', dbOwner, 'New owner:', newDbOwner);\n                    return store.put('owner', newDbOwner);\n                }\n                else {\n                    log.debug(LOG_TAG, 'Valid owner already. Failing. Current owner:', dbOwner);\n                    _this.persistenceError = new FirestoreError(Code.FAILED_PRECONDITION, EXISTING_OWNER_ERROR_MSG);\n                    return PersistencePromise.reject(_this.persistenceError);\n                }\n            });\n        });\n    };\n    /** Checks the owner lease and deletes it if we are the current owner. */\n    IndexedDbPersistence.prototype.releaseOwnerLease = function () {\n        var _this = this;\n        // NOTE: Don't use this.runTransaction, since it requires us to already\n        // have the lease.\n        return this.simpleDb.runTransaction('readwrite', [DbOwner.store], function (txn) {\n            var store = txn.store(DbOwner.store);\n            return store.get('owner').next(function (dbOwner) {\n                if (dbOwner !== null && dbOwner.ownerId === _this.ownerId) {\n                    log.debug(LOG_TAG, 'Releasing owner lease.');\n                    return store.delete('owner');\n                }\n                else {\n                    return PersistencePromise.resolve();\n                }\n            });\n        });\n    };\n    /**\n     * Checks the owner lease and returns a rejected promise if we are not the\n     * current owner. This should be included in every transaction to guard\n     * against losing the owner lease.\n     */\n    IndexedDbPersistence.prototype.ensureOwnerLease = function (txn) {\n        var _this = this;\n        var store = txn.store(DbOwner.store);\n        return store.get('owner').next(function (dbOwner) {\n            if (dbOwner === null || dbOwner.ownerId !== _this.ownerId) {\n                _this.persistenceError = new FirestoreError(Code.FAILED_PRECONDITION, EXISTING_OWNER_ERROR_MSG);\n                return PersistencePromise.reject(_this.persistenceError);\n            }\n            else {\n                return PersistencePromise.resolve();\n            }\n        });\n    };\n    /**\n     * Returns true if the provided owner exists, has a recent timestamp, and\n     * isn't zombied.\n     *\n     * NOTE: To determine if the owner is zombied, this method reads from\n     * LocalStorage which could be mildly expensive.\n     */\n    IndexedDbPersistence.prototype.validOwner = function (dbOwner) {\n        var now = Date.now();\n        var minAcceptable = now - OWNER_LEASE_MAX_AGE_MS;\n        var maxAcceptable = now;\n        if (dbOwner === null) {\n            return false; // no owner.\n        }\n        else if (dbOwner.leaseTimestampMs < minAcceptable) {\n            return false; // owner lease has expired.\n        }\n        else if (dbOwner.leaseTimestampMs > maxAcceptable) {\n            log.error('Persistence owner-lease is in the future. Discarding.', dbOwner);\n            return false;\n        }\n        else if (dbOwner.ownerId === this.getZombiedOwnerId()) {\n            return false; // owner's tab closed.\n        }\n        else {\n            return true;\n        }\n    };\n    /**\n     * Schedules a recurring timer to update the owner lease timestamp to prevent\n     * other tabs from taking the lease.\n     */\n    IndexedDbPersistence.prototype.scheduleOwnerLeaseRefreshes = function () {\n        var _this = this;\n        // NOTE: This doesn't need to be scheduled on the async queue and doing so\n        // would increase the chances of us not refreshing on time if the queue is\n        // backed up for some reason.\n        this.ownerLeaseRefreshHandle = setInterval(function () {\n            var txResult = _this.runTransaction('Refresh owner timestamp', function (txn) {\n                // NOTE: We don't need to validate the current owner contents, since\n                // runTransaction does that automatically.\n                var store = txn.store(DbOwner.store);\n                return store.put('owner', new DbOwner(_this.ownerId, Date.now()));\n            });\n            txResult.catch(function (reason) {\n                // Probably means we lost the lease. Report the error and stop trying to\n                // refresh the lease.\n                log.error(reason);\n                _this.stopOwnerLeaseRefreshes();\n            });\n        }, OWNER_LEASE_REFRESH_INTERVAL_MS);\n    };\n    IndexedDbPersistence.prototype.stopOwnerLeaseRefreshes = function () {\n        if (this.ownerLeaseRefreshHandle) {\n            clearInterval(this.ownerLeaseRefreshHandle);\n            this.ownerLeaseRefreshHandle = null;\n        }\n    };\n    /**\n     * Attaches a window.unload handler that will synchronously write our\n     * ownerId to a \"zombie owner id\" location in localstorage. This can be used\n     * by tabs trying to acquire the lease to determine that the lease should be\n     * acquired immediately even if the timestamp is recent. This is particularly\n     * important for the refresh case (so the tab correctly re-acquires the owner\n     * lease). LocalStorage is used for this rather than IndexedDb because it is\n     * a synchronous API and so can be used reliably from an unload handler.\n     */\n    IndexedDbPersistence.prototype.attachWindowUnloadHook = function () {\n        var _this = this;\n        this.windowUnloadHandler = function () {\n            // Record that we're zombied.\n            _this.setZombiedOwnerId(_this.ownerId);\n            // Attempt graceful shutdown (including releasing our owner lease), but\n            // there's no guarantee it will complete.\n            _this.shutdown();\n        };\n        window.addEventListener('unload', this.windowUnloadHandler);\n    };\n    IndexedDbPersistence.prototype.detachWindowUnloadHook = function () {\n        if (this.windowUnloadHandler) {\n            window.removeEventListener('unload', this.windowUnloadHandler);\n            this.windowUnloadHandler = null;\n        }\n    };\n    /**\n     * Returns any recorded \"zombied owner\" (i.e. a previous owner that became\n     * zombied due to their tab closing) from LocalStorage, or null if no such\n     * record exists.\n     */\n    IndexedDbPersistence.prototype.getZombiedOwnerId = function () {\n        try {\n            var zombiedOwnerId = window.localStorage.getItem(this.zombiedOwnerLocalStorageKey());\n            log.debug(LOG_TAG, 'Zombied ownerID from LocalStorage:', zombiedOwnerId);\n            return zombiedOwnerId;\n        }\n        catch (e) {\n            // Gracefully handle if LocalStorage isn't available / working.\n            log.error('Failed to get zombie owner id.', e);\n            return null;\n        }\n    };\n    /**\n     * Records a zombied owner (an owner that had its tab closed) in LocalStorage\n     * or, if passed null, deletes any recorded zombied owner.\n     */\n    IndexedDbPersistence.prototype.setZombiedOwnerId = function (zombieOwnerId) {\n        try {\n            if (zombieOwnerId === null) {\n                window.localStorage.removeItem(this.zombiedOwnerLocalStorageKey());\n            }\n            else {\n                window.localStorage.setItem(this.zombiedOwnerLocalStorageKey(), zombieOwnerId);\n            }\n        }\n        catch (e) {\n            // Gracefully handle if LocalStorage isn't available / working.\n            log.error('Failed to set zombie owner id.', e);\n        }\n    };\n    IndexedDbPersistence.prototype.zombiedOwnerLocalStorageKey = function () {\n        return this.localStoragePrefix + ZOMBIE_OWNER_LOCALSTORAGE_SUFFIX;\n    };\n    IndexedDbPersistence.prototype.generateOwnerId = function () {\n        // For convenience, just use an AutoId.\n        return AutoId.newId();\n    };\n    /**\n     * The name of the main (and currently only) IndexedDB database. this name is\n     * appended to the prefix provided to the IndexedDbPersistence constructor.\n     */\n    IndexedDbPersistence.MAIN_DATABASE = 'main';\n    return IndexedDbPersistence;\n}());\nexport { IndexedDbPersistence };\n\n//# sourceMappingURL=indexeddb_persistence.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/indexeddb_persistence.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { documentKeySet, documentMap, maybeDocumentMap } from '../model/collections';\nimport { Document, NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { fail } from '../util/assert';\nimport { PersistencePromise } from './persistence_promise';\n/**\n * A readonly view of the local state of all documents we're tracking (i.e. we\n * have a cached version in remoteDocumentCache or local mutations for the\n * document). The view is computed by applying the mutations in the\n * MutationQueue to the RemoteDocumentCache.\n */\nvar LocalDocumentsView = /** @class */ (function () {\n    function LocalDocumentsView(remoteDocumentCache, mutationQueue) {\n        this.remoteDocumentCache = remoteDocumentCache;\n        this.mutationQueue = mutationQueue;\n    }\n    /**\n     * Get the local view of the document identified by `key`.\n     *\n     * @return Local view of the document or null if we don't have any cached\n     * state for it.\n     */\n    LocalDocumentsView.prototype.getDocument = function (transaction, key) {\n        var _this = this;\n        return this.remoteDocumentCache\n            .getEntry(transaction, key)\n            .next(function (remoteDoc) {\n            return _this.computeLocalDocument(transaction, key, remoteDoc);\n        });\n    };\n    /**\n     * Gets the local view of the documents identified by `keys`.\n     *\n     * If we don't have cached state for a document in `keys`, a NoDocument will\n     * be stored for that key in the resulting set.\n     */\n    LocalDocumentsView.prototype.getDocuments = function (transaction, keys) {\n        var _this = this;\n        var promises = [];\n        var results = maybeDocumentMap();\n        keys.forEach(function (key) {\n            promises.push(_this.getDocument(transaction, key).next(function (maybeDoc) {\n                // TODO(http://b/32275378): Don't conflate missing / deleted.\n                if (!maybeDoc) {\n                    maybeDoc = new NoDocument(key, SnapshotVersion.forDeletedDoc());\n                }\n                results = results.insert(key, maybeDoc);\n            }));\n        });\n        return PersistencePromise.waitFor(promises).next(function () { return results; });\n    };\n    /** Performs a query against the local view of all documents. */\n    LocalDocumentsView.prototype.getDocumentsMatchingQuery = function (transaction, query) {\n        if (DocumentKey.isDocumentKey(query.path)) {\n            return this.getDocumentsMatchingDocumentQuery(transaction, query.path);\n        }\n        else {\n            return this.getDocumentsMatchingCollectionQuery(transaction, query);\n        }\n    };\n    LocalDocumentsView.prototype.getDocumentsMatchingDocumentQuery = function (transaction, docPath) {\n        // Just do a simple document lookup.\n        return this.getDocument(transaction, new DocumentKey(docPath)).next(function (maybeDoc) {\n            var result = documentMap();\n            if (maybeDoc instanceof Document) {\n                result = result.insert(maybeDoc.key, maybeDoc);\n            }\n            return result;\n        });\n    };\n    LocalDocumentsView.prototype.getDocumentsMatchingCollectionQuery = function (transaction, query) {\n        var _this = this;\n        // Query the remote documents and overlay mutations.\n        // TODO(mikelehen): There may be significant overlap between the mutations\n        // affecting these remote documents and the\n        // getAllMutationBatchesAffectingQuery() mutations. Consider optimizing.\n        var results;\n        return this.remoteDocumentCache\n            .getDocumentsMatchingQuery(transaction, query)\n            .next(function (queryResults) {\n            return _this.computeLocalDocuments(transaction, queryResults);\n        })\n            .next(function (promisedResults) {\n            results = promisedResults;\n            // Now use the mutation queue to discover any other documents that may\n            // match the query after applying mutations.\n            return _this.mutationQueue.getAllMutationBatchesAffectingQuery(transaction, query);\n        })\n            .next(function (matchingMutationBatches) {\n            var matchingKeys = documentKeySet();\n            for (var _i = 0, matchingMutationBatches_1 = matchingMutationBatches; _i < matchingMutationBatches_1.length; _i++) {\n                var batch = matchingMutationBatches_1[_i];\n                for (var _a = 0, _b = batch.mutations; _a < _b.length; _a++) {\n                    var mutation = _b[_a];\n                    // TODO(mikelehen): PERF: Check if this mutation actually\n                    // affects the query to reduce work.\n                    if (!results.get(mutation.key)) {\n                        matchingKeys = matchingKeys.add(mutation.key);\n                    }\n                }\n            }\n            // Now add in the results for the matchingKeys.\n            var promises = [];\n            matchingKeys.forEach(function (key) {\n                promises.push(_this.getDocument(transaction, key).next(function (doc) {\n                    if (doc instanceof Document) {\n                        results = results.insert(doc.key, doc);\n                    }\n                }));\n            });\n            return PersistencePromise.waitFor(promises);\n        })\n            .next(function () {\n            // Finally, filter out any documents that don't actually match\n            // the query.\n            results.forEach(function (key, doc) {\n                if (!query.matches(doc)) {\n                    results = results.remove(key);\n                }\n            });\n            return results;\n        });\n    };\n    /**\n     * Takes a remote document and applies local mutations to generate the local\n     * view of the document.\n     * @param transaction The transaction in which to perform any persistence\n     *     operations.\n     * @param documentKey The key of the document (necessary when remoteDocument\n     *     is null).\n     * @param document The base remote document to apply mutations to or null.\n     */\n    LocalDocumentsView.prototype.computeLocalDocument = function (transaction, documentKey, document) {\n        return this.mutationQueue\n            .getAllMutationBatchesAffectingDocumentKey(transaction, documentKey)\n            .next(function (batches) {\n            for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {\n                var batch = batches_1[_i];\n                document = batch.applyToLocalView(documentKey, document);\n            }\n            return document;\n        });\n    };\n    /**\n     * Takes a set of remote documents and applies local mutations to generate the\n     * local view of the documents.\n     * @param transaction The transaction in which to perform any persistence\n     *     operations.\n     * @param documents The base remote documents to apply mutations to.\n     * @return The local view of the documents.\n     */\n    LocalDocumentsView.prototype.computeLocalDocuments = function (transaction, documents) {\n        var _this = this;\n        var promises = [];\n        documents.forEach(function (key, doc) {\n            promises.push(_this.computeLocalDocument(transaction, key, doc).next(function (mutatedDoc) {\n                if (mutatedDoc instanceof Document) {\n                    documents = documents.insert(mutatedDoc.key, mutatedDoc);\n                }\n                else if (mutatedDoc instanceof NoDocument) {\n                    documents = documents.remove(mutatedDoc.key);\n                }\n                else {\n                    fail('Unknown MaybeDocument: ' + mutatedDoc);\n                }\n            }));\n        });\n        return PersistencePromise.waitFor(promises).next(function () { return documents; });\n    };\n    return LocalDocumentsView;\n}());\nexport { LocalDocumentsView };\n\n//# sourceMappingURL=local_documents_view.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/local_documents_view.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { maybeDocumentMap } from '../model/collections';\nimport { assert } from '../util/assert';\nimport { PersistencePromise } from './persistence_promise';\n/**\n * An in-memory buffer of entries to be written to a RemoteDocumentCache.\n * It can be used to batch up a set of changes to be written to the cache, but\n * additionally supports reading entries back with the `getEntry()` method,\n * falling back to the underlying RemoteDocumentCache if no entry is\n * buffered.\n *\n * NOTE: This class was introduced in iOS to work around a limitation in\n * LevelDB. Given IndexedDb has full transaction support with\n * read-your-own-writes capability, this class is not technically needed, but\n * has been preserved as a convenience and to aid portability.\n */\nvar RemoteDocumentChangeBuffer = /** @class */ (function () {\n    function RemoteDocumentChangeBuffer(remoteDocumentCache) {\n        this.remoteDocumentCache = remoteDocumentCache;\n        this.changes = maybeDocumentMap();\n    }\n    /** Buffers a `RemoteDocumentCache.addEntry()` call. */\n    RemoteDocumentChangeBuffer.prototype.addEntry = function (maybeDocument) {\n        var changes = this.assertChanges();\n        this.changes = changes.insert(maybeDocument.key, maybeDocument);\n    };\n    // NOTE: removeEntry() is not presently necessary and so is omitted.\n    /**\n     * Looks up an entry in the cache. The buffered changes will first be checked,\n     * and if no buffered change applies, this will forward to\n     * `RemoteDocumentCache.getEntry()`.\n     *\n     * @param transaction The transaction in which to perform any persistence\n     *     operations.\n     * @param documentKey The key of the entry to look up.\n     * @return The cached Document or NoDocument entry, or null if we have nothing\n     * cached.\n     */\n    RemoteDocumentChangeBuffer.prototype.getEntry = function (transaction, documentKey) {\n        var changes = this.assertChanges();\n        var bufferedEntry = changes.get(documentKey);\n        if (bufferedEntry) {\n            return PersistencePromise.resolve(bufferedEntry);\n        }\n        else {\n            return this.remoteDocumentCache.getEntry(transaction, documentKey);\n        }\n    };\n    /**\n     * Applies buffered changes to the underlying RemoteDocumentCache, using\n     * the provided transaction.\n     */\n    RemoteDocumentChangeBuffer.prototype.apply = function (transaction) {\n        var _this = this;\n        var changes = this.assertChanges();\n        var promises = [];\n        changes.forEach(function (key, maybeDoc) {\n            promises.push(_this.remoteDocumentCache.addEntry(transaction, maybeDoc));\n        });\n        // We should not be used to buffer any more changes.\n        this.changes = null;\n        return PersistencePromise.waitFor(promises);\n    };\n    /** Helper to assert this.changes is not null and return it. */\n    RemoteDocumentChangeBuffer.prototype.assertChanges = function () {\n        assert(this.changes !== null, 'Changes have already been applied.');\n        return this.changes;\n    };\n    return RemoteDocumentChangeBuffer;\n}());\nexport { RemoteDocumentChangeBuffer };\n\n//# sourceMappingURL=remote_document_change_buffer.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/remote_document_change_buffer.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { TargetIdGenerator } from '../core/target_id_generator';\nimport { Timestamp } from '../core/timestamp';\nimport { documentKeySet } from '../model/collections';\nimport { BATCHID_UNKNOWN } from '../model/mutation_batch';\nimport { ResetMapping, UpdateMapping } from '../remote/remote_event';\nimport { assert, fail } from '../util/assert';\nimport * as log from '../util/log';\nimport * as objUtils from '../util/obj';\nimport { LocalDocumentsView } from './local_documents_view';\nimport { PersistencePromise } from './persistence_promise';\nimport { QueryData, QueryPurpose } from './query_data';\nimport { ReferenceSet } from './reference_set';\nimport { RemoteDocumentChangeBuffer } from './remote_document_change_buffer';\nvar LOG_TAG = 'LocalStore';\n/**\n * Local storage in the Firestore client. Coordinates persistence components\n * like the mutation queue and remote document cache to present a\n * latency-compensated view of stored data.\n *\n * The LocalStore is responsible for accepting mutations from the Sync Engine.\n * Writes from the client are put into a queue as provisional Mutations until\n * they are processed by the RemoteStore and confirmed as having been written\n * to the server.\n *\n * The local store provides the local version of documents that have been\n * modified locally. It maintains the constraint:\n *\n *   LocalDocument = RemoteDocument + Active(LocalMutations)\n *\n * (Active mutations are those that are enqueued and have not been previously\n * acknowledged or rejected).\n *\n * The RemoteDocument (\"ground truth\") state is provided via the\n * applyChangeBatch method. It will be some version of a server-provided\n * document OR will be a server-provided document PLUS acknowledged mutations:\n *\n *   RemoteDocument' = RemoteDocument + Acknowledged(LocalMutations)\n *\n * Note that this \"dirty\" version of a RemoteDocument will not be identical to a\n * server base version, since it has LocalMutations added to it pending getting\n * an authoritative copy from the server.\n *\n * Since LocalMutations can be rejected by the server, we have to be able to\n * revert a LocalMutation that has already been applied to the LocalDocument\n * (typically done by replaying all remaining LocalMutations to the\n * RemoteDocument to re-apply).\n *\n * The LocalStore is responsible for the garbage collection of the documents it\n * contains. For now, it every doc referenced by a view, the mutation queue, or\n * the RemoteStore.\n *\n * It also maintains the persistence of mapping queries to resume tokens and\n * target ids. It needs to know this data about queries to properly know what\n * docs it would be allowed to garbage collect.\n *\n * The LocalStore must be able to efficiently execute queries against its local\n * cache of the documents, to provide the initial set of results before any\n * remote changes have been received.\n *\n * Note: In TypeScript, most methods return Promises since the implementation\n * may rely on fetching data from IndexedDB which is async.\n * These Promises will only be rejected on an I/O error or other internal\n * (unexpected) failure (e.g. failed assert) and always represent an\n * unrecoverable error (should be caught / reported by the async_queue).\n */\nvar LocalStore = /** @class */ (function () {\n    function LocalStore(\n    /** Manages our in-memory or durable persistence. */\n    persistence, initialUser, \n    /**\n     * The garbage collector collects documents that should no longer be\n     * cached (e.g. if they are no longer retained by the above reference sets\n     * and the garbage collector is performing eager collection).\n     */\n    garbageCollector) {\n        this.persistence = persistence;\n        this.garbageCollector = garbageCollector;\n        /**\n         * The set of document references maintained by any local views.\n         */\n        this.localViewReferences = new ReferenceSet();\n        /** Maps a targetID to data about its query. */\n        this.targetIds = {};\n        /** Used to generate targetIDs for queries tracked locally. */\n        this.targetIdGenerator = TargetIdGenerator.forLocalStore();\n        /**\n         * A heldBatchResult is a mutation batch result (from a write acknowledgement)\n         * that arrived before the watch stream got notified of a snapshot that\n         * includes the write.So we \"hold\" it until the watch stream catches up. It\n         * ensures that the local write remains visible (latency compensation) and\n         * doesn't temporarily appear reverted because the watch stream is slower than\n         * the write stream and so wasn't reflecting it.\n         *\n         * NOTE: Eventually we want to move this functionality into the remote store.\n         */\n        this.heldBatchResults = [];\n        this.mutationQueue = persistence.getMutationQueue(initialUser);\n        this.remoteDocuments = persistence.getRemoteDocumentCache();\n        this.queryCache = persistence.getQueryCache();\n        this.localDocuments = new LocalDocumentsView(this.remoteDocuments, this.mutationQueue);\n        this.garbageCollector.addGarbageSource(this.localViewReferences);\n        this.garbageCollector.addGarbageSource(this.queryCache);\n        this.garbageCollector.addGarbageSource(this.mutationQueue);\n    }\n    /** Performs any initial startup actions required by the local store. */\n    LocalStore.prototype.start = function () {\n        var _this = this;\n        return this.persistence.runTransaction('Start LocalStore', function (txn) {\n            return _this.startMutationQueue(txn).next(function () { return _this.startQueryCache(txn); });\n        });\n    };\n    /**\n     * Tells the LocalStore that the currently authenticated user has changed.\n     *\n     * In response the local store switches the mutation queue to the new user and\n     * returns any resulting document changes.\n     */\n    LocalStore.prototype.handleUserChange = function (user) {\n        var _this = this;\n        return this.persistence.runTransaction('Handle user change', function (txn) {\n            // Swap out the mutation queue, grabbing the pending mutation batches\n            // before and after.\n            var oldBatches;\n            return _this.mutationQueue\n                .getAllMutationBatches(txn)\n                .next(function (promisedOldBatches) {\n                oldBatches = promisedOldBatches;\n                _this.garbageCollector.removeGarbageSource(_this.mutationQueue);\n                _this.mutationQueue = _this.persistence.getMutationQueue(user);\n                _this.garbageCollector.addGarbageSource(_this.mutationQueue);\n                return _this.startMutationQueue(txn);\n            })\n                .next(function () {\n                // Recreate our LocalDocumentsView using the new\n                // MutationQueue.\n                _this.localDocuments = new LocalDocumentsView(_this.remoteDocuments, _this.mutationQueue);\n                return _this.mutationQueue.getAllMutationBatches(txn);\n            })\n                .next(function (newBatches) {\n                // Union the old/new changed keys.\n                var changedKeys = documentKeySet();\n                for (var _i = 0, _a = [oldBatches, newBatches]; _i < _a.length; _i++) {\n                    var batches = _a[_i];\n                    for (var _b = 0, batches_1 = batches; _b < batches_1.length; _b++) {\n                        var batch = batches_1[_b];\n                        for (var _c = 0, _d = batch.mutations; _c < _d.length; _c++) {\n                            var mutation = _d[_c];\n                            changedKeys = changedKeys.add(mutation.key);\n                        }\n                    }\n                }\n                // Return the set of all (potentially) changed documents as the\n                // result of the user change.\n                return _this.localDocuments.getDocuments(txn, changedKeys);\n            });\n        });\n    };\n    LocalStore.prototype.startQueryCache = function (txn) {\n        var _this = this;\n        return this.queryCache.start(txn).next(function () {\n            var targetId = _this.queryCache.getHighestTargetId();\n            _this.targetIdGenerator = TargetIdGenerator.forLocalStore(targetId);\n        });\n    };\n    LocalStore.prototype.startMutationQueue = function (txn) {\n        var _this = this;\n        return this.mutationQueue\n            .start(txn)\n            .next(function () {\n            // If we have any leftover mutation batch results from a prior run,\n            // just drop them.\n            // TODO(http://b/33446471): We probably need to repopulate\n            // heldBatchResults or similar instead, but that is not\n            // straightforward since we're not persisting the write ack versions.\n            _this.heldBatchResults = [];\n            return _this.mutationQueue.getHighestAcknowledgedBatchId(txn);\n        })\n            .next(function (highestAck) {\n            // TODO(mikelehen): This is the only usage of\n            // getAllMutationBatchesThroughBatchId(). Consider removing it in\n            // favor of a getAcknowledgedBatches() method.\n            if (highestAck !== BATCHID_UNKNOWN) {\n                return _this.mutationQueue.getAllMutationBatchesThroughBatchId(txn, highestAck);\n            }\n            else {\n                return PersistencePromise.resolve([]);\n            }\n        })\n            .next(function (ackedBatches) {\n            if (ackedBatches.length > 0) {\n                return _this.mutationQueue.removeMutationBatches(txn, ackedBatches);\n            }\n            else {\n                return PersistencePromise.resolve();\n            }\n        });\n    };\n    /* Accept locally generated Mutations and commit them to storage. */\n    LocalStore.prototype.localWrite = function (mutations) {\n        var _this = this;\n        return this.persistence.runTransaction('Locally write mutations', function (txn) {\n            var batch;\n            var localWriteTime = Timestamp.now();\n            return _this.mutationQueue\n                .addMutationBatch(txn, localWriteTime, mutations)\n                .next(function (promisedBatch) {\n                batch = promisedBatch;\n                // TODO(koss): This is doing an N^2 update by replaying ALL the\n                // mutations on each document (instead of just the ones added) in\n                // this batch.\n                var keys = batch.keys();\n                return _this.localDocuments.getDocuments(txn, keys);\n            })\n                .next(function (changedDocuments) {\n                return { batchId: batch.batchId, changes: changedDocuments };\n            });\n        });\n    };\n    /**\n     * Acknowledge the given batch.\n     *\n     * On the happy path when a batch is acknowledged, the local store will\n     *\n     *  + remove the batch from the mutation queue;\n     *  + apply the changes to the remote document cache;\n     *  + recalculate the latency compensated view implied by those changes (there\n     *    may be mutations in the queue that affect the documents but haven't been\n     *    acknowledged yet); and\n     *  + give the changed documents back the sync engine\n     *\n     * @returns The resulting (modified) documents.\n     */\n    LocalStore.prototype.acknowledgeBatch = function (batchResult) {\n        var _this = this;\n        return this.persistence.runTransaction('Acknowledge batch', function (txn) {\n            var affected;\n            return _this.mutationQueue\n                .acknowledgeBatch(txn, batchResult.batch, batchResult.streamToken)\n                .next(function () {\n                if (_this.shouldHoldBatchResult(batchResult.commitVersion)) {\n                    _this.heldBatchResults.push(batchResult);\n                    affected = documentKeySet();\n                    return PersistencePromise.resolve();\n                }\n                else {\n                    var documentBuffer_1 = new RemoteDocumentChangeBuffer(_this.remoteDocuments);\n                    return _this.releaseBatchResults(txn, [batchResult], documentBuffer_1).next(function (promisedAffectedKeys) {\n                        affected = promisedAffectedKeys;\n                        return documentBuffer_1.apply(txn);\n                    });\n                }\n            })\n                .next(function () {\n                return _this.mutationQueue.performConsistencyCheck(txn);\n            })\n                .next(function () {\n                return _this.localDocuments.getDocuments(txn, affected);\n            });\n        });\n    };\n    /**\n     * Remove mutations from the MutationQueue for the specified batch;\n     * LocalDocuments will be recalculated.\n     *\n     * @returns The resulting modified documents.\n     */\n    LocalStore.prototype.rejectBatch = function (batchId) {\n        var _this = this;\n        return this.persistence.runTransaction('Reject batch', function (txn) {\n            var toReject;\n            var affectedKeys;\n            return _this.mutationQueue\n                .lookupMutationBatch(txn, batchId)\n                .next(function (promisedToReject) {\n                assert(promisedToReject != null, 'Attempt to reject nonexistent batch!');\n                toReject = promisedToReject;\n                return _this.mutationQueue\n                    .getHighestAcknowledgedBatchId(txn)\n                    .next(function (lastAcked) {\n                    assert(batchId > lastAcked, \"Acknowledged batches can't be rejected.\");\n                    return toReject;\n                });\n            })\n                .next(function () {\n                return _this.removeMutationBatch(txn, toReject);\n            })\n                .next(function (promisedAffectedKeys) {\n                affectedKeys = promisedAffectedKeys;\n                return _this.mutationQueue.performConsistencyCheck(txn);\n            })\n                .next(function () {\n                return _this.localDocuments.getDocuments(txn, affectedKeys);\n            });\n        });\n    };\n    /** Returns the last recorded stream token for the current user. */\n    LocalStore.prototype.getLastStreamToken = function () {\n        var _this = this;\n        return this.persistence.runTransaction('Get last stream token', function (txn) {\n            return _this.mutationQueue.getLastStreamToken(txn);\n        });\n    };\n    /**\n     * Sets the stream token for the current user without acknowledging any\n     * mutation batch. This is usually only useful after a stream handshake or in\n     * response to an error that requires clearing the stream token.\n     */\n    LocalStore.prototype.setLastStreamToken = function (streamToken) {\n        var _this = this;\n        return this.persistence.runTransaction('Set last stream token', function (txn) {\n            return _this.mutationQueue.setLastStreamToken(txn, streamToken);\n        });\n    };\n    /**\n     * Returns the last consistent snapshot processed (used by the RemoteStore to\n     * determine whether to buffer incoming snapshots from the backend).\n     */\n    LocalStore.prototype.getLastRemoteSnapshotVersion = function () {\n        return this.queryCache.getLastRemoteSnapshotVersion();\n    };\n    /**\n     * Update the \"ground-state\" (remote) documents. We assume that the remote\n     * event reflects any write batches that have been acknowledged or rejected\n     * (i.e. we do not re-apply local mutations to updates from this event).\n     *\n     * LocalDocuments are re-calculated if there are remaining mutations in the\n     * queue.\n     */\n    LocalStore.prototype.applyRemoteEvent = function (remoteEvent) {\n        var _this = this;\n        var documentBuffer = new RemoteDocumentChangeBuffer(this.remoteDocuments);\n        return this.persistence.runTransaction('Apply remote event', function (txn) {\n            var promises = [];\n            objUtils.forEachNumber(remoteEvent.targetChanges, function (targetId, change) {\n                // Do not ref/unref unassigned targetIds - it may lead to leaks.\n                var queryData = _this.targetIds[targetId];\n                if (!queryData)\n                    return;\n                var mapping = change.mapping;\n                if (mapping) {\n                    // First make sure that all references are deleted\n                    if (mapping instanceof ResetMapping) {\n                        promises.push(_this.queryCache\n                            .removeMatchingKeysForTargetId(txn, targetId)\n                            .next(function () {\n                            return _this.queryCache.addMatchingKeys(txn, mapping.documents, targetId);\n                        }));\n                    }\n                    else if (mapping instanceof UpdateMapping) {\n                        promises.push(_this.queryCache\n                            .removeMatchingKeys(txn, mapping.removedDocuments, targetId)\n                            .next(function () {\n                            return _this.queryCache.addMatchingKeys(txn, mapping.addedDocuments, targetId);\n                        }));\n                    }\n                    else {\n                        return fail('Unknown mapping type: ' + JSON.stringify(mapping));\n                    }\n                }\n                // Update the resume token if the change includes one. Don't clear\n                // any preexisting value.\n                var resumeToken = change.resumeToken;\n                if (resumeToken.length > 0) {\n                    queryData = queryData.update({\n                        resumeToken: resumeToken,\n                        snapshotVersion: change.snapshotVersion\n                    });\n                    _this.targetIds[targetId] = queryData;\n                    promises.push(_this.queryCache.updateQueryData(txn, queryData));\n                }\n            });\n            var changedDocKeys = documentKeySet();\n            remoteEvent.documentUpdates.forEach(function (key, doc) {\n                changedDocKeys = changedDocKeys.add(key);\n                promises.push(documentBuffer.getEntry(txn, key).next(function (existingDoc) {\n                    // Make sure we don't apply an old document version to the remote\n                    // cache, though we make an exception for SnapshotVersion.MIN which\n                    // can happen for manufactured events (e.g. in the case of a limbo\n                    // document resolution failing).\n                    if (existingDoc == null ||\n                        doc.version.isEqual(SnapshotVersion.MIN) ||\n                        doc.version.compareTo(existingDoc.version) >= 0) {\n                        documentBuffer.addEntry(doc);\n                    }\n                    else {\n                        log.debug(LOG_TAG, 'Ignoring outdated watch update for ', key, '. Current version:', existingDoc.version, ' Watch version:', doc.version);\n                    }\n                    // The document might be garbage because it was unreferenced by\n                    // everything. Make sure to mark it as garbage if it is...\n                    _this.garbageCollector.addPotentialGarbageKey(key);\n                }));\n            });\n            // HACK: The only reason we allow a null snapshot version is so that we\n            // can synthesize remote events when we get permission denied errors while\n            // trying to resolve the state of a locally cached document that is in\n            // limbo.\n            var lastRemoteVersion = _this.queryCache.getLastRemoteSnapshotVersion();\n            var remoteVersion = remoteEvent.snapshotVersion;\n            if (!remoteVersion.isEqual(SnapshotVersion.MIN)) {\n                assert(remoteVersion.compareTo(lastRemoteVersion) >= 0, 'Watch stream reverted to previous snapshot?? ' +\n                    remoteVersion +\n                    ' < ' +\n                    lastRemoteVersion);\n                promises.push(_this.queryCache.setLastRemoteSnapshotVersion(txn, remoteVersion));\n            }\n            var releasedWriteKeys;\n            return PersistencePromise.waitFor(promises)\n                .next(function () { return _this.releaseHeldBatchResults(txn, documentBuffer); })\n                .next(function (promisedReleasedWriteKeys) {\n                releasedWriteKeys = promisedReleasedWriteKeys;\n                return documentBuffer.apply(txn);\n            })\n                .next(function () {\n                return _this.localDocuments.getDocuments(txn, changedDocKeys.unionWith(releasedWriteKeys));\n            });\n        });\n    };\n    /**\n     * Notify local store of the changed views to locally pin documents.\n     */\n    LocalStore.prototype.notifyLocalViewChanges = function (viewChanges) {\n        var _this = this;\n        return this.persistence.runTransaction('Notify local view changes', function (txn) {\n            var promises = [];\n            var _loop_1 = function (view) {\n                promises.push(_this.queryCache\n                    .getQueryData(txn, view.query)\n                    .next(function (queryData) {\n                    assert(queryData !== null, 'Local view changes contain unallocated query.');\n                    var targetId = queryData.targetId;\n                    _this.localViewReferences.addReferences(view.addedKeys, targetId);\n                    _this.localViewReferences.removeReferences(view.removedKeys, targetId);\n                }));\n            };\n            for (var _i = 0, viewChanges_1 = viewChanges; _i < viewChanges_1.length; _i++) {\n                var view = viewChanges_1[_i];\n                _loop_1(view);\n            }\n            return PersistencePromise.waitFor(promises);\n        });\n    };\n    /**\n     * Gets the mutation batch after the passed in batchId in the mutation queue\n     * or null if empty.\n     * @param afterBatchId If provided, the batch to search after.\n     * @returns The next mutation or null if there wasn't one.\n     */\n    LocalStore.prototype.nextMutationBatch = function (afterBatchId) {\n        var _this = this;\n        return this.persistence.runTransaction('Get next mutation batch', function (txn) {\n            if (afterBatchId === undefined) {\n                afterBatchId = BATCHID_UNKNOWN;\n            }\n            return _this.mutationQueue.getNextMutationBatchAfterBatchId(txn, afterBatchId);\n        });\n    };\n    /**\n     * Read the current value of a Document with a given key or null if not\n     * found - used for testing.\n     */\n    LocalStore.prototype.readDocument = function (key) {\n        var _this = this;\n        return this.persistence.runTransaction('read document', function (txn) {\n            return _this.localDocuments.getDocument(txn, key);\n        });\n    };\n    /**\n     * Assigns the given query an internal ID so that its results can be pinned so\n     * they don't get GC'd. A query must be allocated in the local store before\n     * the store can be used to manage its view.\n     */\n    LocalStore.prototype.allocateQuery = function (query) {\n        var _this = this;\n        return this.persistence.runTransaction('Allocate query', function (txn) {\n            var queryData;\n            return _this.queryCache\n                .getQueryData(txn, query)\n                .next(function (cached) {\n                if (cached) {\n                    // This query has been listened to previously, so reuse the\n                    // previous targetID.\n                    // TODO(mcg): freshen last accessed date?\n                    queryData = cached;\n                    return PersistencePromise.resolve();\n                }\n                else {\n                    var targetId = _this.targetIdGenerator.next();\n                    queryData = new QueryData(query, targetId, QueryPurpose.Listen);\n                    return _this.queryCache.addQueryData(txn, queryData);\n                }\n            })\n                .next(function () {\n                assert(!_this.targetIds[queryData.targetId], 'Tried to allocate an already allocated query: ' + query);\n                _this.targetIds[queryData.targetId] = queryData;\n                return queryData;\n            });\n        });\n    };\n    /** Unpin all the documents associated with the given query. */\n    LocalStore.prototype.releaseQuery = function (query) {\n        var _this = this;\n        return this.persistence.runTransaction('Release query', function (txn) {\n            return _this.queryCache\n                .getQueryData(txn, query)\n                .next(function (queryData) {\n                assert(queryData != null, 'Tried to release nonexistent query: ' + query);\n                _this.localViewReferences.removeReferencesForId(queryData.targetId);\n                delete _this.targetIds[queryData.targetId];\n                if (_this.garbageCollector.isEager) {\n                    return _this.queryCache.removeQueryData(txn, queryData);\n                }\n                else {\n                    return PersistencePromise.resolve();\n                }\n            })\n                .next(function () {\n                // If this was the last watch target, then we won't get any more\n                // watch snapshots, so we should release any held batch results.\n                if (objUtils.isEmpty(_this.targetIds)) {\n                    var documentBuffer_2 = new RemoteDocumentChangeBuffer(_this.remoteDocuments);\n                    return _this.releaseHeldBatchResults(txn, documentBuffer_2).next(function () {\n                        documentBuffer_2.apply(txn);\n                    });\n                }\n                else {\n                    return PersistencePromise.resolve();\n                }\n            });\n        });\n    };\n    /**\n     * Runs the specified query against all the documents in the local store and\n     * returns the results.\n     */\n    LocalStore.prototype.executeQuery = function (query) {\n        var _this = this;\n        return this.persistence.runTransaction('Execute query', function (txn) {\n            return _this.localDocuments.getDocumentsMatchingQuery(txn, query);\n        });\n    };\n    /**\n     * Returns the keys of the documents that are associated with the given\n     * target id in the remote table.\n     */\n    LocalStore.prototype.remoteDocumentKeys = function (targetId) {\n        var _this = this;\n        return this.persistence.runTransaction('Remote document keys', function (txn) {\n            return _this.queryCache.getMatchingKeysForTargetId(txn, targetId);\n        });\n    };\n    /**\n     * Collect garbage if necessary.\n     * Should be called periodically by Sync Engine to recover resources. The\n     * implementation must guarantee that GC won't happen in other places than\n     * this method call.\n     */\n    LocalStore.prototype.collectGarbage = function () {\n        var _this = this;\n        // Call collectGarbage regardless of whether isGCEnabled so the referenceSet\n        // doesn't continue to accumulate the garbage keys.\n        return this.persistence.runTransaction('Garbage collection', function (txn) {\n            return _this.garbageCollector.collectGarbage(txn).next(function (garbage) {\n                var promises = [];\n                garbage.forEach(function (key) {\n                    promises.push(_this.remoteDocuments.removeEntry(txn, key));\n                });\n                return PersistencePromise.waitFor(promises);\n            });\n        });\n    };\n    LocalStore.prototype.releaseHeldBatchResults = function (txn, documentBuffer) {\n        var toRelease = [];\n        for (var _i = 0, _a = this.heldBatchResults; _i < _a.length; _i++) {\n            var batchResult = _a[_i];\n            if (!this.isRemoteUpToVersion(batchResult.commitVersion)) {\n                break;\n            }\n            toRelease.push(batchResult);\n        }\n        if (toRelease.length === 0) {\n            return PersistencePromise.resolve(documentKeySet());\n        }\n        else {\n            this.heldBatchResults.splice(0, toRelease.length);\n            return this.releaseBatchResults(txn, toRelease, documentBuffer);\n        }\n    };\n    LocalStore.prototype.isRemoteUpToVersion = function (version) {\n        // If there are no watch targets, then we won't get remote snapshots, and\n        // we are always \"up-to-date.\"\n        var lastRemoteVersion = this.queryCache.getLastRemoteSnapshotVersion();\n        return (version.compareTo(lastRemoteVersion) <= 0 ||\n            objUtils.isEmpty(this.targetIds));\n    };\n    LocalStore.prototype.shouldHoldBatchResult = function (version) {\n        // Check if watcher isn't up to date or prior results are already held.\n        return (!this.isRemoteUpToVersion(version) || this.heldBatchResults.length > 0);\n    };\n    LocalStore.prototype.releaseBatchResults = function (txn, batchResults, documentBuffer) {\n        var _this = this;\n        var promiseChain = PersistencePromise.resolve();\n        var _loop_2 = function (batchResult) {\n            promiseChain = promiseChain.next(function () {\n                return _this.applyWriteToRemoteDocuments(txn, batchResult, documentBuffer);\n            });\n        };\n        for (var _i = 0, batchResults_1 = batchResults; _i < batchResults_1.length; _i++) {\n            var batchResult = batchResults_1[_i];\n            _loop_2(batchResult);\n        }\n        return promiseChain.next(function () {\n            return _this.removeMutationBatches(txn, batchResults.map(function (result) { return result.batch; }));\n        });\n    };\n    LocalStore.prototype.removeMutationBatch = function (txn, batch) {\n        return this.removeMutationBatches(txn, [batch]);\n    };\n    /** Removes all the mutation batches named in the given array. */\n    LocalStore.prototype.removeMutationBatches = function (txn, batches) {\n        var affectedDocs = documentKeySet();\n        for (var _i = 0, batches_2 = batches; _i < batches_2.length; _i++) {\n            var batch = batches_2[_i];\n            for (var _a = 0, _b = batch.mutations; _a < _b.length; _a++) {\n                var mutation = _b[_a];\n                var key = mutation.key;\n                affectedDocs = affectedDocs.add(key);\n            }\n        }\n        return this.mutationQueue\n            .removeMutationBatches(txn, batches)\n            .next(function () { return affectedDocs; });\n    };\n    LocalStore.prototype.applyWriteToRemoteDocuments = function (txn, batchResult, documentBuffer) {\n        var batch = batchResult.batch;\n        var docKeys = batch.keys();\n        var promiseChain = PersistencePromise.resolve();\n        docKeys.forEach(function (docKey) {\n            promiseChain = promiseChain\n                .next(function () {\n                return documentBuffer.getEntry(txn, docKey);\n            })\n                .next(function (remoteDoc) {\n                var doc = remoteDoc;\n                var ackVersion = batchResult.docVersions.get(docKey);\n                assert(ackVersion !== null, 'ackVersions should contain every doc in the write.');\n                if (!doc || doc.version.compareTo(ackVersion) < 0) {\n                    doc = batch.applyToRemoteDocument(docKey, doc, batchResult);\n                    if (!doc) {\n                        assert(!remoteDoc, 'Mutation batch ' +\n                            batch +\n                            ' applied to document ' +\n                            remoteDoc +\n                            ' resulted in null');\n                    }\n                    else {\n                        documentBuffer.addEntry(doc);\n                    }\n                }\n            });\n        });\n        return promiseChain;\n    };\n    return LocalStore;\n}());\nexport { LocalStore };\n\n//# sourceMappingURL=local_store.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/local_store.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { DocumentKey } from '../model/document_key';\nimport { BATCHID_UNKNOWN, MutationBatch } from '../model/mutation_batch';\nimport { emptyByteString } from '../platform/platform';\nimport { assert } from '../util/assert';\nimport { primitiveComparator } from '../util/misc';\nimport { SortedSet } from '../util/sorted_set';\nimport { PersistencePromise } from './persistence_promise';\nimport { DocReference } from './reference_set';\nvar MemoryMutationQueue = /** @class */ (function () {\n    function MemoryMutationQueue() {\n        /**\n         * The set of all mutations that have been sent but not yet been applied to\n         * the backend.\n         */\n        this.mutationQueue = [];\n        /** Next value to use when assigning sequential IDs to each mutation batch. */\n        this.nextBatchId = 1;\n        /** The highest acknowledged mutation in the queue. */\n        this.highestAcknowledgedBatchId = BATCHID_UNKNOWN;\n        /** The last received stream token from the server, used to acknowledge which\n         * responses the client has processed. Stream tokens are opaque checkpoint\n         * markers whose only real value is their inclusion in the next request.\n         */\n        this.lastStreamToken = emptyByteString();\n        /** The garbage collector to notify about potential garbage keys. */\n        this.garbageCollector = null;\n        /** An ordered mapping between documents and the mutations batch IDs. */\n        this.batchesByDocumentKey = new SortedSet(DocReference.compareByKey);\n    }\n    MemoryMutationQueue.prototype.start = function (transaction) {\n        // NOTE: The queue may be shutdown / started multiple times, since we\n        // maintain the queue for the duration of the app session in case a user\n        // logs out / back in. To behave like the LevelDB-backed MutationQueue (and\n        // accommodate tests that expect as much), we reset nextBatchId and\n        // highestAcknowledgedBatchId if the queue is empty.\n        if (this.mutationQueue.length === 0) {\n            this.nextBatchId = 1;\n            this.highestAcknowledgedBatchId = BATCHID_UNKNOWN;\n        }\n        assert(this.highestAcknowledgedBatchId < this.nextBatchId, 'highestAcknowledgedBatchId must be less than the nextBatchId');\n        return PersistencePromise.resolve();\n    };\n    MemoryMutationQueue.prototype.checkEmpty = function (transaction) {\n        return PersistencePromise.resolve(this.mutationQueue.length === 0);\n    };\n    MemoryMutationQueue.prototype.getNextBatchId = function (transaction) {\n        return PersistencePromise.resolve(this.nextBatchId);\n    };\n    MemoryMutationQueue.prototype.getHighestAcknowledgedBatchId = function (transaction) {\n        return PersistencePromise.resolve(this.highestAcknowledgedBatchId);\n    };\n    MemoryMutationQueue.prototype.acknowledgeBatch = function (transaction, batch, streamToken) {\n        var batchId = batch.batchId;\n        assert(batchId > this.highestAcknowledgedBatchId, 'Mutation batchIDs must be acknowledged in order');\n        var batchIndex = this.indexOfExistingBatchId(batchId, 'acknowledged');\n        // Verify that the batch in the queue is the one to be acknowledged.\n        var check = this.mutationQueue[batchIndex];\n        assert(batchId === check.batchId, 'Queue ordering failure: expected batch ' +\n            batchId +\n            ', got batch ' +\n            check.batchId);\n        assert(!check.isTombstone(), \"Can't acknowledge a previously removed batch\");\n        this.highestAcknowledgedBatchId = batchId;\n        this.lastStreamToken = streamToken;\n        return PersistencePromise.resolve();\n    };\n    MemoryMutationQueue.prototype.getLastStreamToken = function (transaction) {\n        return PersistencePromise.resolve(this.lastStreamToken);\n    };\n    MemoryMutationQueue.prototype.setLastStreamToken = function (transaction, streamToken) {\n        this.lastStreamToken = streamToken;\n        return PersistencePromise.resolve();\n    };\n    MemoryMutationQueue.prototype.addMutationBatch = function (transaction, localWriteTime, mutations) {\n        assert(mutations.length !== 0, 'Mutation batches should not be empty');\n        var batchId = this.nextBatchId;\n        this.nextBatchId++;\n        if (this.mutationQueue.length > 0) {\n            var prior = this.mutationQueue[this.mutationQueue.length - 1];\n            assert(prior.batchId < batchId, 'Mutation batchIDs must be monotonically increasing order');\n        }\n        var batch = new MutationBatch(batchId, localWriteTime, mutations);\n        this.mutationQueue.push(batch);\n        // Track references by document key.\n        for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {\n            var mutation = mutations_1[_i];\n            this.batchesByDocumentKey = this.batchesByDocumentKey.add(new DocReference(mutation.key, batchId));\n        }\n        return PersistencePromise.resolve(batch);\n    };\n    MemoryMutationQueue.prototype.lookupMutationBatch = function (transaction, batchId) {\n        return PersistencePromise.resolve(this.findMutationBatch(batchId));\n    };\n    MemoryMutationQueue.prototype.getNextMutationBatchAfterBatchId = function (transaction, batchId) {\n        var size = this.mutationQueue.length;\n        // All batches with batchId <= this.highestAcknowledgedBatchId have been\n        // acknowledged so the first unacknowledged batch after batchID will have a\n        // batchID larger than both of these values.\n        var nextBatchId = Math.max(batchId, this.highestAcknowledgedBatchId) + 1;\n        // The requested batchId may still be out of range so normalize it to the\n        // start of the queue.\n        var rawIndex = this.indexOfBatchId(nextBatchId);\n        var index = rawIndex < 0 ? 0 : rawIndex;\n        // Finally return the first non-tombstone batch.\n        for (; index < size; index++) {\n            var batch = this.mutationQueue[index];\n            if (!batch.isTombstone()) {\n                return PersistencePromise.resolve(batch);\n            }\n        }\n        return PersistencePromise.resolve(null);\n    };\n    MemoryMutationQueue.prototype.getAllMutationBatches = function (transaction) {\n        return PersistencePromise.resolve(this.getAllLiveMutationBatchesBeforeIndex(this.mutationQueue.length));\n    };\n    MemoryMutationQueue.prototype.getAllMutationBatchesThroughBatchId = function (transaction, batchId) {\n        var count = this.mutationQueue.length;\n        var endIndex = this.indexOfBatchId(batchId);\n        if (endIndex < 0) {\n            endIndex = 0;\n        }\n        else if (endIndex >= count) {\n            endIndex = count;\n        }\n        else {\n            // The endIndex is in the queue so increment to pull everything in the\n            // queue including it.\n            endIndex++;\n        }\n        return PersistencePromise.resolve(this.getAllLiveMutationBatchesBeforeIndex(endIndex));\n    };\n    MemoryMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKey = function (transaction, documentKey) {\n        var _this = this;\n        var start = new DocReference(documentKey, 0);\n        var end = new DocReference(documentKey, Number.POSITIVE_INFINITY);\n        var result = [];\n        this.batchesByDocumentKey.forEachInRange([start, end], function (ref) {\n            assert(documentKey.isEqual(ref.key), \"Should only iterate over a single key's batches\");\n            var batch = _this.findMutationBatch(ref.targetOrBatchId);\n            assert(batch !== null, 'Batches in the index must exist in the main table');\n            result.push(batch);\n        });\n        return PersistencePromise.resolve(result);\n    };\n    MemoryMutationQueue.prototype.getAllMutationBatchesAffectingQuery = function (transaction, query) {\n        var _this = this;\n        // Use the query path as a prefix for testing if a document matches the\n        // query.\n        var prefix = query.path;\n        var immediateChildrenPathLength = prefix.length + 1;\n        // Construct a document reference for actually scanning the index. Unlike\n        // the prefix the document key in this reference must have an even number of\n        // segments. The empty segment can be used a suffix of the query path\n        // because it precedes all other segments in an ordered traversal.\n        var startPath = prefix;\n        if (!DocumentKey.isDocumentKey(startPath)) {\n            startPath = startPath.child('');\n        }\n        var start = new DocReference(new DocumentKey(startPath), 0);\n        // Find unique batchIDs referenced by all documents potentially matching the\n        // query.\n        var uniqueBatchIDs = new SortedSet(primitiveComparator);\n        this.batchesByDocumentKey.forEachWhile(function (ref) {\n            var rowKeyPath = ref.key.path;\n            if (!prefix.isPrefixOf(rowKeyPath)) {\n                return false;\n            }\n            else {\n                // Rows with document keys more than one segment longer than the query\n                // path can't be matches. For example, a query on 'rooms' can't match\n                // the document /rooms/abc/messages/xyx.\n                // TODO(mcg): we'll need a different scanner when we implement\n                // ancestor queries.\n                if (rowKeyPath.length === immediateChildrenPathLength) {\n                    uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);\n                }\n                return true;\n            }\n        }, start);\n        // Construct an array of matching batches, sorted by batchID to ensure that\n        // multiple mutations affecting the same document key are applied in order.\n        var result = [];\n        uniqueBatchIDs.forEach(function (batchId) {\n            var batch = _this.findMutationBatch(batchId);\n            if (batch !== null) {\n                result.push(batch);\n            }\n        });\n        return PersistencePromise.resolve(result);\n    };\n    MemoryMutationQueue.prototype.removeMutationBatches = function (transaction, batches) {\n        var batchCount = batches.length;\n        assert(batchCount > 0, 'Should not remove mutations when none exist.');\n        var firstBatchId = batches[0].batchId;\n        var queueCount = this.mutationQueue.length;\n        // Find the position of the first batch for removal. This need not be the\n        // first entry in the queue.\n        var startIndex = this.indexOfExistingBatchId(firstBatchId, 'removed');\n        assert(this.mutationQueue[startIndex].batchId === firstBatchId, 'Removed batches must exist in the queue');\n        // Check that removed batches are contiguous (while excluding tombstones).\n        var batchIndex = 1;\n        var queueIndex = startIndex + 1;\n        while (batchIndex < batchCount && queueIndex < queueCount) {\n            var batch = this.mutationQueue[queueIndex];\n            if (batch.isTombstone()) {\n                queueIndex++;\n                continue;\n            }\n            assert(batch.batchId === batches[batchIndex].batchId, 'Removed batches must be contiguous in the queue');\n            batchIndex++;\n            queueIndex++;\n        }\n        // Only actually remove batches if removing at the front of the queue.\n        // Previously rejected batches may have left tombstones in the queue, so\n        // expand the removal range to include any tombstones.\n        if (startIndex === 0) {\n            for (; queueIndex < queueCount; queueIndex++) {\n                var batch = this.mutationQueue[queueIndex];\n                if (!batch.isTombstone()) {\n                    break;\n                }\n            }\n            var length_1 = queueIndex - startIndex;\n            this.mutationQueue.splice(startIndex, length_1);\n        }\n        else {\n            // Mark the tombstones\n            for (var i = startIndex; i < queueIndex; i++) {\n                this.mutationQueue[i] = this.mutationQueue[i].toTombstone();\n            }\n        }\n        var references = this.batchesByDocumentKey;\n        for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {\n            var batch = batches_1[_i];\n            var batchId = batch.batchId;\n            for (var _a = 0, _b = batch.mutations; _a < _b.length; _a++) {\n                var mutation = _b[_a];\n                var key = mutation.key;\n                if (this.garbageCollector !== null) {\n                    this.garbageCollector.addPotentialGarbageKey(key);\n                }\n                var ref = new DocReference(key, batchId);\n                references = references.delete(ref);\n            }\n        }\n        this.batchesByDocumentKey = references;\n        return PersistencePromise.resolve();\n    };\n    MemoryMutationQueue.prototype.setGarbageCollector = function (garbageCollector) {\n        this.garbageCollector = garbageCollector;\n    };\n    MemoryMutationQueue.prototype.containsKey = function (txn, key) {\n        var ref = new DocReference(key, 0);\n        var firstRef = this.batchesByDocumentKey.firstAfterOrEqual(ref);\n        return PersistencePromise.resolve(key.isEqual(firstRef && firstRef.key));\n    };\n    MemoryMutationQueue.prototype.performConsistencyCheck = function (txn) {\n        if (this.mutationQueue.length === 0) {\n            assert(this.batchesByDocumentKey.isEmpty(), 'Document leak -- detected dangling mutation references when queue is empty.');\n        }\n        return PersistencePromise.resolve();\n    };\n    /**\n     * A private helper that collects all the mutations batches in the queue up to\n     * but not including the given endIndex. All tombstones in the queue are\n     * excluded.\n     */\n    MemoryMutationQueue.prototype.getAllLiveMutationBatchesBeforeIndex = function (endIndex) {\n        var result = [];\n        for (var i = 0; i < endIndex; i++) {\n            var batch = this.mutationQueue[i];\n            if (!batch.isTombstone()) {\n                result.push(batch);\n            }\n        }\n        return result;\n    };\n    /**\n     * Finds the index of the given batchId in the mutation queue and asserts that\n     * the resulting index is within the bounds of the queue.\n     *\n     * @param batchId The batchId to search for\n     * @param action A description of what the caller is doing, phrased in passive\n     * form (e.g. \"acknowledged\" in a routine that acknowledges batches).\n     */\n    MemoryMutationQueue.prototype.indexOfExistingBatchId = function (batchId, action) {\n        var index = this.indexOfBatchId(batchId);\n        assert(index >= 0 && index < this.mutationQueue.length, 'Batches must exist to be ' + action);\n        return index;\n    };\n    /**\n     * Finds the index of the given batchId in the mutation queue. This operation\n     * is O(1).\n     *\n     * @return The computed index of the batch with the given batchId, based on\n     * the state of the queue. Note this index can be negative if the requested\n     * batchId has already been remvoed from the queue or past the end of the\n     * queue if the batchId is larger than the last added batch.\n     */\n    MemoryMutationQueue.prototype.indexOfBatchId = function (batchId) {\n        if (this.mutationQueue.length === 0) {\n            // As an index this is past the end of the queue\n            return 0;\n        }\n        // Examine the front of the queue to figure out the difference between the\n        // batchId and indexes in the array. Note that since the queue is ordered\n        // by batchId, if the first batch has a larger batchId then the requested\n        // batchId doesn't exist in the queue.\n        var firstBatchId = this.mutationQueue[0].batchId;\n        return batchId - firstBatchId;\n    };\n    /**\n     * A version of lookupMutationBatch that doesn't return a promise, this makes\n     * other functions that uses this code easier to read and more efficent.\n     */\n    MemoryMutationQueue.prototype.findMutationBatch = function (batchId) {\n        var index = this.indexOfBatchId(batchId);\n        if (index < 0 || index >= this.mutationQueue.length) {\n            return null;\n        }\n        var batch = this.mutationQueue[index];\n        assert(batch.batchId === batchId, 'If found batch must match');\n        return batch.isTombstone() ? null : batch;\n    };\n    return MemoryMutationQueue;\n}());\nexport { MemoryMutationQueue };\n\n//# sourceMappingURL=memory_mutation_queue.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/memory_mutation_queue.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { ObjectMap } from '../util/obj_map';\nimport { PersistencePromise } from './persistence_promise';\nimport { ReferenceSet } from './reference_set';\nimport { assert } from '../util/assert';\nvar MemoryQueryCache = /** @class */ (function () {\n    function MemoryQueryCache() {\n        /**\n         * Maps a query to the data about that query\n         */\n        this.queries = new ObjectMap(function (q) { return q.canonicalId(); });\n        /** The last received snapshot version. */\n        this.lastRemoteSnapshotVersion = SnapshotVersion.MIN;\n        /** The highest numbered target ID encountered. */\n        this.highestTargetId = 0;\n        /**\n         * A ordered bidirectional mapping between documents and the remote target\n         * IDs.\n         */\n        this.references = new ReferenceSet();\n        this.targetCount = 0;\n    }\n    MemoryQueryCache.prototype.start = function (transaction) {\n        // Nothing to do.\n        return PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.getLastRemoteSnapshotVersion = function () {\n        return this.lastRemoteSnapshotVersion;\n    };\n    MemoryQueryCache.prototype.getHighestTargetId = function () {\n        return this.highestTargetId;\n    };\n    MemoryQueryCache.prototype.setLastRemoteSnapshotVersion = function (transaction, snapshotVersion) {\n        this.lastRemoteSnapshotVersion = snapshotVersion;\n        return PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.saveQueryData = function (queryData) {\n        this.queries.set(queryData.query, queryData);\n        var targetId = queryData.targetId;\n        if (targetId > this.highestTargetId) {\n            this.highestTargetId = targetId;\n        }\n        // TODO(GC): track sequence number\n    };\n    MemoryQueryCache.prototype.addQueryData = function (transaction, queryData) {\n        assert(!this.queries.has(queryData.query), 'Adding a query that already exists');\n        this.saveQueryData(queryData);\n        this.targetCount += 1;\n        return PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.updateQueryData = function (transaction, queryData) {\n        assert(this.queries.has(queryData.query), 'Updating a non-existent query');\n        this.saveQueryData(queryData);\n        return PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.removeQueryData = function (transaction, queryData) {\n        assert(this.targetCount > 0, 'Removing a target from an empty cache');\n        assert(this.queries.has(queryData.query), 'Removing a non-existent target from the cache');\n        this.queries.delete(queryData.query);\n        this.references.removeReferencesForId(queryData.targetId);\n        this.targetCount -= 1;\n        return PersistencePromise.resolve();\n    };\n    Object.defineProperty(MemoryQueryCache.prototype, \"count\", {\n        get: function () {\n            return this.targetCount;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MemoryQueryCache.prototype.getQueryData = function (transaction, query) {\n        var queryData = this.queries.get(query) || null;\n        return PersistencePromise.resolve(queryData);\n    };\n    MemoryQueryCache.prototype.addMatchingKeys = function (txn, keys, targetId) {\n        this.references.addReferences(keys, targetId);\n        return PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.removeMatchingKeys = function (txn, keys, targetId) {\n        this.references.removeReferences(keys, targetId);\n        return PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.removeMatchingKeysForTargetId = function (txn, targetId) {\n        this.references.removeReferencesForId(targetId);\n        return PersistencePromise.resolve();\n    };\n    MemoryQueryCache.prototype.getMatchingKeysForTargetId = function (txn, targetId) {\n        var matchingKeys = this.references.referencesForId(targetId);\n        return PersistencePromise.resolve(matchingKeys);\n    };\n    MemoryQueryCache.prototype.setGarbageCollector = function (gc) {\n        this.references.setGarbageCollector(gc);\n    };\n    MemoryQueryCache.prototype.containsKey = function (txn, key) {\n        return this.references.containsKey(txn, key);\n    };\n    return MemoryQueryCache;\n}());\nexport { MemoryQueryCache };\n\n//# sourceMappingURL=memory_query_cache.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/memory_query_cache.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { documentMap, maybeDocumentMap } from '../model/collections';\nimport { Document } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { PersistencePromise } from './persistence_promise';\nvar MemoryRemoteDocumentCache = /** @class */ (function () {\n    function MemoryRemoteDocumentCache() {\n        this.docs = maybeDocumentMap();\n    }\n    MemoryRemoteDocumentCache.prototype.addEntry = function (transaction, maybeDocument) {\n        this.docs = this.docs.insert(maybeDocument.key, maybeDocument);\n        return PersistencePromise.resolve();\n    };\n    MemoryRemoteDocumentCache.prototype.removeEntry = function (transaction, documentKey) {\n        this.docs = this.docs.remove(documentKey);\n        return PersistencePromise.resolve();\n    };\n    MemoryRemoteDocumentCache.prototype.getEntry = function (transaction, documentKey) {\n        return PersistencePromise.resolve(this.docs.get(documentKey));\n    };\n    MemoryRemoteDocumentCache.prototype.getDocumentsMatchingQuery = function (transaction, query) {\n        var results = documentMap();\n        // Documents are ordered by key, so we can use a prefix scan to narrow down\n        // the documents we need to match the query against.\n        var prefix = new DocumentKey(query.path.child(''));\n        var iterator = this.docs.getIteratorFrom(prefix);\n        while (iterator.hasNext()) {\n            var _a = iterator.getNext(), key = _a.key, maybeDoc = _a.value;\n            if (!query.path.isPrefixOf(key.path)) {\n                break;\n            }\n            if (maybeDoc instanceof Document && query.matches(maybeDoc)) {\n                results = results.insert(maybeDoc.key, maybeDoc);\n            }\n        }\n        return PersistencePromise.resolve(results);\n    };\n    return MemoryRemoteDocumentCache;\n}());\nexport { MemoryRemoteDocumentCache };\n\n//# sourceMappingURL=memory_remote_document_cache.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/memory_remote_document_cache.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { assert } from '../util/assert';\nimport { debug } from '../util/log';\nimport { MemoryMutationQueue } from './memory_mutation_queue';\nimport { MemoryQueryCache } from './memory_query_cache';\nimport { MemoryRemoteDocumentCache } from './memory_remote_document_cache';\nvar LOG_TAG = 'MemoryPersistence';\n/**\n * A memory-backed instance of Persistence. Data is stored only in RAM and\n * not persisted across sessions.\n */\nvar MemoryPersistence = /** @class */ (function () {\n    function MemoryPersistence() {\n        /**\n         * Note that these are retained here to make it easier to write tests\n         * affecting both the in-memory and IndexedDB-backed persistence layers. Tests\n         * can create a new LocalStore wrapping this Persistence instance and this\n         * will make the in-memory persistence layer behave as if it were actually\n         * persisting values.\n         */\n        this.mutationQueues = {};\n        this.remoteDocumentCache = new MemoryRemoteDocumentCache();\n        this.queryCache = new MemoryQueryCache();\n        this.started = false;\n    }\n    MemoryPersistence.prototype.start = function () {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            return tslib_1.__generator(this, function (_a) {\n                // No durable state to read on startup.\n                assert(!this.started, 'MemoryPersistence double-started!');\n                this.started = true;\n                return [2 /*return*/];\n            });\n        });\n    };\n    MemoryPersistence.prototype.shutdown = function () {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            return tslib_1.__generator(this, function (_a) {\n                // No durable state to ensure is closed on shutdown.\n                assert(this.started, 'MemoryPersistence shutdown without start!');\n                this.started = false;\n                return [2 /*return*/];\n            });\n        });\n    };\n    MemoryPersistence.prototype.getMutationQueue = function (user) {\n        var queue = this.mutationQueues[user.toKey()];\n        if (!queue) {\n            queue = new MemoryMutationQueue();\n            this.mutationQueues[user.toKey()] = queue;\n        }\n        return queue;\n    };\n    MemoryPersistence.prototype.getQueryCache = function () {\n        return this.queryCache;\n    };\n    MemoryPersistence.prototype.getRemoteDocumentCache = function () {\n        return this.remoteDocumentCache;\n    };\n    MemoryPersistence.prototype.runTransaction = function (action, operation) {\n        debug(LOG_TAG, 'Starting transaction:', action);\n        return operation(new MemoryPersistenceTransaction()).toPromise();\n    };\n    return MemoryPersistence;\n}());\nexport { MemoryPersistence };\n/** Dummy class since memory persistence doesn't actually use transactions. */\nvar MemoryPersistenceTransaction = /** @class */ (function () {\n    function MemoryPersistenceTransaction() {\n    }\n    return MemoryPersistenceTransaction;\n}());\n\n//# sourceMappingURL=memory_persistence.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/memory_persistence.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { documentKeySet } from '../model/collections';\nimport { PersistencePromise } from './persistence_promise';\n/**\n * A garbage collector implementation that does absolutely nothing. It ignores\n * all addGarbageSource and addPotentialGarbageKey messages and and never\n * produces any garbage.\n */\nvar NoOpGarbageCollector = /** @class */ (function () {\n    function NoOpGarbageCollector() {\n        this.isEager = false;\n    }\n    NoOpGarbageCollector.prototype.addGarbageSource = function (garbageSource) {\n        // Not tracking garbage so don't track sources.\n    };\n    NoOpGarbageCollector.prototype.removeGarbageSource = function (garbageSource) {\n        // Not tracking garbage so don't track sources.\n    };\n    NoOpGarbageCollector.prototype.addPotentialGarbageKey = function (key) {\n        // Not tracking garbage so ignore.\n    };\n    NoOpGarbageCollector.prototype.collectGarbage = function (txn) {\n        return PersistencePromise.resolve(documentKeySet());\n    };\n    return NoOpGarbageCollector;\n}());\nexport { NoOpGarbageCollector };\n\n//# sourceMappingURL=no_op_garbage_collector.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/local/no_op_garbage_collector.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar Deferred = /** @class */ (function () {\n    function Deferred() {\n        var _this = this;\n        this.promise = new Promise(function (resolve, reject) {\n            _this.resolve = resolve;\n            _this.reject = reject;\n        });\n    }\n    return Deferred;\n}());\nexport { Deferred };\n/**\n * Takes an array of values and sequences them using the promise (or value)\n * returned by the supplied callback. The callback for each item is called\n * after the promise is resolved for the previous item.\n * The function returns a promise which is resolved after the promise for\n * the last item is resolved.\n */\nexport function sequence(values, fn, initialValue) {\n    var result = Promise.resolve(initialValue);\n    values.forEach(function (value) {\n        result = result.then(function (lastResult) { return fn(value, lastResult); });\n    });\n    return result;\n}\n\n//# sourceMappingURL=promise.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/promise.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { assert } from '../util/assert';\nimport { TimerId } from '../util/async_queue';\nimport { Code, FirestoreError } from '../util/error';\nimport * as log from '../util/log';\nimport { ExponentialBackoff } from './backoff';\nimport { isNullOrUndefined } from '../util/types';\nvar LOG_TAG = 'PersistentStream';\nvar PersistentStreamState;\n(function (PersistentStreamState) {\n    /**\n     * The streaming RPC is not running and there's no error condition.\n     * Calling `start` will start the stream immediately without backoff.\n     * While in this state isStarted will return false.\n     */\n    PersistentStreamState[PersistentStreamState[\"Initial\"] = 0] = \"Initial\";\n    /**\n     * The stream is starting, and is waiting for an auth token to attach to\n     * the initial request. While in this state, isStarted will return\n     * true but isOpen will return false.\n     */\n    PersistentStreamState[PersistentStreamState[\"Auth\"] = 1] = \"Auth\";\n    /**\n     * The streaming RPC is up and running. Requests and responses can flow\n     * freely. Both isStarted and isOpen will return true.\n     */\n    PersistentStreamState[PersistentStreamState[\"Open\"] = 2] = \"Open\";\n    /**\n     * The stream encountered an error. The next start attempt will back off.\n     * While in this state isStarted() will return false.\n     *\n     */\n    PersistentStreamState[PersistentStreamState[\"Error\"] = 3] = \"Error\";\n    /**\n     * An in-between state after an error where the stream is waiting before\n     * re-starting. After\n     * waiting is complete, the stream will try to open. While in this\n     * state isStarted() will return YES but isOpen will return false.\n     */\n    PersistentStreamState[PersistentStreamState[\"Backoff\"] = 4] = \"Backoff\";\n    /**\n     * The stream has been explicitly stopped; no further events will be emitted.\n     */\n    PersistentStreamState[PersistentStreamState[\"Stopped\"] = 5] = \"Stopped\";\n})(PersistentStreamState || (PersistentStreamState = {}));\n/**\n * Initial backoff time in milliseconds after an error.\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\n */\nvar BACKOFF_INITIAL_DELAY_MS = 1000;\n/** Maximum backoff time in milliseconds */\nvar BACKOFF_MAX_DELAY_MS = 60 * 1000;\nvar BACKOFF_FACTOR = 1.5;\n/** The time a stream stays open after it is marked idle. */\nvar IDLE_TIMEOUT_MS = 60 * 1000;\n/**\n * A PersistentStream is an abstract base class that represents a streaming RPC\n * to the Firestore backend. It's built on top of the connections own support\n * for streaming RPCs, and adds several critical features for our clients:\n *\n *   - Exponential backoff on failure\n *   - Authentication via CredentialsProvider\n *   - Dispatching all callbacks into the shared worker queue\n *\n * Subclasses of PersistentStream implement serialization of models to and\n * from the JSON representation of the protocol buffers for a specific\n * streaming RPC.\n *\n * ## Starting and Stopping\n *\n * Streaming RPCs are stateful and need to be `start`ed before messages can\n * be sent and received. The PersistentStream will call the onOpen function\n * of the listener once the stream is ready to accept requests.\n *\n * Should a `start` fail, PersistentStream will call the registered\n * onClose with a FirestoreError indicating what went wrong.\n *\n * A PersistentStream can be started and stopped repeatedly.\n *\n * Generic types:\n *  SendType: The type of the outgoing message of the underlying\n *    connection stream\n *  ReceiveType: The type of the incoming message of the underlying\n *    connection stream\n *  ListenerType: The type of the listener that will be used for callbacks\n */\nvar PersistentStream = /** @class */ (function () {\n    function PersistentStream(queue, connectionTimerId, idleTimerId, connection, credentialsProvider) {\n        this.queue = queue;\n        this.idleTimerId = idleTimerId;\n        this.connection = connection;\n        this.credentialsProvider = credentialsProvider;\n        this.inactivityTimerPromise = null;\n        this.stream = null;\n        this.listener = null;\n        this.backoff = new ExponentialBackoff(queue, connectionTimerId, BACKOFF_INITIAL_DELAY_MS, BACKOFF_FACTOR, BACKOFF_MAX_DELAY_MS);\n        this.state = PersistentStreamState.Initial;\n    }\n    /**\n     * Returns true if `start` has been called and no error has occurred. True\n     * indicates the stream is open or in the process of opening (which\n     * encompasses respecting backoff, getting auth tokens, and starting the\n     * actual RPC). Use `isOpen` to determine if the stream is open and ready for\n     * outbound requests.\n     */\n    PersistentStream.prototype.isStarted = function () {\n        return (this.state === PersistentStreamState.Backoff ||\n            this.state === PersistentStreamState.Auth ||\n            this.state === PersistentStreamState.Open);\n    };\n    /**\n     * Returns true if the underlying RPC is open (the openHandler has been\n     * called) and the stream is ready for outbound requests.\n     */\n    PersistentStream.prototype.isOpen = function () {\n        return this.state === PersistentStreamState.Open;\n    };\n    /**\n     * Starts the RPC. Only allowed if isStarted returns false. The stream is\n     * not immediately ready for use: onOpen will be invoked when the RPC is ready\n     * for outbound requests, at which point isOpen will return true.\n     *\n     *  When start returns, isStarted will return true.\n     */\n    PersistentStream.prototype.start = function (listener) {\n        if (this.state === PersistentStreamState.Error) {\n            this.performBackoff(listener);\n            return;\n        }\n        assert(this.state === PersistentStreamState.Initial, 'Already started');\n        this.listener = listener;\n        this.auth();\n    };\n    /**\n     * Stops the RPC. This call is idempotent and allowed regardless of the\n     * current isStarted state.\n     *\n     * When stop returns, isStarted and isOpen will both return false.\n     */\n    PersistentStream.prototype.stop = function () {\n        if (this.isStarted()) {\n            this.close(PersistentStreamState.Stopped);\n        }\n    };\n    /**\n     * After an error the stream will usually back off on the next attempt to\n     * start it. If the error warrants an immediate restart of the stream, the\n     * sender can use this to indicate that the receiver should not back off.\n     *\n     * Each error will call the onClose function. That function can decide to\n     * inhibit backoff if required.\n     */\n    PersistentStream.prototype.inhibitBackoff = function () {\n        assert(!this.isStarted(), 'Can only inhibit backoff in a stopped state');\n        this.state = PersistentStreamState.Initial;\n        this.backoff.reset();\n    };\n    /**\n     * Marks this stream as idle. If no further actions are performed on the\n     * stream for one minute, the stream will automatically close itself and\n     * notify the stream's onClose() handler with Status.OK. The stream will then\n     * be in a !isStarted() state, requiring the caller to start the stream again\n     * before further use.\n     *\n     * Only streams that are in state 'Open' can be marked idle, as all other\n     * states imply pending network operations.\n     */\n    PersistentStream.prototype.markIdle = function () {\n        var _this = this;\n        // Starts the idle time if we are in state 'Open' and are not yet already\n        // running a timer (in which case the previous idle timeout still applies).\n        if (this.isOpen() && this.inactivityTimerPromise === null) {\n            this.inactivityTimerPromise = this.queue.enqueueAfterDelay(this.idleTimerId, IDLE_TIMEOUT_MS, function () { return _this.handleIdleCloseTimer(); });\n        }\n    };\n    /** Sends a message to the underlying stream. */\n    PersistentStream.prototype.sendRequest = function (msg) {\n        this.cancelIdleCheck();\n        this.stream.send(msg);\n    };\n    /** Called by the idle timer when the stream should close due to inactivity. */\n    PersistentStream.prototype.handleIdleCloseTimer = function () {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            return tslib_1.__generator(this, function (_a) {\n                if (this.isOpen()) {\n                    // When timing out an idle stream there's no reason to force the stream into backoff when\n                    // it restarts so set the stream state to Initial instead of Error.\n                    return [2 /*return*/, this.close(PersistentStreamState.Initial)];\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    /** Marks the stream as active again. */\n    PersistentStream.prototype.cancelIdleCheck = function () {\n        if (this.inactivityTimerPromise) {\n            this.inactivityTimerPromise.cancel();\n            this.inactivityTimerPromise = null;\n        }\n    };\n    /**\n     * Closes the stream and cleans up as necessary:\n     *\n     * * closes the underlying GRPC stream;\n     * * calls the onClose handler with the given 'error';\n     * * sets internal stream state to 'finalState';\n     * * adjusts the backoff timer based on the error\n     *\n     * A new stream can be opened by calling `start` unless `finalState` is set to\n     * `PersistentStreamState.Stopped`.\n     *\n     * @param finalState the intended state of the stream after closing.\n     * @param error the error the connection was closed with.\n     */\n    PersistentStream.prototype.close = function (finalState, error) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var listener;\n            return tslib_1.__generator(this, function (_a) {\n                assert(finalState === PersistentStreamState.Error || isNullOrUndefined(error), \"Can't provide an error when not in an error state.\");\n                // The stream will be closed so we don't need our idle close timer anymore.\n                this.cancelIdleCheck();\n                // Ensure we don't leave a pending backoff operation queued (in case close()\n                // was called while we were waiting to reconnect).\n                this.backoff.cancel();\n                if (finalState !== PersistentStreamState.Error) {\n                    // If this is an intentional close ensure we don't delay our next connection attempt.\n                    this.backoff.reset();\n                }\n                else if (error && error.code === Code.RESOURCE_EXHAUSTED) {\n                    // Log the error. (Probably either 'quota exceeded' or 'max queue length reached'.)\n                    log.error(error.toString());\n                    log.error('Using maximum backoff delay to prevent overloading the backend.');\n                    this.backoff.resetToMax();\n                }\n                // Clean up the underlying stream because we are no longer interested in events.\n                if (this.stream !== null) {\n                    this.tearDown();\n                    this.stream.close();\n                    this.stream = null;\n                }\n                // This state must be assigned before calling onClose() to allow the callback to\n                // inhibit backoff or otherwise manipulate the state in its non-started state.\n                this.state = finalState;\n                listener = this.listener;\n                // Clear the listener to avoid bleeding of events from the underlying streams.\n                this.listener = null;\n                // If the caller explicitly requested a stream stop, don't notify them of a closing stream (it\n                // could trigger undesirable recovery logic, etc.).\n                if (finalState !== PersistentStreamState.Stopped) {\n                    return [2 /*return*/, listener.onClose(error)];\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    /**\n     * Can be overridden to perform additional cleanup before the stream is closed.\n     * Calling super.tearDown() is not required.\n     */\n    PersistentStream.prototype.tearDown = function () { };\n    PersistentStream.prototype.auth = function () {\n        var _this = this;\n        assert(this.state === PersistentStreamState.Initial, 'Must be in initial state to auth');\n        this.state = PersistentStreamState.Auth;\n        this.credentialsProvider.getToken(/*forceRefresh=*/ false).then(function (token) {\n            // Normally we'd have to schedule the callback on the AsyncQueue.\n            // However, the following calls are safe to be called outside the\n            // AsyncQueue since they don't chain asynchronous calls\n            _this.startStream(token);\n        }, function (error) {\n            _this.queue.enqueue(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n                var rpcError;\n                return tslib_1.__generator(this, function (_a) {\n                    if (this.state !== PersistentStreamState.Stopped) {\n                        rpcError = new FirestoreError(Code.UNKNOWN, 'Fetching auth token failed: ' + error.message);\n                        return [2 /*return*/, this.handleStreamClose(rpcError)];\n                    }\n                    return [2 /*return*/];\n                });\n            }); });\n        });\n    };\n    PersistentStream.prototype.startStream = function (token) {\n        var _this = this;\n        if (this.state === PersistentStreamState.Stopped) {\n            // Stream can be stopped while waiting for authorization.\n            return;\n        }\n        assert(this.state === PersistentStreamState.Auth, 'Trying to start stream in a non-auth state');\n        // Helper function to dispatch to AsyncQueue and make sure that any\n        // close will seem instantaneous and events are prevented from being\n        // raised after the close call\n        var dispatchIfStillActive = function (stream, fn) {\n            _this.queue.enqueue(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n                return tslib_1.__generator(this, function (_a) {\n                    // Only raise events if the stream instance has not changed\n                    if (this.stream === stream) {\n                        return [2 /*return*/, fn()];\n                    }\n                    return [2 /*return*/];\n                });\n            }); });\n        };\n        // Only start stream if listener has not changed\n        if (this.listener !== null) {\n            var currentStream_1 = this.startRpc(token);\n            this.stream = currentStream_1;\n            this.stream.onOpen(function () {\n                dispatchIfStillActive(currentStream_1, function () {\n                    assert(_this.state === PersistentStreamState.Auth, 'Expected stream to be in state auth, but was ' + _this.state);\n                    _this.state = PersistentStreamState.Open;\n                    return _this.listener.onOpen();\n                });\n            });\n            this.stream.onClose(function (error) {\n                dispatchIfStillActive(currentStream_1, function () {\n                    return _this.handleStreamClose(error);\n                });\n            });\n            this.stream.onMessage(function (msg) {\n                dispatchIfStillActive(currentStream_1, function () {\n                    return _this.onMessage(msg);\n                });\n            });\n        }\n    };\n    PersistentStream.prototype.performBackoff = function (listener) {\n        var _this = this;\n        assert(this.state === PersistentStreamState.Error, 'Should only perform backoff in an error case');\n        this.state = PersistentStreamState.Backoff;\n        this.backoff.backoffAndRun(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n            return tslib_1.__generator(this, function (_a) {\n                if (this.state === PersistentStreamState.Stopped) {\n                    // We should have canceled the backoff timer when the stream was\n                    // closed, but just in case we make this a no-op.\n                    return [2 /*return*/];\n                }\n                this.state = PersistentStreamState.Initial;\n                this.start(listener);\n                assert(this.isStarted(), 'PersistentStream should have started');\n                return [2 /*return*/];\n            });\n        }); });\n    };\n    PersistentStream.prototype.handleStreamClose = function (error) {\n        assert(this.isStarted(), \"Can't handle server close on non-started stream\");\n        log.debug(LOG_TAG, \"close with error: \" + error);\n        this.stream = null;\n        // In theory the stream could close cleanly, however, in our current model\n        // we never expect this to happen because if we stop a stream ourselves,\n        // this callback will never be called. To prevent cases where we retry\n        // without a backoff accidentally, we set the stream to error in all cases.\n        return this.close(PersistentStreamState.Error, error);\n    };\n    return PersistentStream;\n}());\nexport { PersistentStream };\n/**\n * A PersistentStream that implements the Listen RPC.\n *\n * Once the Listen stream has called the openHandler, any number of listen and\n * unlisten calls calls can be sent to control what changes will be sent from\n * the server for ListenResponses.\n */\nvar PersistentListenStream = /** @class */ (function (_super) {\n    tslib_1.__extends(PersistentListenStream, _super);\n    function PersistentListenStream(queue, connection, credentials, serializer) {\n        var _this = _super.call(this, queue, TimerId.ListenStreamConnectionBackoff, TimerId.ListenStreamIdle, connection, credentials) || this;\n        _this.serializer = serializer;\n        return _this;\n    }\n    PersistentListenStream.prototype.startRpc = function (token) {\n        return this.connection.openStream('Listen', token);\n    };\n    PersistentListenStream.prototype.onMessage = function (watchChangeProto) {\n        // A successful response means the stream is healthy\n        this.backoff.reset();\n        var watchChange = this.serializer.fromWatchChange(watchChangeProto);\n        var snapshot = this.serializer.versionFromListenResponse(watchChangeProto);\n        return this.listener.onWatchChange(watchChange, snapshot);\n    };\n    /**\n     * Registers interest in the results of the given query. If the query\n     * includes a resumeToken it will be included in the request. Results that\n     * affect the query will be streamed back as WatchChange messages that\n     * reference the targetId.\n     */\n    PersistentListenStream.prototype.watch = function (queryData) {\n        var request = {};\n        request.database = this.serializer.encodedDatabaseId;\n        request.addTarget = this.serializer.toTarget(queryData);\n        var labels = this.serializer.toListenRequestLabels(queryData);\n        if (labels) {\n            request.labels = labels;\n        }\n        this.sendRequest(request);\n    };\n    /**\n     * Unregisters interest in the results of the query associated with the\n     * given targetId.\n     */\n    PersistentListenStream.prototype.unwatch = function (targetId) {\n        var request = {};\n        request.database = this.serializer.encodedDatabaseId;\n        request.removeTarget = targetId;\n        this.sendRequest(request);\n    };\n    return PersistentListenStream;\n}(PersistentStream));\nexport { PersistentListenStream };\n/**\n * A Stream that implements the Write RPC.\n *\n * The Write RPC requires the caller to maintain special streamToken\n * state in between calls, to help the server understand which responses the\n * client has processed by the time the next request is made. Every response\n * will contain a streamToken; this value must be passed to the next\n * request.\n *\n * After calling start() on this stream, the next request must be a handshake,\n * containing whatever streamToken is on hand. Once a response to this\n * request is received, all pending mutations may be submitted. When\n * submitting multiple batches of mutations at the same time, it's\n * okay to use the same streamToken for the calls to writeMutations.\n *\n * TODO(b/33271235): Use proto types\n */\nvar PersistentWriteStream = /** @class */ (function (_super) {\n    tslib_1.__extends(PersistentWriteStream, _super);\n    function PersistentWriteStream(queue, connection, credentials, serializer) {\n        var _this = _super.call(this, queue, TimerId.WriteStreamConnectionBackoff, TimerId.WriteStreamIdle, connection, credentials) || this;\n        _this.serializer = serializer;\n        _this.handshakeComplete_ = false;\n        return _this;\n    }\n    Object.defineProperty(PersistentWriteStream.prototype, \"handshakeComplete\", {\n        /**\n         * Tracks whether or not a handshake has been successfully exchanged and\n         * the stream is ready to accept mutations.\n         */\n        get: function () {\n            return this.handshakeComplete_;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // Override of PersistentStream.start\n    PersistentWriteStream.prototype.start = function (listener) {\n        this.handshakeComplete_ = false;\n        _super.prototype.start.call(this, listener);\n    };\n    PersistentWriteStream.prototype.tearDown = function () {\n        if (this.handshakeComplete_) {\n            this.writeMutations([]);\n        }\n    };\n    PersistentWriteStream.prototype.startRpc = function (token) {\n        return this.connection.openStream('Write', token);\n    };\n    PersistentWriteStream.prototype.onMessage = function (responseProto) {\n        // Always capture the last stream token.\n        assert(!!responseProto.streamToken, 'Got a write response without a stream token');\n        this.lastStreamToken = responseProto.streamToken;\n        if (!this.handshakeComplete_) {\n            // The first response is always the handshake response\n            assert(!responseProto.writeResults || responseProto.writeResults.length === 0, 'Got mutation results for handshake');\n            this.handshakeComplete_ = true;\n            return this.listener.onHandshakeComplete();\n        }\n        else {\n            // A successful first write response means the stream is healthy,\n            // Note, that we could consider a successful handshake healthy, however,\n            // the write itself might be causing an error we want to back off from.\n            this.backoff.reset();\n            var results = this.serializer.fromWriteResults(responseProto.writeResults);\n            var commitVersion = this.serializer.fromVersion(responseProto.commitTime);\n            return this.listener.onMutationResult(commitVersion, results);\n        }\n    };\n    /**\n     * Sends an initial streamToken to the server, performing the handshake\n     * required to make the StreamingWrite RPC work. Subsequent\n     * calls should wait until onHandshakeComplete was called.\n     */\n    PersistentWriteStream.prototype.writeHandshake = function () {\n        assert(this.isOpen(), 'Writing handshake requires an opened stream');\n        assert(!this.handshakeComplete_, 'Handshake already completed');\n        // TODO(dimond): Support stream resumption. We intentionally do not set the\n        // stream token on the handshake, ignoring any stream token we might have.\n        var request = {};\n        request.database = this.serializer.encodedDatabaseId;\n        this.sendRequest(request);\n    };\n    /** Sends a group of mutations to the Firestore backend to apply. */\n    PersistentWriteStream.prototype.writeMutations = function (mutations) {\n        var _this = this;\n        assert(this.isOpen(), 'Writing mutations requires an opened stream');\n        assert(this.handshakeComplete_, 'Handshake must be complete before writing mutations');\n        assert(this.lastStreamToken.length > 0, 'Trying to write mutation without a token');\n        var request = {\n            // Protos are typed with string, but we support UInt8Array on Node\n            // tslint:disable-next-line:no-any\n            streamToken: this.lastStreamToken,\n            writes: mutations.map(function (mutation) { return _this.serializer.toMutation(mutation); })\n        };\n        this.sendRequest(request);\n    };\n    return PersistentWriteStream;\n}(PersistentStream));\nexport { PersistentWriteStream };\n\n//# sourceMappingURL=persistent_stream.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/remote/persistent_stream.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as log from '../util/log';\nvar LOG_TAG = 'ExponentialBackoff';\n/**\n * A helper for running delayed tasks following an exponential backoff curve\n * between attempts.\n *\n * Each delay is made up of a \"base\" delay which follows the exponential\n * backoff curve, and a +/- 50% \"jitter\" that is calculated and added to the\n * base delay. This prevents clients from accidentally synchronizing their\n * delays causing spikes of load to the backend.\n */\nvar ExponentialBackoff = /** @class */ (function () {\n    function ExponentialBackoff(\n    /**\n     * The AsyncQueue to run backoff operations on.\n     */\n    queue, \n    /**\n     * The ID to use when scheduling backoff operations on the AsyncQueue.\n     */\n    timerId, \n    /**\n     * The initial delay (used as the base delay on the first retry attempt).\n     * Note that jitter will still be applied, so the actual delay could be as\n     * little as 0.5*initialDelayMs.\n     */\n    initialDelayMs, \n    /**\n     * The multiplier to use to determine the extended base delay after each\n     * attempt.\n     */\n    backoffFactor, \n    /**\n     * The maximum base delay after which no further backoff is performed.\n     * Note that jitter will still be applied, so the actual delay could be as\n     * much as 1.5*maxDelayMs.\n     */\n    maxDelayMs) {\n        this.queue = queue;\n        this.timerId = timerId;\n        this.initialDelayMs = initialDelayMs;\n        this.backoffFactor = backoffFactor;\n        this.maxDelayMs = maxDelayMs;\n        this.timerPromise = null;\n        this.reset();\n    }\n    /**\n     * Resets the backoff delay.\n     *\n     * The very next backoffAndWait() will have no delay. If it is called again\n     * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\n     * subsequent ones will increase according to the backoffFactor.\n     */\n    ExponentialBackoff.prototype.reset = function () {\n        this.currentBaseMs = 0;\n    };\n    /**\n     * Resets the backoff delay to the maximum delay (e.g. for use after a\n     * RESOURCE_EXHAUSTED error).\n     */\n    ExponentialBackoff.prototype.resetToMax = function () {\n        this.currentBaseMs = this.maxDelayMs;\n    };\n    /**\n     * Returns a promise that resolves after currentDelayMs, and increases the\n     * delay for any subsequent attempts. If there was a pending backoff operation\n     * already, it will be canceled.\n     */\n    ExponentialBackoff.prototype.backoffAndRun = function (op) {\n        // Cancel any pending backoff operation.\n        this.cancel();\n        // First schedule using the current base (which may be 0 and should be\n        // honored as such).\n        var delayWithJitterMs = this.currentBaseMs + this.jitterDelayMs();\n        if (this.currentBaseMs > 0) {\n            log.debug(LOG_TAG, \"Backing off for \" + delayWithJitterMs + \" ms \" +\n                (\"(base delay: \" + this.currentBaseMs + \" ms)\"));\n        }\n        this.timerPromise = this.queue.enqueueAfterDelay(this.timerId, delayWithJitterMs, op);\n        // Apply backoff factor to determine next delay and ensure it is within\n        // bounds.\n        this.currentBaseMs *= this.backoffFactor;\n        if (this.currentBaseMs < this.initialDelayMs) {\n            this.currentBaseMs = this.initialDelayMs;\n        }\n        if (this.currentBaseMs > this.maxDelayMs) {\n            this.currentBaseMs = this.maxDelayMs;\n        }\n    };\n    ExponentialBackoff.prototype.cancel = function () {\n        if (this.timerPromise !== null) {\n            this.timerPromise.cancel();\n            this.timerPromise = null;\n        }\n    };\n    /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */\n    ExponentialBackoff.prototype.jitterDelayMs = function () {\n        return (Math.random() - 0.5) * this.currentBaseMs;\n    };\n    return ExponentialBackoff;\n}());\nexport { ExponentialBackoff };\n\n//# sourceMappingURL=backoff.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/remote/backoff.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { maybeDocumentMap } from '../model/collections';\nimport { assert } from '../util/assert';\nimport { PersistentListenStream, PersistentWriteStream } from './persistent_stream';\n/**\n * Datastore is a wrapper around the external Google Cloud Datastore grpc API,\n * which provides an interface that is more convenient for the rest of the\n * client SDK architecture to consume.\n */\nvar Datastore = /** @class */ (function () {\n    function Datastore(queue, connection, credentials, serializer) {\n        this.queue = queue;\n        this.connection = connection;\n        this.credentials = credentials;\n        this.serializer = serializer;\n    }\n    Datastore.prototype.newPersistentWriteStream = function () {\n        return new PersistentWriteStream(this.queue, this.connection, this.credentials, this.serializer);\n    };\n    Datastore.prototype.newPersistentWatchStream = function () {\n        return new PersistentListenStream(this.queue, this.connection, this.credentials, this.serializer);\n    };\n    Datastore.prototype.commit = function (mutations) {\n        var _this = this;\n        var params = {\n            database: this.serializer.encodedDatabaseId,\n            writes: mutations.map(function (m) { return _this.serializer.toMutation(m); })\n        };\n        return this.invokeRPC('Commit', params).then(function (response) {\n            return _this.serializer.fromWriteResults(response.writeResults);\n        });\n    };\n    Datastore.prototype.lookup = function (keys) {\n        var _this = this;\n        var params = {\n            database: this.serializer.encodedDatabaseId,\n            documents: keys.map(function (k) { return _this.serializer.toName(k); })\n        };\n        return this.invokeStreamingRPC('BatchGetDocuments', params).then(function (response) {\n            var docs = maybeDocumentMap();\n            response.forEach(function (proto) {\n                var doc = _this.serializer.fromMaybeDocument(proto);\n                docs = docs.insert(doc.key, doc);\n            });\n            var result = [];\n            keys.forEach(function (key) {\n                var doc = docs.get(key);\n                assert(!!doc, 'Missing entity in write response for ' + key);\n                result.push(doc);\n            });\n            return result;\n        });\n    };\n    /** Gets an auth token and invokes the provided RPC. */\n    Datastore.prototype.invokeRPC = function (rpcName, request) {\n        var _this = this;\n        // TODO(mikelehen): Retry (with backoff) on token failures?\n        return this.credentials.getToken(/*forceRefresh=*/ false).then(function (token) {\n            return _this.connection.invokeRPC(rpcName, request, token);\n        });\n    };\n    /** Gets an auth token and invokes the provided RPC with streamed results. */\n    Datastore.prototype.invokeStreamingRPC = function (rpcName, request) {\n        var _this = this;\n        // TODO(mikelehen): Retry (with backoff) on token failures?\n        return this.credentials.getToken(/*forceRefresh=*/ false).then(function (token) {\n            return _this.connection.invokeStreamingRPC(rpcName, request, token);\n        });\n    };\n    return Datastore;\n}());\nexport { Datastore };\n\n//# sourceMappingURL=datastore.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/remote/datastore.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SnapshotVersion } from './snapshot_version';\nimport { documentVersionMap } from '../model/collections';\nimport { NoDocument } from '../model/document';\nimport { DeleteMutation, Precondition } from '../model/mutation';\nimport { Code, FirestoreError } from '../util/error';\n/**\n * Internal transaction object responsible for accumulating the mutations to\n * perform and the base versions for any documents read.\n */\nvar Transaction = /** @class */ (function () {\n    function Transaction(datastore) {\n        this.datastore = datastore;\n        // The version of each document that was read during this transaction.\n        this.readVersions = documentVersionMap();\n        this.mutations = [];\n        this.committed = false;\n    }\n    Transaction.prototype.recordVersion = function (doc) {\n        var docVersion = doc.version;\n        if (doc instanceof NoDocument) {\n            // For deleted docs, we must use baseVersion 0 when we overwrite them.\n            docVersion = SnapshotVersion.forDeletedDoc();\n        }\n        var existingVersion = this.readVersions.get(doc.key);\n        if (existingVersion !== null) {\n            if (!docVersion.isEqual(existingVersion)) {\n                // This transaction will fail no matter what.\n                throw new FirestoreError(Code.ABORTED, 'Document version changed between two reads.');\n            }\n        }\n        else {\n            this.readVersions = this.readVersions.insert(doc.key, docVersion);\n        }\n    };\n    Transaction.prototype.lookup = function (keys) {\n        var _this = this;\n        if (this.committed) {\n            return Promise.reject('Transaction has already completed.');\n        }\n        if (this.mutations.length > 0) {\n            return Promise.reject('Transactions lookups are invalid after writes.');\n        }\n        return this.datastore.lookup(keys).then(function (docs) {\n            docs.forEach(function (doc) { return _this.recordVersion(doc); });\n            return docs;\n        });\n    };\n    Transaction.prototype.write = function (mutations) {\n        if (this.committed) {\n            throw new FirestoreError(Code.FAILED_PRECONDITION, 'Transaction has already completed.');\n        }\n        this.mutations = this.mutations.concat(mutations);\n    };\n    /**\n     * Returns the version of this document when it was read in this transaction,\n     * as a precondition, or no precondition if it was not read.\n     */\n    Transaction.prototype.precondition = function (key) {\n        var version = this.readVersions.get(key);\n        if (version) {\n            return Precondition.updateTime(version);\n        }\n        else {\n            return Precondition.NONE;\n        }\n    };\n    /**\n     * Returns the precondition for a document if the operation is an update.\n     */\n    Transaction.prototype.preconditionForUpdate = function (key) {\n        var version = this.readVersions.get(key);\n        if (version && version.isEqual(SnapshotVersion.forDeletedDoc())) {\n            // The document doesn't exist, so fail the transaction.\n            throw new FirestoreError(Code.FAILED_PRECONDITION, \"Can't update a document that doesn't exist.\");\n        }\n        else if (version) {\n            // Document exists, base precondition on document update time.\n            return Precondition.updateTime(version);\n        }\n        else {\n            // Document was not read, so we just use the preconditions for a blind\n            // update.\n            return Precondition.exists(true);\n        }\n    };\n    Transaction.prototype.set = function (key, data) {\n        this.write(data.toMutations(key, this.precondition(key)));\n    };\n    Transaction.prototype.update = function (key, data) {\n        this.write(data.toMutations(key, this.preconditionForUpdate(key)));\n    };\n    Transaction.prototype.delete = function (key) {\n        this.write([new DeleteMutation(key, this.precondition(key))]);\n        // Since the delete will be applied before all following writes, we need to\n        // ensure that the precondition for the next write will be exists: false.\n        this.readVersions = this.readVersions.insert(key, SnapshotVersion.forDeletedDoc());\n    };\n    Transaction.prototype.commit = function () {\n        var _this = this;\n        var unwritten = this.readVersions;\n        // For each mutation, note that the doc was written.\n        this.mutations.forEach(function (mutation) {\n            unwritten = unwritten.remove(mutation.key);\n        });\n        if (!unwritten.isEmpty()) {\n            return Promise.reject(Error('Every document read in a transaction must also be written.'));\n        }\n        return this.datastore.commit(this.mutations).then(function () {\n            _this.committed = true;\n        });\n    };\n    return Transaction;\n}());\nexport { Transaction };\n\n//# sourceMappingURL=transaction.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/core/transaction.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { OnlineState } from '../core/types';\nimport * as log from '../util/log';\nimport { assert } from '../util/assert';\nimport { TimerId } from '../util/async_queue';\nvar LOG_TAG = 'OnlineStateTracker';\n// To deal with transient failures, we allow multiple stream attempts before\n// giving up and transitioning from OnlineState.Unknown to Offline.\nvar MAX_WATCH_STREAM_FAILURES = 2;\n// To deal with stream attempts that don't succeed or fail in a timely manner,\n// we have a timeout for OnlineState to reach Online or Offline.\n// If the timeout is reached, we transition to Offline rather than waiting\n// indefinitely.\nvar ONLINE_STATE_TIMEOUT_MS = 10 * 1000;\n/**\n * A component used by the RemoteStore to track the OnlineState (that is,\n * whether or not the client as a whole should be considered to be online or\n * offline), implementing the appropriate heuristics.\n *\n * In particular, when the client is trying to connect to the backend, we\n * allow up to MAX_WATCH_STREAM_FAILURES within ONLINE_STATE_TIMEOUT_MS for\n * a connection to succeed. If we have too many failures or the timeout elapses,\n * then we set the OnlineState to Offline, and the client will behave as if\n * it is offline (get()s will return cached data, etc.).\n */\nvar OnlineStateTracker = /** @class */ (function () {\n    function OnlineStateTracker(asyncQueue, onlineStateHandler) {\n        this.asyncQueue = asyncQueue;\n        this.onlineStateHandler = onlineStateHandler;\n        /** The current OnlineState. */\n        this.state = OnlineState.Unknown;\n        /**\n         * A count of consecutive failures to open the stream. If it reaches the\n         * maximum defined by MAX_WATCH_STREAM_FAILURES, we'll set the OnlineState to\n         * Offline.\n         */\n        this.watchStreamFailures = 0;\n        /**\n         * A timer that elapses after ONLINE_STATE_TIMEOUT_MS, at which point we\n         * transition from OnlineState.Unknown to OnlineState.Offline without waiting\n         * for the stream to actually fail (MAX_WATCH_STREAM_FAILURES times).\n         */\n        this.onlineStateTimer = null;\n        /**\n         * Whether the client should log a warning message if it fails to connect to\n         * the backend (initially true, cleared after a successful stream, or if we've\n         * logged the message already).\n         */\n        this.shouldWarnClientIsOffline = true;\n    }\n    /**\n     * Called by RemoteStore when a watch stream is started.\n     *\n     * It sets the OnlineState to Unknown and starts the onlineStateTimer\n     * if necessary.\n     */\n    OnlineStateTracker.prototype.handleWatchStreamStart = function () {\n        var _this = this;\n        this.setAndBroadcast(OnlineState.Unknown);\n        if (this.onlineStateTimer === null) {\n            this.onlineStateTimer = this.asyncQueue.enqueueAfterDelay(TimerId.OnlineStateTimeout, ONLINE_STATE_TIMEOUT_MS, function () {\n                _this.onlineStateTimer = null;\n                assert(_this.state === OnlineState.Unknown, 'Timer should be canceled if we transitioned to a different state.');\n                log.debug(LOG_TAG, \"Watch stream didn't reach online or offline within \" +\n                    (ONLINE_STATE_TIMEOUT_MS + \"ms. Considering client offline.\"));\n                _this.logClientOfflineWarningIfNecessary();\n                _this.setAndBroadcast(OnlineState.Offline);\n                // NOTE: handleWatchStreamFailure() will continue to increment\n                // watchStreamFailures even though we are already marked Offline,\n                // but this is non-harmful.\n                return Promise.resolve();\n            });\n        }\n    };\n    /**\n     * Updates our OnlineState as appropriate after the watch stream reports a\n     * failure. The first failure moves us to the 'Unknown' state. We then may\n     * allow multiple failures (based on MAX_WATCH_STREAM_FAILURES) before we\n     * actually transition to the 'Offline' state.\n     */\n    OnlineStateTracker.prototype.handleWatchStreamFailure = function () {\n        if (this.state === OnlineState.Online) {\n            this.setAndBroadcast(OnlineState.Unknown);\n        }\n        else {\n            this.watchStreamFailures++;\n            if (this.watchStreamFailures >= MAX_WATCH_STREAM_FAILURES) {\n                this.clearOnlineStateTimer();\n                this.logClientOfflineWarningIfNecessary();\n                this.setAndBroadcast(OnlineState.Offline);\n            }\n        }\n    };\n    /**\n     * Explicitly sets the OnlineState to the specified state.\n     *\n     * Note that this resets our timers / failure counters, etc. used by our\n     * Offline heuristics, so must not be used in place of\n     * handleWatchStreamStart() and handleWatchStreamFailure().\n     */\n    OnlineStateTracker.prototype.set = function (newState) {\n        this.clearOnlineStateTimer();\n        this.watchStreamFailures = 0;\n        if (newState === OnlineState.Online) {\n            // We've connected to watch at least once. Don't warn the developer\n            // about being offline going forward.\n            this.shouldWarnClientIsOffline = false;\n        }\n        this.setAndBroadcast(newState);\n    };\n    OnlineStateTracker.prototype.setAndBroadcast = function (newState) {\n        if (newState !== this.state) {\n            this.state = newState;\n            this.onlineStateHandler(newState);\n        }\n    };\n    OnlineStateTracker.prototype.logClientOfflineWarningIfNecessary = function () {\n        if (this.shouldWarnClientIsOffline) {\n            log.error('Could not reach Firestore backend.');\n            this.shouldWarnClientIsOffline = false;\n        }\n    };\n    OnlineStateTracker.prototype.clearOnlineStateTimer = function () {\n        if (this.onlineStateTimer !== null) {\n            this.onlineStateTimer.cancel();\n            this.onlineStateTimer = null;\n        }\n    };\n    return OnlineStateTracker;\n}());\nexport { OnlineStateTracker };\n\n//# sourceMappingURL=online_state_tracker.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/remote/online_state_tracker.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { SnapshotVersion } from '../core/snapshot_version';\nimport { Transaction } from '../core/transaction';\nimport { OnlineState } from '../core/types';\nimport { QueryData, QueryPurpose } from '../local/query_data';\nimport { NoDocument } from '../model/document';\nimport { DocumentKey } from '../model/document_key';\nimport { BATCHID_UNKNOWN, MutationBatchResult } from '../model/mutation_batch';\nimport { emptyByteString } from '../platform/platform';\nimport { assert } from '../util/assert';\nimport { Code } from '../util/error';\nimport * as log from '../util/log';\nimport * as objUtils from '../util/obj';\nimport { ResetMapping, UpdateMapping } from './remote_event';\nimport { isPermanentError } from './rpc_error';\nimport { WatchChangeAggregator, WatchTargetChange, WatchTargetChangeState } from './watch_change';\nimport { OnlineStateTracker } from './online_state_tracker';\nvar LOG_TAG = 'RemoteStore';\n// TODO(b/35853402): Negotiate this with the stream.\nvar MAX_PENDING_WRITES = 10;\n/**\n * RemoteStore - An interface to remotely stored data, basically providing a\n * wrapper around the Datastore that is more reliable for the rest of the\n * system.\n *\n * RemoteStore is responsible for maintaining the connection to the server.\n * - maintaining a list of active listens.\n * - reconnecting when the connection is dropped.\n * - resuming all the active listens on reconnect.\n *\n * RemoteStore handles all incoming events from the Datastore.\n * - listening to the watch stream and repackaging the events as RemoteEvents\n * - notifying SyncEngine of any changes to the active listens.\n *\n * RemoteStore takes writes from other components and handles them reliably.\n * - pulling pending mutations from LocalStore and sending them to Datastore.\n * - retrying mutations that failed because of network problems.\n * - acking mutations to the SyncEngine once they are accepted or rejected.\n */\nvar RemoteStore = /** @class */ (function () {\n    function RemoteStore(\n    /**\n     * The local store, used to fill the write pipeline with outbound\n     * mutations and resolve existence filter mismatches.\n     */\n    localStore, \n    /** The client-side proxy for interacting with the backend. */\n    datastore, asyncQueue, onlineStateHandler) {\n        this.localStore = localStore;\n        this.datastore = datastore;\n        this.pendingWrites = [];\n        this.lastBatchSeen = BATCHID_UNKNOWN;\n        /**\n         * A mapping of watched targets that the client cares about tracking and the\n         * user has explicitly called a 'listen' for this target.\n         *\n         * These targets may or may not have been sent to or acknowledged by the\n         * server. On re-establishing the listen stream, these targets should be sent\n         * to the server. The targets removed with unlistens are removed eagerly\n         * without waiting for confirmation from the listen stream.\n         */\n        this.listenTargets = {};\n        /**\n         * A mapping of targetId to pending acks needed.\n         *\n         * If a targetId is present in this map, then we're waiting for watch to\n         * acknowledge a removal or addition of the target. If a target is not in this\n         * mapping, and it's in the listenTargets map, then we consider the target to\n         * be active.\n         *\n         * We increment the count here every time we issue a request over the stream\n         * to watch or unwatch. We then decrement the count every time we get a target\n         * added or target removed message from the server. Once the count is equal to\n         * 0 we know that the client and server are in the same state (once this state\n         * is reached the targetId is removed from the map to free the memory).\n         */\n        this.pendingTargetResponses = {};\n        this.accumulatedWatchChanges = [];\n        this.watchStream = null;\n        this.writeStream = null;\n        this.onlineStateTracker = new OnlineStateTracker(asyncQueue, onlineStateHandler);\n    }\n    /**\n     * Starts up the remote store, creating streams, restoring state from\n     * LocalStore, etc.\n     */\n    RemoteStore.prototype.start = function () {\n        return this.enableNetwork();\n    };\n    RemoteStore.prototype.isNetworkEnabled = function () {\n        assert((this.watchStream == null) === (this.writeStream == null), 'WatchStream and WriteStream should both be null or non-null');\n        return this.watchStream != null;\n    };\n    /** Re-enables the network. Idempotent. */\n    RemoteStore.prototype.enableNetwork = function () {\n        var _this = this;\n        if (this.isNetworkEnabled()) {\n            return Promise.resolve();\n        }\n        // Create new streams (but note they're not started yet).\n        this.watchStream = this.datastore.newPersistentWatchStream();\n        this.writeStream = this.datastore.newPersistentWriteStream();\n        // Load any saved stream token from persistent storage\n        return this.localStore.getLastStreamToken().then(function (token) {\n            _this.writeStream.lastStreamToken = token;\n            if (_this.shouldStartWatchStream()) {\n                _this.startWatchStream();\n            }\n            else {\n                _this.onlineStateTracker.set(OnlineState.Unknown);\n            }\n            return _this.fillWritePipeline(); // This may start the writeStream.\n        });\n    };\n    /**\n     * Temporarily disables the network. The network can be re-enabled using\n     * enableNetwork().\n     */\n    RemoteStore.prototype.disableNetwork = function () {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            return tslib_1.__generator(this, function (_a) {\n                this.disableNetworkInternal();\n                // Set the OnlineState to Offline so get()s return from cache, etc.\n                this.onlineStateTracker.set(OnlineState.Offline);\n                return [2 /*return*/];\n            });\n        });\n    };\n    /**\n     * Disables the network, if it is currently enabled.\n     */\n    RemoteStore.prototype.disableNetworkInternal = function () {\n        if (this.isNetworkEnabled()) {\n            // NOTE: We're guaranteed not to get any further events from these streams (not even a close\n            // event).\n            this.watchStream.stop();\n            this.writeStream.stop();\n            this.cleanUpWatchStreamState();\n            this.cleanUpWriteStreamState();\n            this.writeStream = null;\n            this.watchStream = null;\n        }\n    };\n    RemoteStore.prototype.shutdown = function () {\n        log.debug(LOG_TAG, 'RemoteStore shutting down.');\n        this.disableNetworkInternal();\n        // Set the OnlineState to Unknown (rather than Offline) to avoid potentially\n        // triggering spurious listener events with cached data, etc.\n        this.onlineStateTracker.set(OnlineState.Unknown);\n        return Promise.resolve();\n    };\n    /** Starts new listen for the given query. Uses resume token if provided */\n    RemoteStore.prototype.listen = function (queryData) {\n        assert(!objUtils.contains(this.listenTargets, queryData.targetId), 'listen called with duplicate targetId!');\n        // Mark this as something the client is currently listening for.\n        this.listenTargets[queryData.targetId] = queryData;\n        if (this.shouldStartWatchStream()) {\n            // The listen will be sent in onWatchStreamOpen\n            this.startWatchStream();\n        }\n        else if (this.isNetworkEnabled() && this.watchStream.isOpen()) {\n            this.sendWatchRequest(queryData);\n        }\n    };\n    /** Removes the listen from server */\n    RemoteStore.prototype.unlisten = function (targetId) {\n        assert(objUtils.contains(this.listenTargets, targetId), 'unlisten called without assigned target ID!');\n        delete this.listenTargets[targetId];\n        if (this.isNetworkEnabled() && this.watchStream.isOpen()) {\n            this.sendUnwatchRequest(targetId);\n            if (objUtils.isEmpty(this.listenTargets)) {\n                this.watchStream.markIdle();\n            }\n        }\n    };\n    /**\n     * We need to increment the the expected number of pending responses we're due\n     * from watch so we wait for the ack to process any messages from this target.\n     */\n    RemoteStore.prototype.sendWatchRequest = function (queryData) {\n        this.recordPendingTargetRequest(queryData.targetId);\n        this.watchStream.watch(queryData);\n    };\n    /**\n     * We need to increment the expected number of pending responses we're due\n     * from watch so we wait for the removal on the server before we process any\n     * messages from this target.\n     */\n    RemoteStore.prototype.sendUnwatchRequest = function (targetId) {\n        this.recordPendingTargetRequest(targetId);\n        this.watchStream.unwatch(targetId);\n    };\n    /**\n     * Increment the mapping of how many acks are needed from watch before we can\n     * consider the server to be 'in-sync' with the client's active targets.\n     */\n    RemoteStore.prototype.recordPendingTargetRequest = function (targetId) {\n        // For each request we get we need to record we need a response for it.\n        this.pendingTargetResponses[targetId] =\n            (this.pendingTargetResponses[targetId] || 0) + 1;\n    };\n    RemoteStore.prototype.startWatchStream = function () {\n        assert(this.shouldStartWatchStream(), 'startWriteStream() called when shouldStartWatchStream() is false.');\n        this.watchStream.start({\n            onOpen: this.onWatchStreamOpen.bind(this),\n            onClose: this.onWatchStreamClose.bind(this),\n            onWatchChange: this.onWatchStreamChange.bind(this)\n        });\n        this.onlineStateTracker.handleWatchStreamStart();\n    };\n    /**\n     * Returns whether the watch stream should be started because it's necessary\n     * and has not yet been started.\n     */\n    RemoteStore.prototype.shouldStartWatchStream = function () {\n        return (this.isNetworkEnabled() &&\n            !this.watchStream.isStarted() &&\n            !objUtils.isEmpty(this.listenTargets));\n    };\n    RemoteStore.prototype.cleanUpWatchStreamState = function () {\n        // If the connection is closed then we'll never get a snapshot version for\n        // the accumulated changes and so we'll never be able to complete the batch.\n        // When we start up again the server is going to resend these changes\n        // anyway, so just toss the accumulated state.\n        this.accumulatedWatchChanges = [];\n        this.pendingTargetResponses = {};\n    };\n    RemoteStore.prototype.onWatchStreamOpen = function () {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                // TODO(b/35852690): close the stream again (with some timeout?) if no watch\n                // targets are active\n                objUtils.forEachNumber(this.listenTargets, function (targetId, queryData) {\n                    _this.sendWatchRequest(queryData);\n                });\n                return [2 /*return*/];\n            });\n        });\n    };\n    RemoteStore.prototype.onWatchStreamClose = function (error) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            return tslib_1.__generator(this, function (_a) {\n                assert(this.isNetworkEnabled(), 'onWatchStreamClose() should only be called when the network is enabled');\n                this.cleanUpWatchStreamState();\n                this.onlineStateTracker.handleWatchStreamFailure();\n                // If there was an error, retry the connection.\n                if (this.shouldStartWatchStream()) {\n                    this.startWatchStream();\n                }\n                else {\n                    // No need to restart watch stream because there are no active targets.\n                    // The online state is set to unknown because there is no active attempt\n                    // at establishing a connection\n                    this.onlineStateTracker.set(OnlineState.Unknown);\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    RemoteStore.prototype.onWatchStreamChange = function (watchChange, snapshotVersion) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var changes;\n            return tslib_1.__generator(this, function (_a) {\n                // Mark the client as online since we got a message from the server\n                this.onlineStateTracker.set(OnlineState.Online);\n                if (watchChange instanceof WatchTargetChange &&\n                    watchChange.state === WatchTargetChangeState.Removed &&\n                    watchChange.cause) {\n                    // There was an error on a target, don't wait for a consistent snapshot\n                    // to raise events\n                    return [2 /*return*/, this.handleTargetError(watchChange)];\n                }\n                // Accumulate watch changes but don't process them if there's no\n                // snapshotVersion or it's older than a previous snapshot we've processed\n                // (can happen after we resume a target using a resume token).\n                this.accumulatedWatchChanges.push(watchChange);\n                if (!snapshotVersion.isEqual(SnapshotVersion.MIN) &&\n                    snapshotVersion.compareTo(this.localStore.getLastRemoteSnapshotVersion()) >= 0) {\n                    changes = this.accumulatedWatchChanges;\n                    this.accumulatedWatchChanges = [];\n                    return [2 /*return*/, this.handleWatchChangeBatch(snapshotVersion, changes)];\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    /**\n     * Takes a batch of changes from the Datastore, repackages them as a\n     * RemoteEvent, and passes that on to the listener, which is typically the\n     * SyncEngine.\n     */\n    RemoteStore.prototype.handleWatchChangeBatch = function (snapshotVersion, changes) {\n        var _this = this;\n        var aggregator = new WatchChangeAggregator(snapshotVersion, this.listenTargets, this.pendingTargetResponses);\n        aggregator.addChanges(changes);\n        var remoteEvent = aggregator.createRemoteEvent();\n        // Get the new response counts from the aggregator\n        this.pendingTargetResponses = aggregator.pendingTargetResponses;\n        var promises = [];\n        // Handle existence filters and existence filter mismatches.\n        objUtils.forEachNumber(aggregator.existenceFilters, function (targetId, filter) {\n            var queryData = _this.listenTargets[targetId];\n            if (!queryData) {\n                // A watched target might have been removed already.\n                return;\n            }\n            var query = queryData.query;\n            if (query.isDocumentQuery()) {\n                if (filter.count === 0) {\n                    // The existence filter told us the document does not exist.\n                    // We need to deduce that this document does not exist and apply\n                    // a deleted document to our updates. Without applying a deleted\n                    // document there might be another query that will raise this\n                    // document as part of a snapshot until it is resolved,\n                    // essentially exposing inconsistency between queries.\n                    var key = new DocumentKey(query.path);\n                    var deletedDoc = new NoDocument(key, snapshotVersion);\n                    remoteEvent.addDocumentUpdate(deletedDoc);\n                }\n                else {\n                    assert(filter.count === 1, 'Single document existence filter with count: ' + filter.count);\n                }\n            }\n            else {\n                // Not a document query.\n                var promise = _this.localStore\n                    .remoteDocumentKeys(targetId)\n                    .then(function (trackedRemote) {\n                    if (remoteEvent.targetChanges[targetId]) {\n                        var mapping = remoteEvent.targetChanges[targetId].mapping;\n                        if (mapping !== null) {\n                            if (mapping instanceof UpdateMapping) {\n                                trackedRemote = mapping.applyToKeySet(trackedRemote);\n                            }\n                            else {\n                                assert(mapping instanceof ResetMapping, 'Expected either reset or update mapping but got something else: ' +\n                                    mapping);\n                                trackedRemote = mapping.documents;\n                            }\n                        }\n                    }\n                    if (trackedRemote.size !== filter.count) {\n                        // Existence filter mismatch, resetting mapping.\n                        // Make sure the mismatch is exposed in the remote event.\n                        remoteEvent.handleExistenceFilterMismatch(targetId);\n                        // Clear the resume token for the query, since we're in a\n                        // known mismatch state.\n                        var newQueryData = new QueryData(query, targetId, queryData.purpose);\n                        _this.listenTargets[targetId] = newQueryData;\n                        // Cause a hard reset by unwatching and rewatching\n                        // immediately, but deliberately don't send a resume token\n                        // so that we get a full update.\n                        // Make sure we expect that this acks are going to happen.\n                        _this.sendUnwatchRequest(targetId);\n                        // Mark the query we send as being on behalf of an existence\n                        // filter mismatch, but don't actually retain that in\n                        // listenTargets. This ensures that we flag the first\n                        // re-listen this way without impacting future listens of\n                        // this target (that might happen e.g. on reconnect).\n                        var requestQueryData = new QueryData(query, targetId, QueryPurpose.ExistenceFilterMismatch);\n                        _this.sendWatchRequest(requestQueryData);\n                    }\n                });\n                promises.push(promise);\n            }\n        });\n        return Promise.all(promises).then(function () {\n            // Update in-memory resume tokens. LocalStore will update the\n            // persistent view of these when applying the completed RemoteEvent.\n            objUtils.forEachNumber(remoteEvent.targetChanges, function (targetId, change) {\n                if (change.resumeToken.length > 0) {\n                    var queryData = _this.listenTargets[targetId];\n                    // A watched target might have been removed already.\n                    if (queryData) {\n                        _this.listenTargets[targetId] = queryData.update({\n                            resumeToken: change.resumeToken,\n                            snapshotVersion: change.snapshotVersion\n                        });\n                    }\n                }\n            });\n            // Finally handle remote event\n            return _this.syncEngine.applyRemoteEvent(remoteEvent);\n        });\n    };\n    /** Handles an error on a target */\n    RemoteStore.prototype.handleTargetError = function (watchChange) {\n        var _this = this;\n        assert(!!watchChange.cause, 'Handling target error without a cause');\n        var error = watchChange.cause;\n        var promiseChain = Promise.resolve();\n        watchChange.targetIds.forEach(function (targetId) {\n            promiseChain = promiseChain.then(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {\n                return tslib_1.__generator(this, function (_a) {\n                    // A watched target might have been removed already.\n                    if (objUtils.contains(this.listenTargets, targetId)) {\n                        delete this.listenTargets[targetId];\n                        return [2 /*return*/, this.syncEngine.rejectListen(targetId, error)];\n                    }\n                    return [2 /*return*/];\n                });\n            }); });\n        });\n        return promiseChain;\n    };\n    RemoteStore.prototype.cleanUpWriteStreamState = function () {\n        this.lastBatchSeen = BATCHID_UNKNOWN;\n        log.debug(LOG_TAG, 'Stopping write stream with ' +\n            this.pendingWrites.length +\n            ' pending writes');\n        this.pendingWrites = [];\n    };\n    /**\n     * Notifies that there are new mutations to process in the queue. This is\n     * typically called by SyncEngine after it has sent mutations to LocalStore.\n     */\n    RemoteStore.prototype.fillWritePipeline = function () {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return tslib_1.__generator(this, function (_a) {\n                if (this.canWriteMutations()) {\n                    return [2 /*return*/, this.localStore\n                            .nextMutationBatch(this.lastBatchSeen)\n                            .then(function (batch) {\n                            if (batch === null) {\n                                if (_this.pendingWrites.length === 0) {\n                                    _this.writeStream.markIdle();\n                                }\n                            }\n                            else {\n                                _this.commit(batch);\n                                return _this.fillWritePipeline();\n                            }\n                        })];\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    /**\n     * Returns true if the backend can accept additional write requests.\n     *\n     * When sending mutations to the write stream (e.g. in fillWritePipeline),\n     * call this method first to check if more mutations can be sent.\n     *\n     * Currently the only thing that can prevent the backend from accepting\n     * write requests is if there are too many requests already outstanding. As\n     * writes complete the backend will be able to accept more.\n     */\n    RemoteStore.prototype.canWriteMutations = function () {\n        return (this.isNetworkEnabled() && this.pendingWrites.length < MAX_PENDING_WRITES);\n    };\n    // For testing\n    RemoteStore.prototype.outstandingWrites = function () {\n        return this.pendingWrites.length;\n    };\n    /**\n     * Given mutations to commit, actually commits them to the Datastore. Note\n     * that this does *not* return a Promise specifically because the AsyncQueue\n     * should not block operations for this.\n     */\n    RemoteStore.prototype.commit = function (batch) {\n        assert(this.canWriteMutations(), \"commit called when batches can't be written\");\n        this.lastBatchSeen = batch.batchId;\n        this.pendingWrites.push(batch);\n        if (this.shouldStartWriteStream()) {\n            this.startWriteStream();\n        }\n        else if (this.isNetworkEnabled() && this.writeStream.handshakeComplete) {\n            this.writeStream.writeMutations(batch.mutations);\n        }\n    };\n    RemoteStore.prototype.shouldStartWriteStream = function () {\n        return (this.isNetworkEnabled() &&\n            !this.writeStream.isStarted() &&\n            this.pendingWrites.length > 0);\n    };\n    RemoteStore.prototype.startWriteStream = function () {\n        assert(this.shouldStartWriteStream(), 'startWriteStream() called when shouldStartWriteStream() is false.');\n        this.writeStream.start({\n            onOpen: this.onWriteStreamOpen.bind(this),\n            onClose: this.onWriteStreamClose.bind(this),\n            onHandshakeComplete: this.onWriteHandshakeComplete.bind(this),\n            onMutationResult: this.onMutationResult.bind(this)\n        });\n    };\n    RemoteStore.prototype.onWriteStreamOpen = function () {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            return tslib_1.__generator(this, function (_a) {\n                this.writeStream.writeHandshake();\n                return [2 /*return*/];\n            });\n        });\n    };\n    RemoteStore.prototype.onWriteHandshakeComplete = function () {\n        var _this = this;\n        // Record the stream token.\n        return this.localStore\n            .setLastStreamToken(this.writeStream.lastStreamToken)\n            .then(function () {\n            // Drain any pending writes.\n            //\n            // Note that at this point pendingWrites contains mutations that\n            // have already been accepted by fillWritePipeline/commitBatch. If\n            // the pipeline is full, canWriteMutations will be false, despite\n            // the fact that we actually need to send mutations over.\n            //\n            // This also means that this method indirectly respects the limits\n            // imposed by canWriteMutations since writes can't be added to the\n            // pendingWrites array when canWriteMutations is false. If the\n            // limits imposed by canWriteMutations actually protect us from\n            // DOSing ourselves then those limits won't be exceeded here and\n            // we'll continue to make progress.\n            for (var _i = 0, _a = _this.pendingWrites; _i < _a.length; _i++) {\n                var batch = _a[_i];\n                _this.writeStream.writeMutations(batch.mutations);\n            }\n        });\n    };\n    RemoteStore.prototype.onMutationResult = function (commitVersion, results) {\n        var _this = this;\n        // This is a response to a write containing mutations and should be\n        // correlated to the first pending write.\n        assert(this.pendingWrites.length > 0, 'Got result for empty pending writes');\n        var batch = this.pendingWrites.shift();\n        var success = MutationBatchResult.from(batch, commitVersion, results, this.writeStream.lastStreamToken);\n        return this.syncEngine.applySuccessfulWrite(success).then(function () {\n            // It's possible that with the completion of this mutation another\n            // slot has freed up.\n            return _this.fillWritePipeline();\n        });\n    };\n    RemoteStore.prototype.onWriteStreamClose = function (error) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            var errorHandling;\n            return tslib_1.__generator(this, function (_a) {\n                assert(this.isNetworkEnabled(), 'onWriteStreamClose() should only be called when the network is enabled');\n                // If the write stream closed due to an error, invoke the error callbacks if\n                // there are pending writes.\n                if (error && this.pendingWrites.length > 0) {\n                    assert(!!error, 'We have pending writes, but the write stream closed without an error');\n                    errorHandling = void 0;\n                    if (this.writeStream.handshakeComplete) {\n                        // This error affects the actual write.\n                        errorHandling = this.handleWriteError(error);\n                    }\n                    else {\n                        // If there was an error before the handshake has finished, it's\n                        // possible that the server is unable to process the stream token\n                        // we're sending. (Perhaps it's too old?)\n                        errorHandling = this.handleHandshakeError(error);\n                    }\n                    return [2 /*return*/, errorHandling.then(function () {\n                            // The write stream might have been started by refilling the write\n                            // pipeline for failed writes\n                            if (_this.shouldStartWriteStream()) {\n                                _this.startWriteStream();\n                            }\n                        })];\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    RemoteStore.prototype.handleHandshakeError = function (error) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            return tslib_1.__generator(this, function (_a) {\n                // Reset the token if it's a permanent error or the error code is\n                // ABORTED, signaling the write stream is no longer valid.\n                if (isPermanentError(error.code) || error.code === Code.ABORTED) {\n                    log.debug(LOG_TAG, 'RemoteStore error before completed handshake; resetting stream token: ', this.writeStream.lastStreamToken);\n                    this.writeStream.lastStreamToken = emptyByteString();\n                    return [2 /*return*/, this.localStore.setLastStreamToken(emptyByteString())];\n                }\n                else {\n                    // Some other error, don't reset stream token. Our stream logic will\n                    // just retry with exponential backoff.\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    RemoteStore.prototype.handleWriteError = function (error) {\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            var batch;\n            return tslib_1.__generator(this, function (_a) {\n                if (isPermanentError(error.code)) {\n                    batch = this.pendingWrites.shift();\n                    // In this case it's also unlikely that the server itself is melting\n                    // down -- this was just a bad request so inhibit backoff on the next\n                    // restart.\n                    this.writeStream.inhibitBackoff();\n                    return [2 /*return*/, this.syncEngine\n                            .rejectFailedWrite(batch.batchId, error)\n                            .then(function () {\n                            // It's possible that with the completion of this mutation\n                            // another slot has freed up.\n                            return _this.fillWritePipeline();\n                        })];\n                }\n                else {\n                    // Transient error, just let the retry logic kick in.\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    RemoteStore.prototype.createTransaction = function () {\n        return new Transaction(this.datastore);\n    };\n    RemoteStore.prototype.handleUserChange = function (user) {\n        log.debug(LOG_TAG, 'RemoteStore changing users: uid=', user.uid);\n        // If the network has been explicitly disabled, make sure we don't\n        // accidentally re-enable it.\n        if (this.isNetworkEnabled()) {\n            // Tear down and re-create our network streams. This will ensure we get a fresh auth token\n            // for the new user and re-fill the write pipeline with new mutations from the LocalStore\n            // (since mutations are per-user).\n            this.disableNetworkInternal();\n            this.onlineStateTracker.set(OnlineState.Unknown);\n            return this.enableNetwork();\n        }\n    };\n    return RemoteStore;\n}());\nexport { RemoteStore };\n\n//# sourceMappingURL=remote_store.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/remote/remote_store.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { EventManager, QueryListener } from './event_manager';\nimport { SyncEngine } from './sync_engine';\nimport { EagerGarbageCollector } from '../local/eager_garbage_collector';\nimport { IndexedDbPersistence } from '../local/indexeddb_persistence';\nimport { LocalStore } from '../local/local_store';\nimport { MemoryPersistence } from '../local/memory_persistence';\nimport { NoOpGarbageCollector } from '../local/no_op_garbage_collector';\nimport { Datastore } from '../remote/datastore';\nimport { RemoteStore } from '../remote/remote_store';\nimport { JsonProtoSerializer } from '../remote/serializer';\nimport { Code } from '../util/error';\nimport { debug } from '../util/log';\nimport { Deferred } from '../util/promise';\nvar LOG_TAG = 'FirestoreClient';\n/**\n * FirestoreClient is a top-level class that constructs and owns all of the\n * pieces of the client SDK architecture. It is responsible for creating the\n * async queue that is shared by all of the other components in the system.\n */\nvar FirestoreClient = /** @class */ (function () {\n    function FirestoreClient(platform, databaseInfo, credentials, \n    /**\n     * Asynchronous queue responsible for all of our internal processing. When\n     * we get incoming work from the user (via public API) or the network\n     * (incoming GRPC messages), we should always schedule onto this queue.\n     * This ensures all of our work is properly serialized (e.g. we don't\n     * start processing a new operation while the previous one is waiting for\n     * an async I/O to complete).\n     */\n    asyncQueue) {\n        this.platform = platform;\n        this.databaseInfo = databaseInfo;\n        this.credentials = credentials;\n        this.asyncQueue = asyncQueue;\n    }\n    /**\n     * Starts up the FirestoreClient, returning only whether or not enabling\n     * persistence succeeded.\n     *\n     * The intent here is to \"do the right thing\" as far as users are concerned.\n     * Namely, in cases where offline persistence is requested and possible,\n     * enable it, but otherwise fall back to persistence disabled. For the most\n     * part we expect this to succeed one way or the other so we don't expect our\n     * users to actually wait on the firestore.enablePersistence Promise since\n     * they generally won't care.\n     *\n     * Of course some users actually do care about whether or not persistence\n     * was successfully enabled, so the Promise returned from this method\n     * indicates this outcome.\n     *\n     * This presents a problem though: even before enablePersistence resolves or\n     * rejects, users may have made calls to e.g. firestore.collection() which\n     * means that the FirestoreClient in there will be available and will be\n     * enqueuing actions on the async queue.\n     *\n     * Meanwhile any failure of an operation on the async queue causes it to\n     * panic and reject any further work, on the premise that unhandled errors\n     * are fatal.\n     *\n     * Consequently the fallback is handled internally here in start, and if the\n     * fallback succeeds we signal success to the async queue even though the\n     * start() itself signals failure.\n     *\n     * @param usePersistence Whether or not to attempt to enable persistence.\n     * @returns A deferred result indicating the user-visible result of enabling\n     *     offline persistence. This method will reject this if IndexedDB fails to\n     *     start for any reason. If usePersistence is false this is\n     *     unconditionally resolved.\n     */\n    FirestoreClient.prototype.start = function (usePersistence) {\n        var _this = this;\n        // We defer our initialization until we get the current user from\n        // setUserChangeListener(). We block the async queue until we got the\n        // initial user and the initialization is completed. This will prevent\n        // any scheduled work from happening before initialization is completed.\n        //\n        // If initializationDone resolved then the FirestoreClient is in a usable\n        // state.\n        var initializationDone = new Deferred();\n        // If usePersistence is true, certain classes of errors while starting are\n        // recoverable but only by falling back to persistence disabled.\n        //\n        // If there's an error in the first case but not in recovery we cannot\n        // reject the promise blocking the async queue because this will cause the\n        // async queue to panic.\n        var persistenceResult = new Deferred();\n        var initialized = false;\n        this.credentials.setUserChangeListener(function (user) {\n            if (!initialized) {\n                initialized = true;\n                _this.initializePersistence(usePersistence, persistenceResult)\n                    .then(function () { return _this.initializeRest(user); })\n                    .then(initializationDone.resolve, initializationDone.reject);\n            }\n            else {\n                _this.asyncQueue.enqueue(function () {\n                    return _this.handleUserChange(user);\n                });\n            }\n        });\n        // Block the async queue until initialization is done\n        this.asyncQueue.enqueue(function () {\n            return initializationDone.promise;\n        });\n        // Return only the result of enabling persistence. Note that this does not\n        // need to await the completion of initializationDone because the result of\n        // this method should not reflect any other kind of failure to start.\n        return persistenceResult.promise;\n    };\n    /** Enables the network connection and requeues all pending operations. */\n    FirestoreClient.prototype.enableNetwork = function () {\n        var _this = this;\n        return this.asyncQueue.enqueue(function () {\n            return _this.remoteStore.enableNetwork();\n        });\n    };\n    /**\n     * Initializes persistent storage, attempting to use IndexedDB if\n     * usePersistence is true or memory-only if false.\n     *\n     * If IndexedDB fails because it's already open in another tab or because the\n     * platform can't possibly support our implementation then this method rejects\n     * the persistenceResult and falls back on memory-only persistence.\n     *\n     * @param usePersistence indicates whether or not to use offline persistence\n     * @param persistenceResult A deferred result indicating the user-visible\n     *     result of enabling offline persistence. This method will reject this if\n     *     IndexedDB fails to start for any reason. If usePersistence is false\n     *     this is unconditionally resolved.\n     * @returns a Promise indicating whether or not initialization should\n     *     continue, i.e. that one of the persistence implementations actually\n     *     succeeded.\n     */\n    FirestoreClient.prototype.initializePersistence = function (usePersistence, persistenceResult) {\n        var _this = this;\n        if (usePersistence) {\n            return this.startIndexedDbPersistence()\n                .then(persistenceResult.resolve)\n                .catch(function (error) {\n                // Regardless of whether or not the retry succeeds, from an user\n                // perspective, offline persistence has failed.\n                persistenceResult.reject(error);\n                // An unknown failure on the first stage shuts everything down.\n                if (!_this.canFallback(error)) {\n                    return Promise.reject(error);\n                }\n                console.warn('Error enabling offline storage. Falling back to' +\n                    ' storage disabled: ' +\n                    error);\n                return _this.startMemoryPersistence();\n            });\n        }\n        else {\n            // When usePersistence == false, enabling offline persistence is defined\n            // to unconditionally succeed. This allows start() to have the same\n            // signature for both cases, despite the fact that the returned promise\n            // is only used in the enablePersistence call.\n            persistenceResult.resolve();\n            return this.startMemoryPersistence();\n        }\n    };\n    FirestoreClient.prototype.canFallback = function (error) {\n        return (error.code === Code.FAILED_PRECONDITION ||\n            error.code === Code.UNIMPLEMENTED);\n    };\n    /**\n     * Starts IndexedDB-based persistence.\n     *\n     * @returns A promise indicating success or failure.\n     */\n    FirestoreClient.prototype.startIndexedDbPersistence = function () {\n        // TODO(http://b/33384523): For now we just disable garbage collection\n        // when persistence is enabled.\n        this.garbageCollector = new NoOpGarbageCollector();\n        var storagePrefix = IndexedDbPersistence.buildStoragePrefix(this.databaseInfo);\n        // Opt to use proto3 JSON in case the platform doesn't support Uint8Array.\n        var serializer = new JsonProtoSerializer(this.databaseInfo.databaseId, {\n            useProto3Json: true\n        });\n        this.persistence = new IndexedDbPersistence(storagePrefix, serializer);\n        return this.persistence.start();\n    };\n    /**\n     * Starts Memory-backed persistence. In practice this cannot fail.\n     *\n     * @returns A promise that will successfully resolve.\n     */\n    FirestoreClient.prototype.startMemoryPersistence = function () {\n        this.garbageCollector = new EagerGarbageCollector();\n        this.persistence = new MemoryPersistence();\n        return this.persistence.start();\n    };\n    /**\n     * Initializes the rest of the FirestoreClient, assuming the initial user\n     * has been obtained from the credential provider and some persistence\n     * implementation is available in this.persistence.\n     */\n    FirestoreClient.prototype.initializeRest = function (user) {\n        var _this = this;\n        return this.platform\n            .loadConnection(this.databaseInfo)\n            .then(function (connection) {\n            _this.localStore = new LocalStore(_this.persistence, user, _this.garbageCollector);\n            var serializer = _this.platform.newSerializer(_this.databaseInfo.databaseId);\n            var datastore = new Datastore(_this.asyncQueue, connection, _this.credentials, serializer);\n            var onlineStateChangedHandler = function (onlineState) {\n                _this.syncEngine.applyOnlineStateChange(onlineState);\n                _this.eventMgr.applyOnlineStateChange(onlineState);\n            };\n            _this.remoteStore = new RemoteStore(_this.localStore, datastore, _this.asyncQueue, onlineStateChangedHandler);\n            _this.syncEngine = new SyncEngine(_this.localStore, _this.remoteStore, user);\n            // Setup wiring between sync engine and remote store\n            _this.remoteStore.syncEngine = _this.syncEngine;\n            _this.eventMgr = new EventManager(_this.syncEngine);\n            // NOTE: RemoteStore depends on LocalStore (for persisting stream\n            // tokens, refilling mutation queue, etc.) so must be started after\n            // LocalStore.\n            return _this.localStore.start();\n        })\n            .then(function () {\n            return _this.remoteStore.start();\n        });\n    };\n    FirestoreClient.prototype.handleUserChange = function (user) {\n        this.asyncQueue.verifyOperationInProgress();\n        debug(LOG_TAG, 'User Changed: ' + user.uid);\n        return this.syncEngine.handleUserChange(user);\n    };\n    /** Disables the network connection. Pending operations will not complete. */\n    FirestoreClient.prototype.disableNetwork = function () {\n        var _this = this;\n        return this.asyncQueue.enqueue(function () {\n            return _this.remoteStore.disableNetwork();\n        });\n    };\n    FirestoreClient.prototype.shutdown = function () {\n        var _this = this;\n        return this.asyncQueue\n            .enqueue(function () {\n            _this.credentials.removeUserChangeListener();\n            return _this.remoteStore.shutdown();\n        })\n            .then(function () {\n            // PORTING NOTE: LocalStore does not need an explicit shutdown on web.\n            return _this.persistence.shutdown();\n        });\n    };\n    FirestoreClient.prototype.listen = function (query, observer, options) {\n        var _this = this;\n        var listener = new QueryListener(query, observer, options);\n        this.asyncQueue.enqueue(function () {\n            return _this.eventMgr.listen(listener);\n        });\n        return listener;\n    };\n    FirestoreClient.prototype.unlisten = function (listener) {\n        var _this = this;\n        this.asyncQueue.enqueue(function () {\n            return _this.eventMgr.unlisten(listener);\n        });\n    };\n    FirestoreClient.prototype.write = function (mutations) {\n        var _this = this;\n        var deferred = new Deferred();\n        this.asyncQueue.enqueue(function () { return _this.syncEngine.write(mutations, deferred); });\n        return deferred.promise;\n    };\n    FirestoreClient.prototype.databaseId = function () {\n        return this.databaseInfo.databaseId;\n    };\n    FirestoreClient.prototype.transaction = function (updateFunction) {\n        var _this = this;\n        // We have to wait for the async queue to be sure syncEngine is initialized.\n        return this.asyncQueue\n            .enqueue(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {\n            return [2 /*return*/];\n        }); }); })\n            .then(function () { return _this.syncEngine.runTransaction(updateFunction); });\n    };\n    return FirestoreClient;\n}());\nexport { FirestoreClient };\n\n//# sourceMappingURL=firestore_client.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/core/firestore_client.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * A wrapper implementation of Observer<T> that will dispatch events\n * asynchronously. To allow immediate silencing, a mute call is added which\n * causes events scheduled to no longer be raised.\n */\nvar AsyncObserver = /** @class */ (function () {\n    function AsyncObserver(observer) {\n        this.observer = observer;\n        /**\n         * When set to true, will not raise future events. Necessary to deal with\n         * async detachment of listener.\n         */\n        this.muted = false;\n    }\n    AsyncObserver.prototype.next = function (value) {\n        this.scheduleEvent(this.observer.next, value);\n    };\n    AsyncObserver.prototype.error = function (error) {\n        this.scheduleEvent(this.observer.error, error);\n    };\n    AsyncObserver.prototype.mute = function () {\n        this.muted = true;\n    };\n    AsyncObserver.prototype.scheduleEvent = function (eventHandler, event) {\n        var _this = this;\n        if (!this.muted) {\n            setTimeout(function () {\n                if (!_this.muted) {\n                    eventHandler(event);\n                }\n            }, 0);\n        }\n    };\n    return AsyncObserver;\n}());\nexport { AsyncObserver };\n\n//# sourceMappingURL=async_observer.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/util/async_observer.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Simple wrapper around a nullable UID. Mostly exists to make code more\n * readable.\n */\nvar User = /** @class */ (function () {\n    function User(uid) {\n        this.uid = uid;\n    }\n    User.prototype.isAuthenticated = function () {\n        return this.uid != null;\n    };\n    /**\n     * Returns a key representing this user, suitable for inclusion in a\n     * dictionary.\n     */\n    User.prototype.toKey = function () {\n        if (this.isAuthenticated()) {\n            return 'uid:' + this.uid;\n        }\n        else {\n            return 'anonymous-user';\n        }\n    };\n    User.prototype.isEqual = function (otherUser) {\n        return otherUser.uid === this.uid;\n    };\n    /** A user with a null UID. */\n    User.UNAUTHENTICATED = new User(null);\n    // TODO(mikelehen): Look into getting a proper uid-equivalent for\n    // non-FirebaseAuth providers.\n    User.GOOGLE_CREDENTIALS = new User('google-credentials-uid');\n    User.FIRST_PARTY = new User('first-party-uid');\n    return User;\n}());\nexport { User };\n\n//# sourceMappingURL=user.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/auth/user.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as tslib_1 from \"tslib\";\nimport { makeConstructorPrivate } from '../util/api';\n/**\n * An opaque base class for FieldValue sentinel objects in our public API,\n * with public static methods for creating said sentinel objects.\n */\n// tslint:disable-next-line:class-as-namespace  We use this as a base class.\nvar FieldValueImpl = /** @class */ (function () {\n    function FieldValueImpl() {\n    }\n    FieldValueImpl.delete = function () {\n        return DeleteFieldValueImpl.instance;\n    };\n    FieldValueImpl.serverTimestamp = function () {\n        return ServerTimestampFieldValueImpl.instance;\n    };\n    FieldValueImpl.prototype.isEqual = function (other) {\n        return this === other;\n    };\n    return FieldValueImpl;\n}());\nexport { FieldValueImpl };\nvar DeleteFieldValueImpl = /** @class */ (function (_super) {\n    tslib_1.__extends(DeleteFieldValueImpl, _super);\n    function DeleteFieldValueImpl() {\n        return _super.call(this) || this;\n    }\n    /** Singleton instance. */\n    DeleteFieldValueImpl.instance = new DeleteFieldValueImpl();\n    return DeleteFieldValueImpl;\n}(FieldValueImpl));\nexport { DeleteFieldValueImpl };\nvar ServerTimestampFieldValueImpl = /** @class */ (function (_super) {\n    tslib_1.__extends(ServerTimestampFieldValueImpl, _super);\n    function ServerTimestampFieldValueImpl() {\n        return _super.call(this) || this;\n    }\n    /** Singleton instance. */\n    ServerTimestampFieldValueImpl.instance = new ServerTimestampFieldValueImpl();\n    return ServerTimestampFieldValueImpl;\n}(FieldValueImpl));\nexport { ServerTimestampFieldValueImpl };\n// Public instance that disallows construction at runtime. This constructor is\n// used when exporting FieldValueImpl on firebase.firestore.FieldValue and will\n// be called FieldValue publicly. Internally we still use FieldValueImpl which\n// has a type-checked private constructor. Note that FieldValueImpl and\n// PublicFieldValue can be used interchangeably in instanceof checks.\n// For our internal TypeScript code PublicFieldValue doesn't exist as a type,\n// and so we need to use FieldValueImpl as type and export it too.\n// tslint:disable-next-line:variable-name  We treat this as a class name.\nexport var PublicFieldValue = makeConstructorPrivate(FieldValueImpl, 'Use FieldValue.<field>() instead.');\n\n//# sourceMappingURL=field_value.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../firestore/dist/esm/src/api/field_value.js\n// module id = null\n// module chunks = ","(function() {var g,goog=goog||{},k=this;function l(a){return\"string\"==typeof a}function aa(){}\nfunction ba(a){var b=typeof a;if(\"object\"==b)if(a){if(a instanceof Array)return\"array\";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if(\"[object Window]\"==c)return\"object\";if(\"[object Array]\"==c||\"number\"==typeof a.length&&\"undefined\"!=typeof a.splice&&\"undefined\"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable(\"splice\"))return\"array\";if(\"[object Function]\"==c||\"undefined\"!=typeof a.call&&\"undefined\"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable(\"call\"))return\"function\"}else return\"null\";\nelse if(\"function\"==b&&\"undefined\"==typeof a.call)return\"object\";return b}function n(a){return\"array\"==ba(a)}function ca(a){var b=ba(a);return\"array\"==b||\"object\"==b&&\"number\"==typeof a.length}function da(a){return\"function\"==ba(a)}function ea(a){var b=typeof a;return\"object\"==b&&null!=a||\"function\"==b}var p=\"closure_uid_\"+(1E9*Math.random()>>>0),fa=0;function ha(a,b,c){return a.call.apply(a.bind,arguments)}\nfunction ia(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function q(a,b,c){Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf(\"native code\")?q=ha:q=ia;return q.apply(null,arguments)}\nfunction ja(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=c.slice();b.push.apply(b,arguments);return a.apply(this,b)}}var r=Date.now||function(){return+new Date};function t(a,b){function c(){}c.prototype=b.prototype;a.H=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.Db=function(a,c,f){for(var d=Array(arguments.length-2),e=2;e<arguments.length;e++)d[e-2]=arguments[e];return b.prototype[c].apply(a,d)}};function ka(a){if(Error.captureStackTrace)Error.captureStackTrace(this,ka);else{var b=Error().stack;b&&(this.stack=b)}a&&(this.message=String(a))}t(ka,Error);ka.prototype.name=\"CustomError\";function la(a,b){a=a.split(\"%s\");for(var c=\"\",d=a.length-1,e=0;e<d;e++)c+=a[e]+(e<b.length?b[e]:\"%s\");ka.call(this,c+a[d])}t(la,ka);la.prototype.name=\"AssertionError\";function ma(a,b){throw new la(\"Failure\"+(a?\": \"+a:\"\"),Array.prototype.slice.call(arguments,1));};function u(){0!=na&&(pa[this[p]||(this[p]=++fa)]=this);this.i=this.i;this.m=this.m}var na=0,pa={};u.prototype.i=!1;u.prototype.$=function(){if(!this.i&&(this.i=!0,this.w(),0!=na)){var a=this[p]||(this[p]=++fa);if(0!=na&&this.m&&0<this.m.length)throw Error(this+\" did not empty its onDisposeCallbacks queue. This probably means it overrode dispose() or disposeInternal() without calling the superclass' method.\");delete pa[a]}};u.prototype.w=function(){if(this.m)for(;this.m.length;)this.m.shift()()};var qa=Array.prototype.indexOf?function(a,b){return Array.prototype.indexOf.call(a,b,void 0)}:function(a,b){if(l(a))return l(b)&&1==b.length?a.indexOf(b,0):-1;for(var c=0;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1},ra=Array.prototype.forEach?function(a,b,c){Array.prototype.forEach.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=l(a)?a.split(\"\"):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a)};\nfunction sa(a){a:{var b=ta;for(var c=a.length,d=l(a)?a.split(\"\"):a,e=0;e<c;e++)if(e in d&&b.call(void 0,d[e],e,a)){b=e;break a}b=-1}return 0>b?null:l(a)?a.charAt(b):a[b]}function ua(a){if(!n(a))for(var b=a.length-1;0<=b;b--)delete a[b];a.length=0}function va(a){return Array.prototype.concat.apply([],arguments)}function wa(a){var b=a.length;if(0<b){for(var c=Array(b),d=0;d<b;d++)c[d]=a[d];return c}return[]};function xa(a){return/^[\\s\\xa0]*$/.test(a)}var ya=String.prototype.trim?function(a){return a.trim()}:function(a){return/^[\\s\\xa0]*([\\s\\S]*?)[\\s\\xa0]*$/.exec(a)[1]};function za(a,b){return a<b?-1:a>b?1:0};var w;a:{var Aa=k.navigator;if(Aa){var Ba=Aa.userAgent;if(Ba){w=Ba;break a}}w=\"\"}function x(a){return-1!=w.indexOf(a)};function Ca(a,b,c){for(var d in a)b.call(c,a[d],d,a)}function Da(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b}function Ea(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b}function Fa(a){var b={},c;for(c in a)b[c]=a[c];return b}var Ga=\"constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf\".split(\" \");\nfunction Ha(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<Ga.length;f++)c=Ga[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c])}};function Ia(a){Ia[\" \"](a);return a}Ia[\" \"]=aa;function Ja(a,b){var c=Ka;return Object.prototype.hasOwnProperty.call(c,a)?c[a]:c[a]=b(a)};var La=x(\"Opera\"),y=x(\"Trident\")||x(\"MSIE\"),Ma=x(\"Edge\"),Na=Ma||y,Oa=x(\"Gecko\")&&!(-1!=w.toLowerCase().indexOf(\"webkit\")&&!x(\"Edge\"))&&!(x(\"Trident\")||x(\"MSIE\"))&&!x(\"Edge\"),Pa=-1!=w.toLowerCase().indexOf(\"webkit\")&&!x(\"Edge\");function Qa(){var a=k.document;return a?a.documentMode:void 0}var Ra;\na:{var Sa=\"\",Ta=function(){var a=w;if(Oa)return/rv:([^\\);]+)(\\)|;)/.exec(a);if(Ma)return/Edge\\/([\\d\\.]+)/.exec(a);if(y)return/\\b(?:MSIE|rv)[: ]([^\\);]+)(\\)|;)/.exec(a);if(Pa)return/WebKit\\/(\\S+)/.exec(a);if(La)return/(?:Version)[ \\/]?(\\S+)/.exec(a)}();Ta&&(Sa=Ta?Ta[1]:\"\");if(y){var Ua=Qa();if(null!=Ua&&Ua>parseFloat(Sa)){Ra=String(Ua);break a}}Ra=Sa}var Ka={};\nfunction Va(a){return Ja(a,function(){for(var b=0,c=ya(String(Ra)).split(\".\"),d=ya(String(a)).split(\".\"),e=Math.max(c.length,d.length),f=0;0==b&&f<e;f++){var h=c[f]||\"\",m=d[f]||\"\";do{h=/(\\d*)(\\D*)(.*)/.exec(h)||[\"\",\"\",\"\",\"\"];m=/(\\d*)(\\D*)(.*)/.exec(m)||[\"\",\"\",\"\",\"\"];if(0==h[0].length&&0==m[0].length)break;b=za(0==h[1].length?0:parseInt(h[1],10),0==m[1].length?0:parseInt(m[1],10))||za(0==h[2].length,0==m[2].length)||za(h[2],m[2]);h=h[3];m=m[3]}while(0==b)}return 0<=b})}var Wa;var Xa=k.document;\nWa=Xa&&y?Qa()||(\"CSS1Compat\"==Xa.compatMode?parseInt(Ra,10):5):void 0;var Ya=Object.freeze||function(a){return a};var Za=!y||9<=Number(Wa),$a=y&&!Va(\"9\"),ab=function(){if(!k.addEventListener||!Object.defineProperty)return!1;var a=!1,b=Object.defineProperty({},\"passive\",{get:function(){a=!0}});k.addEventListener(\"test\",aa,b);k.removeEventListener(\"test\",aa,b);return a}();function z(a,b){this.type=a;this.a=this.target=b;this.Qa=!0}z.prototype.b=function(){this.Qa=!1};function bb(a,b){z.call(this,a?a.type:\"\");this.relatedTarget=this.a=this.target=null;this.button=this.screenY=this.screenX=this.clientY=this.clientX=0;this.key=\"\";this.metaKey=this.shiftKey=this.altKey=this.ctrlKey=!1;this.pointerId=0;this.pointerType=\"\";this.c=null;if(a){var c=this.type=a.type,d=a.changedTouches?a.changedTouches[0]:null;this.target=a.target||a.srcElement;this.a=b;if(b=a.relatedTarget){if(Oa){a:{try{Ia(b.nodeName);var e=!0;break a}catch(f){}e=!1}e||(b=null)}}else\"mouseover\"==c?b=\na.fromElement:\"mouseout\"==c&&(b=a.toElement);this.relatedTarget=b;null===d?(this.clientX=void 0!==a.clientX?a.clientX:a.pageX,this.clientY=void 0!==a.clientY?a.clientY:a.pageY,this.screenX=a.screenX||0,this.screenY=a.screenY||0):(this.clientX=void 0!==d.clientX?d.clientX:d.pageX,this.clientY=void 0!==d.clientY?d.clientY:d.pageY,this.screenX=d.screenX||0,this.screenY=d.screenY||0);this.button=a.button;this.key=a.key||\"\";this.ctrlKey=a.ctrlKey;this.altKey=a.altKey;this.shiftKey=a.shiftKey;this.metaKey=\na.metaKey;this.pointerId=a.pointerId||0;this.pointerType=l(a.pointerType)?a.pointerType:cb[a.pointerType]||\"\";this.c=a;a.defaultPrevented&&this.b()}}t(bb,z);var cb=Ya({2:\"touch\",3:\"pen\",4:\"mouse\"});bb.prototype.b=function(){bb.H.b.call(this);var a=this.c;if(a.preventDefault)a.preventDefault();else if(a.returnValue=!1,$a)try{if(a.ctrlKey||112<=a.keyCode&&123>=a.keyCode)a.keyCode=-1}catch(b){}};var db=\"closure_listenable_\"+(1E6*Math.random()|0),eb=0;function fb(a,b,c,d,e){this.listener=a;this.proxy=null;this.src=b;this.type=c;this.capture=!!d;this.ga=e;this.key=++eb;this.Z=this.ba=!1}function gb(a){a.Z=!0;a.listener=null;a.proxy=null;a.src=null;a.ga=null};function hb(a){this.src=a;this.a={};this.b=0}hb.prototype.add=function(a,b,c,d,e){var f=a.toString();a=this.a[f];a||(a=this.a[f]=[],this.b++);var h=ib(a,b,d,e);-1<h?(b=a[h],c||(b.ba=!1)):(b=new fb(b,this.src,f,!!d,e),b.ba=c,a.push(b));return b};function jb(a,b){var c=b.type;if(c in a.a){var d=a.a[c],e=qa(d,b),f;(f=0<=e)&&Array.prototype.splice.call(d,e,1);f&&(gb(b),0==a.a[c].length&&(delete a.a[c],a.b--))}}\nfunction ib(a,b,c,d){for(var e=0;e<a.length;++e){var f=a[e];if(!f.Z&&f.listener==b&&f.capture==!!c&&f.ga==d)return e}return-1};var kb=\"closure_lm_\"+(1E6*Math.random()|0),lb={},mb=0;function nb(a,b,c,d,e){if(d&&d.once)return ob(a,b,c,d,e);if(n(b)){for(var f=0;f<b.length;f++)nb(a,b[f],c,d,e);return null}c=pb(c);return a&&a[db]?a.Ha(b,c,ea(d)?!!d.capture:!!d,e):qb(a,b,c,!1,d,e)}\nfunction qb(a,b,c,d,e,f){if(!b)throw Error(\"Invalid event type\");var h=ea(e)?!!e.capture:!!e,m=rb(a);m||(a[kb]=m=new hb(a));c=m.add(b,c,d,h,f);if(c.proxy)return c;d=sb();c.proxy=d;d.src=a;d.listener=c;if(a.addEventListener)ab||(e=h),void 0===e&&(e=!1),a.addEventListener(b.toString(),d,e);else if(a.attachEvent)a.attachEvent(tb(b.toString()),d);else if(a.addListener&&a.removeListener)a.addListener(d);else throw Error(\"addEventListener and attachEvent are unavailable.\");mb++;return c}\nfunction sb(){var a=ub,b=Za?function(c){return a.call(b.src,b.listener,c)}:function(c){c=a.call(b.src,b.listener,c);if(!c)return c};return b}function ob(a,b,c,d,e){if(n(b)){for(var f=0;f<b.length;f++)ob(a,b[f],c,d,e);return null}c=pb(c);return a&&a[db]?a.Ia(b,c,ea(d)?!!d.capture:!!d,e):qb(a,b,c,!0,d,e)}\nfunction vb(a,b,c,d,e){if(n(b))for(var f=0;f<b.length;f++)vb(a,b[f],c,d,e);else(d=ea(d)?!!d.capture:!!d,c=pb(c),a&&a[db])?(a=a.f,b=String(b).toString(),b in a.a&&(f=a.a[b],c=ib(f,c,d,e),-1<c&&(gb(f[c]),Array.prototype.splice.call(f,c,1),0==f.length&&(delete a.a[b],a.b--)))):a&&(a=rb(a))&&(b=a.a[b.toString()],a=-1,b&&(a=ib(b,c,d,e)),(c=-1<a?b[a]:null)&&wb(c))}\nfunction wb(a){if(\"number\"!=typeof a&&a&&!a.Z){var b=a.src;if(b&&b[db])jb(b.f,a);else{var c=a.type,d=a.proxy;b.removeEventListener?b.removeEventListener(c,d,a.capture):b.detachEvent?b.detachEvent(tb(c),d):b.addListener&&b.removeListener&&b.removeListener(d);mb--;(c=rb(b))?(jb(c,a),0==c.b&&(c.src=null,b[kb]=null)):gb(a)}}}function tb(a){return a in lb?lb[a]:lb[a]=\"on\"+a}\nfunction xb(a,b,c,d){var e=!0;if(a=rb(a))if(b=a.a[b.toString()])for(b=b.concat(),a=0;a<b.length;a++){var f=b[a];f&&f.capture==c&&!f.Z&&(f=yb(f,d),e=e&&!1!==f)}return e}function yb(a,b){var c=a.listener,d=a.ga||a.src;a.ba&&wb(a);return c.call(d,b)}\nfunction ub(a,b){if(a.Z)return!0;if(!Za){if(!b)a:{b=[\"window\",\"event\"];for(var c=k,d=0;d<b.length;d++)if(c=c[b[d]],null==c){b=null;break a}b=c}d=b;b=new bb(d,this);c=!0;if(!(0>d.keyCode||void 0!=d.returnValue)){a:{var e=!1;if(0==d.keyCode)try{d.keyCode=-1;break a}catch(h){e=!0}if(e||void 0==d.returnValue)d.returnValue=!0}d=[];for(e=b.a;e;e=e.parentNode)d.push(e);a=a.type;for(e=d.length-1;0<=e;e--){b.a=d[e];var f=xb(d[e],a,!0,b);c=c&&f}for(e=0;e<d.length;e++)b.a=d[e],f=xb(d[e],a,!1,b),c=c&&f}return c}return yb(a,\nnew bb(b,this))}function rb(a){a=a[kb];return a instanceof hb?a:null}var zb=\"__closure_events_fn_\"+(1E9*Math.random()>>>0);function pb(a){if(da(a))return a;a[zb]||(a[zb]=function(b){return a.handleEvent(b)});return a[zb]};function A(){u.call(this);this.f=new hb(this);this.N=this;this.J=null}t(A,u);A.prototype[db]=!0;g=A.prototype;g.addEventListener=function(a,b,c,d){nb(this,a,b,c,d)};g.removeEventListener=function(a,b,c,d){vb(this,a,b,c,d)};\ng.dispatchEvent=function(a){var b,c=this.J;if(c)for(b=[];c;c=c.J)b.push(c);c=this.N;var d=a.type||a;if(l(a))a=new z(a,c);else if(a instanceof z)a.target=a.target||c;else{var e=a;a=new z(d,c);Ha(a,e)}e=!0;if(b)for(var f=b.length-1;0<=f;f--){var h=a.a=b[f];e=Ab(h,d,!0,a)&&e}h=a.a=c;e=Ab(h,d,!0,a)&&e;e=Ab(h,d,!1,a)&&e;if(b)for(f=0;f<b.length;f++)h=a.a=b[f],e=Ab(h,d,!1,a)&&e;return e};\ng.w=function(){A.H.w.call(this);if(this.f){var a=this.f,b=0,c;for(c in a.a){for(var d=a.a[c],e=0;e<d.length;e++)++b,gb(d[e]);delete a.a[c];a.b--}}this.J=null};g.Ha=function(a,b,c,d){return this.f.add(String(a),b,!1,c,d)};g.Ia=function(a,b,c,d){return this.f.add(String(a),b,!0,c,d)};\nfunction Ab(a,b,c,d){b=a.f.a[String(b)];if(!b)return!0;b=b.concat();for(var e=!0,f=0;f<b.length;++f){var h=b[f];if(h&&!h.Z&&h.capture==c){var m=h.listener,v=h.ga||h.src;h.ba&&jb(a.f,h);e=!1!==m.call(v,d)&&e}}return e&&0!=d.Qa};function Bb(a){return/^\\s*$/.test(a)?!1:/^[\\],:{}\\s\\u2028\\u2029]*$/.test(a.replace(/\\\\[\"\\\\\\/bfnrtu]/g,\"@\").replace(/(?:\"[^\"\\\\\\n\\r\\u2028\\u2029\\x00-\\x08\\x0a-\\x1f]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)[\\s\\u2028\\u2029]*(?=:|,|]|}|$)/g,\"]\").replace(/(?:^|:|,)(?:[\\s\\u2028\\u2029]*\\[)+/g,\"\"))}function Cb(a){a=String(a);if(Bb(a))try{return eval(\"(\"+a+\")\")}catch(b){}throw Error(\"Invalid JSON string: \"+a);}function Db(a){var b=[];Eb(new Fb,a,b);return b.join(\"\")}function Fb(){}\nfunction Eb(a,b,c){if(null==b)c.push(\"null\");else{if(\"object\"==typeof b){if(n(b)){var d=b;b=d.length;c.push(\"[\");for(var e=\"\",f=0;f<b;f++)c.push(e),Eb(a,d[f],c),e=\",\";c.push(\"]\");return}if(b instanceof String||b instanceof Number||b instanceof Boolean)b=b.valueOf();else{c.push(\"{\");e=\"\";for(d in b)Object.prototype.hasOwnProperty.call(b,d)&&(f=b[d],\"function\"!=typeof f&&(c.push(e),Gb(d,c),c.push(\":\"),Eb(a,f,c),e=\",\"));c.push(\"}\");return}}switch(typeof b){case \"string\":Gb(b,c);break;case \"number\":c.push(isFinite(b)&&\n!isNaN(b)?String(b):\"null\");break;case \"boolean\":c.push(String(b));break;case \"function\":c.push(\"null\");break;default:throw Error(\"Unknown type: \"+typeof b);}}}var Hb={'\"':'\\\\\"',\"\\\\\":\"\\\\\\\\\",\"/\":\"\\\\/\",\"\\b\":\"\\\\b\",\"\\f\":\"\\\\f\",\"\\n\":\"\\\\n\",\"\\r\":\"\\\\r\",\"\\t\":\"\\\\t\",\"\\x0B\":\"\\\\u000b\"},Ib=/\\uffff/.test(\"\\uffff\")?/[\\\\\"\\x00-\\x1f\\x7f-\\uffff]/g:/[\\\\\"\\x00-\\x1f\\x7f-\\xff]/g;\nfunction Gb(a,b){b.push('\"',a.replace(Ib,function(a){var b=Hb[a];b||(b=\"\\\\u\"+(a.charCodeAt(0)|65536).toString(16).substr(1),Hb[a]=b);return b}),'\"')};function Jb(a,b){this.c=a;this.f=b;this.b=0;this.a=null}Jb.prototype.get=function(){if(0<this.b){this.b--;var a=this.a;this.a=a.next;a.next=null}else a=this.c();return a};function Kb(){this.b=this.a=null}var Nb=new Jb(function(){return new Mb},function(a){a.reset()});Kb.prototype.add=function(a,b){var c=Nb.get();c.set(a,b);this.b?this.b.next=c:this.a=c;this.b=c};function Ob(){var a=Pb,b=null;a.a&&(b=a.a,a.a=a.a.next,a.a||(a.b=null),b.next=null);return b}function Mb(){this.next=this.b=this.a=null}Mb.prototype.set=function(a,b){this.a=a;this.b=b;this.next=null};Mb.prototype.reset=function(){this.next=this.b=this.a=null};function Qb(a){k.setTimeout(function(){throw a;},0)}var Rb;\nfunction Sb(){var a=k.MessageChannel;\"undefined\"===typeof a&&\"undefined\"!==typeof window&&window.postMessage&&window.addEventListener&&!x(\"Presto\")&&(a=function(){var a=document.createElement(\"IFRAME\");a.style.display=\"none\";a.src=\"\";document.documentElement.appendChild(a);var b=a.contentWindow;a=b.document;a.open();a.write(\"\");a.close();var c=\"callImmediate\"+Math.random(),d=\"file:\"==b.location.protocol?\"*\":b.location.protocol+\"//\"+b.location.host;a=q(function(a){if((\"*\"==d||a.origin==d)&&a.data==\nc)this.port1.onmessage()},this);b.addEventListener(\"message\",a,!1);this.port1={};this.port2={postMessage:function(){b.postMessage(c,d)}}});if(\"undefined\"!==typeof a&&!x(\"Trident\")&&!x(\"MSIE\")){var b=new a,c={},d=c;b.port1.onmessage=function(){if(void 0!==c.next){c=c.next;var a=c.ya;c.ya=null;a()}};return function(a){d.next={ya:a};d=d.next;b.port2.postMessage(0)}}return\"undefined\"!==typeof document&&\"onreadystatechange\"in document.createElement(\"SCRIPT\")?function(a){var b=document.createElement(\"SCRIPT\");\nb.onreadystatechange=function(){b.onreadystatechange=null;b.parentNode.removeChild(b);b=null;a();a=null};document.documentElement.appendChild(b)}:function(a){k.setTimeout(a,0)}};var Tb;function Ub(){if(-1!=String(k.Promise).indexOf(\"[native code]\")){var a=k.Promise.resolve(void 0);Tb=function(){a.then(Vb)}}else Tb=function(){var a=Vb;!da(k.setImmediate)||k.Window&&k.Window.prototype&&!x(\"Edge\")&&k.Window.prototype.setImmediate==k.setImmediate?(Rb||(Rb=Sb()),Rb(a)):k.setImmediate(a)}}var Wb=!1,Pb=new Kb;function Vb(){for(var a;a=Ob();){try{a.a.call(a.b)}catch(c){Qb(c)}var b=Nb;b.f(a);100>b.b&&(b.b++,a.next=b.a,b.a=a)}Wb=!1};function Xb(a,b){A.call(this);this.b=a||1;this.a=b||k;this.c=q(this.lb,this);this.g=r()}t(Xb,A);g=Xb.prototype;g.ea=!1;g.O=null;g.lb=function(){if(this.ea){var a=r()-this.g;0<a&&a<.8*this.b?this.O=this.a.setTimeout(this.c,this.b-a):(this.O&&(this.a.clearTimeout(this.O),this.O=null),this.dispatchEvent(\"tick\"),this.ea&&(this.O=this.a.setTimeout(this.c,this.b),this.g=r()))}};g.start=function(){this.ea=!0;this.O||(this.O=this.a.setTimeout(this.c,this.b),this.g=r())};\nfunction Yb(a){a.ea=!1;a.O&&(a.a.clearTimeout(a.O),a.O=null)}g.w=function(){Xb.H.w.call(this);Yb(this);delete this.a};function Zb(a,b,c){if(da(a))c&&(a=q(a,c));else if(a&&\"function\"==typeof a.handleEvent)a=q(a.handleEvent,a);else throw Error(\"Invalid listener argument\");return 2147483647<Number(b)?-1:k.setTimeout(a,b||0)};function $b(a,b,c){u.call(this);this.f=null!=c?q(a,c):a;this.c=b;this.b=q(this.fb,this);this.a=[]}t($b,u);g=$b.prototype;g.ha=!1;g.Y=null;g.Ya=function(a){this.a=arguments;this.Y?this.ha=!0:ac(this)};g.w=function(){$b.H.w.call(this);this.Y&&(k.clearTimeout(this.Y),this.Y=null,this.ha=!1,this.a=[])};g.fb=function(){this.Y=null;this.ha&&(this.ha=!1,ac(this))};function ac(a){a.Y=Zb(a.b,a.c);a.f.apply(null,a.a)};function bc(a){u.call(this);this.b=a;this.a={}}t(bc,u);var cc=[];function dc(a,b,c,d){n(c)||(c&&(cc[0]=c.toString()),c=cc);for(var e=0;e<c.length;e++){var f=nb(b,c[e],d||a.handleEvent,!1,a.b||a);if(!f)break;a.a[f.key]=f}}function ec(a){Ca(a.a,function(a,c){this.a.hasOwnProperty(c)&&wb(a)},a);a.a={}}bc.prototype.w=function(){bc.H.w.call(this);ec(this)};bc.prototype.handleEvent=function(){throw Error(\"EventHandler.handleEvent not implemented\");};function fc(a,b,c){this.reset(a,b,c,void 0,void 0)}fc.prototype.a=null;var gc=0;fc.prototype.reset=function(a,b,c,d,e){\"number\"==typeof e||gc++;d||r();delete this.a};function hc(a){this.f=a;this.b=this.c=this.a=null}function B(a,b){this.name=a;this.value=b}B.prototype.toString=function(){return this.name};var ic=new B(\"SEVERE\",1E3),jc=new B(\"WARNING\",900),kc=new B(\"INFO\",800),lc=new B(\"CONFIG\",700),mc=new B(\"FINE\",500);function nc(a){if(a.c)return a.c;if(a.a)return nc(a.a);ma(\"Root logger has no level set.\");return null}hc.prototype.log=function(a,b,c){if(a.value>=nc(this).value)for(da(b)&&(b=b()),a=new fc(a,String(b),this.f),c&&(a.a=c),c=this;c;)c=c.a};\nvar oc={},pc=null;function qc(a){pc||(pc=new hc(\"\"),oc[\"\"]=pc,pc.c=lc);var b;if(!(b=oc[a])){b=new hc(a);var c=a.lastIndexOf(\".\"),d=a.substr(c+1);c=qc(a.substr(0,c));c.b||(c.b={});c.b[d]=b;b.a=c;oc[a]=b}return b};function C(a,b){a&&a.log(jc,b,void 0)}function rc(a,b){a&&a.log(kc,b,void 0)}function D(a,b){a&&a.log(mc,b,void 0)};function sc(){this.a=qc(\"goog.labs.net.webChannel.WebChannelDebug\");this.b=!0}sc.prototype.Ea=function(){this.b=!1};function tc(a,b,c,d,e,f){E(a,function(){if(a.b)if(f){var h=\"\";for(var m=f.split(\"&\"),v=0;v<m.length;v++){var I=m[v].split(\"=\");if(1<I.length){var W=I[0];I=I[1];var Lb=W.split(\"_\");h=2<=Lb.length&&\"type\"==Lb[1]?h+(W+\"=\"+I+\"&\"):h+(W+\"=redacted&\")}}}else h=null;else h=f;return\"XMLHTTP REQ (\"+d+\") [attempt \"+e+\"]: \"+b+\"\\n\"+c+\"\\n\"+h})}\nfunction uc(a,b,c,d,e,f,h){E(a,function(){return\"XMLHTTP RESP (\"+d+\") [ attempt \"+e+\"]: \"+b+\"\\n\"+c+\"\\n\"+f+\" \"+h})}function F(a,b,c,d){E(a,function(){return\"XMLHTTP TEXT (\"+b+\"): \"+vc(a,c)+(d?\" \"+d:\"\")})}function wc(a,b){E(a,function(){return\"TIMEOUT: \"+b})}function G(a,b){D(a.a,b)}function xc(a,b,c){(a=a.a)&&a.log(ic,c||\"Exception\",b)}function E(a,b){rc(a.a,b)}function H(a,b){(a=a.a)&&a.log(ic,b,void 0)}\nfunction vc(a,b){if(!a.b)return b;if(!b)return null;try{var c=JSON.parse(b);if(c)for(var d=0;d<c.length;d++)if(n(c[d])){var e=c[d];if(!(2>e.length)){var f=e[1];if(n(f)&&!(1>f.length)){var h=f[0];if(\"noop\"!=h&&\"stop\"!=h&&\"close\"!=h)for(var m=1;m<f.length;m++)f[m]=\"\"}}}return Db(c)}catch(v){return G(a,\"Exception parsing expected JS array - probably was not JS\"),b}};var J=new A;function yc(a){z.call(this,\"serverreachability\",a)}t(yc,z);function zc(a){J.dispatchEvent(new yc(J,a))}function Ac(a){z.call(this,\"statevent\",a)}t(Ac,z);function K(a){J.dispatchEvent(new Ac(J,a))}function Bc(a){z.call(this,\"timingevent\",a)}t(Bc,z);function Cc(a,b,c){J.dispatchEvent(new Bc(J,a,b,c))}function Dc(a,b){if(!da(a))throw Error(\"Fn must not be null and must be a function\");return k.setTimeout(function(){a()},b)};var Ec={NO_ERROR:0,mb:1,tb:2,sb:3,pb:4,rb:5,ub:6,Sa:7,TIMEOUT:8,xb:9};var Fc={ob:\"complete\",Bb:\"success\",Ta:\"error\",Sa:\"abort\",zb:\"ready\",Ab:\"readystatechange\",TIMEOUT:\"timeout\",vb:\"incrementaldata\",yb:\"progress\",qb:\"downloadprogress\",Cb:\"uploadprogress\"};function Gc(){}var Hc={OPEN:\"a\",nb:\"b\",Ta:\"c\",wb:\"d\"};function Ic(){z.call(this,\"d\")}t(Ic,z);function Jc(){z.call(this,\"c\")}t(Jc,z);function Kc(){}Kc.prototype.a=null;function Lc(a){var b;(b=a.a)||(b={},Mc(a)&&(b[0]=!0,b[1]=!0),b=a.a=b);return b};var Nc;function Oc(){}t(Oc,Kc);function Pc(a){return(a=Mc(a))?new ActiveXObject(a):new XMLHttpRequest}function Mc(a){if(!a.b&&\"undefined\"==typeof XMLHttpRequest&&\"undefined\"!=typeof ActiveXObject){for(var b=[\"MSXML2.XMLHTTP.6.0\",\"MSXML2.XMLHTTP.3.0\",\"MSXML2.XMLHTTP\",\"Microsoft.XMLHTTP\"],c=0;c<b.length;c++){var d=b[c];try{return new ActiveXObject(d),a.b=d}catch(e){}}throw Error(\"Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed\");}return a.b}Nc=new Oc;function L(a,b,c,d){this.i=a;this.b=b;this.c=c;this.T=d||1;this.L=new bc(this);this.R=Qc;a=Na?125:void 0;this.S=new Xb(a);this.j=null;this.f=!1;this.l=this.g=this.h=this.J=this.D=this.U=this.s=null;this.u=[];this.a=null;this.G=0;this.m=this.o=null;this.C=-1;this.B=!1;this.N=0;this.I=null;this.v=this.X=this.K=!1}var Qc=45E3;\nfunction Rc(a,b){switch(a){case 0:return\"Non-200 return code (\"+b+\")\";case 1:return\"XMLHTTP failure (no data)\";case 2:return\"HttpConnection timeout\";default:return\"Unknown error\"}}var Sc={},Tc={};g=L.prototype;g.setTimeout=function(a){this.R=a};function Uc(a,b,c){a.J=1;a.h=Vc(M(b));a.l=c;a.K=!0;Wc(a,null)}function Xc(a,b,c,d){a.J=1;a.h=Vc(M(b));a.l=null;a.K=c;Wc(a,d)}\nfunction Wc(a,b){a.D=r();Yc(a);a.g=M(a.h);Zc(a.g,\"t\",a.T);a.G=0;a.a=a.i.ca(a.i.ia()?b:null);0<a.N&&(a.I=new $b(q(a.Ra,a,a.a),a.N));dc(a.L,a.a,\"readystatechange\",a.ib);b=a.j?Fa(a.j):{};a.l?(a.o||(a.o=\"POST\"),b[\"Content-Type\"]=\"application/x-www-form-urlencoded\",a.a.fa(a.g,a.o,a.l,b)):(a.o=\"GET\",a.a.fa(a.g,a.o,null,b));zc(1);tc(a.b,a.o,a.g,a.c,a.T,a.l)}g.ib=function(a){a=a.target;var b=this.I;b&&3==N(a)?(G(this.b,\"Throttling readystatechange.\"),b.Ya()):this.Ra(a)};\ng.Ra=function(a){try{a==this.a?$c(this):C(this.b.a,\"Called back with an unexpected xmlhttp\")}catch(c){if(G(this.b,\"Failed call to OnXmlHttpReadyStateChanged_\"),this.a&&this.a.V()){var b=this;xc(this.b,c,function(){return\"ResponseText: \"+b.a.V()})}else xc(this.b,c,\"No response text\")}finally{}};\nfunction $c(a){var b=N(a.a),c=a.a.Fa(),d=a.a.W();if(!(3>b||3==b&&!Na&&!a.a.V())){a.B||4!=b||7==c||(8==c||0>=d?zc(3):zc(2));ad(a);var e=a.a.W();a.C=e;(c=a.a.V())||G(a.b,function(){return\"No response text for uri \"+a.g+\" status \"+e});a.f=200==e;uc(a.b,a.o,a.g,a.c,a.T,b,e);if(a.f){if(d=bd(a))F(a.b,a.c,d,\"Initial handshake response via X-HTTP-Initial-Response\"),a.v=!0,cd(a,d);a.K?(dd(a,b,c),Na&&a.f&&3==b&&ed(a)):(F(a.b,a.c,c,null),cd(a,c));4==b&&fd(a);a.f&&!a.B&&(4==b?a.i.ta(a):(a.f=!1,Yc(a)))}else 400==\ne&&0<c.indexOf(\"Unknown SID\")?(a.m=3,K(12),C(a.b.a,\"XMLHTTP Unknown SID (\"+a.c+\")\")):(a.m=0,K(13),C(a.b.a,\"XMLHTTP Bad status \"+e+\" (\"+a.c+\")\")),fd(a),gd(a)}}function bd(a){return!a.X||a.v?null:a.a&&(a=hd(a.a,\"X-HTTP-Initial-Response\"))&&!xa(a)?a:null}\nfunction dd(a,b,c){for(var d=!0;!a.B&&a.G<c.length;){var e=id(a,c);if(e==Tc){4==b&&(a.m=4,K(14),d=!1);F(a.b,a.c,null,\"[Incomplete Response]\");break}else if(e==Sc){a.m=4;K(15);F(a.b,a.c,c,\"[Invalid Chunk]\");d=!1;break}else F(a.b,a.c,e,null),cd(a,e)}4==b&&0==c.length&&(a.m=1,K(16),d=!1);a.f=a.f&&d;d||(F(a.b,a.c,c,\"[Invalid Chunked Response]\"),fd(a),gd(a))}g.hb=function(){if(this.a){var a=N(this.a),b=this.a.V();this.G<b.length&&(ad(this),dd(this,a,b),this.f&&4!=a&&Yc(this))}};\nfunction ed(a){dc(a.L,a.S,\"tick\",a.hb);a.S.start()}function id(a,b){var c=a.G,d=b.indexOf(\"\\n\",c);if(-1==d)return Tc;c=Number(b.substring(c,d));if(isNaN(c))return Sc;d+=1;if(d+c>b.length)return Tc;b=b.substr(d,c);a.G=d+c;return b}g.cancel=function(){this.B=!0;fd(this)};function Yc(a){a.U=r()+a.R;jd(a,a.R)}function jd(a,b){if(null!=a.s)throw Error(\"WatchDog timer not null\");a.s=Dc(q(a.gb,a),b)}function ad(a){a.s&&(k.clearTimeout(a.s),a.s=null)}\ng.gb=function(){this.s=null;var a=r();0<=a-this.U?(this.f&&H(this.b,\"Received watchdog timeout even though request loaded successfully\"),wc(this.b,this.g),2!=this.J&&(zc(3),K(17)),fd(this),this.m=2,gd(this)):(C(this.b.a,\"WatchDog timer called too early\"),jd(this,this.U-a))};function gd(a){a.i.Ka()||a.B||a.i.ta(a)}function fd(a){ad(a);var b=a.I;b&&\"function\"==typeof b.$&&b.$();a.I=null;Yb(a.S);ec(a.L);a.a&&(b=a.a,a.a=null,b.abort(),b.$())}\nfunction cd(a,b){try{a.i.Na(a,b),zc(4)}catch(c){xc(a.b,c,\"Error in httprequest callback\")}};function kd(a){if(a.A&&\"function\"==typeof a.A)return a.A();if(l(a))return a.split(\"\");if(ca(a)){for(var b=[],c=a.length,d=0;d<c;d++)b.push(a[d]);return b}return Da(a)}\nfunction ld(a,b){if(a.forEach&&\"function\"==typeof a.forEach)a.forEach(b,void 0);else if(ca(a)||l(a))ra(a,b,void 0);else{if(a.M&&\"function\"==typeof a.M)var c=a.M();else if(a.A&&\"function\"==typeof a.A)c=void 0;else if(ca(a)||l(a)){c=[];for(var d=a.length,e=0;e<d;e++)c.push(e)}else c=Ea(a);d=kd(a);e=d.length;for(var f=0;f<e;f++)b.call(void 0,d[f],c&&c[f],a)}};function O(a,b){this.b={};this.a=[];this.c=0;var c=arguments.length;if(1<c){if(c%2)throw Error(\"Uneven number of arguments\");for(var d=0;d<c;d+=2)this.set(arguments[d],arguments[d+1])}else if(a)if(a instanceof O)for(c=a.M(),d=0;d<c.length;d++)this.set(c[d],a.get(c[d]));else for(d in a)this.set(d,a[d])}g=O.prototype;g.A=function(){md(this);for(var a=[],b=0;b<this.a.length;b++)a.push(this.b[this.a[b]]);return a};g.M=function(){md(this);return this.a.concat()};\nfunction nd(a){a.b={};a.a.length=0;a.c=0}function od(a,b){return P(a.b,b)?(delete a.b[b],a.c--,a.a.length>2*a.c&&md(a),!0):!1}function md(a){if(a.c!=a.a.length){for(var b=0,c=0;b<a.a.length;){var d=a.a[b];P(a.b,d)&&(a.a[c++]=d);b++}a.a.length=c}if(a.c!=a.a.length){var e={};for(c=b=0;b<a.a.length;)d=a.a[b],P(e,d)||(a.a[c++]=d,e[d]=1),b++;a.a.length=c}}g.get=function(a,b){return P(this.b,a)?this.b[a]:b};g.set=function(a,b){P(this.b,a)||(this.c++,this.a.push(a));this.b[a]=b};\ng.forEach=function(a,b){for(var c=this.M(),d=0;d<c.length;d++){var e=c[d],f=this.get(e);a.call(b,f,e,this)}};function P(a,b){return Object.prototype.hasOwnProperty.call(a,b)};var pd=/^(?:([^:/?#.]+):)?(?:\\/\\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$/;function qd(a,b){if(a){a=a.split(\"&\");for(var c=0;c<a.length;c++){var d=a[c].indexOf(\"=\"),e=null;if(0<=d){var f=a[c].substring(0,d);e=a[c].substring(d+1)}else f=a[c];b(f,e?decodeURIComponent(e.replace(/\\+/g,\" \")):\"\")}}};function Q(a,b){this.b=this.j=this.f=\"\";this.i=null;this.g=this.a=\"\";this.h=!1;var c;a instanceof Q?(this.h=void 0!==b?b:a.h,rd(this,a.f),this.j=a.j,sd(this,a.b),td(this,a.i),this.a=a.a,ud(this,vd(a.c)),this.g=a.g):a&&(c=String(a).match(pd))?(this.h=!!b,rd(this,c[1]||\"\",!0),this.j=wd(c[2]||\"\"),sd(this,c[3]||\"\",!0),td(this,c[4]),this.a=wd(c[5]||\"\",!0),ud(this,c[6]||\"\",!0),this.g=wd(c[7]||\"\")):(this.h=!!b,this.c=new xd(null,this.h))}\nQ.prototype.toString=function(){var a=[],b=this.f;b&&a.push(yd(b,zd,!0),\":\");var c=this.b;if(c||\"file\"==b)a.push(\"//\"),(b=this.j)&&a.push(yd(b,zd,!0),\"@\"),a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g,\"%$1\")),c=this.i,null!=c&&a.push(\":\",String(c));if(c=this.a)this.b&&\"/\"!=c.charAt(0)&&a.push(\"/\"),a.push(yd(c,\"/\"==c.charAt(0)?Ad:Bd,!0));(c=this.c.toString())&&a.push(\"?\",c);(c=this.g)&&a.push(\"#\",yd(c,Cd));return a.join(\"\")};\nQ.prototype.resolve=function(a){var b=M(this),c=!!a.f;c?rd(b,a.f):c=!!a.j;c?b.j=a.j:c=!!a.b;c?sd(b,a.b):c=null!=a.i;var d=a.a;if(c)td(b,a.i);else if(c=!!a.a){if(\"/\"!=d.charAt(0))if(this.b&&!this.a)d=\"/\"+d;else{var e=b.a.lastIndexOf(\"/\");-1!=e&&(d=b.a.substr(0,e+1)+d)}e=d;if(\"..\"==e||\".\"==e)d=\"\";else if(-1!=e.indexOf(\"./\")||-1!=e.indexOf(\"/.\")){d=0==e.lastIndexOf(\"/\",0);e=e.split(\"/\");for(var f=[],h=0;h<e.length;){var m=e[h++];\".\"==m?d&&h==e.length&&f.push(\"\"):\"..\"==m?((1<f.length||1==f.length&&\"\"!=\nf[0])&&f.pop(),d&&h==e.length&&f.push(\"\")):(f.push(m),d=!0)}d=f.join(\"/\")}else d=e}c?b.a=d:c=\"\"!==a.c.toString();c?ud(b,vd(a.c)):c=!!a.g;c&&(b.g=a.g);return b};function M(a){return new Q(a)}function rd(a,b,c){a.f=c?wd(b,!0):b;a.f&&(a.f=a.f.replace(/:$/,\"\"))}function sd(a,b,c){a.b=c?wd(b,!0):b}function td(a,b){if(b){b=Number(b);if(isNaN(b)||0>b)throw Error(\"Bad port number \"+b);a.i=b}else a.i=null}function ud(a,b,c){b instanceof xd?(a.c=b,Dd(a.c,a.h)):(c||(b=yd(b,Ed)),a.c=new xd(b,a.h))}\nfunction R(a,b,c){a.c.set(b,c)}function Zc(a,b,c){n(c)||(c=[String(c)]);Fd(a.c,b,c)}function Vc(a){R(a,\"zx\",Math.floor(2147483648*Math.random()).toString(36)+Math.abs(Math.floor(2147483648*Math.random())^r()).toString(36));return a}function Gd(a){return a instanceof Q?M(a):new Q(a,void 0)}function Hd(a,b,c,d){var e=new Q(null,void 0);a&&rd(e,a);b&&sd(e,b);c&&td(e,c);d&&(e.a=d);return e}function wd(a,b){return a?b?decodeURI(a.replace(/%25/g,\"%2525\")):decodeURIComponent(a):\"\"}\nfunction yd(a,b,c){return l(a)?(a=encodeURI(a).replace(b,Id),c&&(a=a.replace(/%25([0-9a-fA-F]{2})/g,\"%$1\")),a):null}function Id(a){a=a.charCodeAt(0);return\"%\"+(a>>4&15).toString(16)+(a&15).toString(16)}var zd=/[#\\/\\?@]/g,Bd=/[#\\?:]/g,Ad=/[#\\?]/g,Ed=/[#\\?@]/g,Cd=/#/g;function xd(a,b){this.b=this.a=null;this.c=a||null;this.f=!!b}function S(a){a.a||(a.a=new O,a.b=0,a.c&&qd(a.c,function(b,c){a.add(decodeURIComponent(b.replace(/\\+/g,\" \")),c)}))}g=xd.prototype;\ng.add=function(a,b){S(this);this.c=null;a=Jd(this,a);var c=this.a.get(a);c||this.a.set(a,c=[]);c.push(b);this.b+=1;return this};function Kd(a,b){S(a);b=Jd(a,b);P(a.a.b,b)&&(a.c=null,a.b-=a.a.get(b).length,od(a.a,b))}function Ld(a,b){S(a);b=Jd(a,b);return P(a.a.b,b)}g.forEach=function(a,b){S(this);this.a.forEach(function(c,d){ra(c,function(c){a.call(b,c,d,this)},this)},this)};\ng.M=function(){S(this);for(var a=this.a.A(),b=this.a.M(),c=[],d=0;d<b.length;d++)for(var e=a[d],f=0;f<e.length;f++)c.push(b[d]);return c};g.A=function(a){S(this);var b=[];if(l(a))Ld(this,a)&&(b=va(b,this.a.get(Jd(this,a))));else{a=this.a.A();for(var c=0;c<a.length;c++)b=va(b,a[c])}return b};g.set=function(a,b){S(this);this.c=null;a=Jd(this,a);Ld(this,a)&&(this.b-=this.a.get(a).length);this.a.set(a,[b]);this.b+=1;return this};g.get=function(a,b){a=a?this.A(a):[];return 0<a.length?String(a[0]):b};\nfunction Fd(a,b,c){Kd(a,b);0<c.length&&(a.c=null,a.a.set(Jd(a,b),wa(c)),a.b+=c.length)}g.toString=function(){if(this.c)return this.c;if(!this.a)return\"\";for(var a=[],b=this.a.M(),c=0;c<b.length;c++){var d=b[c],e=encodeURIComponent(String(d));d=this.A(d);for(var f=0;f<d.length;f++){var h=e;\"\"!==d[f]&&(h+=\"=\"+encodeURIComponent(String(d[f])));a.push(h)}}return this.c=a.join(\"&\")};function vd(a){var b=new xd;b.c=a.c;a.a&&(b.a=new O(a.a),b.b=a.b);return b}\nfunction Jd(a,b){b=String(b);a.f&&(b=b.toLowerCase());return b}function Dd(a,b){b&&!a.f&&(S(a),a.c=null,a.a.forEach(function(a,b){var c=b.toLowerCase();b!=c&&(Kd(this,b),Fd(this,c,a))},a));a.f=b};function Md(){this.a=r()}var Nd=null;Md.prototype.set=function(a){this.a=a};Md.prototype.reset=function(){this.set(r())};Md.prototype.get=function(){return this.a};function Od(){Nd||(Nd=new Md)}function Pd(){Nd||(Nd=new Md)}t(Pd,Od);function Qd(a,b){this.a=a;this.b=b;this.c=this.i=null;this.h=!1;this.m=null;this.f=-1;this.l=this.g=null}g=Qd.prototype;g.P=null;\nfunction Rd(a){G(a.b,\"TestConnection: starting stage 2\");var b=a.a.I.a;if(null!=b)G(a.b,function(){return\"TestConnection: skipping stage 2, precomputed result is \"+b?\"Buffered\":\"Unbuffered\"}),K(4),b?(K(10),Sd(a.a,a,!1)):(K(11),Sd(a.a,a,!0));else{a.c=new L(a,a.b,void 0,void 0);a.c.j=a.i;var c=Td(a.a,a.g,a.m);K(4);Zc(c,\"TYPE\",\"xmlhttp\");var d=a.a.j,e=a.a.K;d&&e&&R(c,d,e);Xc(a.c,c,!1,a.g)}}g.ca=function(a){return this.a.ca(a)};g.abort=function(){this.c&&(this.c.cancel(),this.c=null);this.f=-1};\ng.Ka=function(){return!1};\ng.Na=function(a,b){this.f=a.C;if(0==this.P){G(this.b,\"TestConnection: Got data for stage 1\");if(!this.a.o&&(a=a.a)){var c=hd(a,\"X-Client-Wire-Protocol\");this.l=c?c:null;this.a.j&&((a=hd(a,\"X-HTTP-Session-Id\"))?this.a.K=a:C(this.b.a,\"Missing X_HTTP_SESSION_ID in the handshake response\"))}if(b){try{var d=this.a.la.a.parse(b)}catch(e){xc(this.b,e);Ud(this.a,this);return}this.g=d[0]}else G(this.b,\"TestConnection: Null responseText\"),Ud(this.a,this)}else if(1==this.P)if(this.h)K(6);else if(\"11111\"==b){if(K(5),\nthis.h=!0,!y||10<=Number(Wa))this.f=200,this.c.cancel(),G(this.b,\"Test connection succeeded; using streaming connection\"),K(11),Sd(this.a,this,!0)}else K(7),this.h=!1};\ng.ta=function(){this.f=this.c.C;this.c.f?0==this.P?(this.P=1,G(this.b,\"TestConnection: request complete for initial check\"),Rd(this)):1==this.P&&(G(this.b,\"TestConnection: request complete for stage 2\"),this.h?(G(this.b,\"Test connection succeeded; using streaming connection\"),K(11),Sd(this.a,this,!0)):(G(this.b,\"Test connection failed; not using streaming\"),K(10),Sd(this.a,this,!1))):(G(this.b,\"TestConnection: request failed, in state \"+this.P),0==this.P?K(8):1==this.P&&K(9),Ud(this.a,this))};\ng.ia=function(){return this.a.ia()};g.qa=function(){return this.a.qa()};function Vd(){this.a=this.b=null};function Wd(){this.a=new O}function Xd(a){var b=typeof a;return\"object\"==b&&a||\"function\"==b?\"o\"+(a[p]||(a[p]=++fa)):b.charAt(0)+a}Wd.prototype.add=function(a){this.a.set(Xd(a),a)};Wd.prototype.A=function(){return this.a.A()};function Yd(a,b){this.a=a;this.b=b};function Zd(a){this.g=a||$d;this.f=k.oa&&k.oa.La&&k.oa.La()&&k.oa.La().Fb?this.g:1;this.a=null;1<this.f&&(this.a=new Wd);this.b=null;this.c=[]}var $d=10;function ae(a,b){a.a||-1==b.indexOf(\"spdy\")&&-1==b.indexOf(\"quic\")&&-1==b.indexOf(\"h2\")||(a.f=a.g,a.a=new Wd,a.b&&(be(a,a.b),a.b=null))}function ce(a){return a.b?!0:a.a?a.a.a.c>=a.f:!1}function de(a,b){a.b?a=a.b==b:a.a?(b=Xd(b),a=P(a.a.a.b,b)):a=!1;return a}function be(a,b){a.a?a.a.add(b):a.b=b}\nfunction ee(a,b){if(a.b&&a.b==b)a.b=null;else{var c;if(c=a.a)c=Xd(b),c=P(a.a.a.b,c);c&&od(a.a.a,Xd(b))}}Zd.prototype.cancel=function(){this.c=fe(this);this.b?(this.b.cancel(),this.b=null):this.a&&0!=this.a.a.c&&(ra(this.a.A(),function(a){a.cancel()}),nd(this.a.a))};function fe(a){if(null!=a.b)return a.c.concat(a.b.u);if(null!=a.a&&0!=a.a.a.c){var b=a.c;ra(a.a.A(),function(a){b=b.concat(a.u)});return b}return wa(a.c)}function ge(a,b){a.c=a.c.concat(b)};function he(){}he.prototype.stringify=function(a){return k.JSON.stringify(a,void 0)};he.prototype.parse=function(a){return k.JSON.parse(a,void 0)};function ie(){this.a=new he}function je(a,b,c){var d=c||\"\";try{ld(a,function(a,c){var e=a;ea(a)&&(e=Db(a));b.push(d+c+\"=\"+encodeURIComponent(e))})}catch(e){throw b.push(d+\"type=\"+encodeURIComponent(\"_badmap\")),e;}};function ke(a,b){var c=new sc;G(c,\"TestLoadImage: loading \"+a);var d=new Image;d.onload=ja(le,c,d,\"TestLoadImage: loaded\",!0,b);d.onerror=ja(le,c,d,\"TestLoadImage: error\",!1,b);d.onabort=ja(le,c,d,\"TestLoadImage: abort\",!1,b);d.ontimeout=ja(le,c,d,\"TestLoadImage: timeout\",!1,b);k.setTimeout(function(){if(d.ontimeout)d.ontimeout()},1E4);d.src=a}function le(a,b,c,d,e){try{G(a,c),b.onload=null,b.onerror=null,b.onabort=null,b.ontimeout=null,e(d)}catch(f){xc(a,f)}};function T(a){A.call(this);this.headers=new O;this.D=a||null;this.c=!1;this.v=this.a=null;this.K=this.u=\"\";this.j=0;this.g=\"\";this.h=this.I=this.s=this.G=!1;this.l=0;this.B=null;this.L=me;this.C=this.o=!1}t(T,A);var me=\"\";T.prototype.b=qc(\"goog.net.XhrIo\");var ne=/^https?$/i,oe=[\"POST\",\"PUT\"];g=T.prototype;\ng.fa=function(a,b,c,d){if(this.a)throw Error(\"[goog.net.XhrIo] Object is active with another request=\"+this.u+\"; newUri=\"+a);b=b?b.toUpperCase():\"GET\";this.u=a;this.g=\"\";this.j=0;this.K=b;this.G=!1;this.c=!0;this.a=this.D?Pc(this.D):Pc(Nc);this.v=this.D?Lc(this.D):Lc(Nc);this.a.onreadystatechange=q(this.Ma,this);try{D(this.b,U(this,\"Opening Xhr\")),this.I=!0,this.a.open(b,String(a),!0),this.I=!1}catch(f){D(this.b,U(this,\"Error opening Xhr: \"+f.message));pe(this,f);return}a=c||\"\";var e=new O(this.headers);\nd&&ld(d,function(a,b){e.set(b,a)});d=sa(e.M());c=k.FormData&&a instanceof k.FormData;!(0<=qa(oe,b))||d||c||e.set(\"Content-Type\",\"application/x-www-form-urlencoded;charset=utf-8\");e.forEach(function(a,b){this.a.setRequestHeader(b,a)},this);this.L&&(this.a.responseType=this.L);\"withCredentials\"in this.a&&this.a.withCredentials!==this.o&&(this.a.withCredentials=this.o);try{qe(this),0<this.l&&(this.C=re(this.a),D(this.b,U(this,\"Will abort after \"+this.l+\"ms if incomplete, xhr2 \"+this.C)),this.C?(this.a.timeout=\nthis.l,this.a.ontimeout=q(this.Ja,this)):this.B=Zb(this.Ja,this.l,this)),D(this.b,U(this,\"Sending request\")),this.s=!0,this.a.send(a),this.s=!1}catch(f){D(this.b,U(this,\"Send error: \"+f.message)),pe(this,f)}};function re(a){return y&&Va(9)&&\"number\"==typeof a.timeout&&void 0!==a.ontimeout}function ta(a){return\"content-type\"==a.toLowerCase()}\ng.Ja=function(){\"undefined\"!=typeof goog&&this.a&&(this.g=\"Timed out after \"+this.l+\"ms, aborting\",this.j=8,D(this.b,U(this,this.g)),this.dispatchEvent(\"timeout\"),this.abort(8))};function pe(a,b){a.c=!1;a.a&&(a.h=!0,a.a.abort(),a.h=!1);a.g=b;a.j=5;se(a);te(a)}function se(a){a.G||(a.G=!0,a.dispatchEvent(\"complete\"),a.dispatchEvent(\"error\"))}\ng.abort=function(a){this.a&&this.c&&(D(this.b,U(this,\"Aborting\")),this.c=!1,this.h=!0,this.a.abort(),this.h=!1,this.j=a||7,this.dispatchEvent(\"complete\"),this.dispatchEvent(\"abort\"),te(this))};g.w=function(){this.a&&(this.c&&(this.c=!1,this.h=!0,this.a.abort(),this.h=!1),te(this,!0));T.H.w.call(this)};g.Ma=function(){this.i||(this.I||this.s||this.h?ue(this):this.eb())};g.eb=function(){ue(this)};\nfunction ue(a){if(a.c&&\"undefined\"!=typeof goog)if(a.v[1]&&4==N(a)&&2==a.W())D(a.b,U(a,\"Local request error detected and ignored\"));else if(a.s&&4==N(a))Zb(a.Ma,0,a);else if(a.dispatchEvent(\"readystatechange\"),4==N(a)){D(a.b,U(a,\"Request complete\"));a.c=!1;try{var b=a.W();a:switch(b){case 200:case 201:case 202:case 204:case 206:case 304:case 1223:var c=!0;break a;default:c=!1}var d;if(!(d=c)){var e;if(e=0===b){var f=String(a.u).match(pd)[1]||null;if(!f&&k.self&&k.self.location){var h=k.self.location.protocol;\nf=h.substr(0,h.length-1)}e=!ne.test(f?f.toLowerCase():\"\")}d=e}d?(a.dispatchEvent(\"complete\"),a.dispatchEvent(\"success\")):(a.j=6,a.g=a.Ga()+\" [\"+a.W()+\"]\",se(a))}finally{te(a)}}}function te(a,b){if(a.a){qe(a);var c=a.a,d=a.v[0]?aa:null;a.a=null;a.v=null;b||a.dispatchEvent(\"ready\");try{c.onreadystatechange=d}catch(e){(a=a.b)&&a.log(ic,\"Problem encountered resetting onreadystatechange: \"+e.message,void 0)}}}function qe(a){a.a&&a.C&&(a.a.ontimeout=null);a.B&&(k.clearTimeout(a.B),a.B=null)}\nfunction N(a){return a.a?a.a.readyState:0}g.W=function(){try{return 2<N(this)?this.a.status:-1}catch(a){return-1}};g.Ga=function(){try{return 2<N(this)?this.a.statusText:\"\"}catch(a){return D(this.b,\"Can not get status: \"+a.message),\"\"}};g.V=function(){try{return this.a?this.a.responseText:\"\"}catch(a){return D(this.b,\"Can not get responseText: \"+a.message),\"\"}};\ng.Za=function(a){if(this.a){var b=this.a.responseText;a&&0==b.indexOf(a)&&(b=b.substring(a.length));a:{a=b;if(k.JSON)try{var c=k.JSON.parse(a);break a}catch(d){}c=Cb(a)}return c}};function hd(a,b){return a.a?a.a.getResponseHeader(b):null}g.Fa=function(){return this.j};g.bb=function(){return l(this.g)?this.g:String(this.g)};function U(a,b){return b+\" [\"+a.K+\" \"+a.u+\" \"+a.W()+\"]\"};function ve(a){var b=\"\";Ca(a,function(a,d){b+=d;b+=\":\";b+=a;b+=\"\\r\\n\"});return b}function we(a,b,c){a:{for(d in c){var d=!1;break a}d=!0}if(d)return a;c=ve(c);if(l(a)){b=encodeURIComponent(String(b));c=null!=c?\"=\"+encodeURIComponent(String(c)):\"\";if(b+=c){c=a.indexOf(\"#\");0>c&&(c=a.length);d=a.indexOf(\"?\");if(0>d||d>c){d=c;var e=\"\"}else e=a.substring(d+1,c);a=[a.substr(0,d),e,a.substr(c)];c=a[1];a[1]=b?c?c+\"&\"+b:b:c;a=a[0]+(a[1]?\"?\"+a[1]:\"\")+a[2]}return a}R(a,b,c);return a};function xe(a){this.xa=0;this.g=[];this.a=new sc;this.I=new Vd;this.X=this.ua=this.D=this.ja=this.b=this.K=this.j=this.U=this.h=this.L=this.i=null;this.Va=this.R=0;this.Ua=a&&a.Eb||!1;this.ka=this.C=this.s=this.l=this.m=this.f=null;this.u=this.wa=this.N=-1;this.T=this.B=this.v=0;this.G=void 0;this.S=a&&a.supportsCrossDomainXhr||!1;this.J=\"\";this.c=new Zd(a&&a.concurrentRequestLimit);this.la=new ie;this.o=a&&void 0!==a.backgroundChannelTest?a.backgroundChannelTest:!0;(this.va=a&&a.fastHandshake||!1)&&\n!this.o&&(C(this.a.a,\"Force backgroundChannelTest when fastHandshake is enabled.\"),this.o=!0);a&&a.Ea&&this.a.Ea()}g=xe.prototype;g.na=8;g.F=1;\nfunction ye(a){G(a.a,\"disconnect()\");ze(a);if(3==a.F){var b=a.R++,c=M(a.D);R(c,\"SID\",a.J);R(c,\"RID\",b);R(c,\"TYPE\",\"terminate\");Ae(a,c);b=new L(a,a.a,b,void 0);b.J=2;b.h=Vc(M(c));c=!1;k.navigator&&k.navigator.sendBeacon&&(c=k.navigator.sendBeacon(b.h.toString(),\"\"));!c&&k.Image&&((new Image).src=b.h,c=!0);c||(b.a=b.i.ca(null),b.a.fa(b.h));b.D=r();Yc(b)}Be(a)}\nfunction ze(a){a.C&&(a.C.abort(),a.C=null);a.b&&(a.b.cancel(),a.b=null);a.l&&(k.clearTimeout(a.l),a.l=null);Ce(a);a.c.cancel();a.m&&(k.clearTimeout(a.m),a.m=null)}function De(a,b){1E3==a.g.length&&H(a.a,function(){return\"Already have 1000 queued maps upon queueing \"+Db(b)});a.g.push(new Yd(a.Va++,b));3==a.F&&Ee(a)}g.Ka=function(){return 0==this.F};function Ee(a){ce(a.c)||a.m||(a.m=Dc(q(a.Pa,a),0),a.v=0)}\nfunction Fe(a,b){var c=a.c;if((c.b?1:c.a?c.a.a.c:0)>=a.c.f-(a.m?1:0))return H(a.a,\"Unexpected retry request is scheduled.\"),!1;if(a.m)return G(a.a,\"Use the retry request that is already scheduled.\"),a.g=b.u.concat(a.g),!0;if(1==a.F||2==a.F||a.v>=(a.Ua?0:2))return!1;G(a.a,\"Going to retry POST\");a.m=Dc(q(a.Pa,a,b),Ge(a,a.v));a.v++;return!0}\ng.Pa=function(a){this.m=null;G(this.a,\"startForwardChannel_\");if(1==this.F)if(a)H(this.a,\"Not supposed to retry the open\");else{G(this.a,\"open_()\");this.R=Math.floor(1E5*Math.random());a=this.R++;var b=new L(this,this.a,a,void 0),c=this.i;this.L&&(c?(c=Fa(c),Ha(c,this.L)):c=this.L);null===this.h&&(b.j=c);var d=He(this,b),e=M(this.D);R(e,\"RID\",a);R(e,\"CVER\",22);this.o&&this.j&&R(e,\"X-HTTP-Session-Id\",this.j);Ae(this,e);this.h&&c&&we(e,this.h,c);be(this.c,b);this.va?(R(e,\"$req\",d),R(e,\"SID\",\"null\"),\nb.X=!0,Uc(b,e,null)):Uc(b,e,d);this.F=2}else 3==this.F&&(a?Ie(this,a):0==this.g.length?G(this.a,\"startForwardChannel_ returned: nothing to send\"):ce(this.c)?H(this.a,\"startForwardChannel_ returned: connection already in progress\"):(Ie(this),G(this.a,\"startForwardChannel_ finished, sent request\")))};\nfunction Ie(a,b){var c;b?c=b.c:c=a.R++;var d=M(a.D);R(d,\"SID\",a.J);R(d,\"RID\",c);R(d,\"AID\",a.N);Ae(a,d);a.h&&a.i&&we(d,a.h,a.i);c=new L(a,a.a,c,a.v+1);null===a.h&&(c.j=a.i);b&&(a.g=b.u.concat(a.g));b=He(a,c);c.setTimeout(1E4+Math.round(1E4*Math.random()));be(a.c,c);Uc(c,d,b)}function Ae(a,b){a.f&&ld({},function(a,d){R(b,d,a)})}\nfunction He(a,b){var c=Math.min(a.g.length,1E3),d=a.f?q(a.f.Wa,a.f,a):null;a:for(var e=a.g,f=-1;;){var h=[\"count=\"+c];-1==f?0<c?(f=e[0].a,h.push(\"ofs=\"+f)):f=0:h.push(\"ofs=\"+f);for(var m=!0,v=0;v<c;v++){var I=e[v].a,W=e[v].b;I-=f;if(0>I)f=Math.max(0,e[v].a-100),m=!1;else try{je(W,h,\"req\"+I+\"_\")}catch(Lb){d&&d(W)}}if(m){d=h.join(\"&\");break a}}a=a.g.splice(0,c);b.u=a;return d}function Je(a){if(!a.b&&!a.l){a.T=1;var b=a.Oa;Tb||Ub();Wb||(Tb(),Wb=!0);Pb.add(b,a);a.B=0}}\nfunction Ke(a){if(a.b||a.l)return H(a.a,\"Request already in progress\"),!1;if(3<=a.B)return!1;G(a.a,\"Going to retry GET\");a.T++;a.l=Dc(q(a.Oa,a),Ge(a,a.B));a.B++;return!0}\ng.Oa=function(){this.l=null;G(this.a,\"Creating new HttpRequest\");this.b=new L(this,this.a,\"rpc\",this.T);null===this.h&&(this.b.j=this.i);this.b.N=0;var a=M(this.ua);R(a,\"RID\",\"rpc\");R(a,\"SID\",this.J);R(a,\"CI\",this.ka?\"0\":\"1\");R(a,\"AID\",this.N);Ae(this,a);R(a,\"TYPE\",\"xmlhttp\");this.h&&this.i&&we(a,this.h,this.i);this.G&&this.b.setTimeout(this.G);Xc(this.b,a,!0,this.X);G(this.a,\"New Request created\")};\nfunction Sd(a,b,c){G(a.a,\"Test Connection Finished\");var d=b.l;d&&ae(a.c,d);a.ka=c;a.u=b.f;G(a.a,\"connectChannel_()\");a.D=Le(a,a.ja);Ee(a)}function Ud(a,b){G(a.a,\"Test Connection Failed\");a.u=b.f;V(a,2)}\ng.Na=function(a,b){if(0!=this.F&&(this.b==a||de(this.c,a)))if(this.u=a.C,!a.v&&de(this.c,a)&&3==this.F){try{var c=this.la.a.parse(b)}catch(f){c=null}if(n(c)&&3==c.length)if(b=c,0==b[0])a:if(G(this.a,\"Server claims our backchannel is missing.\"),this.l)G(this.a,\"But we are currently starting the request.\");else{if(this.b)if(this.b.D+3E3<a.D)Ce(this),this.b.cancel(),this.b=null;else break a;else C(this.a.a,\"We do not have a BackChannel established\");Ke(this);K(18)}else this.wa=b[1],a=this.wa-this.N,\n0<a&&(b=b[2],G(this.a,b+\" bytes (in \"+a+\" arrays) are outstanding on the BackChannel\"),37500>b&&this.ka&&0==this.B&&!this.s&&(this.s=Dc(q(this.cb,this),6E3)));else G(this.a,\"Bad POST response data returned\"),V(this,11)}else if((a.v||this.b==a)&&Ce(this),!xa(b))for(b=c=this.la.a.parse(b),c=0;c<b.length;c++){var d=b[c];this.N=d[0];d=d[1];if(2==this.F)if(\"c\"==d[0]){this.J=d[1];this.X=d[2];var e=d[3];null!=e&&(this.na=e,E(this.a,\"VER=\"+this.na));e=d[4];null!=e&&(this.xa=e,E(this.a,\"SVER=\"+this.xa));d=\nd[5];null!=d&&\"number\"==typeof d&&0<d&&(this.G=d*=1.5,E(this.a,\"backChannelRequestTimeoutMs_=\"+d));this.o&&(d=a.a)&&((e=hd(d,\"X-Client-Wire-Protocol\"))&&ae(this.c,e),this.j&&((d=hd(d,\"X-HTTP-Session-Id\"))?(this.K=d,R(this.D,this.j,d)):C(this.a.a,\"Missing X_HTTP_SESSION_ID in the handshake response\")));this.F=3;this.f&&this.f.Ca();d=a;this.ua=Td(this,this.X,this.ja);d.v?(G(this.a,\"Upgrade the handshake request to a backchannel.\"),ee(this.c,d),(e=this.G)&&d.setTimeout(e),d.s&&(ad(d),Yc(d)),this.b=d):\nJe(this)}else\"stop\"!=d[0]&&\"close\"!=d[0]||V(this,7);else 3==this.F&&(\"stop\"==d[0]||\"close\"==d[0]?\"stop\"==d[0]?V(this,7):ye(this):\"noop\"!=d[0]&&this.f&&this.f.Ba(d),this.B=0)}};g.cb=function(){null!=this.s&&(this.s=null,this.b.cancel(),this.b=null,Ke(this),K(19))};function Ce(a){null!=a.s&&(k.clearTimeout(a.s),a.s=null)}\ng.ta=function(a){G(this.a,\"Request complete\");var b=null;if(this.b==a){Ce(this);this.b=null;var c=2}else if(de(this.c,a))b=a.u,ee(this.c,a),c=1;else return;this.u=a.C;if(0!=this.F)if(a.f)1==c?(Cc(a.l?a.l.length:0,r()-a.D,this.v),Ee(this)):Je(this);else{var d=a.m;if(3==d||0==d&&0<this.u)G(this.a,\"Not retrying due to error type\");else{var e=this;G(this.a,function(){return\"Maybe retrying, last error: \"+Rc(d,e.u)});if(1==c&&Fe(this,a)||2==c&&Ke(this))return;G(this.a,\"Exceeded max number of retries\")}b&&\n0<b.length&&ge(this.c,b);G(this.a,\"Error: HTTP request failed\");switch(d){case 1:V(this,5);break;case 4:V(this,10);break;case 3:V(this,6);break;default:V(this,2)}}};function Ge(a,b){var c=5E3+Math.floor(1E4*Math.random());a.qa()||(G(a.a,\"Inactive channel\"),c*=2);return c*b}\nfunction V(a,b){E(a.a,\"Error code \"+b);if(2==b){var c=null;a.f&&(c=null);var d=q(a.kb,a);c||(c=new Q(\"//www.google.com/images/cleardot.gif\"),k.location&&\"http\"==k.location.protocol||rd(c,\"https\"),Vc(c));ke(c.toString(),d)}else K(2);G(a.a,\"HttpChannel: error - \"+b);a.F=0;a.f&&a.f.Aa(b);Be(a);ze(a)}g.kb=function(a){a?(E(this.a,\"Successfully pinged google.com\"),K(2)):(E(this.a,\"Failed to ping google.com\"),K(1))};\nfunction Be(a){a.F=0;a.u=-1;if(a.f){var b=fe(a.c);if(0!=b.length||0!=a.g.length)G(a.a,function(){return\"Number of undelivered maps, pending: \"+b.length+\", outgoing: \"+a.g.length}),a.c.c.length=0,wa(a.g),a.g.length=0;a.f.za()}}function Le(a,b){b=Me(a,null,b);G(a.a,\"GetForwardChannelUri: \"+b);return b}function Td(a,b,c){b=Me(a,a.ia()?b:null,c);G(a.a,\"GetBackChannelUri: \"+b);return b}\nfunction Me(a,b,c){var d=Gd(c);if(\"\"!=d.b)b&&sd(d,b+\".\"+d.b),td(d,d.i);else{var e=k.location,f;b?f=b+\".\"+e.hostname:f=e.hostname;d=Hd(e.protocol,f,e.port,c)}a.U&&Ca(a.U,function(a,b){R(d,b,a)});b=a.j;c=a.K;b&&c&&R(d,b,c);R(d,\"VER\",a.na);Ae(a,d);return d}g.ca=function(a){if(a&&!this.S)throw Error(\"Can't create secondary domain capable XhrIo object.\");a=new T;a.o=this.S;return a};g.qa=function(){return!!this.f&&!0};g.ia=function(){return this.S};new Pd;function Ne(){}g=Ne.prototype;g.Ca=function(){};\ng.Ba=function(){};g.Aa=function(){};g.za=function(){};g.Wa=function(){};function Oe(a){for(var b=arguments[0],c=1;c<arguments.length;c++){var d=arguments[c];if(0==d.lastIndexOf(\"/\",0))b=d;else{var e;(e=\"\"==b)||(e=b.length-1,e=0<=e&&b.indexOf(\"/\",e)==e);e?b+=d:b+=\"/\"+d}}return b};function Pe(){if(y&&!(10<=Number(Wa)))throw Error(\"Environmental error: no available transport.\");}Pe.prototype.a=function(a,b){return new X(a,b)};\nfunction X(a,b){A.call(this);this.a=new xe(b);this.b=a;this.o=b&&b.testUrl?b.testUrl:Oe(this.b,\"test\");this.c=qc(\"goog.labs.net.webChannel.WebChannelBaseTransport\");this.g=b&&b.messageUrlParams||null;a=b&&b.messageHeaders||null;b&&b.clientProtocolHeaderRequired&&(a?a[\"X-Client-Protocol\"]=\"webchannel\":a={\"X-Client-Protocol\":\"webchannel\"});this.a.i=a;a=b&&b.initMessageHeaders||null;b&&b.messageContentType&&(a?a[\"X-WebChannel-Content-Type\"]=b.messageContentType:a={\"X-WebChannel-Content-Type\":b.messageContentType});\nb&&b.Da&&(a?a[\"X-WebChannel-Client-Profile\"]=b.Da:a={\"X-WebChannel-Client-Profile\":b.Da});this.a.L=a;(a=b&&b.httpHeadersOverwriteParam)&&!xa(a)&&(this.a.h=a);this.l=b&&b.supportsCrossDomainXhr||!1;this.j=b&&b.sendRawJson||!1;(b=b&&b.httpSessionIdParam)&&!xa(b)&&(this.a.j=b,a=this.g,null!==a&&b in a&&(a=this.g,b in a&&delete a[b],C(this.c,\"Ignore httpSessionIdParam also specified with messageUrlParams: \"+b)));this.h=new Qe(this)}t(X,A);g=X.prototype;\ng.addEventListener=function(a,b,c,d){X.H.addEventListener.call(this,a,b,c,d)};g.removeEventListener=function(a,b,c,d){X.H.removeEventListener.call(this,a,b,c,d)};\ng.$a=function(){this.a.f=this.h;this.l&&(this.a.S=!0);var a=this.a,b=this.o,c=this.b,d=this.g||void 0;G(a.a,\"connect()\");K(0);a.ja=c;a.U=d||{};a.o&&(G(a.a,\"connect() bypassed channel-test.\"),a.I.b=[],a.I.a=!1);G(a.a,\"connectTest_()\");a.C=new Qd(a,a.a);null===a.h&&(a.C.i=a.i);c=b;a.h&&a.i&&(c=we(b,a.h,a.i));a=a.C;a.m=c;b=Le(a.a,a.m);K(3);c=a.a.I.b;null!=c?(a.g=c[0],a.P=1,Rd(a)):(Zc(b,\"MODE\",\"init\"),!a.a.o&&a.a.j&&Zc(b,\"X-HTTP-Session-Id\",a.a.j),a.c=new L(a,a.b,void 0,void 0),a.c.j=a.i,Xc(a.c,b,!1,\nnull),a.P=0)};g.close=function(){ye(this.a)};g.ab=function(a){if(l(a)){var b={};b.__data__=a;De(this.a,b)}else this.j?(b={},b.__data__=Db(a),De(this.a,b)):De(this.a,a)};g.w=function(){this.a.f=null;delete this.h;ye(this.a);delete this.a;X.H.w.call(this)};function Re(a){Ic.call(this);var b=a.__sm__;if(b){a:{for(var c in b){a=c;break a}a=void 0}(this.c=a)?(a=this.c,this.data=null!==b&&a in b?b[a]:void 0):this.data=b}else this.data=a}t(Re,Ic);function Se(){Jc.call(this);this.status=1}t(Se,Jc);\nfunction Qe(a){this.a=a}t(Qe,Ne);Qe.prototype.Ca=function(){rc(this.a.c,\"WebChannel opened on \"+this.a.b);this.a.dispatchEvent(\"a\")};Qe.prototype.Ba=function(a){this.a.dispatchEvent(new Re(a))};Qe.prototype.Aa=function(a){rc(this.a.c,\"WebChannel aborted on \"+this.a.b+\" due to channel error: \"+a);this.a.dispatchEvent(new Se(a))};Qe.prototype.za=function(){rc(this.a.c,\"WebChannel closed on \"+this.a.b);this.a.dispatchEvent(\"b\")};var Te=ja(function(a,b){function c(){}c.prototype=a.prototype;var d=new c;a.apply(d,Array.prototype.slice.call(arguments,1));return d},Pe);function Ue(){this.b=[];this.a=[]}function Ve(a){0==a.b.length&&(a.b=a.a,a.b.reverse(),a.a=[]);return a.b.pop()}function We(a){return a.b.length+a.a.length}Ue.prototype.A=function(){for(var a=[],b=this.b.length-1;0<=b;--b)a.push(this.b[b]);var c=this.a.length;for(b=0;b<c;++b)a.push(this.a[b]);return a};function Xe(a,b){u.call(this);this.h=a||0;this.c=b||10;if(this.h>this.c)throw Error(Ye);this.a=new Ue;this.b=new Wd;this.g=null;this.aa()}t(Xe,u);var Ye=\"[goog.structs.Pool] Min can not be greater than max\";g=Xe.prototype;g.da=function(){var a=r();if(!(null!=this.g&&0>a-this.g)){for(var b;0<We(this.a)&&(b=Ve(this.a),!this.sa(b));)this.aa();!b&&Ze(this)<this.c&&(b=this.pa());b&&(this.g=a,this.b.add(b));return b}};g.jb=function(a){return od(this.b.a,Xd(a))?(this.ma(a),!0):!1};\ng.ma=function(a){od(this.b.a,Xd(a));this.sa(a)&&Ze(this)<this.c?this.a.a.push(a):$e(a)};g.aa=function(){for(var a=this.a;Ze(this)<this.h;){var b=this.pa();a.a.push(b)}for(;Ze(this)>this.c&&0<We(this.a);)$e(Ve(a))};g.pa=function(){return{}};function $e(a){if(\"function\"==typeof a.$)a.$();else for(var b in a)a[b]=null}g.sa=function(a){return\"function\"==typeof a.Xa?a.Xa():!0};function Ze(a){return We(a.a)+a.b.a.c}\ng.w=function(){Xe.H.w.call(this);if(0<this.b.a.c)throw Error(\"[goog.structs.Pool] Objects not released\");delete this.b;for(var a=this.a;0!=a.b.length||0!=a.a.length;)$e(Ve(a));delete this.a};function af(a,b){this.a=a;this.b=b};function bf(a){this.a=[];if(a)a:{if(a instanceof bf){var b=a.M();a=a.A();if(0>=this.a.length){for(var c=this.a,d=0;d<b.length;d++)c.push(new af(b[d],a[d]));break a}}else b=Ea(a),a=Da(a);for(d=0;d<b.length;d++)cf(this,b[d],a[d])}}function cf(a,b,c){var d=a.a;d.push(new af(b,c));b=d.length-1;a=a.a;for(c=a[b];0<b;)if(d=b-1>>1,a[d].a>c.a)a[b]=a[d],b=d;else break;a[b]=c}bf.prototype.A=function(){for(var a=this.a,b=[],c=a.length,d=0;d<c;d++)b.push(a[d].b);return b};\nbf.prototype.M=function(){for(var a=this.a,b=[],c=a.length,d=0;d<c;d++)b.push(a[d].a);return b};function df(){bf.call(this)}t(df,bf);function Y(a,b){this.f=new df;Xe.call(this,a,b)}t(Y,Xe);g=Y.prototype;g.da=function(a,b){if(!a)return Y.H.da.call(this);cf(this.f,void 0!==b?b:100,a);this.ra()};g.ra=function(){for(var a=this.f;0<a.a.length;){var b=this.da();if(b){var c=a,d=c.a,e=d.length;var f=d[0];if(0>=e)f=void 0;else{if(1==e)ua(d);else{d[0]=d.pop();d=0;c=c.a;e=c.length;for(var h=c[d];d<e>>1;){var m=2*d+1,v=2*d+2;m=v<e&&c[v].a<c[m].a?v:m;if(c[m].a>h.a)break;c[d]=c[m];d=m}c[d]=h}f=f.b}f.apply(this,[b])}else break}};\ng.ma=function(a){Y.H.ma.call(this,a);this.ra()};g.aa=function(){Y.H.aa.call(this);this.ra()};g.w=function(){Y.H.w.call(this);k.clearTimeout(void 0);ua(this.f.a);this.f=null};function Z(a,b,c,d){this.l=a;this.j=!!d;Y.call(this,b,c)}t(Z,Y);Z.prototype.pa=function(){var a=new T,b=this.l;b&&b.forEach(function(b,d){a.headers.set(d,b)});this.j&&(a.o=!0);return a};Z.prototype.sa=function(a){return!a.i&&!a.a};Pe.prototype.createWebChannel=Pe.prototype.a;X.prototype.send=X.prototype.ab;X.prototype.open=X.prototype.$a;X.prototype.close=X.prototype.close;Ec.NO_ERROR=0;Ec.TIMEOUT=8;Ec.HTTP_ERROR=6;Fc.COMPLETE=\"complete\";Gc.EventType=Hc;Hc.OPEN=\"a\";Hc.CLOSE=\"b\";Hc.ERROR=\"c\";Hc.MESSAGE=\"d\";A.prototype.listen=A.prototype.Ha;Z.prototype.getObject=Z.prototype.da;Z.prototype.releaseObject=Z.prototype.jb;T.prototype.listenOnce=T.prototype.Ia;T.prototype.getLastError=T.prototype.bb;T.prototype.getLastErrorCode=T.prototype.Fa;\nT.prototype.getStatus=T.prototype.W;T.prototype.getStatusText=T.prototype.Ga;T.prototype.getResponseJson=T.prototype.Za;T.prototype.getResponseText=T.prototype.V;T.prototype.getResponseText=T.prototype.V;T.prototype.send=T.prototype.fa;module.exports={createWebChannelTransport:Te,ErrorCode:Ec,EventType:Fc,WebChannel:Gc,XhrIoPool:Z};}).call(typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {})\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../webchannel-wrapper/dist/index.js\n// module id = 117\n// module chunks = 1","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { instances } from './src/logger';\nexport function setLogLevel(level) {\n    instances.forEach(function (inst) {\n        inst.logLevel = level;\n    });\n}\nexport { Logger, LogLevel } from './src/logger';\n\n//# sourceMappingURL=index.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../logger/dist/esm/index.js\n// module id = null\n// module chunks = ","/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A container for all of the Logger instances\n */\nexport var instances = [];\n/**\n * The JS SDK supports 5 log levels and also allows a user the ability to\n * silence the logs altogether.\n *\n * The order is a follows:\n * DEBUG < VERBOSE < INFO < WARN < ERROR\n *\n * All of the log types above the current log level will be captured (i.e. if\n * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and\n * `VERBOSE` logs will not)\n */\nexport var LogLevel;\n(function (LogLevel) {\n    LogLevel[LogLevel[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogLevel[LogLevel[\"VERBOSE\"] = 1] = \"VERBOSE\";\n    LogLevel[LogLevel[\"INFO\"] = 2] = \"INFO\";\n    LogLevel[LogLevel[\"WARN\"] = 3] = \"WARN\";\n    LogLevel[LogLevel[\"ERROR\"] = 4] = \"ERROR\";\n    LogLevel[LogLevel[\"SILENT\"] = 5] = \"SILENT\";\n})(LogLevel || (LogLevel = {}));\n/**\n * The default log level\n */\nvar defaultLogLevel = LogLevel.INFO;\n/**\n * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR\n * messages on to their corresponding console counterparts (if the log method\n * is supported by the current log level)\n */\nvar defaultLogHandler = function (instance, logType) {\n    var args = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        args[_i - 2] = arguments[_i];\n    }\n    if (logType < instance.logLevel)\n        return;\n    var now = new Date().toISOString();\n    switch (logType) {\n        /**\n         * By default, `console.debug` is not displayed in the developer console (in\n         * chrome). To avoid forcing users to have to opt-in to these logs twice\n         * (i.e. once for firebase, and once in the console), we are sending `DEBUG`\n         * logs to the `console.log` function.\n         */\n        case LogLevel.DEBUG:\n            console.log.apply(console, [\"[\" + now + \"]  \" + instance.name + \":\"].concat(args));\n            break;\n        case LogLevel.VERBOSE:\n            console.log.apply(console, [\"[\" + now + \"]  \" + instance.name + \":\"].concat(args));\n            break;\n        case LogLevel.INFO:\n            console.info.apply(console, [\"[\" + now + \"]  \" + instance.name + \":\"].concat(args));\n            break;\n        case LogLevel.WARN:\n            console.warn.apply(console, [\"[\" + now + \"]  \" + instance.name + \":\"].concat(args));\n            break;\n        case LogLevel.ERROR:\n            console.error.apply(console, [\"[\" + now + \"]  \" + instance.name + \":\"].concat(args));\n            break;\n        default:\n            throw new Error(\"Attempted to log a message with an invalid logType (value: \" + logType + \")\");\n    }\n};\nvar Logger = /** @class */ (function () {\n    /**\n     * Gives you an instance of a Logger to capture messages according to\n     * Firebase's logging scheme.\n     *\n     * @param name The name that the logs will be associated with\n     */\n    function Logger(name) {\n        this.name = name;\n        /**\n         * The log level of the given Logger instance.\n         */\n        this._logLevel = defaultLogLevel;\n        /**\n         * The log handler for the Logger instance.\n         */\n        this._logHandler = defaultLogHandler;\n        /**\n         * Capture the current instance for later use\n         */\n        instances.push(this);\n    }\n    Object.defineProperty(Logger.prototype, \"logLevel\", {\n        get: function () {\n            return this._logLevel;\n        },\n        set: function (val) {\n            if (!(val in LogLevel)) {\n                throw new TypeError('Invalid value assigned to `logLevel`');\n            }\n            this._logLevel = val;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Logger.prototype, \"logHandler\", {\n        get: function () {\n            return this._logHandler;\n        },\n        set: function (val) {\n            if (typeof val !== 'function') {\n                throw new TypeError('Value assigned to `logHandler` must be a function');\n            }\n            this._logHandler = val;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * The functions below are all based on the `console` interface\n     */\n    Logger.prototype.debug = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        this._logHandler.apply(this, [this, LogLevel.DEBUG].concat(args));\n    };\n    Logger.prototype.log = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        this._logHandler.apply(this, [this, LogLevel.VERBOSE].concat(args));\n    };\n    Logger.prototype.info = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        this._logHandler.apply(this, [this, LogLevel.INFO].concat(args));\n    };\n    Logger.prototype.warn = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        this._logHandler.apply(this, [this, LogLevel.WARN].concat(args));\n    };\n    Logger.prototype.error = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        this._logHandler.apply(this, [this, LogLevel.ERROR].concat(args));\n    };\n    return Logger;\n}());\nexport { Logger };\n\n//# sourceMappingURL=logger.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../logger/dist/esm/src/logger.js\n// module id = null\n// module chunks = "],"sourceRoot":""}